{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to dropwizard-guicey \u00b6 Guice 6.0.0 integration for dropwizard 2.1.10 . Compiled for java 8 , compatible with java 11 - 17 . Release Notes - History - Javadoc - Support - License For migration see migration guide Main features \u00b6 Auto configuration from classpath scan and guice bindings . Yaml config values bindings by path or unique sub objects. Advanced Web support Dropwizard style console reporting : detected (and installed) extensions are printed to console to remove uncertainty Test support : custom junit and spock extensions Advanced test abilities to disable or override application logic Developer friendly: core integrations may be replaced (to better fit needs) rich api for developing custom integrations , and hooking into lifecycle ) out of the box support for plug-n-play plugins ( auto discoverable ) diagnostic tools (reports), support for custom diagnostic tools Sponsors \u00b6 If guicey makes your life easier, you can support its development . Project structure \u00b6 ru.vyarus:dropwizard-guicey - core guicey module. Could be used without any extra modules ru.vyarus.guicey:guicey-[module name] - guicey extension modules (use with ru.vyarus.guicey:guicey-bom ). Modules provide additional functionality like 3 rd party libraries integration. Also, serve as an example of possible extension implementations. Examples - various usage examples for core guicey, extension modules and some direct integrations Before, guicey and extensions were released separately in different repositories - different packages were preserved after merge SBOM \u00b6 SBOM (cyclonedx) is published for every guicey module with cyclonedx classifier (same way as dropwizard) as json and xml files. For example: XML , JSON Documentation Summary \u00b6 Introduction \u00b6 Getting started guide describes installation and provides core usage examples Concepts overview guide introduces core guicey concepts and demonstrates differences from pure dropwizard usage Guice the essence of guice integration Testing describes integration testing techniques Decomposition guide on writing re-usable modules Reference \u00b6 User guide contains detailed feature descriptions. It is good to read, but it also functions well as a reference if you're short on time. Installers describes all guicey installers. Use it as a extensions hand book . Modules external extension modules overview. Examples some usage examples.","title":"Home"},{"location":"#welcome-to-dropwizard-guicey","text":"Guice 6.0.0 integration for dropwizard 2.1.10 . Compiled for java 8 , compatible with java 11 - 17 . Release Notes - History - Javadoc - Support - License For migration see migration guide","title":"Welcome to dropwizard-guicey"},{"location":"#main-features","text":"Auto configuration from classpath scan and guice bindings . Yaml config values bindings by path or unique sub objects. Advanced Web support Dropwizard style console reporting : detected (and installed) extensions are printed to console to remove uncertainty Test support : custom junit and spock extensions Advanced test abilities to disable or override application logic Developer friendly: core integrations may be replaced (to better fit needs) rich api for developing custom integrations , and hooking into lifecycle ) out of the box support for plug-n-play plugins ( auto discoverable ) diagnostic tools (reports), support for custom diagnostic tools","title":"Main features"},{"location":"#sponsors","text":"If guicey makes your life easier, you can support its development .","title":"Sponsors"},{"location":"#project-structure","text":"ru.vyarus:dropwizard-guicey - core guicey module. Could be used without any extra modules ru.vyarus.guicey:guicey-[module name] - guicey extension modules (use with ru.vyarus.guicey:guicey-bom ). Modules provide additional functionality like 3 rd party libraries integration. Also, serve as an example of possible extension implementations. Examples - various usage examples for core guicey, extension modules and some direct integrations Before, guicey and extensions were released separately in different repositories - different packages were preserved after merge","title":"Project structure"},{"location":"#sbom","text":"SBOM (cyclonedx) is published for every guicey module with cyclonedx classifier (same way as dropwizard) as json and xml files. For example: XML , JSON","title":"SBOM"},{"location":"#documentation-summary","text":"","title":"Documentation Summary"},{"location":"#introduction","text":"Getting started guide describes installation and provides core usage examples Concepts overview guide introduces core guicey concepts and demonstrates differences from pure dropwizard usage Guice the essence of guice integration Testing describes integration testing techniques Decomposition guide on writing re-usable modules","title":"Introduction"},{"location":"#reference","text":"User guide contains detailed feature descriptions. It is good to read, but it also functions well as a reference if you're short on time. Installers describes all guicey installers. Use it as a extensions hand book . Modules external extension modules overview. Examples some usage examples.","title":"Reference"},{"location":"concepts/","text":"Concepts overview \u00b6 Section briefly describes new concepts introduced by guicey and explains why it was done that way. For usage instruction and basic examples see getting-started section . HK2 \u00b6 Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it in the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase) and, for example, it is impossible to use HK2 to instantiate dropwizard managed objects because managed must be registered before HK2 context starts. Guicey use lazy factories for integration: it registers providers for HK2 objects in guice context. Guice-managed objects (extensions) are simply registered as instances. So most of the time you don't have to know about HK2 at all. There are additional features allowing you to delegate some extensions management completely to HK2 , but it's intended to be used in very rare cases (edge cases!). In this case you may require to explicitly register hk2-guice bride so hk2 could see guice beans directly. Danger Since jersey 2.26 it is possible to get rid of HK2 completely. Next guicey version will ONLY use guice and all current HK2-related features will be removed. Lifecycle \u00b6 Dropwizard declares two phases: initialization ( App.initialize method) - when dropwizard app must be configured run ( App.run method) - when configuration is available and extensions could be registered in environment Guicey follow dropwizard convention: it will configure everything (almost) on initialization phase and start injector on run phase . Note If we create injector in initialization phase then we will not have access to Configuration and Environment in guice modules, but configuration could be required, especially for 3 rd party modules, which does not support lazy configuration. The only exception for configuration under initialization phase is guice modules, which can be registered in run phase (simply because modules too often require configuration values for construction). As a consequence, extensions recognized from guice bindings are registered in run phase too. This separation of initialization and run phases makes configuration more predictable (especially important when bundles depend on initialization order). Guice module \u00b6 In the main GuiceBundle guice modules registration appears under initialization phase (when neither Configuration nor Environment objects are available). If a module requires these objects and its registration can't be moved to guicey bundle's run method, then use marker interfaces . For example, ConfigurationAwareModule will lead to configuration object set into module before injector creation. Tip If possible, use DropwizardAwareModule as base module class to avoid boilerplate public class SampleModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { configuration () // access configuration environment () // access environment bootstrap () // access dropwizard bootstrap configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) annotatedConfiguration ( ann ) // annotaed configuration value by instance annotatedConfiguration ( Class ) // annotaed configuration value by annotation type options () // access guicey options } } Warning Marker interfaces work only on modules, directly registered through guicey api. Extensions \u00b6 In raw dropwizard you register extensions like: public class App extends Application < Configuration > { ... @Override public void run ( Configuration configuration , Environment environment ) throws Exception { // resource registration environment . jersey (). register ( MyResource . class ); // if extension requires configuration: environment . lifecycle (). manage ( new MyManaged ( configuration . getSomething ())); } } Very easy, just need to remember where it should be registered. If we want to use guice for extensions management, then all extensions must be obtained from guice injector, but it's a boilerplate. Instead, guicey introduce Extension-Installer concept: you create extension (e.g. MyResource ) and Installer knows how to install it. Guicey only need to know extension class. If you use classpath scanning , then you don't need to do anything: guicey will recognize extensions and install them. For example, ResourceInstaller will: recognize MyResource class as rest resource by @Path annotation gets instance from injector ( injector.getInstance(MyResource.class) ) and performs registration environment.jersey().register(guiceManagedInstance) The same way, MangedInstaller recognize MyManaged as managed extension (by implemented interface) and installs guice managed instance (and so all other extensions). Summary With classpath scan you don't need to do anything to install extension and in manual mode you only need to specify extension classes. Tip Most installer implementations are very simple, so you can easily understand how it works (all core installers are declared in core installers bundle ). Guice bindings \u00b6 Guicey also search extensions in registered guice modules. For example: public class MyModule extends AbstarctModule { @Override protected void configure () { bind ( MyResource . class ); } } GuiceBundle . builder () . modules ( new MyModule ()) . build () MyResource will be recognized as extension and installed. Summary So overall there are 3 possible sources for extensions: Classpath scan (mainly used for application extensions) Manual declaration (used in bundles to explicitly declare extensions) Guice bindings In all cases extension is identifyed by it's class, but for extensions detected from guice bindings automatic untargetted binding is not performed. Jersey extensions \u00b6 It is important to note that jersey extensions ( resources and other ) are forced to be singletons (if explicit scope annotation is not set). This force you to always use all request scoped objects through Provider . But, from the other side, this avoids a jvm garbage from creating them for each request and makes everything a bit faster (no extra DI work required for each request). If you think that developer comfort worth more than small performance gain, then: You can use explicit scope annotations to change singleton scope ( @RequestScoped , @Prototype ) Switch off forced singletons ( .option(InstallerOptions.ForceSingletonForJerseyExtensions, false) ) Delegate some extensions or resources management to HK2 using @JerseyManaged Use HK2 by default for jersey extensions Warning Guice AOP will not work on extensions managed by HK2 Custom extensions \u00b6 Installers are not limited to dropwizard only features: you can use custom installers to write any 3 rd party integration. The only condition is extension classes must have some unique identity (usually annotation). For example, EagerSingletonInstaller simply binds extensions annotated with @EagerSingleton with bind(Ext.class).asEeagerSingleton() , so we can simply annotate class and make sure it would be registered in guice context without additional configurations (thanks to classpath scan). Tip Custom installers are also discovered and registered during classpath scan . Another example is PluginInstaller which allows you to declare plugins (e.g. implementing some interface) and inject all of them at once (as Set<PluginInterface> ). guicey-eventbus provides special installer to register events in guava eventBus: EventBusInstaller check class methods and if any method is annotated with @Subscribe - register extension as event bus listener. Not existing, but possible extension for scheduled tasks: we can create @Schedule annotation and write installer to automatically register such classes in scheduler framework. Summary In essence, custom installers could help you avoid many boilerplate operations. Warning Each extension could be installed only by one installer. It will be the first installer which recognize the extension in class (according to installers order ). Core installers override \u00b6 It is also possible to replace any core installer (e.g. to change its behaviour) - you just need to disable core installer and install a replacement: bootstrap . addBundle ( GuiceBundle . builder () ... . disableInstaller ( ManagedInstaller . class ) . installers ( MyCustomManagedInstaller . class ) . build ()); Tip You can disable all installers enabled by default with: . noDefaultInstallers () In this case, you will have to register some installers manually (even if it would be just a few of guicey's own installers). Bundles \u00b6 Dropwizard use bundles for re-usable logic. Bundle support both dropwizard phases (initialization and run). public interface ConfiguredBundle < T > { default void initialize ( Bootstrap <?> bootstrap ) {}; default void run ( T configuration , Environment environment ) throws Exception {}; } The concept is great, but, in context of guice, dropwizard bundle did not allow us to register guice modules (and, of course, guicey installers and extensions). So there is no way to elegantly re-use dropwizard bundles mechanism. Guicey introduce its own bundles: public interface GuiceyBundle { default void initialize ( GuiceyBootstrap bootstrap ) {}; default void run ( GuiceyEnvironment environment ) throws Exception {}; } As you can see guicey bundles are completely equivalent to dropwizard bundles and so it is very easy to switch from dropwizard bundles into guicey bundles. GuiceyBootstrap provides almost all the same methods as main GuiceBundle , allowing you to register installers, extensions, modules and other bundles. Also, it provides access to dropwizard Bootstrap object GuiceyEnvironment allows to register only guice modules (as all configuration should appear under initialization), but provide many shortcut methods for simplify manual registrations (or delayed manual logic). Provides access to dropwizard configuration, environment and introspected configuration tree. Tip Guicey bundles assume to be used together with dropwizard bundles (because there are already many ready-to use dropwizard bundles): GuiceyBootstrap . builder () . dropwizardBundles (..) Bundles usage difference \u00b6 In dropwizard, bundles are helpful not just for extracting re-usable extensions, but for separation of application logic. In guicey, you don't need to write registration code and with enabled classpath scan , don't need to configure much at all. This makes guicey bundles mostly usable for 3 rd party integrations (or core modules extraction for large projects), where you can't (and should not) rely on class path scan and must declare all installers and extensions manually. Many bundle examples could be found in extension modules . Bundles lookup \u00b6 Dropwizard force you to always register bundles manually, and this is good for clarity. But, sometimes, it is desirable to apply bundles under some condition. For example, you want custom installers to be registered when 3 rd party integrations jar is available or you may want to enable some bundles under integration tests only. Guicey provides such ability: add bundles appeared in classpath (with ServiceLoader, not classpath scan) declare extra bundles with system property (for example, could be used in tests) apply custom lookup implementation ServiceLookup based lookup is ideal for 3 rd party integrations. For example, suppose you have scheduler framework integration which provides installers for custom annotation ( @Job ). All you need to do to apply extension is to put integration jar into classpath - installers will be implicitly registered. Important ServiceLookup requires you to prepare extra files so you prepare your bundle for using that way. It does not mean guicey loads all bundles in classpath! Tip ServiceLoader and property based look-ups are always enabled, but you can switch them off if required with .disableBundleLookup() bundle option. Disabling items \u00b6 As you have seen in overriding installers example , you can disable installers. But actually you can disable almost anything: installers, extensions, guice modules, guicey bundles and even dropwizard bundles. Mostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else). But, in some cases, you may want to change behaviour of 3 rd party module: as an example above (with replaced installer), you can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles) installation. Suppose you have some 3 rd party bundle: public class XBundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . extensions (...) . modules ( new XModule (), new XAddonModule ()); } } And, for some reason, you don't need XAddonModule guice module, then you can simply disable it: bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new XBundle ()) . disableModules ( XAddonModule . class ) . build ()) Tip You can even perform mass disables by predicate . For example, disable all installations (extensions, bundles etc) from package: . disable ( Disables . inPackage ( \"some.package.here\" )) Warning Disabling of guice modules also affect transitive modules! For example, public class MyModule extends AbstractModule { @Override protected void configure () { // transitive install ( new OtherMyModule ()); } } GuiceBundle . builder () . modules ( new MyModule ()) . disableModules ( OtherMyModule . class ) Will disable transitive module! Warning Only dropwizard bundles, registered through guicey api are visible! For such bundles, guicey will see all transitive bundles too and will be able to disable them: public class MyDwBundle implements ConfiguredBundle { public void initialize ( Bootstrap bootstrap ) { // transitive bundle bootstrap . addBundle ( new OtherMyDwBundle ()); } } GuiceBundle . builder () . dropwizardBundles ( new MyDwBundle ()) . disableDropwziardBundle ( OtherMyDwBundle . class ) Will prevent OtherMyDwBundle bundle installation. De-duplication items \u00b6 Guice modules, guicey bundles and dropwizard bundles are registered by instance. That means that multiple instances of the same type could be registered, for example: . bundles ( new MyBundle (), new MyBndle ()) Sometimes it may be desirable, but sometimes not. For example, there may be some common bundle: public class Feature1Bundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ()); ... } } public class Feature2Bundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ()); ... } } And duplicate initialization of common bundle may lead to error. In order to detect duplicate instances guicey rely on equals() method. So if two instances of the same type are equal then only one of them will be used and other considered duplicate. So if ComonBundle implement equals everything will work as planned. For completely unique bundles and modules there are pre-defined base classes UniqueGuiceyBundle and UniqueModule ( UniqueDropwizardAwareModule ) accordingly. (e.g. CommonBundle extends UniqueGuiceyBundle ) For cases when it is not possible to change bundle or module class, it could be declared as unique: GuiceBundle . builder () . bundles ( new Feature1Bundle (), new Feature2Bundle ()) . uniqueItems ( ComonBundle . class ) . build () Guice modules limitation Transitive guice modules are not counted! That means in case of de-duplication transitive modules are not visible. Note that \"common bundle\" problem for dropwizard bundles may be solved by simply registering dropwizard bundles through guicey api. Dropwizard bundles Only dropwizard bundles, registered through guicey api are visible. So if there would be one bundle registered directly in dropwizard and another with guicey api - guicey will not detect duplicate. Options \u00b6 Dropwizard configuration covers most configuration cases, except development specific cases. For example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration). Other example is an ability of low level tuning for 3 rd party bundles. Options are developer configurations: either required only for development or triggers set during development and not intended to be changed later. Options are declared with enum (each enum represents options group) with value type declaration to grant safety. Option could be set only in main bundle (in your application class) You can access options anywhere : guice module, guicey bundle, and in any guice service by injecting special service Options report is included into diagnostic report so you can see all option values. For example, guicey use two option groups: GuiceyOptions and InstallersOptions . GuiceyOptions used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc. That means you have access to all these application configurations from anywhere in your code (for example, you can know if classpath scan is enabled or not in 3 rd party bundle). Another good example is InstallersOptions.JerseyExtensionsManagedByGuice which changes the way jersey extensions are handled: with guice or with HK2. This is developer time decision and must be selected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could know what was chosen. HK2 usage is highly dependent on HK2-guice-bridge presence and with option we can verify it: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" ) Options lookup \u00b6 You can bind option to system property in order to introduce special \"hidden\" application flag: GuiceBuilder . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . map ()) . build () Now you can run application with -Dmyprop=value and this value will be mapped to option (accessible everywhere in the application). Note There are built-in basic value conversions from string, but in complex cases you can do manual conversion . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) Note You can map options from sys properties, environment variables or strings (obtained somewhere else). You can even allow mass binding to allow external definition of any option .props(\"prefix\") . See options lookup doc. Configuration hooks \u00b6 Guicey provides special configuration hooks mechanism which may be used to change application configuration. It is useful for tests or to attach various diagnostic tools for compiled application. For example, out of the box guicey provides DiagnosticHook , which activates diagnostic reporting (print* methods). It may be enabled even on compiled application with a system property: -Dguicey.hooks=diagnostic The same way you can write your hooks and register them with shortcuts ( GuiceBundle.builder().aliasHook(\"tool\", ToolHook.class) ). You don't need to remember all this \u00b6 All guicey features could be revealed from main bundle methods. So you don't need to remember everything - just look methods. There is a special group of print[Something] methods, which are intended to help you understand internal state (and help with debugging). As you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan, bundles, bundles installing other bundles, many guicey modules. Also, some bundles may disable extensions, installers, guice modules (and some modules could even override bindings). During startup guicey tracks all performed configurations and you can even access this information at runtime using @Inject GuiceyConfigurationInfo info . Out of the box, guicey could print all this into console, you just need to add: bootstrap . addBundle ( GuiceBundle . builder () . printDiagnosticInfo () . build ()) And other logs giving you inside look on configuration. Not mentioned \u00b6 Dropwizard commands support Integration tests support Lifecycle events Shared state","title":"Concepts overview"},{"location":"concepts/#concepts-overview","text":"Section briefly describes new concepts introduced by guicey and explains why it was done that way. For usage instruction and basic examples see getting-started section .","title":"Concepts overview"},{"location":"concepts/#hk2","text":"Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it in the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase) and, for example, it is impossible to use HK2 to instantiate dropwizard managed objects because managed must be registered before HK2 context starts. Guicey use lazy factories for integration: it registers providers for HK2 objects in guice context. Guice-managed objects (extensions) are simply registered as instances. So most of the time you don't have to know about HK2 at all. There are additional features allowing you to delegate some extensions management completely to HK2 , but it's intended to be used in very rare cases (edge cases!). In this case you may require to explicitly register hk2-guice bride so hk2 could see guice beans directly. Danger Since jersey 2.26 it is possible to get rid of HK2 completely. Next guicey version will ONLY use guice and all current HK2-related features will be removed.","title":"HK2"},{"location":"concepts/#lifecycle","text":"Dropwizard declares two phases: initialization ( App.initialize method) - when dropwizard app must be configured run ( App.run method) - when configuration is available and extensions could be registered in environment Guicey follow dropwizard convention: it will configure everything (almost) on initialization phase and start injector on run phase . Note If we create injector in initialization phase then we will not have access to Configuration and Environment in guice modules, but configuration could be required, especially for 3 rd party modules, which does not support lazy configuration. The only exception for configuration under initialization phase is guice modules, which can be registered in run phase (simply because modules too often require configuration values for construction). As a consequence, extensions recognized from guice bindings are registered in run phase too. This separation of initialization and run phases makes configuration more predictable (especially important when bundles depend on initialization order).","title":"Lifecycle"},{"location":"concepts/#guice-module","text":"In the main GuiceBundle guice modules registration appears under initialization phase (when neither Configuration nor Environment objects are available). If a module requires these objects and its registration can't be moved to guicey bundle's run method, then use marker interfaces . For example, ConfigurationAwareModule will lead to configuration object set into module before injector creation. Tip If possible, use DropwizardAwareModule as base module class to avoid boilerplate public class SampleModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { configuration () // access configuration environment () // access environment bootstrap () // access dropwizard bootstrap configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) annotatedConfiguration ( ann ) // annotaed configuration value by instance annotatedConfiguration ( Class ) // annotaed configuration value by annotation type options () // access guicey options } } Warning Marker interfaces work only on modules, directly registered through guicey api.","title":"Guice module"},{"location":"concepts/#extensions","text":"In raw dropwizard you register extensions like: public class App extends Application < Configuration > { ... @Override public void run ( Configuration configuration , Environment environment ) throws Exception { // resource registration environment . jersey (). register ( MyResource . class ); // if extension requires configuration: environment . lifecycle (). manage ( new MyManaged ( configuration . getSomething ())); } } Very easy, just need to remember where it should be registered. If we want to use guice for extensions management, then all extensions must be obtained from guice injector, but it's a boilerplate. Instead, guicey introduce Extension-Installer concept: you create extension (e.g. MyResource ) and Installer knows how to install it. Guicey only need to know extension class. If you use classpath scanning , then you don't need to do anything: guicey will recognize extensions and install them. For example, ResourceInstaller will: recognize MyResource class as rest resource by @Path annotation gets instance from injector ( injector.getInstance(MyResource.class) ) and performs registration environment.jersey().register(guiceManagedInstance) The same way, MangedInstaller recognize MyManaged as managed extension (by implemented interface) and installs guice managed instance (and so all other extensions). Summary With classpath scan you don't need to do anything to install extension and in manual mode you only need to specify extension classes. Tip Most installer implementations are very simple, so you can easily understand how it works (all core installers are declared in core installers bundle ).","title":"Extensions"},{"location":"concepts/#guice-bindings","text":"Guicey also search extensions in registered guice modules. For example: public class MyModule extends AbstarctModule { @Override protected void configure () { bind ( MyResource . class ); } } GuiceBundle . builder () . modules ( new MyModule ()) . build () MyResource will be recognized as extension and installed. Summary So overall there are 3 possible sources for extensions: Classpath scan (mainly used for application extensions) Manual declaration (used in bundles to explicitly declare extensions) Guice bindings In all cases extension is identifyed by it's class, but for extensions detected from guice bindings automatic untargetted binding is not performed.","title":"Guice bindings"},{"location":"concepts/#jersey-extensions","text":"It is important to note that jersey extensions ( resources and other ) are forced to be singletons (if explicit scope annotation is not set). This force you to always use all request scoped objects through Provider . But, from the other side, this avoids a jvm garbage from creating them for each request and makes everything a bit faster (no extra DI work required for each request). If you think that developer comfort worth more than small performance gain, then: You can use explicit scope annotations to change singleton scope ( @RequestScoped , @Prototype ) Switch off forced singletons ( .option(InstallerOptions.ForceSingletonForJerseyExtensions, false) ) Delegate some extensions or resources management to HK2 using @JerseyManaged Use HK2 by default for jersey extensions Warning Guice AOP will not work on extensions managed by HK2","title":"Jersey extensions"},{"location":"concepts/#custom-extensions","text":"Installers are not limited to dropwizard only features: you can use custom installers to write any 3 rd party integration. The only condition is extension classes must have some unique identity (usually annotation). For example, EagerSingletonInstaller simply binds extensions annotated with @EagerSingleton with bind(Ext.class).asEeagerSingleton() , so we can simply annotate class and make sure it would be registered in guice context without additional configurations (thanks to classpath scan). Tip Custom installers are also discovered and registered during classpath scan . Another example is PluginInstaller which allows you to declare plugins (e.g. implementing some interface) and inject all of them at once (as Set<PluginInterface> ). guicey-eventbus provides special installer to register events in guava eventBus: EventBusInstaller check class methods and if any method is annotated with @Subscribe - register extension as event bus listener. Not existing, but possible extension for scheduled tasks: we can create @Schedule annotation and write installer to automatically register such classes in scheduler framework. Summary In essence, custom installers could help you avoid many boilerplate operations. Warning Each extension could be installed only by one installer. It will be the first installer which recognize the extension in class (according to installers order ).","title":"Custom extensions"},{"location":"concepts/#core-installers-override","text":"It is also possible to replace any core installer (e.g. to change its behaviour) - you just need to disable core installer and install a replacement: bootstrap . addBundle ( GuiceBundle . builder () ... . disableInstaller ( ManagedInstaller . class ) . installers ( MyCustomManagedInstaller . class ) . build ()); Tip You can disable all installers enabled by default with: . noDefaultInstallers () In this case, you will have to register some installers manually (even if it would be just a few of guicey's own installers).","title":"Core installers override"},{"location":"concepts/#bundles","text":"Dropwizard use bundles for re-usable logic. Bundle support both dropwizard phases (initialization and run). public interface ConfiguredBundle < T > { default void initialize ( Bootstrap <?> bootstrap ) {}; default void run ( T configuration , Environment environment ) throws Exception {}; } The concept is great, but, in context of guice, dropwizard bundle did not allow us to register guice modules (and, of course, guicey installers and extensions). So there is no way to elegantly re-use dropwizard bundles mechanism. Guicey introduce its own bundles: public interface GuiceyBundle { default void initialize ( GuiceyBootstrap bootstrap ) {}; default void run ( GuiceyEnvironment environment ) throws Exception {}; } As you can see guicey bundles are completely equivalent to dropwizard bundles and so it is very easy to switch from dropwizard bundles into guicey bundles. GuiceyBootstrap provides almost all the same methods as main GuiceBundle , allowing you to register installers, extensions, modules and other bundles. Also, it provides access to dropwizard Bootstrap object GuiceyEnvironment allows to register only guice modules (as all configuration should appear under initialization), but provide many shortcut methods for simplify manual registrations (or delayed manual logic). Provides access to dropwizard configuration, environment and introspected configuration tree. Tip Guicey bundles assume to be used together with dropwizard bundles (because there are already many ready-to use dropwizard bundles): GuiceyBootstrap . builder () . dropwizardBundles (..)","title":"Bundles"},{"location":"concepts/#bundles-usage-difference","text":"In dropwizard, bundles are helpful not just for extracting re-usable extensions, but for separation of application logic. In guicey, you don't need to write registration code and with enabled classpath scan , don't need to configure much at all. This makes guicey bundles mostly usable for 3 rd party integrations (or core modules extraction for large projects), where you can't (and should not) rely on class path scan and must declare all installers and extensions manually. Many bundle examples could be found in extension modules .","title":"Bundles usage difference"},{"location":"concepts/#bundles-lookup","text":"Dropwizard force you to always register bundles manually, and this is good for clarity. But, sometimes, it is desirable to apply bundles under some condition. For example, you want custom installers to be registered when 3 rd party integrations jar is available or you may want to enable some bundles under integration tests only. Guicey provides such ability: add bundles appeared in classpath (with ServiceLoader, not classpath scan) declare extra bundles with system property (for example, could be used in tests) apply custom lookup implementation ServiceLookup based lookup is ideal for 3 rd party integrations. For example, suppose you have scheduler framework integration which provides installers for custom annotation ( @Job ). All you need to do to apply extension is to put integration jar into classpath - installers will be implicitly registered. Important ServiceLookup requires you to prepare extra files so you prepare your bundle for using that way. It does not mean guicey loads all bundles in classpath! Tip ServiceLoader and property based look-ups are always enabled, but you can switch them off if required with .disableBundleLookup() bundle option.","title":"Bundles lookup"},{"location":"concepts/#disabling-items","text":"As you have seen in overriding installers example , you can disable installers. But actually you can disable almost anything: installers, extensions, guice modules, guicey bundles and even dropwizard bundles. Mostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else). But, in some cases, you may want to change behaviour of 3 rd party module: as an example above (with replaced installer), you can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles) installation. Suppose you have some 3 rd party bundle: public class XBundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . extensions (...) . modules ( new XModule (), new XAddonModule ()); } } And, for some reason, you don't need XAddonModule guice module, then you can simply disable it: bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new XBundle ()) . disableModules ( XAddonModule . class ) . build ()) Tip You can even perform mass disables by predicate . For example, disable all installations (extensions, bundles etc) from package: . disable ( Disables . inPackage ( \"some.package.here\" )) Warning Disabling of guice modules also affect transitive modules! For example, public class MyModule extends AbstractModule { @Override protected void configure () { // transitive install ( new OtherMyModule ()); } } GuiceBundle . builder () . modules ( new MyModule ()) . disableModules ( OtherMyModule . class ) Will disable transitive module! Warning Only dropwizard bundles, registered through guicey api are visible! For such bundles, guicey will see all transitive bundles too and will be able to disable them: public class MyDwBundle implements ConfiguredBundle { public void initialize ( Bootstrap bootstrap ) { // transitive bundle bootstrap . addBundle ( new OtherMyDwBundle ()); } } GuiceBundle . builder () . dropwizardBundles ( new MyDwBundle ()) . disableDropwziardBundle ( OtherMyDwBundle . class ) Will prevent OtherMyDwBundle bundle installation.","title":"Disabling items"},{"location":"concepts/#de-duplication-items","text":"Guice modules, guicey bundles and dropwizard bundles are registered by instance. That means that multiple instances of the same type could be registered, for example: . bundles ( new MyBundle (), new MyBndle ()) Sometimes it may be desirable, but sometimes not. For example, there may be some common bundle: public class Feature1Bundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ()); ... } } public class Feature2Bundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ()); ... } } And duplicate initialization of common bundle may lead to error. In order to detect duplicate instances guicey rely on equals() method. So if two instances of the same type are equal then only one of them will be used and other considered duplicate. So if ComonBundle implement equals everything will work as planned. For completely unique bundles and modules there are pre-defined base classes UniqueGuiceyBundle and UniqueModule ( UniqueDropwizardAwareModule ) accordingly. (e.g. CommonBundle extends UniqueGuiceyBundle ) For cases when it is not possible to change bundle or module class, it could be declared as unique: GuiceBundle . builder () . bundles ( new Feature1Bundle (), new Feature2Bundle ()) . uniqueItems ( ComonBundle . class ) . build () Guice modules limitation Transitive guice modules are not counted! That means in case of de-duplication transitive modules are not visible. Note that \"common bundle\" problem for dropwizard bundles may be solved by simply registering dropwizard bundles through guicey api. Dropwizard bundles Only dropwizard bundles, registered through guicey api are visible. So if there would be one bundle registered directly in dropwizard and another with guicey api - guicey will not detect duplicate.","title":"De-duplication items"},{"location":"concepts/#options","text":"Dropwizard configuration covers most configuration cases, except development specific cases. For example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration). Other example is an ability of low level tuning for 3 rd party bundles. Options are developer configurations: either required only for development or triggers set during development and not intended to be changed later. Options are declared with enum (each enum represents options group) with value type declaration to grant safety. Option could be set only in main bundle (in your application class) You can access options anywhere : guice module, guicey bundle, and in any guice service by injecting special service Options report is included into diagnostic report so you can see all option values. For example, guicey use two option groups: GuiceyOptions and InstallersOptions . GuiceyOptions used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc. That means you have access to all these application configurations from anywhere in your code (for example, you can know if classpath scan is enabled or not in 3 rd party bundle). Another good example is InstallersOptions.JerseyExtensionsManagedByGuice which changes the way jersey extensions are handled: with guice or with HK2. This is developer time decision and must be selected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could know what was chosen. HK2 usage is highly dependent on HK2-guice-bridge presence and with option we can verify it: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" )","title":"Options"},{"location":"concepts/#options-lookup","text":"You can bind option to system property in order to introduce special \"hidden\" application flag: GuiceBuilder . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . map ()) . build () Now you can run application with -Dmyprop=value and this value will be mapped to option (accessible everywhere in the application). Note There are built-in basic value conversions from string, but in complex cases you can do manual conversion . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) Note You can map options from sys properties, environment variables or strings (obtained somewhere else). You can even allow mass binding to allow external definition of any option .props(\"prefix\") . See options lookup doc.","title":"Options lookup"},{"location":"concepts/#configuration-hooks","text":"Guicey provides special configuration hooks mechanism which may be used to change application configuration. It is useful for tests or to attach various diagnostic tools for compiled application. For example, out of the box guicey provides DiagnosticHook , which activates diagnostic reporting (print* methods). It may be enabled even on compiled application with a system property: -Dguicey.hooks=diagnostic The same way you can write your hooks and register them with shortcuts ( GuiceBundle.builder().aliasHook(\"tool\", ToolHook.class) ).","title":"Configuration hooks"},{"location":"concepts/#you-dont-need-to-remember-all-this","text":"All guicey features could be revealed from main bundle methods. So you don't need to remember everything - just look methods. There is a special group of print[Something] methods, which are intended to help you understand internal state (and help with debugging). As you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan, bundles, bundles installing other bundles, many guicey modules. Also, some bundles may disable extensions, installers, guice modules (and some modules could even override bindings). During startup guicey tracks all performed configurations and you can even access this information at runtime using @Inject GuiceyConfigurationInfo info . Out of the box, guicey could print all this into console, you just need to add: bootstrap . addBundle ( GuiceBundle . builder () . printDiagnosticInfo () . build ()) And other logs giving you inside look on configuration.","title":"You don't need to remember all this"},{"location":"concepts/#not-mentioned","text":"Dropwizard commands support Integration tests support Lifecycle events Shared state","title":"Not mentioned"},{"location":"decomposition/","text":"Decomposition \u00b6 Guide for writing re-usable bundles In dropwizard there is only one decomposition element: ConfiguredBundle . Note In pure dropwizard, bundles may also be used within a single application to separate configuration blocks (simplify logic). In guicey, this is not required as classpath scan may be used for extension registration and reduce the amount of required configuration. This chapter describes only re-usable logic decomposition. In guicey there are three decomposition elements - guicey bundles ( GuiceyBundle ), guice modules ( Module ) and dropwizard bundle ( ConfiguredBundle ). Having three options could be confusing. There are existing dropwizard modules - ConfiguredBundle Existing guice modules (outdated list, just as an example) - Module And guicey extensions - GuiceyBundle All of these modules are supposed to be used together. In some cases, guicey explicitly provides wrapping modules (e.g. the jdbi wrapper around the dropwizard module ). Such wrappers provide guice related features and enhancements, impossible in vanilla dropwizard modules. Guicey bundle \u00b6 As described here , guicey introduces its own bundle because guicey provides additional configuration features. Even a simple use case may have a need to configure guice modules from a bundle. Prefer GuiceyBundle over dropwizard Bundle for developing re-usable modules. Of course, if module is very generic (does not depend on guice) you can use a pure dropwizard module (to publish it for wider audience), but almost all bundles rely on guicey features. Benefits: guice support (ability to register guice modules) options support use sub-configuration objects directly (important for writing generic modules) define custom extension types to simplify usage (e.g. like jdbi ) automatic module loading when jar appear in classpath (e.g. like lifecycle annotations ) shared state - advanced techniques for bundle communication (e.g. used by GSP and SPA ) events - internal lifecycle events for fine-tuning lifecycle (again, complex cases only, for example, GSP use it to order bundles logic) ability to replace functionality (prevent feature x registration by disabling it and register feature y instead) Dropwizard bundle \u00b6 It is important to note that there is an important difference between registering a dropwizard bundle directly via the dropwizard Bootstrap and registering a bundle through the guicey api - any bundle registered through the guicey api may be disabled , de-duplicated , and/or tracked for transitive bundles . All bundles registered through guicey api will also appear in configuration report . There is a difference between the order that dropwizard and guicey bundles are initialized: Dropwizard bundles immediately initialize a transitive bundle. public class MyBundle implements ConfiguredBundle { @Override public void initialize ( Bootstrap <?> bootstrap ) { bootstrap . addBundle ( new MyOtherBundle ()); // line executed after MyOtherBundle init } } Guicey bundle registers a transitive bundle after current bundle, but dropwizard bundles are still immediately initialized. public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundles ( new DwBundle ()) . bundles ( new MyOtherBundle ()); // line executed before MyOtherBundle init, but after DwBundle init } } Guicey bundle de-duplication logic is further explained here . In short, registered root bundles must be initialized in priority. This avoids situations like: GuiceBundle . builder () . bundles ( new Bundle1 (), new Bundle2 ( 12 )) If Bundle2 is unique and Bundle1 transitively installs new Bundle2(1) (e.g. with different config), then this transitive bundle would be ignored because the root bundle's init will appear first. If guicey bundles worked like dropwizard bundles, then the directly registered Bundle2 would be ignored and remaining instance would have different configuration, introducing a major point of confusion. Normally, this behaviour should not be an issue as you shouldn't rely on bundles initialization order. But this may be important with shared state . Bundle vs Module \u00b6 When extracting functionality into re-usable module always start with a bundle. A guice module will likely be required as well. Logic should be separated as: Guice module is responsible for guice bindings and should not be aware of dropwizard. Bundle works with dropwizard, extracts required configuration for creating module and do other registrations. That's an ideal case. But, for example, if you need to apply some bindings based on configuration only then you can do it with pure guice module, like: public class ModuleConfig { @JsonProperty private String something ; } Module knows that target application (where this re-usable module would be used) will declare this configuration inside its main configuration: public class AppConfig extends Configuration { @JsonProperty private ModuleConfig module ; } Make module aware of dropwizard stuff : public class ModuleImpl < C extends Configuration > extends DropwizardAwareModule < C > { @Override protected void configure () { // obtain sub-configuration object ModuleConfig config = Preconditions . checkNotNull ( configuration ( ModuleConfig . class ), \"ModuleConfig is not found within application config. Please declare it.\" ); // use it for binding bind ( SomeService . class ). annotatedWith ( Names . named ( config . getSomething ())). to ( SomeServiceImpl . class ); } } Warning This is not the recommended way! It was shown just to demonstrate that guice module could be used without bundle. It's better to use a declarative bundle instead: public class ModuleImpl extends AbstractBundle { private ModuleConfig config ; public ModuleImpl ( ModuleConfig config ) { this . config = config ; } @Override protected void configure () { bind ( SomeService . class ). annotatedWith ( Names . named ( config . getSomething ())). to ( SomeServiceImpl . class ); } } public class ModuleBundle extends GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { ModuleConfig config = Preconditions . checkNotNull ( environment . configuration ( ModuleConfig . class ), \"ModuleConfig is not found within application config. Please declare it.\" ); environment . modules ( new ModuleImpl ( config )); } } Bundle tips \u00b6 These tips show various techniques for developing bundles. Mostly, these tips are based on developing guicey extensions . See extensions source for examples. Uniqueness \u00b6 For everything that is registered \"by instance\", the de-duplication mechanism is applied. You can use it to provide only one instance of a bundle by extends UniqueGuiceyBundle . If more sophisticated logic is required, a manual equals and hash code implementation , may be used. This could be used to de-duplicate only instances with the same constructor arguments. This is most applicable to guice modules as guice will not start with duplicate bindings ( MyModule extends UniqueModule ). Auto-loaded bundle \u00b6 Auto-loading is based on the guicey bundles lookup feature. Be aware that a user may switch off bundle lookup (with .disableBundleLookup() ) or apply custom lookup ). Auto load override \u00b6 If your bundle provides configuration, but you still want to load it automatically with the default configuration, then you can use bundle uniqueness : public class AutoLoadableBundle extends UniqueGuiceyBundle { ... } If this is used, only one bundle instance is allowed. If a user registers another instance of the bundle manually, the bundle found from a lookup will simply be ignored. The lifecycle annotations module uses this technique. Optional extensions \u00b6 All extensions must be registered during the initialization phase, when configuration is not yet available and so it is not possible to implement optional extension registration. To work around this, you can conditionally disable extensions: public class MyFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // always register extension bootstrap . extensions ( OptionalExtension . class ); } @Override public void run ( GuiceyEnvironment environment ) throws Exception { // disable extension based on configuration value if ( ! environment . configuration (). getSomeValue ()) { environment . disableExtension ( OptionalExtension . class ); } } } Replace features \u00b6 As bundle has almost complete access to configuration, it can use disables to substitute application functions. For example, it is known that an application uses ServiceX from some core module provided by the organization. Your module requires a modified service. Your bundle may disable the core module, and install a customized module as a replacement: public class MyFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . disableModules ( CoreModule . class ) . modules ( new CustomizedCoreModule ()); } } Note This is not the best pattern to follow. It is simpler to use binding override to override single service. This is an example for demonstration purposes. Bundles can't disable other bundles (because target bundle could be already processed at this point). Bundle options \u00b6 Bundles can use the guicey options mechanism to access guicey option values: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { if ( bootstrap . option ( GuiceyOptions . UseHkBridge )) { // show warning that bridge required } } } There is also support for custom options . Note Option values are set only in main GuiceBundle . They are immutable, so all bundles receive the same option values. Configuration access \u00b6 A bundle may access direct dropwizard Configuration , as well as individual values thanks to yaml values introspection. Qualified properties \u00b6 Configuration properties, required for injection, could be simply annotated with a qualifier annotations : public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); And used directly in service: @Singleton public class MyService { @Inject @Named ( \"custom\" ) String prop ; @Inject @CustomQualifier SubObj obj ; } Or accessed in bundle (or guice module): public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { SubObj config = bootstrap . annotatedValue ( CustomQualifier . class ); ... } } Unique sub config \u00b6 When creating re-usable bundle it is often required to access yaml configuration data. Usually this is solved by some \"configuration look-ups\" like in dropwizard-views Guicey allows you to obtain the sub-configuration object directly: public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { XFeatureConfig environment = bootstrap . configuration ( XFeatureConfig . class ); ... } } Note that this bundle doesn't know exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration at any level just once . For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Your sub configuration object must appear only once within user configuration. Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt extends XFeatureConfig ) it will be different unique config. Access by path \u00b6 When you are not sure that configuration is unique, you can rely on exact path definition of required sub configuration: public class XFeatureBundle implements GuiceyBundle { private String path ; public XFeatureBundle ( String path ) { this . path = path ; } @Override public void run ( GuiceyEnvironment environment ) throws Exception { XFeatureConfig conf = environment . configuration ( path ); ... } } The Path may be declared by the bundle user, who knows required configuration location: GuiceBundle . builder () . bundles ( new XFeatureBundle ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... } Multiple configs \u00b6 In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { List < XFeatureConfig > confs = environment . configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } This configurations method will return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses as well. So if there are XFeatureConfigExt extends XFeatureConfig declared somewhere it will also be returned. Custom configuration analysis \u00b6 In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = environment . configurationTree () . findAllRootPathsFrom ( MyConfig . class ); // search for not null values of marked (annotated) classes List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, the bundle searches for properties declared directly in the MyConfig configuration class with non-null values and the custom marker ( @MyMarker ) class annotation. See introspected configuration structure description for details. Shared state \u00b6 Guicey maintains special shared state object useful for storing application-wide data. Warning Yes, any shared state is a \"hack\". Normally, you should avoid using it. Guicey provides this ability to unify all such current and future hacks: so if you need to communicate between bundles - you don't need to reinvent the wheel and don't have additional problems in tests (due to leaking states). For example, it is used by spa bundle to share list of registered application names between all spa bundle instances and so be able to prevent duplicate name registration. Server pages bundle use shared state to maintain global configuration and allow application bundles communication with global views bundle. Equal communication scenario \u00b6 Use the following in cases when multiple (equal) bundles need to communicate, the first initialized bundle will initialize the shared state and others simply use it: public class EqualBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // either obtain already shared object or share new object SomeState state = bootstrap . sharedState ( EqualBundle , () -> new SomeState ()); ... } } Parent-child scenario \u00b6 Use the following in cases when there is one global bundle, which must initialize some global state and child bundles, which use or append to this global state: public class GlobalBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // share global state object bootstrap . shareState ( GlobalBundle , new GlobalState ()); } } public class ChildBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // access shared object or fail when not found GlobalState state = environment . sharedStateOrFail ( GlobalBundle , \"Failed to obtain global state - check if global bundle registered\" ); } } Before/after run logic \u00b6 If multiple bundles must be synchronized on run phase, use guicey events . To run code after all guicey bundles have been initialized, but before run is called: @Override public void initialize ( final GuiceyBootstrap bootstrap ) { bootstrap . listen ( new GuiceyLifecycleAdapter () { @Override protected void beforeRun ( final BeforeRunEvent event ) { // do something before bundles run // NOTE that environment and configuration already available! } }); } To run code after all guicey bundles run methods have been called (delayed init): @Override public void run ( final GuiceyEnvironment environment ) { environment . listen ( new GuiceyLifecycleAdapter () { @Override protected void bundlesStarted ( final BundlesStartedEvent event ) { // still sdropwizard run phase (anything could be configured) // but all guicey bundles aready executed } }); } Note This will work only for guicey bundles! Registered dropwizard bundles may execute before or after these events. Events are broadcast from the main dropwizard GuiceBundle run method, so other dropwizard bundles, registered after guice bundle will run after it. It is assumed that guicey bundles will be used for most configurations, but especially in complex cases when bundle synchronization is required.","title":"Decomposition"},{"location":"decomposition/#decomposition","text":"Guide for writing re-usable bundles In dropwizard there is only one decomposition element: ConfiguredBundle . Note In pure dropwizard, bundles may also be used within a single application to separate configuration blocks (simplify logic). In guicey, this is not required as classpath scan may be used for extension registration and reduce the amount of required configuration. This chapter describes only re-usable logic decomposition. In guicey there are three decomposition elements - guicey bundles ( GuiceyBundle ), guice modules ( Module ) and dropwizard bundle ( ConfiguredBundle ). Having three options could be confusing. There are existing dropwizard modules - ConfiguredBundle Existing guice modules (outdated list, just as an example) - Module And guicey extensions - GuiceyBundle All of these modules are supposed to be used together. In some cases, guicey explicitly provides wrapping modules (e.g. the jdbi wrapper around the dropwizard module ). Such wrappers provide guice related features and enhancements, impossible in vanilla dropwizard modules.","title":"Decomposition"},{"location":"decomposition/#guicey-bundle","text":"As described here , guicey introduces its own bundle because guicey provides additional configuration features. Even a simple use case may have a need to configure guice modules from a bundle. Prefer GuiceyBundle over dropwizard Bundle for developing re-usable modules. Of course, if module is very generic (does not depend on guice) you can use a pure dropwizard module (to publish it for wider audience), but almost all bundles rely on guicey features. Benefits: guice support (ability to register guice modules) options support use sub-configuration objects directly (important for writing generic modules) define custom extension types to simplify usage (e.g. like jdbi ) automatic module loading when jar appear in classpath (e.g. like lifecycle annotations ) shared state - advanced techniques for bundle communication (e.g. used by GSP and SPA ) events - internal lifecycle events for fine-tuning lifecycle (again, complex cases only, for example, GSP use it to order bundles logic) ability to replace functionality (prevent feature x registration by disabling it and register feature y instead)","title":"Guicey bundle"},{"location":"decomposition/#dropwizard-bundle","text":"It is important to note that there is an important difference between registering a dropwizard bundle directly via the dropwizard Bootstrap and registering a bundle through the guicey api - any bundle registered through the guicey api may be disabled , de-duplicated , and/or tracked for transitive bundles . All bundles registered through guicey api will also appear in configuration report . There is a difference between the order that dropwizard and guicey bundles are initialized: Dropwizard bundles immediately initialize a transitive bundle. public class MyBundle implements ConfiguredBundle { @Override public void initialize ( Bootstrap <?> bootstrap ) { bootstrap . addBundle ( new MyOtherBundle ()); // line executed after MyOtherBundle init } } Guicey bundle registers a transitive bundle after current bundle, but dropwizard bundles are still immediately initialized. public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundles ( new DwBundle ()) . bundles ( new MyOtherBundle ()); // line executed before MyOtherBundle init, but after DwBundle init } } Guicey bundle de-duplication logic is further explained here . In short, registered root bundles must be initialized in priority. This avoids situations like: GuiceBundle . builder () . bundles ( new Bundle1 (), new Bundle2 ( 12 )) If Bundle2 is unique and Bundle1 transitively installs new Bundle2(1) (e.g. with different config), then this transitive bundle would be ignored because the root bundle's init will appear first. If guicey bundles worked like dropwizard bundles, then the directly registered Bundle2 would be ignored and remaining instance would have different configuration, introducing a major point of confusion. Normally, this behaviour should not be an issue as you shouldn't rely on bundles initialization order. But this may be important with shared state .","title":"Dropwizard bundle"},{"location":"decomposition/#bundle-vs-module","text":"When extracting functionality into re-usable module always start with a bundle. A guice module will likely be required as well. Logic should be separated as: Guice module is responsible for guice bindings and should not be aware of dropwizard. Bundle works with dropwizard, extracts required configuration for creating module and do other registrations. That's an ideal case. But, for example, if you need to apply some bindings based on configuration only then you can do it with pure guice module, like: public class ModuleConfig { @JsonProperty private String something ; } Module knows that target application (where this re-usable module would be used) will declare this configuration inside its main configuration: public class AppConfig extends Configuration { @JsonProperty private ModuleConfig module ; } Make module aware of dropwizard stuff : public class ModuleImpl < C extends Configuration > extends DropwizardAwareModule < C > { @Override protected void configure () { // obtain sub-configuration object ModuleConfig config = Preconditions . checkNotNull ( configuration ( ModuleConfig . class ), \"ModuleConfig is not found within application config. Please declare it.\" ); // use it for binding bind ( SomeService . class ). annotatedWith ( Names . named ( config . getSomething ())). to ( SomeServiceImpl . class ); } } Warning This is not the recommended way! It was shown just to demonstrate that guice module could be used without bundle. It's better to use a declarative bundle instead: public class ModuleImpl extends AbstractBundle { private ModuleConfig config ; public ModuleImpl ( ModuleConfig config ) { this . config = config ; } @Override protected void configure () { bind ( SomeService . class ). annotatedWith ( Names . named ( config . getSomething ())). to ( SomeServiceImpl . class ); } } public class ModuleBundle extends GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { ModuleConfig config = Preconditions . checkNotNull ( environment . configuration ( ModuleConfig . class ), \"ModuleConfig is not found within application config. Please declare it.\" ); environment . modules ( new ModuleImpl ( config )); } }","title":"Bundle vs Module"},{"location":"decomposition/#bundle-tips","text":"These tips show various techniques for developing bundles. Mostly, these tips are based on developing guicey extensions . See extensions source for examples.","title":"Bundle tips"},{"location":"decomposition/#uniqueness","text":"For everything that is registered \"by instance\", the de-duplication mechanism is applied. You can use it to provide only one instance of a bundle by extends UniqueGuiceyBundle . If more sophisticated logic is required, a manual equals and hash code implementation , may be used. This could be used to de-duplicate only instances with the same constructor arguments. This is most applicable to guice modules as guice will not start with duplicate bindings ( MyModule extends UniqueModule ).","title":"Uniqueness"},{"location":"decomposition/#auto-loaded-bundle","text":"Auto-loading is based on the guicey bundles lookup feature. Be aware that a user may switch off bundle lookup (with .disableBundleLookup() ) or apply custom lookup ).","title":"Auto-loaded bundle"},{"location":"decomposition/#auto-load-override","text":"If your bundle provides configuration, but you still want to load it automatically with the default configuration, then you can use bundle uniqueness : public class AutoLoadableBundle extends UniqueGuiceyBundle { ... } If this is used, only one bundle instance is allowed. If a user registers another instance of the bundle manually, the bundle found from a lookup will simply be ignored. The lifecycle annotations module uses this technique.","title":"Auto load override"},{"location":"decomposition/#optional-extensions","text":"All extensions must be registered during the initialization phase, when configuration is not yet available and so it is not possible to implement optional extension registration. To work around this, you can conditionally disable extensions: public class MyFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // always register extension bootstrap . extensions ( OptionalExtension . class ); } @Override public void run ( GuiceyEnvironment environment ) throws Exception { // disable extension based on configuration value if ( ! environment . configuration (). getSomeValue ()) { environment . disableExtension ( OptionalExtension . class ); } } }","title":"Optional extensions"},{"location":"decomposition/#replace-features","text":"As bundle has almost complete access to configuration, it can use disables to substitute application functions. For example, it is known that an application uses ServiceX from some core module provided by the organization. Your module requires a modified service. Your bundle may disable the core module, and install a customized module as a replacement: public class MyFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . disableModules ( CoreModule . class ) . modules ( new CustomizedCoreModule ()); } } Note This is not the best pattern to follow. It is simpler to use binding override to override single service. This is an example for demonstration purposes. Bundles can't disable other bundles (because target bundle could be already processed at this point).","title":"Replace features"},{"location":"decomposition/#bundle-options","text":"Bundles can use the guicey options mechanism to access guicey option values: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { if ( bootstrap . option ( GuiceyOptions . UseHkBridge )) { // show warning that bridge required } } } There is also support for custom options . Note Option values are set only in main GuiceBundle . They are immutable, so all bundles receive the same option values.","title":"Bundle options"},{"location":"decomposition/#configuration-access","text":"A bundle may access direct dropwizard Configuration , as well as individual values thanks to yaml values introspection.","title":"Configuration access"},{"location":"decomposition/#qualified-properties","text":"Configuration properties, required for injection, could be simply annotated with a qualifier annotations : public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); And used directly in service: @Singleton public class MyService { @Inject @Named ( \"custom\" ) String prop ; @Inject @CustomQualifier SubObj obj ; } Or accessed in bundle (or guice module): public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { SubObj config = bootstrap . annotatedValue ( CustomQualifier . class ); ... } }","title":"Qualified properties"},{"location":"decomposition/#unique-sub-config","text":"When creating re-usable bundle it is often required to access yaml configuration data. Usually this is solved by some \"configuration look-ups\" like in dropwizard-views Guicey allows you to obtain the sub-configuration object directly: public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { XFeatureConfig environment = bootstrap . configuration ( XFeatureConfig . class ); ... } } Note that this bundle doesn't know exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration at any level just once . For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Your sub configuration object must appear only once within user configuration. Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt extends XFeatureConfig ) it will be different unique config.","title":"Unique sub config"},{"location":"decomposition/#access-by-path","text":"When you are not sure that configuration is unique, you can rely on exact path definition of required sub configuration: public class XFeatureBundle implements GuiceyBundle { private String path ; public XFeatureBundle ( String path ) { this . path = path ; } @Override public void run ( GuiceyEnvironment environment ) throws Exception { XFeatureConfig conf = environment . configuration ( path ); ... } } The Path may be declared by the bundle user, who knows required configuration location: GuiceBundle . builder () . bundles ( new XFeatureBundle ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... }","title":"Access by path"},{"location":"decomposition/#multiple-configs","text":"In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { List < XFeatureConfig > confs = environment . configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } This configurations method will return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses as well. So if there are XFeatureConfigExt extends XFeatureConfig declared somewhere it will also be returned.","title":"Multiple configs"},{"location":"decomposition/#custom-configuration-analysis","text":"In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) throws Exception { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = environment . configurationTree () . findAllRootPathsFrom ( MyConfig . class ); // search for not null values of marked (annotated) classes List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, the bundle searches for properties declared directly in the MyConfig configuration class with non-null values and the custom marker ( @MyMarker ) class annotation. See introspected configuration structure description for details.","title":"Custom configuration analysis"},{"location":"decomposition/#shared-state","text":"Guicey maintains special shared state object useful for storing application-wide data. Warning Yes, any shared state is a \"hack\". Normally, you should avoid using it. Guicey provides this ability to unify all such current and future hacks: so if you need to communicate between bundles - you don't need to reinvent the wheel and don't have additional problems in tests (due to leaking states). For example, it is used by spa bundle to share list of registered application names between all spa bundle instances and so be able to prevent duplicate name registration. Server pages bundle use shared state to maintain global configuration and allow application bundles communication with global views bundle.","title":"Shared state"},{"location":"decomposition/#equal-communication-scenario","text":"Use the following in cases when multiple (equal) bundles need to communicate, the first initialized bundle will initialize the shared state and others simply use it: public class EqualBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // either obtain already shared object or share new object SomeState state = bootstrap . sharedState ( EqualBundle , () -> new SomeState ()); ... } }","title":"Equal communication scenario"},{"location":"decomposition/#parent-child-scenario","text":"Use the following in cases when there is one global bundle, which must initialize some global state and child bundles, which use or append to this global state: public class GlobalBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // share global state object bootstrap . shareState ( GlobalBundle , new GlobalState ()); } } public class ChildBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // access shared object or fail when not found GlobalState state = environment . sharedStateOrFail ( GlobalBundle , \"Failed to obtain global state - check if global bundle registered\" ); } }","title":"Parent-child scenario"},{"location":"decomposition/#beforeafter-run-logic","text":"If multiple bundles must be synchronized on run phase, use guicey events . To run code after all guicey bundles have been initialized, but before run is called: @Override public void initialize ( final GuiceyBootstrap bootstrap ) { bootstrap . listen ( new GuiceyLifecycleAdapter () { @Override protected void beforeRun ( final BeforeRunEvent event ) { // do something before bundles run // NOTE that environment and configuration already available! } }); } To run code after all guicey bundles run methods have been called (delayed init): @Override public void run ( final GuiceyEnvironment environment ) { environment . listen ( new GuiceyLifecycleAdapter () { @Override protected void bundlesStarted ( final BundlesStartedEvent event ) { // still sdropwizard run phase (anything could be configured) // but all guicey bundles aready executed } }); } Note This will work only for guicey bundles! Registered dropwizard bundles may execute before or after these events. Events are broadcast from the main dropwizard GuiceBundle run method, so other dropwizard bundles, registered after guice bundle will run after it. It is assumed that guicey bundles will be used for most configurations, but especially in complex cases when bundle synchronization is required.","title":"Before/after run logic"},{"location":"dev/","text":"Development tips \u00b6 Summary Tips and tricks simplifying development Auto reload static resources in IntelliJ IDEA \u00b6 To enable automatic reload of static resources: Go to Help -> Find Action Type \"Registry\". Find and mark : \u201ccompiler.automake.allow.when.app.running\u201d. Go to \"Settings -> Build, Execution, Deployment -> Compiler\". Mark \"Build project automatically\". Warning This is not enabled by default in IDEA because this changes application classpath, which may be harmful for some applications. In case of dropwizard applications there should be no problems still (only with your custom logic dealing with classpath directly) Now static resources would \"hot swap\". Warning Note that template engines (freemarker, mustache) may cache templates","title":"Development tips"},{"location":"dev/#development-tips","text":"Summary Tips and tricks simplifying development","title":"Development tips"},{"location":"dev/#auto-reload-static-resources-in-intellij-idea","text":"To enable automatic reload of static resources: Go to Help -> Find Action Type \"Registry\". Find and mark : \u201ccompiler.automake.allow.when.app.running\u201d. Go to \"Settings -> Build, Execution, Deployment -> Compiler\". Mark \"Build project automatically\". Warning This is not enabled by default in IDEA because this changes application classpath, which may be harmful for some applications. In case of dropwizard applications there should be no problems still (only with your custom logic dealing with classpath directly) Now static resources would \"hot swap\". Warning Note that template engines (freemarker, mustache) may cache templates","title":"Auto reload static resources in IntelliJ IDEA"},{"location":"getting-started/","text":"Setup \u00b6 Getting started guide briefly shows the most commonly used features. Advanced descriptions of guicey concepts may be found in the concepts section . Installation \u00b6 Core guicey could be used directly: Maven: <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus:dropwizard-guicey:5.10.0' BOM \u00b6 But, it would be simpler to use it with BOM because of simplified versions management for guice, dropwizard and guicey modules : Gradle: dependencies { implementation platform ( 'ru.vyarus.guicey:guicey-bom:5.10.0' ) // uncomment to override dropwizard and its dependencies versions // implementation platform('io.dropwizard:dropwizard-dependencies:2.1.10') // no need to specify versions implementation 'ru.vyarus:dropwizard-guicey' // example modules without versions implementation 'io.dropwizard:dropwizard-auth' implementation 'com.google.inject:guice-assistedinject' testImplementation 'io.dropwizard:dropwizard-test' } Maven: <dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-bom </artifactId> <version> 5.10.0 </version> <type> pom </type> <scope> import </scope> </dependency> <!-- uncomment to override dropwizard and its dependencies versions <dependency> <groupId>io.dropwizard/groupId> <artifactId>dropwizard-dependencies</artifactId> <version>2.1.10</version> <type>pom</type> <scope>import</scope> </dependency> --> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> </dependency> </dependencies> Usage \u00b6 Full source of example application is published here Register guice bundle: public class SampleApplication extends Application < Configuration > { public static void main ( String [] args ) throws Exception { new SampleApplication (). run ( args ); } @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig () . build ()); } @Override public void run ( Configuration configuration , Environment environment ) throws Exception { } } Tip Bundle builder contains shortcuts for all available features, so required function may be found only by looking at available methods (and reading the javadoc). Auto configuration (activated with enableAutoConfig ) means that guicey will search for extensions in the application package and subpackages. Extension classes are detected by \"feature markers\": for example, resources has @Path annotation, tasks extends Task etc. Tip By default, auto configuration enabled for application package, but you can declare manually any packages for classpath scan: . enableAutoConfig ( \"com.mycompany.foo\" , \"com.mycompany.bar\" ) The application could be launched by running main class (assumes you will use an IDE run command): SampleApplication server Note a config.yml is not passed as a parameter because we don't need additional configuration yet Adding a Resource \u00b6 Create a custom rest resource class: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @GET @Path ( \"/\" ) public Response ask () { return Response . ok ( \"ok\" ). build (); } } After creating your resource, when you run the application the resource was installed automatically: INFO [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource) Call http://localhost:8080/sample/ to make sure it works. Tip Rest context is mapped to root by default. To change it use configuration file: server : rootPath : '/rest/*' Resource is a guice bean, so you can use guice injection inside it. To access request scoped objects like javax.servlet.http. HttpServletRequest , javax.servlet.http.HttpServletResponse , javax.ws.rs.core.UriInfo , org.glassfish.jersey.server. ContainerRequest , etc, you must wrap the desired objects in a Provider : @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/\" ) public Response ask () { final String ip = requestProvider . get (). getRemoteAddr (); return Response . ok ( ip ). build (); } } The example resource now obtains the caller's remote ip address and returns it in the response body. Warning Providers must be used instead of @Context field injections But @Context can be used for method parameters Note By default, resources are forced to be singletons (when no scope annotation defined). Adding a Managed Object \u00b6 Dropwizard managed objects are extremely useful for managing resources. Create a simple managed implementation: @Singleton public class SampleBootstrap implements Managed { private final Logger logger = LoggerFactory . getLogger ( SampleBootstrap . class ); @Override public void start () throws Exception { logger . info ( \"Starting some resource\" ); } @Override public void stop () throws Exception { logger . info ( \"Shutting down some resource\" ); } } The managed class will be automatically discovered and installed by Guicey. Guicey always reports installed extensions when they are not reported by dropwizard itself. In the start-up logs of the application, you can see: INFO [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap) Adding A Filter \u00b6 Note Guice ServletModule may be used for servlets and filters definitions, but most of the time it's more convenient to use simple servlet annotations ( @WebFilter , @WebServlet , @WebListener ). Moreover, guice servlet module is not able to register async filters and servlets . Add a sample filter around rest methods: @WebFilter ( urlPatterns = \"/*\" ) public class CustomHeaderFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( \"me\" . equals ( request . getParameter ( \"user\" ))) { chain . doFilter ( request , response ); } else { (( HttpServletResponse ) response ) . sendError ( HttpServletResponse . SC_UNAUTHORIZED , \"Not authorized\" ); } } @Override public void destroy () { } } The filter will only pass through requests with the user=me request parameter. It is used just to show how to register custom filters with annotations. The implementation itself is not useful. Upon start-up, new logs will confirm successful filter installation: INFO [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters = /* (ru.vyarus.dropwizard.guice.examples.web.AuthFilter) .auth Call http://localhost:8080/sample/ and http://localhost:8080/sample/?user=me to make sure filter works. Adding a Guice Module \u00b6 Guice module registration: bootstrap . addBundle ( GuiceBundle . builder () ... . modules ( new SampleModule ()) . build ()); Multiple modules could be registered at once: . modules ( new SampleModule (), new Some3rdPartyModule ()) Note The above registration occurs in dropwizard initialization phase, when neither Configuration nor Environment objects are available. If you need either of them in a module, you may register a module in guicey bundle's run method or use marker interfaces . Manual mode \u00b6 If you don't want to use classpath scanning for extension discovery, then you will have to manually specify all extensions. Example above would look in manual mode like this: bootstrap . addBundle ( GuiceBundle . builder () . modules ( new SampleModule ()) . extensions ( SampleResource . class , SampleBootstrap . class , CustomHeaderFilter . class ) . build ()); The only difference is the absence of .enableAutoConfig() and the explicit declaration of desired extensions. Tip Explicit extension declaration could be used together with enableAutoConfig (classpath scan). For example, a classpath scan may only scan for extensions in your application's package and subpackages, while extensions outside of those packages may be specified separately. This avoids large class path scans and improves the startup time of your application. Note Only distinct extensions are registered. Duplicates are not registered. If some extension is registered manually and also found with auto config, then only one instance of that extension will be registered. If an extension is registered multiple times manually, the same rules apply and only one extension instance will be registered. Configuration from bindings \u00b6 Guicey is also able to recognize extensions from declared guice bindings, so manual example above is equal to: bootstrap . addBundle ( GuiceBundle . builder () . modules ( new SampleModule ()) . build ()); public class SampleModule extends AbstractModule { @Override protected void configure () { bind ( SampleResource . class ). in ( Singleton . class ); bind ( SampleBootstrap . class ); bind ( CustomHeaderFilter . class ); } } Guicey will recognize all three bindings and register extensions. The difference with classpath scanning or manual declaration is only that guicey will not declare default bindings for extensions (by default, guicey creates untargeted bindings for all extensions: bind(Extension.class) ). Tip An extension may be found three ways: by classpath scan, explicit extension declaration on the GuiceBundle, and by declaring a binding in a guice module. Even if all three were used, the extension would only be registered once. Recognized Extensions \u00b6 Guicey can recognize and install: Dropwizard tasks Dropwizard managed objects Dropwizard health checks REST resources REST extensions (exception mappers, message body readers etc.) Jersey features Filters , servlets , listeners Eager singletons , without direct guice registration It can even simulate simple plugins . Other extension types may be recognized with additional installed modules. For example, jdbi adds support for jdbi mappers and repositories. You may add others yourself. Any existing extension integration may be replaced, if it doesn't suit your needs. Tip If you are unsure or don't understand what guicey is using for its configuration, enable diagnostic logs: GuiceBundle . builder () . printDiagnosticInfo () ... To see what extensions are supported you can always use: GuiceBundle . builder () . printAvailableInstallers () And to see available guice bindings: GuiceBundle . builder () . printGuiceBindings () Guicey Bundles \u00b6 Guicey Bundles are intended to extend the functionality of Dropwizard Bundles, not limit them. To get access for these extended abilities you'll need to use GuiceyBundle instead of a dropwizard ConfiguredBundle . The Guicey Bundle lifecycle and methods are the same as Dropwizard Bundles. Guicey Bundles simply provide more functionality. Attention This does not mean that dropwizard bundles can't be used! An opposite, Guicey provides direct shortcuts for them in its bundles: public class MyBundle implements GuiceyBundle { default void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundles ( new MyDropeizardBundle ()); } } Additional features will be available for Dropwizard Bundles registered through guicey api and they also will appear in reports. You can always use vanilla Dropwizard Bundles if you don't need to register guice modules or use other guicey features. Usually Dropwizard Bundles used when the required integration has already implemented as a 3 rd party Dropwizard Bundle.","title":"Setup"},{"location":"getting-started/#setup","text":"Getting started guide briefly shows the most commonly used features. Advanced descriptions of guicey concepts may be found in the concepts section .","title":"Setup"},{"location":"getting-started/#installation","text":"Core guicey could be used directly: Maven: <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus:dropwizard-guicey:5.10.0'","title":"Installation"},{"location":"getting-started/#bom","text":"But, it would be simpler to use it with BOM because of simplified versions management for guice, dropwizard and guicey modules : Gradle: dependencies { implementation platform ( 'ru.vyarus.guicey:guicey-bom:5.10.0' ) // uncomment to override dropwizard and its dependencies versions // implementation platform('io.dropwizard:dropwizard-dependencies:2.1.10') // no need to specify versions implementation 'ru.vyarus:dropwizard-guicey' // example modules without versions implementation 'io.dropwizard:dropwizard-auth' implementation 'com.google.inject:guice-assistedinject' testImplementation 'io.dropwizard:dropwizard-test' } Maven: <dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-bom </artifactId> <version> 5.10.0 </version> <type> pom </type> <scope> import </scope> </dependency> <!-- uncomment to override dropwizard and its dependencies versions <dependency> <groupId>io.dropwizard/groupId> <artifactId>dropwizard-dependencies</artifactId> <version>2.1.10</version> <type>pom</type> <scope>import</scope> </dependency> --> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> </dependency> </dependencies>","title":"BOM"},{"location":"getting-started/#usage","text":"Full source of example application is published here Register guice bundle: public class SampleApplication extends Application < Configuration > { public static void main ( String [] args ) throws Exception { new SampleApplication (). run ( args ); } @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig () . build ()); } @Override public void run ( Configuration configuration , Environment environment ) throws Exception { } } Tip Bundle builder contains shortcuts for all available features, so required function may be found only by looking at available methods (and reading the javadoc). Auto configuration (activated with enableAutoConfig ) means that guicey will search for extensions in the application package and subpackages. Extension classes are detected by \"feature markers\": for example, resources has @Path annotation, tasks extends Task etc. Tip By default, auto configuration enabled for application package, but you can declare manually any packages for classpath scan: . enableAutoConfig ( \"com.mycompany.foo\" , \"com.mycompany.bar\" ) The application could be launched by running main class (assumes you will use an IDE run command): SampleApplication server Note a config.yml is not passed as a parameter because we don't need additional configuration yet","title":"Usage"},{"location":"getting-started/#adding-a-resource","text":"Create a custom rest resource class: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @GET @Path ( \"/\" ) public Response ask () { return Response . ok ( \"ok\" ). build (); } } After creating your resource, when you run the application the resource was installed automatically: INFO [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource) Call http://localhost:8080/sample/ to make sure it works. Tip Rest context is mapped to root by default. To change it use configuration file: server : rootPath : '/rest/*' Resource is a guice bean, so you can use guice injection inside it. To access request scoped objects like javax.servlet.http. HttpServletRequest , javax.servlet.http.HttpServletResponse , javax.ws.rs.core.UriInfo , org.glassfish.jersey.server. ContainerRequest , etc, you must wrap the desired objects in a Provider : @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/\" ) public Response ask () { final String ip = requestProvider . get (). getRemoteAddr (); return Response . ok ( ip ). build (); } } The example resource now obtains the caller's remote ip address and returns it in the response body. Warning Providers must be used instead of @Context field injections But @Context can be used for method parameters Note By default, resources are forced to be singletons (when no scope annotation defined).","title":"Adding a Resource"},{"location":"getting-started/#adding-a-managed-object","text":"Dropwizard managed objects are extremely useful for managing resources. Create a simple managed implementation: @Singleton public class SampleBootstrap implements Managed { private final Logger logger = LoggerFactory . getLogger ( SampleBootstrap . class ); @Override public void start () throws Exception { logger . info ( \"Starting some resource\" ); } @Override public void stop () throws Exception { logger . info ( \"Shutting down some resource\" ); } } The managed class will be automatically discovered and installed by Guicey. Guicey always reports installed extensions when they are not reported by dropwizard itself. In the start-up logs of the application, you can see: INFO [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)","title":"Adding a Managed Object"},{"location":"getting-started/#adding-a-filter","text":"Note Guice ServletModule may be used for servlets and filters definitions, but most of the time it's more convenient to use simple servlet annotations ( @WebFilter , @WebServlet , @WebListener ). Moreover, guice servlet module is not able to register async filters and servlets . Add a sample filter around rest methods: @WebFilter ( urlPatterns = \"/*\" ) public class CustomHeaderFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( \"me\" . equals ( request . getParameter ( \"user\" ))) { chain . doFilter ( request , response ); } else { (( HttpServletResponse ) response ) . sendError ( HttpServletResponse . SC_UNAUTHORIZED , \"Not authorized\" ); } } @Override public void destroy () { } } The filter will only pass through requests with the user=me request parameter. It is used just to show how to register custom filters with annotations. The implementation itself is not useful. Upon start-up, new logs will confirm successful filter installation: INFO [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters = /* (ru.vyarus.dropwizard.guice.examples.web.AuthFilter) .auth Call http://localhost:8080/sample/ and http://localhost:8080/sample/?user=me to make sure filter works.","title":"Adding A Filter"},{"location":"getting-started/#adding-a-guice-module","text":"Guice module registration: bootstrap . addBundle ( GuiceBundle . builder () ... . modules ( new SampleModule ()) . build ()); Multiple modules could be registered at once: . modules ( new SampleModule (), new Some3rdPartyModule ()) Note The above registration occurs in dropwizard initialization phase, when neither Configuration nor Environment objects are available. If you need either of them in a module, you may register a module in guicey bundle's run method or use marker interfaces .","title":"Adding a Guice Module"},{"location":"getting-started/#manual-mode","text":"If you don't want to use classpath scanning for extension discovery, then you will have to manually specify all extensions. Example above would look in manual mode like this: bootstrap . addBundle ( GuiceBundle . builder () . modules ( new SampleModule ()) . extensions ( SampleResource . class , SampleBootstrap . class , CustomHeaderFilter . class ) . build ()); The only difference is the absence of .enableAutoConfig() and the explicit declaration of desired extensions. Tip Explicit extension declaration could be used together with enableAutoConfig (classpath scan). For example, a classpath scan may only scan for extensions in your application's package and subpackages, while extensions outside of those packages may be specified separately. This avoids large class path scans and improves the startup time of your application. Note Only distinct extensions are registered. Duplicates are not registered. If some extension is registered manually and also found with auto config, then only one instance of that extension will be registered. If an extension is registered multiple times manually, the same rules apply and only one extension instance will be registered.","title":"Manual mode"},{"location":"getting-started/#configuration-from-bindings","text":"Guicey is also able to recognize extensions from declared guice bindings, so manual example above is equal to: bootstrap . addBundle ( GuiceBundle . builder () . modules ( new SampleModule ()) . build ()); public class SampleModule extends AbstractModule { @Override protected void configure () { bind ( SampleResource . class ). in ( Singleton . class ); bind ( SampleBootstrap . class ); bind ( CustomHeaderFilter . class ); } } Guicey will recognize all three bindings and register extensions. The difference with classpath scanning or manual declaration is only that guicey will not declare default bindings for extensions (by default, guicey creates untargeted bindings for all extensions: bind(Extension.class) ). Tip An extension may be found three ways: by classpath scan, explicit extension declaration on the GuiceBundle, and by declaring a binding in a guice module. Even if all three were used, the extension would only be registered once.","title":"Configuration from bindings"},{"location":"getting-started/#recognized-extensions","text":"Guicey can recognize and install: Dropwizard tasks Dropwizard managed objects Dropwizard health checks REST resources REST extensions (exception mappers, message body readers etc.) Jersey features Filters , servlets , listeners Eager singletons , without direct guice registration It can even simulate simple plugins . Other extension types may be recognized with additional installed modules. For example, jdbi adds support for jdbi mappers and repositories. You may add others yourself. Any existing extension integration may be replaced, if it doesn't suit your needs. Tip If you are unsure or don't understand what guicey is using for its configuration, enable diagnostic logs: GuiceBundle . builder () . printDiagnosticInfo () ... To see what extensions are supported you can always use: GuiceBundle . builder () . printAvailableInstallers () And to see available guice bindings: GuiceBundle . builder () . printGuiceBindings ()","title":"Recognized Extensions"},{"location":"getting-started/#guicey-bundles","text":"Guicey Bundles are intended to extend the functionality of Dropwizard Bundles, not limit them. To get access for these extended abilities you'll need to use GuiceyBundle instead of a dropwizard ConfiguredBundle . The Guicey Bundle lifecycle and methods are the same as Dropwizard Bundles. Guicey Bundles simply provide more functionality. Attention This does not mean that dropwizard bundles can't be used! An opposite, Guicey provides direct shortcuts for them in its bundles: public class MyBundle implements GuiceyBundle { default void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundles ( new MyDropeizardBundle ()); } } Additional features will be available for Dropwizard Bundles registered through guicey api and they also will appear in reports. You can always use vanilla Dropwizard Bundles if you don't need to register guice modules or use other guicey features. Usually Dropwizard Bundles used when the required integration has already implemented as a 3 rd party Dropwizard Bundle.","title":"Guicey Bundles"},{"location":"guice/","text":"Guice \u00b6 Note It is important to say that guicey did not apply any \"guice magic\" . Guicey just register additional bindings, which you can use in your beans. Or you can simply enable full guice report ( .printAllGuiceBindings() ) and see all added bindings under GuiceBootsrapModule : 7 MODULES with 106 bindings \u2502 \u2514\u2500\u2500 GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 <scope> [@Prototype] - at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:51) \u251c\u2500\u2500 instance [@Singleton] Options at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:57) \u251c\u2500\u2500 instance [@Singleton] ConfigurationInfo at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:60) ... Added bindings \u00b6 All applied bindings are described in the user guide . Main objects: io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Bindings below are not immediately available as HK2 context starts after guice : javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.internal.process.AsyncContext javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse Request scoped objects must be used through provider: @Inject Provider < HttpServletRequest > requestProvider ; Warning Pay attention that inside rest resources @Context injection on fields will not work on fields , but will for method arguments. Configuration bindings \u00b6 It is quite common need to access configuration value by path, instead of using entire configuration object. Often this removes boilerplate when one option is used in multiple places, compare: @Inject MyConfiguration config ... // in each usage config . getSub (). getFoo () and @Inject @Config ( \"sub.foo\" ) String foo ; // and use direct value in all places Also, often you have some unique configuration sub object, e.g. public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; } It may be more convenient to bind it directly, instead of full configuration: @Inject @Config AuthConfig auth ; See complete description in the user guide Warning If not disabled , guicey will always bind all configuration values (including values from base Configuration class). Don't be confused when use custom config report - it just not shows common bindings for simplicity, but they are still applied. Note Use configuration bindings report to see available configuration bindings. It is executed before injector creation and so could be used for problems diagnosis. Bindings may change with configuration values changes (e.g. server section depends on server implementation used). You can also annotate any configuration property (or getter) with qualifier annotation and property value would be bound with this qualifier directly : public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); ... @Singleton public class MyService { @Inject @Named ( \"custom\" ) String prop ; @Inject @CustomQualifier SubObj obj ; } Extensions and AOP \u00b6 As it was mentioned guice knows about extensions either by classpath scan search, manual declaration or guice bindings. Recognition from guice binding is not interesting as you bind it manually. Auto scan and manual declaration are essentially the same: guicey have extension class, which must be bound to guice context . In most cases it would be just bind(Extension.class) (but some installers can do more sophisticated bindings, like plugins installer ). As you can see, in all cases extension is constructed by guice and so AOP features will work. Note While HK2 is still used, instance management may be delegated to HK2 but it is not used in core guicey (just an ability; this is almost never required) All extensions recognized from guice bindings are clearly visible in the configuration report . Servlets and filters \u00b6 GuiceFilter is registered on both main and admin contexts. Guice servlets and filters (registered through ServletModule ) may co-exist with pure servlets and filters: as guice filter intercept both contexts, it would be able to manage request scope for all calls (even rest). When you register servlets and filters directly, their instances will be managed by guice (because they are extensions ), just dispatching will work a bit differently, which is almost never important. As you can see, in case of servlets, AOP features will also be always available. Moreover, scopes will work as expected. Note Web report could show actual mapping difference between pure servlets and GuiceFilter -managed servlets. Startup \u00b6 The only not intuitive step, performed by guicey, is modules analysis : just before injector creation guicey parse all registered modules (using guice SPI ): List < Element > elements = Elements . getElements ( modules ) Note Pay attention that guicey looks only actual bindings before injector creation. And that's why it would not \"see\" JIT bindings (bindings that was not declared and created just because guice found an injection point). This is intentional to force declaration of all important bindings. To avoid re-parsing elements during injector creation, guicey pack all parsed elements as module with: Module module = Elements . getModule ( elements ) And so guicey injector factory will receive this synthetic module. So if you need access to raw module, you can either do it with event or disable modules analysis (but in this case some features would not work) Note Guice bindings override ( Modules.override() ), available through guicey api modulesOverride() , will also cause synthetic module (because overrides are applied before calling injector factory). But this supposed to be used for tests only (just to mention). AOP \u00b6 Not guicey-related, but still, as it's not always obvious how AOP is applied on beans use AOP report - it shows all affected beans and (more importantly) applied aop handlers order.","title":"Guice"},{"location":"guice/#guice","text":"Note It is important to say that guicey did not apply any \"guice magic\" . Guicey just register additional bindings, which you can use in your beans. Or you can simply enable full guice report ( .printAllGuiceBindings() ) and see all added bindings under GuiceBootsrapModule : 7 MODULES with 106 bindings \u2502 \u2514\u2500\u2500 GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 <scope> [@Prototype] - at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:51) \u251c\u2500\u2500 instance [@Singleton] Options at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:57) \u251c\u2500\u2500 instance [@Singleton] ConfigurationInfo at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:60) ...","title":"Guice"},{"location":"guice/#added-bindings","text":"All applied bindings are described in the user guide . Main objects: io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Bindings below are not immediately available as HK2 context starts after guice : javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.internal.process.AsyncContext javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse Request scoped objects must be used through provider: @Inject Provider < HttpServletRequest > requestProvider ; Warning Pay attention that inside rest resources @Context injection on fields will not work on fields , but will for method arguments.","title":"Added bindings"},{"location":"guice/#configuration-bindings","text":"It is quite common need to access configuration value by path, instead of using entire configuration object. Often this removes boilerplate when one option is used in multiple places, compare: @Inject MyConfiguration config ... // in each usage config . getSub (). getFoo () and @Inject @Config ( \"sub.foo\" ) String foo ; // and use direct value in all places Also, often you have some unique configuration sub object, e.g. public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; } It may be more convenient to bind it directly, instead of full configuration: @Inject @Config AuthConfig auth ; See complete description in the user guide Warning If not disabled , guicey will always bind all configuration values (including values from base Configuration class). Don't be confused when use custom config report - it just not shows common bindings for simplicity, but they are still applied. Note Use configuration bindings report to see available configuration bindings. It is executed before injector creation and so could be used for problems diagnosis. Bindings may change with configuration values changes (e.g. server section depends on server implementation used). You can also annotate any configuration property (or getter) with qualifier annotation and property value would be bound with this qualifier directly : public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); ... @Singleton public class MyService { @Inject @Named ( \"custom\" ) String prop ; @Inject @CustomQualifier SubObj obj ; }","title":"Configuration bindings"},{"location":"guice/#extensions-and-aop","text":"As it was mentioned guice knows about extensions either by classpath scan search, manual declaration or guice bindings. Recognition from guice binding is not interesting as you bind it manually. Auto scan and manual declaration are essentially the same: guicey have extension class, which must be bound to guice context . In most cases it would be just bind(Extension.class) (but some installers can do more sophisticated bindings, like plugins installer ). As you can see, in all cases extension is constructed by guice and so AOP features will work. Note While HK2 is still used, instance management may be delegated to HK2 but it is not used in core guicey (just an ability; this is almost never required) All extensions recognized from guice bindings are clearly visible in the configuration report .","title":"Extensions and AOP"},{"location":"guice/#servlets-and-filters","text":"GuiceFilter is registered on both main and admin contexts. Guice servlets and filters (registered through ServletModule ) may co-exist with pure servlets and filters: as guice filter intercept both contexts, it would be able to manage request scope for all calls (even rest). When you register servlets and filters directly, their instances will be managed by guice (because they are extensions ), just dispatching will work a bit differently, which is almost never important. As you can see, in case of servlets, AOP features will also be always available. Moreover, scopes will work as expected. Note Web report could show actual mapping difference between pure servlets and GuiceFilter -managed servlets.","title":"Servlets and filters"},{"location":"guice/#startup","text":"The only not intuitive step, performed by guicey, is modules analysis : just before injector creation guicey parse all registered modules (using guice SPI ): List < Element > elements = Elements . getElements ( modules ) Note Pay attention that guicey looks only actual bindings before injector creation. And that's why it would not \"see\" JIT bindings (bindings that was not declared and created just because guice found an injection point). This is intentional to force declaration of all important bindings. To avoid re-parsing elements during injector creation, guicey pack all parsed elements as module with: Module module = Elements . getModule ( elements ) And so guicey injector factory will receive this synthetic module. So if you need access to raw module, you can either do it with event or disable modules analysis (but in this case some features would not work) Note Guice bindings override ( Modules.override() ), available through guicey api modulesOverride() , will also cause synthetic module (because overrides are applied before calling injector factory). But this supposed to be used for tests only (just to mention).","title":"Startup"},{"location":"guice/#aop","text":"Not guicey-related, but still, as it's not always obvious how AOP is applied on beans use AOP report - it shows all affected beans and (more importantly) applied aop handlers order.","title":"AOP"},{"location":"tests/","text":"Testing \u00b6 Core dropwziard testing support proposes atomic testing approach (separate testing of each element, which you still could use when possible). With DI (guice) we have to move towards integration testing because: It is now harder to mock classes \"manually\" (because of DI \"black box\") We have a core (guice injector, without web services), starting much faster than complete application. Guicey tests \u00b6 Guicey intended to shine in integration tests: it provides a lot of tools for application modification. The most important is hooks mechanism which allows you to re-configure existing application. There are two main testing approaches: Disable everything not required and register custom versions instead Override some bindings (pure guice Modules.override() method) Disable and replace \u00b6 Suppose we have the following application: public class App extends Application < MyConfig > { public void initialize ( Bootstrap < MyConfig > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new SecurityOnlyBundle ()) . modules ( new ServiceModule (), new DaoModule ()) . build () } } Specifically for tests we create special module MockDaoModule which applies all the same bindings, but with mock implementations. Just for demonstration, suppose that application registers SecurityOnlyBundle which do nothing except of additional security. Suppose we don't need this in tests. @TestGuiceyApp ( App . class ) public class MyTest { @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . disableBundles ( SecurityOnlyBundle . class ) . disableModules ( DaoModule . class ) . modules ( new MockDaoModule ()); } Here hook applied to: remove SecurityOnlyBundle remove DaoModule add MockDaoModule This way you can disable everything : module, extensions, guicey and dropwizard bundles and installers. Note Bundles (both guice and dropwizard) and guice modules are actually hierarchical (one bundle/module can register other bundle/module) and you can disable even exact bundle/module inside this hierarchy (not just directly registered). See more: about guice transitive bundles and dropwizard transitive bundles All disables are shown on diagnostic report - you can use it to verify configuration state. Override bindings \u00b6 We can do the same without replacing module, but overriding bindings using guice Modules.override() feature. This is preferred in cases when modules are not so well structured and you need to override just a subset of bindings (not all bindings in module). Above example would look like: @TestDropwizardApp ( App . class ) public class MyTest { @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . disableBundles ( SecurityOnlyBundle . class ) . modulesOverride ( new MockDaoModule ()); } In the previous example all bindings from DaoModule were removed and here we just register overriding bindings so bindings from MockDaoModule will be used instead of (the same) bindings from DaoModule . Note All overrides are visible on guice report - use it to verify override correctness. Configuration \u00b6 For tests you can use custom configuration file (e.g. src/test/resources/test-config.yml ). @TestDropwizardApp ( value = MyApp . class , conifg = \"src/test/resources/test-config.yml\" ) Or just override exact values (without declaring config file): @TestDropwizardApp ( value = MyApp . class , conifgOverride = \"server.applicationConnectors[0].port: 0\" ) Lightweight tests \u00b6 In many cases, you don't need the entire application, but just a working Injector to check core application logic. For such cases, guicey provides lightweight extensions like @TestGuiceyApp : will not start jetty (no ports bind, no HK2 launched) start Managed objects to simulate lifecycle These tests work much faster! @TestGuiceyApp ( App . class ) public class MyTest { @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . disableBundles ( SecurityOnlyBundle . class ) . modulesOverride ( new MockDaoModule ()); @Test public void test ( MyService service ) { service . doSomething (); ... } } Spock \u00b6 All examples above was for junit 5, but you can also use groovy-based Spock framework 2 . Spock tests are much easier to write (you can write less code) and more expressive. You'll use the same Junit 5 rules (instead of writing custom spock extensions, junit 5 compatibility layer was implemented , so you can use any junit 5 extensions with spock). See this article for spock usage motivation. For example, the first junit example will look like in spock: @TestDropwizardApp ( App ) class MyTest extends Specification { @EnableHook static GuiceyConfigurationHook HOOK = { it . disableBundles ( SecurityOnlyBundle ) . disableModules ( DaoModule ) . modules ( new MockDaoModule ()) } @Inject MyService service def 'Check service method' () { when: 'calling service method' def res = service . doSoomething () then: 'value is correct' res == 12 } } See Spock 2 docs for more details. Testing commands \u00b6 Guicey also provides special support for testing dropwizard commands : CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); Such run never fails (in case of error exception would be inside result object) Result countain all required objects for assertions and contains Full console output is accessible for assertions Could mock user input (for commands requiring interaction) Also commands could be used to check application failures on startup (self-checks testing): CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Such test would fail in case of successful application start. No additional mocks or extensions required because running like this would not cause System.exist(1) call, performed in Application class (see Application.onFatalError ).","title":"Testing"},{"location":"tests/#testing","text":"Core dropwziard testing support proposes atomic testing approach (separate testing of each element, which you still could use when possible). With DI (guice) we have to move towards integration testing because: It is now harder to mock classes \"manually\" (because of DI \"black box\") We have a core (guice injector, without web services), starting much faster than complete application.","title":"Testing"},{"location":"tests/#guicey-tests","text":"Guicey intended to shine in integration tests: it provides a lot of tools for application modification. The most important is hooks mechanism which allows you to re-configure existing application. There are two main testing approaches: Disable everything not required and register custom versions instead Override some bindings (pure guice Modules.override() method)","title":"Guicey tests"},{"location":"tests/#disable-and-replace","text":"Suppose we have the following application: public class App extends Application < MyConfig > { public void initialize ( Bootstrap < MyConfig > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new SecurityOnlyBundle ()) . modules ( new ServiceModule (), new DaoModule ()) . build () } } Specifically for tests we create special module MockDaoModule which applies all the same bindings, but with mock implementations. Just for demonstration, suppose that application registers SecurityOnlyBundle which do nothing except of additional security. Suppose we don't need this in tests. @TestGuiceyApp ( App . class ) public class MyTest { @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . disableBundles ( SecurityOnlyBundle . class ) . disableModules ( DaoModule . class ) . modules ( new MockDaoModule ()); } Here hook applied to: remove SecurityOnlyBundle remove DaoModule add MockDaoModule This way you can disable everything : module, extensions, guicey and dropwizard bundles and installers. Note Bundles (both guice and dropwizard) and guice modules are actually hierarchical (one bundle/module can register other bundle/module) and you can disable even exact bundle/module inside this hierarchy (not just directly registered). See more: about guice transitive bundles and dropwizard transitive bundles All disables are shown on diagnostic report - you can use it to verify configuration state.","title":"Disable and replace"},{"location":"tests/#override-bindings","text":"We can do the same without replacing module, but overriding bindings using guice Modules.override() feature. This is preferred in cases when modules are not so well structured and you need to override just a subset of bindings (not all bindings in module). Above example would look like: @TestDropwizardApp ( App . class ) public class MyTest { @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . disableBundles ( SecurityOnlyBundle . class ) . modulesOverride ( new MockDaoModule ()); } In the previous example all bindings from DaoModule were removed and here we just register overriding bindings so bindings from MockDaoModule will be used instead of (the same) bindings from DaoModule . Note All overrides are visible on guice report - use it to verify override correctness.","title":"Override bindings"},{"location":"tests/#configuration","text":"For tests you can use custom configuration file (e.g. src/test/resources/test-config.yml ). @TestDropwizardApp ( value = MyApp . class , conifg = \"src/test/resources/test-config.yml\" ) Or just override exact values (without declaring config file): @TestDropwizardApp ( value = MyApp . class , conifgOverride = \"server.applicationConnectors[0].port: 0\" )","title":"Configuration"},{"location":"tests/#lightweight-tests","text":"In many cases, you don't need the entire application, but just a working Injector to check core application logic. For such cases, guicey provides lightweight extensions like @TestGuiceyApp : will not start jetty (no ports bind, no HK2 launched) start Managed objects to simulate lifecycle These tests work much faster! @TestGuiceyApp ( App . class ) public class MyTest { @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . disableBundles ( SecurityOnlyBundle . class ) . modulesOverride ( new MockDaoModule ()); @Test public void test ( MyService service ) { service . doSomething (); ... } }","title":"Lightweight tests"},{"location":"tests/#spock","text":"All examples above was for junit 5, but you can also use groovy-based Spock framework 2 . Spock tests are much easier to write (you can write less code) and more expressive. You'll use the same Junit 5 rules (instead of writing custom spock extensions, junit 5 compatibility layer was implemented , so you can use any junit 5 extensions with spock). See this article for spock usage motivation. For example, the first junit example will look like in spock: @TestDropwizardApp ( App ) class MyTest extends Specification { @EnableHook static GuiceyConfigurationHook HOOK = { it . disableBundles ( SecurityOnlyBundle ) . disableModules ( DaoModule ) . modules ( new MockDaoModule ()) } @Inject MyService service def 'Check service method' () { when: 'calling service method' def res = service . doSoomething () then: 'value is correct' res == 12 } } See Spock 2 docs for more details.","title":"Spock"},{"location":"tests/#testing-commands","text":"Guicey also provides special support for testing dropwizard commands : CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); Such run never fails (in case of error exception would be inside result object) Result countain all required objects for assertions and contains Full console output is accessible for assertions Could mock user input (for commands requiring interaction) Also commands could be used to check application failures on startup (self-checks testing): CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Such test would fail in case of successful application start. No additional mocks or extensions required because running like this would not cause System.exist(1) call, performed in Application class (see Application.onFatalError ).","title":"Testing commands"},{"location":"about/compatibility/","text":"Dropwizard compatibility \u00b6 Dropwizard Guicey 2.1.0 5.10.0 2.0.0 5.5.0 1.3.0 4.2.3 1.2.0 4.1.0 1.1.0 4.1.0 1.0 4.0.1 0.9 3.3.0 0.8 3.1.0 0.7 1.1.0","title":"Compatibility"},{"location":"about/compatibility/#dropwizard-compatibility","text":"Dropwizard Guicey 2.1.0 5.10.0 2.0.0 5.5.0 1.3.0 4.2.3 1.2.0 4.1.0 1.1.0 4.1.0 1.0 4.0.1 0.9 3.3.0 0.8 3.1.0 0.7 1.1.0","title":"Dropwizard compatibility"},{"location":"about/history/","text":"5.10.0 (2023-11-28) \u00b6 Update to dropwizard 2.1.10 Add jsr305 as direct dependency to simplify usage @javax.annotation.Nullable (annotation is required for guice when nullable value could be injected) Add qualifier annotations support for configuration properties binding: any configuration property (any level), annotated with qualifier annotation, would be directly bound with that qualifier. Core dropwizard objects could be qualified on overridden getter Test improvements: Junit 5 extensions could inject DropwizardTestSupport object itself as test method parameter ClientSupport: inner jersey client creation is customizable now with TestClientFactory implementation (new attribute \"clientFactory\" in @TestGuiceyApp and @TestDropwizardApp) default factory would automatically configure: multipart feature if available in classpath (dropwizard-forms) direct console logging (to see requests and responses directly in console) New methods: basePathRoot - root url (only with port) get(), post(), delete(), put() - simple shortcut methods to perform basic operations relative to server root Context support object (DropwizardTestSupport) and client (ClientSupport) instances are accessible now statically for both manual run (TestSupport) and junit extensions: TestSupport.getContext() and TestSupport.getContextClient() New generic builder for flexible DropwizardTestSupport object creation and run (when junit extension can't be used): TestSupport.builder() (with lifecycle listeners support) TestSupport methods changes: Creation and run methods updated with config override (strings) support Add creation and run methods application class only (and optional overrides). Run methods without callback now return RunResult containing all objects, required for validation (for example, to examine config) Add captureOutput method to record console output for assertions Commands test support: TestSupport.buildCommandRunner() - builds runner for command execution with the same builder options as in generic builder (TestSupport.builder(); including same configuration) and user input support. Could be used to test application startup fail (without using system mocks) 5.9.3 (2023-11-05) \u00b6 Update to dropwizard 2.1.9 NOTE: dropwizard-jdbi3 drops java 8 support in gradle because it leaks (through metrics-jdbi3) jdbi3 3.43.1, compiled for java 11, so, for java 8 compatibility, you'll have to manually force the correct version: implementation ( 'org.jdbi:jdbi3-core' ) { version { strictly '3.39.1' } } 5.9.2 (2023-10-06) \u00b6 Update to dropwizard 2.1.8 5.9.1 (2023-07-05) \u00b6 Update to dropwizard 2.1.7 Add missed javax.inject dependency (guice 6 could work with both javax and jakarta) Fix BOM for MAVEN projects: incorrect jakarta.inject version was selected (#317) [jdbi] Fix jdbi 3.39 compatibility Avoid redundant transaction isolation level checks (extra queries) (#318) [gsp] Fix redirection to error page after direct template rendering fails 5.9.0 (2023-05-14) \u00b6 Update to guice 6.0 5.8.1 (2023-04-28) \u00b6 Fix BOM for correct guava version selection in maven (#302) 5.8.0 (2023-04-24) \u00b6 Update to dropwizard 2.1.6 Merged with guicey-ext modules repository: Ext modules version would be the same as guicey dropwizard-guicey POM would not be a BOM anymore (everything moved to guicey-bom) Exclusions not applied in BOM anymore, instead they applied directly in POM 5.7.1 (2023-03-09) \u00b6 Update to dropwizard 2.1.5 Revert changing reports log level: now INFO used instead of WARN (#276) 5.7.0 (2022-12-29) \u00b6 Update to dropwizard 2.1.4 Fix NoClassDefFoundError(AbstractCollectionJaxbProvider) appeared for some jersey provider registrations (#240) Jersey extensions might omit @Provider on known extension types (ExceptionMapper, MessageBodyReader, etc.). Unifies usage with pure dropwizard (no additional @Provider annotation required). (#265) New option InstallerOptions.JerseyExtensionsRecognizedByType could disable new behaviour Support ModelProcessor jersey extension installation (#186) Add extensions help: .printExtensionsHelp() showing extension signs recognized by installers (in recognition order) Custom installers could participate in report by overriding FeatureInstaller.getRecognizableSigns() (default interface method). Change reports log level from INFO to WARN to comply with default dropwizard level Support application reuse between tests (#269) new reuseApplication parameter in extensions enables reuse reusable application must be declared in base test class: all tests derived from this base class would use the same application instance Add SBOM (json and xml with cyclonedx classifier) Add .enableAutoConfig() no-args shortcut for enabling classpath scan in application package 5.6.1 (2022-07-02) \u00b6 Update dropwizard to 2.1.1 (fixes java 8 issue by allowing afterburner usage) Fix classpath scan recognition of inner static classes inside jars (#231) Junit 5 extensions: Fix parallel test methods support (configuration overrides were applied incorrectly) Add \"debug\" option: when enabled, prints registered setup objects, hooks and applied configuration overrides Setup objects and hooks not printed by default as before, only when debug enabled Debug could be also enabled with system property -Dguicey.extensions.debug=true or with alias TestSupport.debugExtensions() 5.6.0 (2022-06-07) \u00b6 Update dropwizard to 2.1.0 Test support objects changes: Add new interface TestEnvironmentSetup to simplify test environment setup In contrast to guicey hooks, setup objects used only in tests to replace the need of writing additional junit extensions (for example, to set up a test db). It provides a simple way to override application configuration (e.g. to specify credentials to just started db) Registration is the same as with hooks: annotation or inside extension builder and with field using new annotation @EnableSetup Hooks and setup objects configured in test are logged now in execution order and with registration source hint @EnableHook fields might be declared with custom classes (not only raw hook interface) Junit 5 extensions field registration (@RegisterExtension) changes Application might be started per-test-method now (when extension registered in non-static field) In this case support objects might also be registered in non-static fields Add configOverrideByExtension method to read configuration override value registered by 3 rd party junit 5 extension (from junit extension store). hooks(Class) method accepts multiple classes configOverrides(String...) now aggregates multiple calls 5.5.0 (2022-03-30) \u00b6 Test framework-agnostic utilities: Add GuiceyTestSupport to simplify guice-only manual application runs (by analogy to DropwizardTestSupport class) Add TestSupport class as a root for test framework-agnostic utilities. Suitable for application startup errors testing and integration within not supported test runner. Add Spock 2 support: there is no custom extensions, instead existing junit 5 extensions would be used through a special library spock-junit5 (developed specifically for this integration) Change \"hooks in base test class\" behaviour: hooks from static fields from base classes applied before hooks in test itself. Such behaviour is more natural - \"base classes declarations go first\" (before all field hooks were applied after annotation hooks) Extract Spock 1 and Junit 4 extensions from core into ext modules: packages remain the same, so there should be no issues with it (just add new dependency) removed deprecation markers from Junit 4 rules (entire module assumed to be deprecated; fewer warnings on build) BOM changes: spock version removed in order to avoid problems downgrading spock version for spock1 module system-rules removed because it targets junit4 (ext module provides it) groovy libraries removed (newer groovy 2.x was required for spock1 to run on java 11) add spock-junit5 version 5.4.2 (2022-01-26) \u00b6 Update dropwizard to 2.0.28 Update guice to 5.1.0 (java 17 support) 5.4.1 (2021-12-19) \u00b6 Fix inner guice class usage in always executable code (#187, OSGi issue) Update dropwizard to 2.0.27 (many dependency updates in the latest versions fixing java 17 support) 5.4.0 (2021-10-21) \u00b6 Use direct dependency versions in pom to simplify resolution (dependencyManagement section remains but for usage as BOM only) Fix lambda modules support (modules declared with lambda expression) (#160) Exclude \"sun.*\" objects from configuration analysis (#170, #180) Fix junit5 extensions support for @TestInstance(TestInstance.Lifecycle.PER_CLASS) (class instance injections now processed in beforeEach hook instead of instancePostProcessor) Add error message when junit5 extensions incorrectly registered with non-static fields (to avoid confusion) SharedConfigurationState: Add ability for direct static lookup during startup (from main thread): SharedConfigurationState.getStartupInstance() (option required for places where neither application not environment object accessible (e.g. binding installer, bundle lookup, etc.); and could be used for common objects resolution where otherwise they are not directly accessible) Add shortcut methods on state instance producing providers (lazy) for common objects: getBootstrap, getApplication, getEnvironment, getConfiguration, getConfigurationTree (example usage during startup: SharedConfigurationState.getStartupInstance().getApplication() returns Provider ) Unify shared state access methods in GuiceyBootstrap, GuiceyEnvironment and DropwizardAwareModule (removes implicit limitation that shared state must be initialized only in init phase) 5.3.0 (2021-03-06) \u00b6 Update to guice 5.0.1 (java15 support, removes cglib, fixes \"illegal reflective access\" warnings, update Guava to LATEST 30.1-jre) Update to dropwizard 2.0.20 Unify GuiceyAppRule (junit4) behaviour with DropwizardAppRule: config overrides should initialize just before test and not in the constructor. The issue was causing early evaluation of lazy (deferred) overrides (#151) Add custom ConfigOverride objects support for junit 5 extensions (registered with @RegisterExtension) 5.2.0 (2020-11-29) \u00b6 Update to dropwizard 2.0.16 Remove direct usages of logback-classic classes to unlock logger switching (#127) Fix stackoverflow on config introspection caused by EnumMap fields (#87) Prioritize registered jersey provider extensions and add support for @Priority annotation (#97) Unifies raw dropwizard and guicey behaviour. Possibly breaking, see note below. Add lifecycle event: ApplicationStoppedEvent (triggered on jersey lifecycle stop) 5.1.0 (2020-06-02) \u00b6 Update guice to 4.2.3 ( java 14 support ) Update to dropwizard 2.0.10 Add junit 5 extensions (#74). Works much like existing spock extensions: @TestGuiceyApp for replacement of GuiceyAppRule @TestDropwizardApp for using instead of DropwizardAppRule (or current dropwizard extension) Spock extensions updates: Internally, use DropwizardTestSupport instead of deprecated junit 4 rules New features (port features from junit 5 extensions): @UseDropwizardApp got new configurations: randomPorts and restMapping @UseGuiceyHooks deprecated: instead additional hooks may be declared in static test field ClientSupport test field will be injected with client support object instance Junit 4 rules deprecated GuiceyAppRule, StartupErrorRules Fix parallel tests support: guice logs interception wasn't thread safe (#103) Fix invalid Automatic-Module-Name to 'ru.vyarus.dropwizard.guicey' (#106) 5.0.1 (2020-03-13) \u00b6 Update to dropwizard 2.0.2 (address CVE-2020-5245 ) Fix yaml bindings report rendering with values containing string format parameters like %s (#77) 5.0.0 (2019-12-15) \u00b6 Update to dropwizard 2.0.0 (breaking in jersey 2.26) Jersey 2.26 introduces an abstraction for injection layer in order to get rid of hk2 direct usage. This allows complete hk2 avoidance in the future. Right now it means that all direct hk2 classes must be replaced by jersey abstractions (but still hk2 is the only production ready integration) Jersey InjectionManager now bound to guice context instead of hk2 ServiceLocator (locator still can be retrieved from manager) Rename HK2 mentions into jersey (because now jersey is not tied to hk2) @HK2Managed renamed to @JerseyManaged JerseyProviderInstaller (installs classes annotated with @Provider ) changes: ValueParamProvider detected instead of ValueFactoryProvider Supplier detected instead Factory (Factory implementations are not recognized anymore!) org.glassfish.jersey.internal.inject.InjectionResolver detected instead of org.glassfish.hk2.api.InjectionResolver Jersey installers use org.glassfish.jersey.internal.inject.AbstractBinder instead of hk specific org.glassfish.hk2.utilities.binding.AbstractBinder Mark all hk2-related methods and options as deprecated (to be removed in the next version) Jersey 2.26 implements jax-rs 2.1 which forced it to change some of it's apis. org.glassfish.jersey.server.AsyncContext binding used instead of org.glassfish.jersey.server.internal.process.AsyncContext (breaking dw 2.0) Deprecated Bundle usages replaced with ConfigurableBundle (in new dropwizard version Bundle extends ConfigurableBundle ) Guicey configuration scope ConfigSope.DropwizardBundle now use ConfigurableBundle class for marking guice bundle scope instead of Bundle dropwizard-bom now includes only dropwizard modules. All 3 rd party dependencies are moved to dropwizard-dependencies package. So you'll have to update two boms now in order to update dropwizard version. Update hk2 guice-bridge to 2.6.1 (breaking) Guicey configuration and lifecycle changes: GuiceyBundle contract and behaviour changed to match dropwizard lifecycle: GuiceyBundle now contains two methods initialize and run and called according to dropwizard lifecycle. Now guicey bundles are complete replacement for dropwizard bundles, but with good interoperability with pure dropwizard bundles The following guicey initializations were moved into dropwizard configuration phase: Guicey bundles lookup and initialization (to be able to install dropwizard bundles inside guicey bundles) Installers classpath search and instantiation Extensions classpath search and validation (but on run phase it is still possible to disable extensions) Extensions initialization moved outside injector creation scope. It will affect time report and, in case of extension installation error, exception will be thrown directly instead of Guice's CreationException. A lot of guicey lifecycle events obviously changed (and new added) Add special ApplicationStarted event: always fired after complete dropwizard startup. Supposed to be used to simplify diagnostic reporting. Support lifecycle listeners deduplication for correct report behaviour in case of multiple registrations. LinkedHashSet used as listeners holder, so only proper equals and hashcode methods implementation is required for deduplication Removed GuiceyOptions.ConfigureFromDropwizardBundles option because it's useless with new bundles lifecycle. (if required, the same behaviour may be implemented with custom bundles lookup) Removed GuiceyOptions.BindConfigurationInterfaces option (interfaces are already bound with @Config qualifier) Guicey web installers ( WebInstallersBundle ) enabled by default. GuiceBundle.builder()#useWebInstallers() option removed Direct dropwizard bundles support: bundles could be registered directly in main bundle ( GuiceBundle.dropwizardBundles() ) or inside guicey bundle ( GuiceyBundle.dropwizardBundles() ). These bundles could be disabled (same as guicey bundles - with .disableDropwizardBundles() methods) and are show in reporting. Transitive dropwizard bundles tracking: all dropwizard bundles registered through guicey api are tracked for transitive registration with bootstrap proxy. That means that all transitive bundles are shown in reports and any transitive bundle could be disabled (with .disableDropwizardBundle or custom predicate). Also, deduplication checks will work (same as for guicey bundles and guice modules). Tracking may be disabled with GuieyOptions.TrackDropwizardBundles option. Allow registration of multiple instances for guice modules and guicey bundles (multiple instances of the same class) By default, equal instances of the same type considered duplicate (only one registered). So, to grant uniqueness of bundle or module, implement correct equals method. For custom cases (when custom equals method is impossible), DuplicateConfigDetector may be implemented and registered with GuiceBundle.Builder#duplicateConfigDetector() Legacy behaviour (1 instance per type) could be simulated with: .duplicateConfigDetector(new LegacyModeDuplicatesDetector()) OR method GuiceBundle.Builder#uniqueItems(Class...) may be used to specify exact items to grant uniqueness for ItemId is now used as identity instead of pure Class . ItemId compute object hash string and preserve it for instance identification. Class types does not contain hash in id. Required because even scopes, represented previously as classes now could be duplicated as multiple instances of the same bundle class could be registered. For simplicity, ItemId equals method consider class-only id's equal to any type instance id. Add bundle loops detection: as multiple bundle instances allowed loops are highly possible Entire bundle chain is provided in exception to simplify fixing loops. Add base classes for unique bundles and modules (with correct equals and hash code implementations): UniqueGuiceyBundle and UniqueModule or UniqueDropwizardAwareModule (use class name strings for comparison to correctly detect even instances of classes from different class loaders). Note: no such class for dropwizard bundle because it's useless (if you use guicey - use GuiceyBundle instead and if you need dropwizard bundle - it shouldn't be dependent on guicey classes) Support extensions recognition from guice modules (jersey1-guice style): extensions are detected from declaration in specified guice modules (essentially same as classpath scan, but from bindings) extensions declared in: direct type bindings (all generified or qualified declarations ignored) linked bindings (right part) bind(Something).to(Extension) are also recognized (which must also be non qualified) like in classpath scan @InvisibleForScanner prevents recognition (or bean may be simply qualified) all extension registration types may work together (classpath scan, manual declaration and binding declaration) extensions registered directly (or found by classpath scan) and also bound manually in guice module will not conflict anymore (as manual declaration would be detected) and so @LazyBinding workaround is not needed extensions declared in guice module may be also disabled (guicey will remove binding declaration in this case and all chains leading to this declaration to prevent possible context failures) Transitive guice modules (installed by other modules) may be disabled with usual disableModules() (but only if guice bindings analysis is not disabled). enabled by default, but can be disabled with GuiceyOptions.AnalyzeModules option BindingInstaller interface changed (because of direct guice bindings): it now contains 3 methods for class binding, manual binding validation and reporting Extension classes loaded by different class loaders now detected as duplicate extension registration Guicey hooks, initially supposed to be used for testing only, now considered to be also used for diagnostic tools Add guicey hooks lookup from system property guicey.hooks as comma-separated list of classes. Add hook aliases support: alias name assumed to be used instead of full class name in system property ( -Dguicey.hooks ). Alias registered with GuiceBundle.builder()#hookAlias() . All registered aliases are logged at startup. Add diagnostic hook, which enables diagnostic reports and lifecycle logs. Could be enabled with system property: -Dguicey.hooks=diagnostic (where diagnostic is pre-registered hook alias) Useful to enable diagnostic logs on compiled (deployed) application. (breaking) Removed hooks recognition on registered GuiceyLifecycleLister (as it was very confusing feature) Add shared configuration state (for special configuration-time needs like bundles communication). This is required only in very special cases. But such unified place will replace all current and future hacks. Static access by application: SharedConfigurationState.get(app) or SharedConfigurationState.lookup(app, key) Static access by environment: SharedConfigurationState.get(env) or SharedConfigurationState.lookup(env, key) Value access from guicey bundle: boostrap.sharedState(key, defSupplier) , environment.sharedState(key) Value access from DropwizardAwareModule : sharedState Hooks can use GuiceBundle.Builder.withSharedState to access application state. (breaking) InjectorLookup now use global shared state clear() method removed, but SharedConfigurationState.clear() could be used instead (breaking) Test support changes Rename test extensions for guicey hooks registration: GuiceyConfigurationRule into GuiceyHooksRule @UseGuiceyConfiguration (spock extension) into @UseGuiceyHooks (breaking) Reporting changes All reports moved into one top-level debug package. All guicey reports are now guicey lifecycle listeners DiagnosticBundle bundle become ConfigurationDiagnostic guicey listener. Reporters are no more bound to guice context (they could always be constructed manually). DebugGuiceyLifecycle listener renamed into LifecycleDiagnostic Guicey reports (listeners) properly implement equals and hashcode in order to use new deduplication mechanism and avoid reports duplication (for example, if .printDiagnosticInfo() would be called multiple times, only one report would be shown; but still different configurations will be reported separately (e.g. list .printDiagnosticInfo() and .printAvailableInstallers() which internally use one listener)) Report all diagnostic reports as one log message in order to differentiate .printDiagnosticInfo() and .printAvailableInstallers() reports when both active Diagnostic report changes ( .printDiagnosticInfo() ): Show both dropwizard and guicey bundles together (dropwizard bundles marked with DW) Always show \"empty\" bundles (bundles without sub registrations) - important for dw bundles Add \"-\" before ignored or disabled items (to visually differentiate from accepted items) Identify instance deduplication: Instead of registrations count (REG(2)) show exact counter of all registered and accepted items: REG(5/12) Show ignored items even in context where items of the same type were accepted Show exact number of ignored items in context (DUPLICATE(3)) Show extension recognized from guice bindings (as sub report) Stats report improved: Show guice internal stat logs in stats diagnostic report (intercept guice logs) Show guicey time by phases (init/run/jersey) Show guice modules analysis stats Show installer marker interfaces in printAvailableInstallers() report to indicate installer actions (installation by type or instance, custom guice or jersey bindings, options support). Detailed lifecycle report ( .printLifecyclePhasesDetailed ) show context data for each event Add guice bindings report ( printGuiceBindings() or printAllGuiceBindings() ) Add guice aop appliance report ( .printGuiceAopMap() ). This report supposed to be used as \"a tool\" to look exact services and so configurable method version is directly available: .printGuiceAopMap(new GuiceAopConfig().types(...).methods(...)) Add web mappings report ( .printWebMappings() ): prints all registered servlets and filters Add jersey config report ( .printJerseyConfig ): prints all registered jersey extensions Fix configuration bindings for recursive configuration object declarations (#60) Guicey version added into BOM (dependencyManagement section in guicey pom) to avoid duplicate versions declarations Java 11 compatibility. Automatic module name (in meta-inf): dropwizard-guicey.core (breaking) AdminRestBundle moved into ext modules (bundle become guicey bundle, now return 404 instead of 403 on main context for admin-only resources) (breaking) Remove useless configuration generic on main bundle: GuiceBundle.<MyConfig>builder() must be just GuiceBundle.builder() InjectorLookup: Add lookup by environment instance: InjectorLookup.get(environment) Add direct lookup for bean instance: InjectorLookup.getInstance(app, MyBean.class) (or with environment) Update installers console reporting to use more readable class format: SimpleName (reduced package) Add optional extensions support: optional extension automatically become disabled when no compatible installer found Could be registered with new method in main and guicey bundles: .extensionsOptional 4.2.2 (2018-11-26) \u00b6 Update to guice 4.2.2 (java 11 compatible) Update to dropwizard 1.3.7 Fix inner non static classes detection by classpath scan Fix lifecycle debug messages decoration (unicode fix) 4.2.1 (2018-07-23) \u00b6 Show warning when configuration path's value resolution failed instead of startup fail (#53) Add GuiceyOptions.BindConfigurationByPath to be able to disable configuration introspection (for edge cases) (#53) Fix unique sub configuration object access (#54) 4.2.0 (2018-06-25) \u00b6 Update to guice 4.2.0 remove guice-multibindings dependency as it's moved to guice core Update to dropwizard 1.3.5 Add more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions: Guicey bundles disabled through main builder only: .disableBundles() Other disable methods available in both main bundle and guicey bundles bootstrap: .disableModules(Class...) - disable guice modules .disableExtensions(Class...) - extensions disabling (for possible replacement) generic disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.) Add direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap: .modulesOverride(Module...) Add BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case) Add hooks for configuration override in integration tests (#23): New GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods) Junit: New rule GuiceyConfigurationRule for hook registration Spock: New @UseGuiceyConfiguration extension allows base hook definition (in base class) New attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks Add guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment. It may be used to write instance specific features (post processing) or just advanced logging Add new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...) Add guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic): .printLifecyclePhases() - identify configuration stages in console logs .printLifecyclePhasesDetailed() - identify lifecycle phases with detailed configuration report (in console logs) Improve options support: Add OptionsAwareModule interface to let guice modules access options Add OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options() Add ability to manage jersey extensions with HK2 by default (#41). It's like using @HK2Managed on all jersey-related beans (resources, filters etc). This is useful, for example, if you get common to jersey resources features like @Context injection. Add option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default. HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not). Add @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless). In guice-first mode this annotation is useless. Builder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling. Guice beans scope-related improvements: Singleton scope is not forced for jersey extensions with explicit scoping annotation Add option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions Add annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled Fix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49) Add Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object) Add ConfigScope enum for special scopes description (to not remember special classes). Add shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo) (breaking) Config reporting api changes: Diagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items Diagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application) New configuration bindings: Configuration object could be bound as: any class from configuration class hierarchy (as before) any class from hierarchy with @Config qualifier: @Inject @Config Configuration conf interface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config (Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before), but prefer binding interfaces with qualifier (@Config), which is always available. Option will be removed in the future versions (Deprecated) bundle's builder.bindConfigurationInterfaces() Configuration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg Sub configuration objects could be bound without path if object type appear only once in configuration: @Inject @Config ServerFactory serverCfg ConfigurationTree - configuration introspection object is available for direct binding and from GuiceyConfigurationInfo bean: getConfigurationTree() Alternative configuration access: New configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule): configuration(String) - configuration value by path configuration(Class) - unique sub configuration object configurations(Class) - all sub configuration objects with assignable type (on any depth) configurationTree() - access raw introspection data for more complex searches Reports to see available config bindings (before injector creation for potential problems solving) in main bundle: .printConfigurationBindings() - log all bindings (including dropwizard Configuration) .printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes) Includes much improved generics-resolver 4.1.0 (2017-05-09) \u00b6 Update to dropwizard 1.1.0 Add StartupErrorRule to simplify dropwizard startup error testing (breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used to enable bridge (#28) Fix NPE when used with JRebel (#29) Add binding for jersey javax.ws.rs.container.ResourceInfo (#26) Fix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32) Fix guava conflict in guicey pom. Make guicey pom usable as BOM. 4.0.1 (2016-11-18) \u00b6 Update to dropwizard 1.0.5 and fix compatibility (#24) Fix guice version conflict for maven (#20) 4.0.0 (2016-08-22) \u00b6 Update to dropwizard 1.0.0 (breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle) Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts: WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3 rd party bundles use its own low-level options. GuiceyBootstrap option(option) method provides access to defined options from bundles Options guice bean provide access to options from guice services Installers could access options by implementing WithOptions interface OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions()) Options reporting added to DiagnosticBundle (breaking) remove GuiceBundle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) (use either shortcuts without parameters or generic options method instead) (breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option (breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava (breaking) InjectorLookup changed to use java8 Optional instead of guava Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2) Add methods to GuiceBundle builder: option(option, value) - used to specify custom option value options(Map) - used to provide multiple options at once (for custom options lookup mechanisms) printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features) useWebInstallers() - shortcut for installing WebInstallersBundle noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support noDefaultInstallers() - disables CoreInstallersBundle automatic installation 3.3.0 (2016-08-02) \u00b6 Update to guice 4.1.0 Update to dropwizard 0.9.3 Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings ResourceInstaller looks for @Path on directly implemented interface (#10) Fix bundles lookup reporting (correct multiline) Fix duplicate extensions installation when registered both manually and by auto scan Restrict extension installation to one installer (first matching, according to installers order) Improve dropwizard configuration class binding: Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself) (optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces())) Add GuiceyBootstrap methods (extend GuiceyBundle abilities): bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type. application(): returns current application instance Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc) Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). Add GuiceBundle builder configuration options: bindConfigurationInterfaces() to enable configuration interface bindings strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests) printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs) shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces() NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api) 3.2.0 (2016-01-23) \u00b6 Clear possible duplicate guicey bundle instances Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources. Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles. Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions. Add builder bundleLookup method to register custom lookup implementation Add builder disableBundleLookup to disable default look-ups Default lookup implementation logs all resolved bundles Fix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support. Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed are managed by HK2 only. May be used in tests as extra validation. Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. Update to dropwizard 0.9 Revert system exit on guice injector creation error (added in 3.1.1) 3.1.1 (2015-11-24) \u00b6 Exit on guice injector creation error. Add classpath scan packages validation for intersection (to prevent duplicate instances) 3.1.0 (2015-09-06) \u00b6 JerseyProviderInstaller: add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener support multiple extension interfaces on the same bean Introduce bundles (GuiceyBundle) to simplify extensions: core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed builder bundles() method to add guicey bundles builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism) Add admin context rest support (AdminRestBundle) Add request scoped beans support in admin context 3.0.1 (2015-07-04) \u00b6 Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces 3.0.0 (2015-04-26) \u00b6 Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) (breaking) Remove static state from GuiceBundle: GuiceBundle.getInjector method remain, but its now instance specific (instead of static) Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() JerseyInstaller interface signature changed: now install method receives injector instance 2.2.0 (2015-04-17) \u00b6 Fix ExceptionMapper registration Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 (to simplify custom installers injection between them) 2.1.2 (2015-03-03) \u00b6 Spock 1.0 compatibility 2.1.1 (2015-01-25) \u00b6 Dropwizard 0.8-rc2 compatibility 2.1.0 (2015-01-04) \u00b6 Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by Nicholas Pace Add spock extensions to use injections directly in specification (like spock-guice do) 2.0.0 (2014-11-25) \u00b6 Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)). Jersey integration completely rewritten. Add JerseyInstaller installer type Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request) 1.1.0 (2014-10-23) \u00b6 Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils Drop java 1.6 compatibility, because dropwizard is 1.7 compatible Add junit rule for lightweight testing (run guice without starting jetty) 1.0.0 (2014-10-14) \u00b6 Add dependency on guice-multibindings Installers may choose now from three types of installation (binding, type or instance) or combine them. Add PluginInstaller: shortcut for multibindings mechanism Updated guice (4.0.beta4 -> 4.0.beta5) Force singleton for resources @Eager renamed to @EagerSingleton and now forces singleton scope for bean Add dropwizard style reporting for installed features (like resources or tasks) Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers) Add admin context filter and servlet installers Rename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions 0.9.0 (2014-09-05) \u00b6 Initial release","title":"Version history"},{"location":"about/history/#5100-2023-11-28","text":"Update to dropwizard 2.1.10 Add jsr305 as direct dependency to simplify usage @javax.annotation.Nullable (annotation is required for guice when nullable value could be injected) Add qualifier annotations support for configuration properties binding: any configuration property (any level), annotated with qualifier annotation, would be directly bound with that qualifier. Core dropwizard objects could be qualified on overridden getter Test improvements: Junit 5 extensions could inject DropwizardTestSupport object itself as test method parameter ClientSupport: inner jersey client creation is customizable now with TestClientFactory implementation (new attribute \"clientFactory\" in @TestGuiceyApp and @TestDropwizardApp) default factory would automatically configure: multipart feature if available in classpath (dropwizard-forms) direct console logging (to see requests and responses directly in console) New methods: basePathRoot - root url (only with port) get(), post(), delete(), put() - simple shortcut methods to perform basic operations relative to server root Context support object (DropwizardTestSupport) and client (ClientSupport) instances are accessible now statically for both manual run (TestSupport) and junit extensions: TestSupport.getContext() and TestSupport.getContextClient() New generic builder for flexible DropwizardTestSupport object creation and run (when junit extension can't be used): TestSupport.builder() (with lifecycle listeners support) TestSupport methods changes: Creation and run methods updated with config override (strings) support Add creation and run methods application class only (and optional overrides). Run methods without callback now return RunResult containing all objects, required for validation (for example, to examine config) Add captureOutput method to record console output for assertions Commands test support: TestSupport.buildCommandRunner() - builds runner for command execution with the same builder options as in generic builder (TestSupport.builder(); including same configuration) and user input support. Could be used to test application startup fail (without using system mocks)","title":"5.10.0 (2023-11-28)"},{"location":"about/history/#593-2023-11-05","text":"Update to dropwizard 2.1.9 NOTE: dropwizard-jdbi3 drops java 8 support in gradle because it leaks (through metrics-jdbi3) jdbi3 3.43.1, compiled for java 11, so, for java 8 compatibility, you'll have to manually force the correct version: implementation ( 'org.jdbi:jdbi3-core' ) { version { strictly '3.39.1' } }","title":"5.9.3 (2023-11-05)"},{"location":"about/history/#592-2023-10-06","text":"Update to dropwizard 2.1.8","title":"5.9.2 (2023-10-06)"},{"location":"about/history/#591-2023-07-05","text":"Update to dropwizard 2.1.7 Add missed javax.inject dependency (guice 6 could work with both javax and jakarta) Fix BOM for MAVEN projects: incorrect jakarta.inject version was selected (#317) [jdbi] Fix jdbi 3.39 compatibility Avoid redundant transaction isolation level checks (extra queries) (#318) [gsp] Fix redirection to error page after direct template rendering fails","title":"5.9.1 (2023-07-05)"},{"location":"about/history/#590-2023-05-14","text":"Update to guice 6.0","title":"5.9.0 (2023-05-14)"},{"location":"about/history/#581-2023-04-28","text":"Fix BOM for correct guava version selection in maven (#302)","title":"5.8.1 (2023-04-28)"},{"location":"about/history/#580-2023-04-24","text":"Update to dropwizard 2.1.6 Merged with guicey-ext modules repository: Ext modules version would be the same as guicey dropwizard-guicey POM would not be a BOM anymore (everything moved to guicey-bom) Exclusions not applied in BOM anymore, instead they applied directly in POM","title":"5.8.0 (2023-04-24)"},{"location":"about/history/#571-2023-03-09","text":"Update to dropwizard 2.1.5 Revert changing reports log level: now INFO used instead of WARN (#276)","title":"5.7.1 (2023-03-09)"},{"location":"about/history/#570-2022-12-29","text":"Update to dropwizard 2.1.4 Fix NoClassDefFoundError(AbstractCollectionJaxbProvider) appeared for some jersey provider registrations (#240) Jersey extensions might omit @Provider on known extension types (ExceptionMapper, MessageBodyReader, etc.). Unifies usage with pure dropwizard (no additional @Provider annotation required). (#265) New option InstallerOptions.JerseyExtensionsRecognizedByType could disable new behaviour Support ModelProcessor jersey extension installation (#186) Add extensions help: .printExtensionsHelp() showing extension signs recognized by installers (in recognition order) Custom installers could participate in report by overriding FeatureInstaller.getRecognizableSigns() (default interface method). Change reports log level from INFO to WARN to comply with default dropwizard level Support application reuse between tests (#269) new reuseApplication parameter in extensions enables reuse reusable application must be declared in base test class: all tests derived from this base class would use the same application instance Add SBOM (json and xml with cyclonedx classifier) Add .enableAutoConfig() no-args shortcut for enabling classpath scan in application package","title":"5.7.0 (2022-12-29)"},{"location":"about/history/#561-2022-07-02","text":"Update dropwizard to 2.1.1 (fixes java 8 issue by allowing afterburner usage) Fix classpath scan recognition of inner static classes inside jars (#231) Junit 5 extensions: Fix parallel test methods support (configuration overrides were applied incorrectly) Add \"debug\" option: when enabled, prints registered setup objects, hooks and applied configuration overrides Setup objects and hooks not printed by default as before, only when debug enabled Debug could be also enabled with system property -Dguicey.extensions.debug=true or with alias TestSupport.debugExtensions()","title":"5.6.1 (2022-07-02)"},{"location":"about/history/#560-2022-06-07","text":"Update dropwizard to 2.1.0 Test support objects changes: Add new interface TestEnvironmentSetup to simplify test environment setup In contrast to guicey hooks, setup objects used only in tests to replace the need of writing additional junit extensions (for example, to set up a test db). It provides a simple way to override application configuration (e.g. to specify credentials to just started db) Registration is the same as with hooks: annotation or inside extension builder and with field using new annotation @EnableSetup Hooks and setup objects configured in test are logged now in execution order and with registration source hint @EnableHook fields might be declared with custom classes (not only raw hook interface) Junit 5 extensions field registration (@RegisterExtension) changes Application might be started per-test-method now (when extension registered in non-static field) In this case support objects might also be registered in non-static fields Add configOverrideByExtension method to read configuration override value registered by 3 rd party junit 5 extension (from junit extension store). hooks(Class) method accepts multiple classes configOverrides(String...) now aggregates multiple calls","title":"5.6.0 (2022-06-07)"},{"location":"about/history/#550-2022-03-30","text":"Test framework-agnostic utilities: Add GuiceyTestSupport to simplify guice-only manual application runs (by analogy to DropwizardTestSupport class) Add TestSupport class as a root for test framework-agnostic utilities. Suitable for application startup errors testing and integration within not supported test runner. Add Spock 2 support: there is no custom extensions, instead existing junit 5 extensions would be used through a special library spock-junit5 (developed specifically for this integration) Change \"hooks in base test class\" behaviour: hooks from static fields from base classes applied before hooks in test itself. Such behaviour is more natural - \"base classes declarations go first\" (before all field hooks were applied after annotation hooks) Extract Spock 1 and Junit 4 extensions from core into ext modules: packages remain the same, so there should be no issues with it (just add new dependency) removed deprecation markers from Junit 4 rules (entire module assumed to be deprecated; fewer warnings on build) BOM changes: spock version removed in order to avoid problems downgrading spock version for spock1 module system-rules removed because it targets junit4 (ext module provides it) groovy libraries removed (newer groovy 2.x was required for spock1 to run on java 11) add spock-junit5 version","title":"5.5.0 (2022-03-30)"},{"location":"about/history/#542-2022-01-26","text":"Update dropwizard to 2.0.28 Update guice to 5.1.0 (java 17 support)","title":"5.4.2 (2022-01-26)"},{"location":"about/history/#541-2021-12-19","text":"Fix inner guice class usage in always executable code (#187, OSGi issue) Update dropwizard to 2.0.27 (many dependency updates in the latest versions fixing java 17 support)","title":"5.4.1 (2021-12-19)"},{"location":"about/history/#540-2021-10-21","text":"Use direct dependency versions in pom to simplify resolution (dependencyManagement section remains but for usage as BOM only) Fix lambda modules support (modules declared with lambda expression) (#160) Exclude \"sun.*\" objects from configuration analysis (#170, #180) Fix junit5 extensions support for @TestInstance(TestInstance.Lifecycle.PER_CLASS) (class instance injections now processed in beforeEach hook instead of instancePostProcessor) Add error message when junit5 extensions incorrectly registered with non-static fields (to avoid confusion) SharedConfigurationState: Add ability for direct static lookup during startup (from main thread): SharedConfigurationState.getStartupInstance() (option required for places where neither application not environment object accessible (e.g. binding installer, bundle lookup, etc.); and could be used for common objects resolution where otherwise they are not directly accessible) Add shortcut methods on state instance producing providers (lazy) for common objects: getBootstrap, getApplication, getEnvironment, getConfiguration, getConfigurationTree (example usage during startup: SharedConfigurationState.getStartupInstance().getApplication() returns Provider ) Unify shared state access methods in GuiceyBootstrap, GuiceyEnvironment and DropwizardAwareModule (removes implicit limitation that shared state must be initialized only in init phase)","title":"5.4.0 (2021-10-21)"},{"location":"about/history/#530-2021-03-06","text":"Update to guice 5.0.1 (java15 support, removes cglib, fixes \"illegal reflective access\" warnings, update Guava to LATEST 30.1-jre) Update to dropwizard 2.0.20 Unify GuiceyAppRule (junit4) behaviour with DropwizardAppRule: config overrides should initialize just before test and not in the constructor. The issue was causing early evaluation of lazy (deferred) overrides (#151) Add custom ConfigOverride objects support for junit 5 extensions (registered with @RegisterExtension)","title":"5.3.0 (2021-03-06)"},{"location":"about/history/#520-2020-11-29","text":"Update to dropwizard 2.0.16 Remove direct usages of logback-classic classes to unlock logger switching (#127) Fix stackoverflow on config introspection caused by EnumMap fields (#87) Prioritize registered jersey provider extensions and add support for @Priority annotation (#97) Unifies raw dropwizard and guicey behaviour. Possibly breaking, see note below. Add lifecycle event: ApplicationStoppedEvent (triggered on jersey lifecycle stop)","title":"5.2.0 (2020-11-29)"},{"location":"about/history/#510-2020-06-02","text":"Update guice to 4.2.3 ( java 14 support ) Update to dropwizard 2.0.10 Add junit 5 extensions (#74). Works much like existing spock extensions: @TestGuiceyApp for replacement of GuiceyAppRule @TestDropwizardApp for using instead of DropwizardAppRule (or current dropwizard extension) Spock extensions updates: Internally, use DropwizardTestSupport instead of deprecated junit 4 rules New features (port features from junit 5 extensions): @UseDropwizardApp got new configurations: randomPorts and restMapping @UseGuiceyHooks deprecated: instead additional hooks may be declared in static test field ClientSupport test field will be injected with client support object instance Junit 4 rules deprecated GuiceyAppRule, StartupErrorRules Fix parallel tests support: guice logs interception wasn't thread safe (#103) Fix invalid Automatic-Module-Name to 'ru.vyarus.dropwizard.guicey' (#106)","title":"5.1.0 (2020-06-02)"},{"location":"about/history/#501-2020-03-13","text":"Update to dropwizard 2.0.2 (address CVE-2020-5245 ) Fix yaml bindings report rendering with values containing string format parameters like %s (#77)","title":"5.0.1 (2020-03-13)"},{"location":"about/history/#500-2019-12-15","text":"Update to dropwizard 2.0.0 (breaking in jersey 2.26) Jersey 2.26 introduces an abstraction for injection layer in order to get rid of hk2 direct usage. This allows complete hk2 avoidance in the future. Right now it means that all direct hk2 classes must be replaced by jersey abstractions (but still hk2 is the only production ready integration) Jersey InjectionManager now bound to guice context instead of hk2 ServiceLocator (locator still can be retrieved from manager) Rename HK2 mentions into jersey (because now jersey is not tied to hk2) @HK2Managed renamed to @JerseyManaged JerseyProviderInstaller (installs classes annotated with @Provider ) changes: ValueParamProvider detected instead of ValueFactoryProvider Supplier detected instead Factory (Factory implementations are not recognized anymore!) org.glassfish.jersey.internal.inject.InjectionResolver detected instead of org.glassfish.hk2.api.InjectionResolver Jersey installers use org.glassfish.jersey.internal.inject.AbstractBinder instead of hk specific org.glassfish.hk2.utilities.binding.AbstractBinder Mark all hk2-related methods and options as deprecated (to be removed in the next version) Jersey 2.26 implements jax-rs 2.1 which forced it to change some of it's apis. org.glassfish.jersey.server.AsyncContext binding used instead of org.glassfish.jersey.server.internal.process.AsyncContext (breaking dw 2.0) Deprecated Bundle usages replaced with ConfigurableBundle (in new dropwizard version Bundle extends ConfigurableBundle ) Guicey configuration scope ConfigSope.DropwizardBundle now use ConfigurableBundle class for marking guice bundle scope instead of Bundle dropwizard-bom now includes only dropwizard modules. All 3 rd party dependencies are moved to dropwizard-dependencies package. So you'll have to update two boms now in order to update dropwizard version. Update hk2 guice-bridge to 2.6.1 (breaking) Guicey configuration and lifecycle changes: GuiceyBundle contract and behaviour changed to match dropwizard lifecycle: GuiceyBundle now contains two methods initialize and run and called according to dropwizard lifecycle. Now guicey bundles are complete replacement for dropwizard bundles, but with good interoperability with pure dropwizard bundles The following guicey initializations were moved into dropwizard configuration phase: Guicey bundles lookup and initialization (to be able to install dropwizard bundles inside guicey bundles) Installers classpath search and instantiation Extensions classpath search and validation (but on run phase it is still possible to disable extensions) Extensions initialization moved outside injector creation scope. It will affect time report and, in case of extension installation error, exception will be thrown directly instead of Guice's CreationException. A lot of guicey lifecycle events obviously changed (and new added) Add special ApplicationStarted event: always fired after complete dropwizard startup. Supposed to be used to simplify diagnostic reporting. Support lifecycle listeners deduplication for correct report behaviour in case of multiple registrations. LinkedHashSet used as listeners holder, so only proper equals and hashcode methods implementation is required for deduplication Removed GuiceyOptions.ConfigureFromDropwizardBundles option because it's useless with new bundles lifecycle. (if required, the same behaviour may be implemented with custom bundles lookup) Removed GuiceyOptions.BindConfigurationInterfaces option (interfaces are already bound with @Config qualifier) Guicey web installers ( WebInstallersBundle ) enabled by default. GuiceBundle.builder()#useWebInstallers() option removed Direct dropwizard bundles support: bundles could be registered directly in main bundle ( GuiceBundle.dropwizardBundles() ) or inside guicey bundle ( GuiceyBundle.dropwizardBundles() ). These bundles could be disabled (same as guicey bundles - with .disableDropwizardBundles() methods) and are show in reporting. Transitive dropwizard bundles tracking: all dropwizard bundles registered through guicey api are tracked for transitive registration with bootstrap proxy. That means that all transitive bundles are shown in reports and any transitive bundle could be disabled (with .disableDropwizardBundle or custom predicate). Also, deduplication checks will work (same as for guicey bundles and guice modules). Tracking may be disabled with GuieyOptions.TrackDropwizardBundles option. Allow registration of multiple instances for guice modules and guicey bundles (multiple instances of the same class) By default, equal instances of the same type considered duplicate (only one registered). So, to grant uniqueness of bundle or module, implement correct equals method. For custom cases (when custom equals method is impossible), DuplicateConfigDetector may be implemented and registered with GuiceBundle.Builder#duplicateConfigDetector() Legacy behaviour (1 instance per type) could be simulated with: .duplicateConfigDetector(new LegacyModeDuplicatesDetector()) OR method GuiceBundle.Builder#uniqueItems(Class...) may be used to specify exact items to grant uniqueness for ItemId is now used as identity instead of pure Class . ItemId compute object hash string and preserve it for instance identification. Class types does not contain hash in id. Required because even scopes, represented previously as classes now could be duplicated as multiple instances of the same bundle class could be registered. For simplicity, ItemId equals method consider class-only id's equal to any type instance id. Add bundle loops detection: as multiple bundle instances allowed loops are highly possible Entire bundle chain is provided in exception to simplify fixing loops. Add base classes for unique bundles and modules (with correct equals and hash code implementations): UniqueGuiceyBundle and UniqueModule or UniqueDropwizardAwareModule (use class name strings for comparison to correctly detect even instances of classes from different class loaders). Note: no such class for dropwizard bundle because it's useless (if you use guicey - use GuiceyBundle instead and if you need dropwizard bundle - it shouldn't be dependent on guicey classes) Support extensions recognition from guice modules (jersey1-guice style): extensions are detected from declaration in specified guice modules (essentially same as classpath scan, but from bindings) extensions declared in: direct type bindings (all generified or qualified declarations ignored) linked bindings (right part) bind(Something).to(Extension) are also recognized (which must also be non qualified) like in classpath scan @InvisibleForScanner prevents recognition (or bean may be simply qualified) all extension registration types may work together (classpath scan, manual declaration and binding declaration) extensions registered directly (or found by classpath scan) and also bound manually in guice module will not conflict anymore (as manual declaration would be detected) and so @LazyBinding workaround is not needed extensions declared in guice module may be also disabled (guicey will remove binding declaration in this case and all chains leading to this declaration to prevent possible context failures) Transitive guice modules (installed by other modules) may be disabled with usual disableModules() (but only if guice bindings analysis is not disabled). enabled by default, but can be disabled with GuiceyOptions.AnalyzeModules option BindingInstaller interface changed (because of direct guice bindings): it now contains 3 methods for class binding, manual binding validation and reporting Extension classes loaded by different class loaders now detected as duplicate extension registration Guicey hooks, initially supposed to be used for testing only, now considered to be also used for diagnostic tools Add guicey hooks lookup from system property guicey.hooks as comma-separated list of classes. Add hook aliases support: alias name assumed to be used instead of full class name in system property ( -Dguicey.hooks ). Alias registered with GuiceBundle.builder()#hookAlias() . All registered aliases are logged at startup. Add diagnostic hook, which enables diagnostic reports and lifecycle logs. Could be enabled with system property: -Dguicey.hooks=diagnostic (where diagnostic is pre-registered hook alias) Useful to enable diagnostic logs on compiled (deployed) application. (breaking) Removed hooks recognition on registered GuiceyLifecycleLister (as it was very confusing feature) Add shared configuration state (for special configuration-time needs like bundles communication). This is required only in very special cases. But such unified place will replace all current and future hacks. Static access by application: SharedConfigurationState.get(app) or SharedConfigurationState.lookup(app, key) Static access by environment: SharedConfigurationState.get(env) or SharedConfigurationState.lookup(env, key) Value access from guicey bundle: boostrap.sharedState(key, defSupplier) , environment.sharedState(key) Value access from DropwizardAwareModule : sharedState Hooks can use GuiceBundle.Builder.withSharedState to access application state. (breaking) InjectorLookup now use global shared state clear() method removed, but SharedConfigurationState.clear() could be used instead (breaking) Test support changes Rename test extensions for guicey hooks registration: GuiceyConfigurationRule into GuiceyHooksRule @UseGuiceyConfiguration (spock extension) into @UseGuiceyHooks (breaking) Reporting changes All reports moved into one top-level debug package. All guicey reports are now guicey lifecycle listeners DiagnosticBundle bundle become ConfigurationDiagnostic guicey listener. Reporters are no more bound to guice context (they could always be constructed manually). DebugGuiceyLifecycle listener renamed into LifecycleDiagnostic Guicey reports (listeners) properly implement equals and hashcode in order to use new deduplication mechanism and avoid reports duplication (for example, if .printDiagnosticInfo() would be called multiple times, only one report would be shown; but still different configurations will be reported separately (e.g. list .printDiagnosticInfo() and .printAvailableInstallers() which internally use one listener)) Report all diagnostic reports as one log message in order to differentiate .printDiagnosticInfo() and .printAvailableInstallers() reports when both active Diagnostic report changes ( .printDiagnosticInfo() ): Show both dropwizard and guicey bundles together (dropwizard bundles marked with DW) Always show \"empty\" bundles (bundles without sub registrations) - important for dw bundles Add \"-\" before ignored or disabled items (to visually differentiate from accepted items) Identify instance deduplication: Instead of registrations count (REG(2)) show exact counter of all registered and accepted items: REG(5/12) Show ignored items even in context where items of the same type were accepted Show exact number of ignored items in context (DUPLICATE(3)) Show extension recognized from guice bindings (as sub report) Stats report improved: Show guice internal stat logs in stats diagnostic report (intercept guice logs) Show guicey time by phases (init/run/jersey) Show guice modules analysis stats Show installer marker interfaces in printAvailableInstallers() report to indicate installer actions (installation by type or instance, custom guice or jersey bindings, options support). Detailed lifecycle report ( .printLifecyclePhasesDetailed ) show context data for each event Add guice bindings report ( printGuiceBindings() or printAllGuiceBindings() ) Add guice aop appliance report ( .printGuiceAopMap() ). This report supposed to be used as \"a tool\" to look exact services and so configurable method version is directly available: .printGuiceAopMap(new GuiceAopConfig().types(...).methods(...)) Add web mappings report ( .printWebMappings() ): prints all registered servlets and filters Add jersey config report ( .printJerseyConfig ): prints all registered jersey extensions Fix configuration bindings for recursive configuration object declarations (#60) Guicey version added into BOM (dependencyManagement section in guicey pom) to avoid duplicate versions declarations Java 11 compatibility. Automatic module name (in meta-inf): dropwizard-guicey.core (breaking) AdminRestBundle moved into ext modules (bundle become guicey bundle, now return 404 instead of 403 on main context for admin-only resources) (breaking) Remove useless configuration generic on main bundle: GuiceBundle.<MyConfig>builder() must be just GuiceBundle.builder() InjectorLookup: Add lookup by environment instance: InjectorLookup.get(environment) Add direct lookup for bean instance: InjectorLookup.getInstance(app, MyBean.class) (or with environment) Update installers console reporting to use more readable class format: SimpleName (reduced package) Add optional extensions support: optional extension automatically become disabled when no compatible installer found Could be registered with new method in main and guicey bundles: .extensionsOptional","title":"5.0.0 (2019-12-15)"},{"location":"about/history/#422-2018-11-26","text":"Update to guice 4.2.2 (java 11 compatible) Update to dropwizard 1.3.7 Fix inner non static classes detection by classpath scan Fix lifecycle debug messages decoration (unicode fix)","title":"4.2.2 (2018-11-26)"},{"location":"about/history/#421-2018-07-23","text":"Show warning when configuration path's value resolution failed instead of startup fail (#53) Add GuiceyOptions.BindConfigurationByPath to be able to disable configuration introspection (for edge cases) (#53) Fix unique sub configuration object access (#54)","title":"4.2.1 (2018-07-23)"},{"location":"about/history/#420-2018-06-25","text":"Update to guice 4.2.0 remove guice-multibindings dependency as it's moved to guice core Update to dropwizard 1.3.5 Add more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions: Guicey bundles disabled through main builder only: .disableBundles() Other disable methods available in both main bundle and guicey bundles bootstrap: .disableModules(Class...) - disable guice modules .disableExtensions(Class...) - extensions disabling (for possible replacement) generic disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.) Add direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap: .modulesOverride(Module...) Add BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case) Add hooks for configuration override in integration tests (#23): New GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods) Junit: New rule GuiceyConfigurationRule for hook registration Spock: New @UseGuiceyConfiguration extension allows base hook definition (in base class) New attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks Add guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment. It may be used to write instance specific features (post processing) or just advanced logging Add new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...) Add guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic): .printLifecyclePhases() - identify configuration stages in console logs .printLifecyclePhasesDetailed() - identify lifecycle phases with detailed configuration report (in console logs) Improve options support: Add OptionsAwareModule interface to let guice modules access options Add OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options() Add ability to manage jersey extensions with HK2 by default (#41). It's like using @HK2Managed on all jersey-related beans (resources, filters etc). This is useful, for example, if you get common to jersey resources features like @Context injection. Add option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default. HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not). Add @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless). In guice-first mode this annotation is useless. Builder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling. Guice beans scope-related improvements: Singleton scope is not forced for jersey extensions with explicit scoping annotation Add option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions Add annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled Fix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49) Add Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object) Add ConfigScope enum for special scopes description (to not remember special classes). Add shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo) (breaking) Config reporting api changes: Diagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items Diagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application) New configuration bindings: Configuration object could be bound as: any class from configuration class hierarchy (as before) any class from hierarchy with @Config qualifier: @Inject @Config Configuration conf interface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config (Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before), but prefer binding interfaces with qualifier (@Config), which is always available. Option will be removed in the future versions (Deprecated) bundle's builder.bindConfigurationInterfaces() Configuration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg Sub configuration objects could be bound without path if object type appear only once in configuration: @Inject @Config ServerFactory serverCfg ConfigurationTree - configuration introspection object is available for direct binding and from GuiceyConfigurationInfo bean: getConfigurationTree() Alternative configuration access: New configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule): configuration(String) - configuration value by path configuration(Class) - unique sub configuration object configurations(Class) - all sub configuration objects with assignable type (on any depth) configurationTree() - access raw introspection data for more complex searches Reports to see available config bindings (before injector creation for potential problems solving) in main bundle: .printConfigurationBindings() - log all bindings (including dropwizard Configuration) .printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes) Includes much improved generics-resolver","title":"4.2.0 (2018-06-25)"},{"location":"about/history/#410-2017-05-09","text":"Update to dropwizard 1.1.0 Add StartupErrorRule to simplify dropwizard startup error testing (breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used to enable bridge (#28) Fix NPE when used with JRebel (#29) Add binding for jersey javax.ws.rs.container.ResourceInfo (#26) Fix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32) Fix guava conflict in guicey pom. Make guicey pom usable as BOM.","title":"4.1.0 (2017-05-09)"},{"location":"about/history/#401-2016-11-18","text":"Update to dropwizard 1.0.5 and fix compatibility (#24) Fix guice version conflict for maven (#20)","title":"4.0.1 (2016-11-18)"},{"location":"about/history/#400-2016-08-22","text":"Update to dropwizard 1.0.0 (breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle) Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts: WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3 rd party bundles use its own low-level options. GuiceyBootstrap option(option) method provides access to defined options from bundles Options guice bean provide access to options from guice services Installers could access options by implementing WithOptions interface OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions()) Options reporting added to DiagnosticBundle (breaking) remove GuiceBundle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) (use either shortcuts without parameters or generic options method instead) (breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option (breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava (breaking) InjectorLookup changed to use java8 Optional instead of guava Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2) Add methods to GuiceBundle builder: option(option, value) - used to specify custom option value options(Map) - used to provide multiple options at once (for custom options lookup mechanisms) printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features) useWebInstallers() - shortcut for installing WebInstallersBundle noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support noDefaultInstallers() - disables CoreInstallersBundle automatic installation","title":"4.0.0 (2016-08-22)"},{"location":"about/history/#330-2016-08-02","text":"Update to guice 4.1.0 Update to dropwizard 0.9.3 Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings ResourceInstaller looks for @Path on directly implemented interface (#10) Fix bundles lookup reporting (correct multiline) Fix duplicate extensions installation when registered both manually and by auto scan Restrict extension installation to one installer (first matching, according to installers order) Improve dropwizard configuration class binding: Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself) (optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces())) Add GuiceyBootstrap methods (extend GuiceyBundle abilities): bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type. application(): returns current application instance Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc) Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). Add GuiceBundle builder configuration options: bindConfigurationInterfaces() to enable configuration interface bindings strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests) printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs) shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces() NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)","title":"3.3.0 (2016-08-02)"},{"location":"about/history/#320-2016-01-23","text":"Clear possible duplicate guicey bundle instances Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources. Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles. Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions. Add builder bundleLookup method to register custom lookup implementation Add builder disableBundleLookup to disable default look-ups Default lookup implementation logs all resolved bundles Fix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support. Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed are managed by HK2 only. May be used in tests as extra validation. Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. Update to dropwizard 0.9 Revert system exit on guice injector creation error (added in 3.1.1)","title":"3.2.0 (2016-01-23)"},{"location":"about/history/#311-2015-11-24","text":"Exit on guice injector creation error. Add classpath scan packages validation for intersection (to prevent duplicate instances)","title":"3.1.1 (2015-11-24)"},{"location":"about/history/#310-2015-09-06","text":"JerseyProviderInstaller: add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener support multiple extension interfaces on the same bean Introduce bundles (GuiceyBundle) to simplify extensions: core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed builder bundles() method to add guicey bundles builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism) Add admin context rest support (AdminRestBundle) Add request scoped beans support in admin context","title":"3.1.0 (2015-09-06)"},{"location":"about/history/#301-2015-07-04","text":"Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces","title":"3.0.1 (2015-07-04)"},{"location":"about/history/#300-2015-04-26","text":"Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) (breaking) Remove static state from GuiceBundle: GuiceBundle.getInjector method remain, but its now instance specific (instead of static) Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() JerseyInstaller interface signature changed: now install method receives injector instance","title":"3.0.0 (2015-04-26)"},{"location":"about/history/#220-2015-04-17","text":"Fix ExceptionMapper registration Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 (to simplify custom installers injection between them)","title":"2.2.0 (2015-04-17)"},{"location":"about/history/#212-2015-03-03","text":"Spock 1.0 compatibility","title":"2.1.2 (2015-03-03)"},{"location":"about/history/#211-2015-01-25","text":"Dropwizard 0.8-rc2 compatibility","title":"2.1.1 (2015-01-25)"},{"location":"about/history/#210-2015-01-04","text":"Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by Nicholas Pace Add spock extensions to use injections directly in specification (like spock-guice do)","title":"2.1.0 (2015-01-04)"},{"location":"about/history/#200-2014-11-25","text":"Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)). Jersey integration completely rewritten. Add JerseyInstaller installer type Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)","title":"2.0.0 (2014-11-25)"},{"location":"about/history/#110-2014-10-23","text":"Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils Drop java 1.6 compatibility, because dropwizard is 1.7 compatible Add junit rule for lightweight testing (run guice without starting jetty)","title":"1.1.0 (2014-10-23)"},{"location":"about/history/#100-2014-10-14","text":"Add dependency on guice-multibindings Installers may choose now from three types of installation (binding, type or instance) or combine them. Add PluginInstaller: shortcut for multibindings mechanism Updated guice (4.0.beta4 -> 4.0.beta5) Force singleton for resources @Eager renamed to @EagerSingleton and now forces singleton scope for bean Add dropwizard style reporting for installed features (like resources or tasks) Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers) Add admin context filter and servlet installers Rename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions","title":"1.0.0 (2014-10-14)"},{"location":"about/history/#090-2014-09-05","text":"Initial release","title":"0.9.0 (2014-09-05)"},{"location":"about/license/","text":"The MIT License (MIT) Copyright \u00a9 2014-2023, Vyacheslav Rusakov Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/migration/","text":"Migration guide \u00b6 Dropwizard 2.1 \u00b6 Since dropwizard 2.1.0 jackson blackbird used by default instead of afterburner . If you use java 8 then apply afterburner dependency in order to switch into it: implementation 'com.fasterxml.jackson.module:jackson-module-afterburner:2.13.3' (omit version if guicey or dropwizard if BOM used). Without it, you'll always see a nasty warning on startup (afterburner is better for java 8, but for java 9+ blackbird should be used) Java 8 issue discussion dropwizard upgrade instructions Dropwizard 2.0 \u00b6 dropwizard upgrade instructions guicey migration guide .","title":"Migration guide"},{"location":"about/migration/#migration-guide","text":"","title":"Migration guide"},{"location":"about/migration/#dropwizard-21","text":"Since dropwizard 2.1.0 jackson blackbird used by default instead of afterburner . If you use java 8 then apply afterburner dependency in order to switch into it: implementation 'com.fasterxml.jackson.module:jackson-module-afterburner:2.13.3' (omit version if guicey or dropwizard if BOM used). Without it, you'll always see a nasty warning on startup (afterburner is better for java 8, but for java 9+ blackbird should be used) Java 8 issue discussion dropwizard upgrade instructions","title":"Dropwizard 2.1"},{"location":"about/migration/#dropwizard-20","text":"dropwizard upgrade instructions guicey migration guide .","title":"Dropwizard 2.0"},{"location":"about/release-notes/","text":"5.10.0 Release Notes \u00b6 Update to dropwizard 2.1.10 Add jsr305 as transitive dependency Add qualified configuration bindings Test improvements: DropwizardTestSupport and ClientSupport objects availability Web client improvements (ClientSupport) Improve generic testing Support commands testing JSR305 dependency \u00b6 com.google.code.findbugs:jsr305:3.0.2 is now a transitive dependency to simplify javax.annotation.Nullable usage (note that jsr305 dependency become optional in guice 6.0). Guice, by default, does not allow null values injection . Nullable injections should be explicitly annotated with @Nullable . This might be useful for (potentially nullable) configuration properties injection. Qualified configuration bindings \u00b6 Any configuration property could be bound to guice just by annotating field or getter with qualifier annotation (guice or jakarta). Annotated fields with the same type and qualifier are bound aggregated with Set Core dropwizard configuration objects could be bound with qualified overridden getter public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); public String getProp1 () { return prop1 ; } public SubObj getSubObj () { return obj1 ; } @Named ( \"metrics\" ) // dropwizard object bind @Override MetricsFactory getMetricsFactory () { return super . getMetricsFactory (); } } public class SubObj { private String prop2 ; private String prop3 ; // aggregated binding (same type + qualifier) @Named ( \"sub-prop\" ) public String getProp2 () { return prop2 ; } @Named ( \"sub-prop\" ) public String getProp3 () { return prop3 ; } } @Retention ( RetentionPolicy . RUNTIME ) @Target ({ ElementType . FIELD , ElementType . PARAMETER , ElementType . METHOD }) @BindingAnnotation public @interface CustomQualifier {} The following injections would be available: @Inject @Named ( \"custom\" ) String prop1 ; @Inject @CustomQualifier SubObj obj1 ; @Inject @Named ( \"sub-prop\" ) Set < String > prop23 ; @Inject @Named ( \"metrics\" ) MetricsFactory metricsFactyry ; Note Properties are grouped by exact type and annotation (exactly the same binding keys), so don't expect more complex grouping (for example, by some base class). Configuration bindings report: GuiceBundle . builder () . printCustomConfigurationBindings () Would show qualified bindings (with source property names in braces): Qualified bindings: @Named(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[], reportOnStop=false} (metrics) @CustomQualifier SubObj = ru.vyarus.dropwizard.guice.yaml.qualifier.QualifierSampleTest$SubObj@19e0dffe (obj1) @Named(\"sub-prop\") Set<String> = (aggregated values) String = \"2\" (obj1.prop2) String = \"3\" (obj1.prop3) @Named(\"custom\") String = \"1\" (prop1) Guice modules and guicey bundles could also access annotated values (through DropwizardAwareModule and GuiceyEnvironment in GuiceyBundle#run ): .annotatedValue(Names.named(\"custom\")) - access by (equal) annotation instance (for annotations with state) .annotatedValue(CustomQualifier.class) - access by annotation type More related methods added for ConfigurationTree object: findAllByAnnotation - find all annotated paths findByAnnotation - find exactly one annotated path (fail if more found) annotatatedValues - all non-null values from annotated paths Test improvements \u00b6 DropwizardTestSupport and ClientSupport objects availability \u00b6 In junit 5 and spock 2 DropwizardTestSupport object could now be injected as test parameter (or constructor, or lifecycle method parameter): @Test public void testSomething ( DropwizardTestSupport support ) { } Note GuiceyTestSupport extends DropwizardTestSupport so this works for both web and core runs. Also, context DropwizardTestSupport and ClientSupport objects now available statically (at the same thread): DropwizardTestSupport support = TestSupport . getContext (); ClientSupport client = TestSupport . getContextClient (); These static references would also work inside generic run callbacks, like: TestSupport . runCoreApp ( App . class , injector -> { DropwizardTestSupport support = TestSupport . getContext (); }); (works for all TestSupport.run* methods) Web client improvements (ClientSupport) \u00b6 Simple methods \u00b6 The client now contains simple GET/POST/PUT/DELETE methods for simple cases: @Test public void testWeb ( ClientSupport client ) { // get with result Result res = client . get ( \"rest/sample\" , Result . class ); // post without result (void) client . post ( \"rest/action\" , new PostObject (), null ); } All methods: Methods accept paths relative to server root. In the example above: \"http://localhost:8080/rest/sample\" Could return mapped response. For void calls, use null instead of the result type. In this case, only 200 and 204 (no content) responses would be considered successful POST and PUT also accept (body) object to send. But methods does not allow multipart execution. These methods could be used as examples for jersey client usage. There is also a new helper method: client.basePathRoot() returning the base server path (localhost + port); Default client \u00b6 JerseyClient used inside ClientSupport now automatically configures multipart feature if dropwizard-forms is in classpath (so the client could be used for sending multipart data). Request and response logging is enabled by default now to simplify writing (and debugging) tests. By default, all messages are written directly into console to guarantee client actions visibility (logging might not be configured in tests). Example output: [Client action]---------------------------------------------{ 1 * Sending client request on thread main 1 > GET http://localhost:8080/sample/get }---------------------------------------------------------- [Client action]---------------------------------------------{ 1 * Client response received on thread main 1 < 200 1 < Content-Length: 13 1 < Content-Type: application/json 1 < Date: Mon, 27 Nov 2023 10:00:40 GMT 1 < Vary: Accept-Encoding {\"foo\":\"get\"} }---------------------------------------------------------- Console output might be disabled with a system proprty: // shortcut sets DefaultTestClientFactory.USE_LOGGER property DefaultTestClientFactory . disableConsoleLog () With it, everything would be logged into ClientSupport logger under INFO (most likely, would be invisible in the most logger configurations, but could be enabled). To reset property (and get logs back into console) use: DefaultTestClientFactory . enableConsoleLog () Note Static methods added not directly into ClientSupport because this is the default client factory feature. You might use a completely different factory. Custom client factory \u00b6 JerseyClient used in ClientSupport could be customized now using TestClientFactory implementation. Simple factory example: public class SimpleTestClientFactory implements TestClientFactory { @Override public JerseyClient create ( final DropwizardTestSupport <?> support ) { return new JerseyClientBuilder () . register ( new JacksonFeature ( support . getEnvironment (). getObjectMapper ())) . property ( ClientProperties . CONNECT_TIMEOUT , 1000 ) . property ( ClientProperties . READ_TIMEOUT , 5000 ) . property ( HttpUrlConnectorProvider . SET_METHOD_WORKAROUND , true ) . build (); } } Tip See DefaultTestClientFactory implementation (it's a bit more complex) Custom factory could be specified directly in test annotation (junit 5, spock 2): @TestDropwizardApp ( value = MyApp . class , clientFactory = CustomTestClientFactory . class ) All other builders also support client factory as an optional parameter. Improve generic testing \u00b6 Generic run builder \u00b6 Generic builder was added to simplify application testing without test framework. It supports almost everything as junit 5 extensions. Example: RunResult result = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) . runCore () or with action: Object serviceValue = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) . runWeb ( injector -> { return injector . getInstance ( FooService . class ). getSomething (); }) Builder provide simple listener support to simplify setup and cleanup logic (without test framework): TestSupport . build ( App . class ) . listen ( new TestSupportBuilder . TestListener <> () { public void setup ( final DropwizardTestSupport < C > support ) throws Exception { // do before test } ... }) . runCore (); All listener methods are default so only required methods could be overridden. TestSupport run* and \"create\" methods ( coreApp , webApp ) are powered now with a new builder (and so many of them support string config overrides as parameter). Run methods improvements \u00b6 Extra run* methods added for simple cases (the same could be achieved with a new builder). Void methods now return RunResult object containing DropwizardTestSupport object and Injector - everything that could be required for assertions after application run: RunResult < MyConfig > res = TestSupport . runCoreApp ( MyApp . class ); Assertions . assertEquals ( 2 , res . getConfiguration (). foo ); Shortcut methods with config overrides: RunResult < MyConfig > res = TestSupport . runCoreApp ( MyApp . class , \"path/to/config.yml\" , // could be null \"foo: 2\" , \"bar: 11\" ); Capture console output \u00b6 There is now a utility to capture console output: String out = TestSupport . captureOutput (() -> { // run application inside TestSupport . runWebApp ( App . class , injector -> { ClientSupport client = TestSupport . getContextClient (); // call application api endpoint client . get ( \"sample/get\" , null ); return null ; }); }); // uses assert4j, test that client was called (just an example) Assertions . assertThat ( out ) . contains ( \"[Client action]---------------------------------------------{\" ); Returned output contains both System.out and System.err - same as it would be seen in console. All output is also printed into console to simplify visual validation Warning Such tests could not be run in parallel (due to system io overrides) Support commands testing \u00b6 An easy way for testing commands was added: CommandTestSupport object is equivalent to DropwizardTestSupport , but for running commands. It uses dropwizard Cli for arguments recognition and command selection. The main difference with DropwizardTestSupport is that command execution is a short-lived process and all assertions are possible only after the execution. That's why command runner would include in the result all possible dropwizard objects, created during execution (because it would be impossible to reference them after execution). New builder (very similar to application execution builder, described above) was added to simplify commands execution: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); This runner could be used to run any command type (simple, configured, environment). The type of command would define what objects would be present ofter the command execution (for example, Injector would be available only for EnvironmentCommand ). Important Such run never fails with an exception: any appeared exception would be stored inside the response: Assertions . assertFalse ( result . isSuccessful ()); Assertions . assertEquals ( \"Error message\" , result . getException (). getMessage ()); IO \u00b6 Runner use System.in/err/out replacement. All output is intercepted and could be asserted: Assertions . assertTrue ( result . getOutput (). contains ( \"some text\" )) result.getOutput() contains both out and err streams together (the same way as user would see it in console). Error output is also available separately with result.getErrorOutput() . Note All output is always printed to console, so you could always see it after test execution (without additional actions) Commands requiring user input could also be tested (with mocked input): CommandResult result = TestSupport . buildCommandRunner ( App . class ) . consoleInputs ( \"1\" , \"two\" , \"something else\" ) . run ( \"quiz\" ) At least, the required number of answers must be provided (otherwise error would be thrown, indicating not enough inputs) Warning Due to IO overrides, command tests could not run in parallel. For junit 5, such tests could be annotated with @Isolated (to prevent execution in parallel with other tests) Configuration \u00b6 Configuration could be applied the same way as in run builder: direct configuration instance, file or (with) overrides: // override only TestSupport . buildCommandRunner ( App . class ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // file with overrides TestSupport . buildCommandRunner ( App . class ) . config ( \"src/test/resources/path/to/config.yml\" ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // direct config object MyConfig config = new MyConfig (); TestSupport . buildCommandRunner ( App . class ) . config ( config ) . run ( \"cfg\" ); Note Config file should not be specified in command itself - builder would add it, if required. But still, it would not be a mistake to use config file directly in command: TestSupport . buildCommandRunner ( App . class ) // note .config(\"...\") was not used (otherwise two files would appear)! . run ( \"cfg\" , \"path/to/config.yml\" ); Using builder for config file configuration assumed to be a preferred way. Listener \u00b6 There is a simple listener support (like in application run builder) for setup-cleanup actions: TestSupport . buildCommandRunner ( App . class ) . listen ( new CommandRunBuilder . CommandListener <> () { public void setup ( String [] args ) { ... } public void cleanup ( CommandResult < TestConfiguration > result ) { ... } }) . run ( \"cmd\" ) Test application startup fail \u00b6 Command runner could also be used for application startup fail tests: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"server\" ) or with the shortcut: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Note In case of application successful start, special check would immediately stop it by throwing exception (resulting object would contain it), so such test would never freeze. No additional mocks or extensions required because running like this would not cause System.exist(1) call, performed in Application class (see Application.onFatalError ).","title":"Release notes"},{"location":"about/release-notes/#5100-release-notes","text":"Update to dropwizard 2.1.10 Add jsr305 as transitive dependency Add qualified configuration bindings Test improvements: DropwizardTestSupport and ClientSupport objects availability Web client improvements (ClientSupport) Improve generic testing Support commands testing","title":"5.10.0 Release Notes"},{"location":"about/release-notes/#jsr305-dependency","text":"com.google.code.findbugs:jsr305:3.0.2 is now a transitive dependency to simplify javax.annotation.Nullable usage (note that jsr305 dependency become optional in guice 6.0). Guice, by default, does not allow null values injection . Nullable injections should be explicitly annotated with @Nullable . This might be useful for (potentially nullable) configuration properties injection.","title":"JSR305 dependency"},{"location":"about/release-notes/#qualified-configuration-bindings","text":"Any configuration property could be bound to guice just by annotating field or getter with qualifier annotation (guice or jakarta). Annotated fields with the same type and qualifier are bound aggregated with Set Core dropwizard configuration objects could be bound with qualified overridden getter public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); public String getProp1 () { return prop1 ; } public SubObj getSubObj () { return obj1 ; } @Named ( \"metrics\" ) // dropwizard object bind @Override MetricsFactory getMetricsFactory () { return super . getMetricsFactory (); } } public class SubObj { private String prop2 ; private String prop3 ; // aggregated binding (same type + qualifier) @Named ( \"sub-prop\" ) public String getProp2 () { return prop2 ; } @Named ( \"sub-prop\" ) public String getProp3 () { return prop3 ; } } @Retention ( RetentionPolicy . RUNTIME ) @Target ({ ElementType . FIELD , ElementType . PARAMETER , ElementType . METHOD }) @BindingAnnotation public @interface CustomQualifier {} The following injections would be available: @Inject @Named ( \"custom\" ) String prop1 ; @Inject @CustomQualifier SubObj obj1 ; @Inject @Named ( \"sub-prop\" ) Set < String > prop23 ; @Inject @Named ( \"metrics\" ) MetricsFactory metricsFactyry ; Note Properties are grouped by exact type and annotation (exactly the same binding keys), so don't expect more complex grouping (for example, by some base class). Configuration bindings report: GuiceBundle . builder () . printCustomConfigurationBindings () Would show qualified bindings (with source property names in braces): Qualified bindings: @Named(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[], reportOnStop=false} (metrics) @CustomQualifier SubObj = ru.vyarus.dropwizard.guice.yaml.qualifier.QualifierSampleTest$SubObj@19e0dffe (obj1) @Named(\"sub-prop\") Set<String> = (aggregated values) String = \"2\" (obj1.prop2) String = \"3\" (obj1.prop3) @Named(\"custom\") String = \"1\" (prop1) Guice modules and guicey bundles could also access annotated values (through DropwizardAwareModule and GuiceyEnvironment in GuiceyBundle#run ): .annotatedValue(Names.named(\"custom\")) - access by (equal) annotation instance (for annotations with state) .annotatedValue(CustomQualifier.class) - access by annotation type More related methods added for ConfigurationTree object: findAllByAnnotation - find all annotated paths findByAnnotation - find exactly one annotated path (fail if more found) annotatatedValues - all non-null values from annotated paths","title":"Qualified configuration bindings"},{"location":"about/release-notes/#test-improvements","text":"","title":"Test improvements"},{"location":"about/release-notes/#dropwizardtestsupport-and-clientsupport-objects-availability","text":"In junit 5 and spock 2 DropwizardTestSupport object could now be injected as test parameter (or constructor, or lifecycle method parameter): @Test public void testSomething ( DropwizardTestSupport support ) { } Note GuiceyTestSupport extends DropwizardTestSupport so this works for both web and core runs. Also, context DropwizardTestSupport and ClientSupport objects now available statically (at the same thread): DropwizardTestSupport support = TestSupport . getContext (); ClientSupport client = TestSupport . getContextClient (); These static references would also work inside generic run callbacks, like: TestSupport . runCoreApp ( App . class , injector -> { DropwizardTestSupport support = TestSupport . getContext (); }); (works for all TestSupport.run* methods)","title":"DropwizardTestSupport and ClientSupport objects availability"},{"location":"about/release-notes/#web-client-improvements-clientsupport","text":"","title":"Web client improvements (ClientSupport)"},{"location":"about/release-notes/#simple-methods","text":"The client now contains simple GET/POST/PUT/DELETE methods for simple cases: @Test public void testWeb ( ClientSupport client ) { // get with result Result res = client . get ( \"rest/sample\" , Result . class ); // post without result (void) client . post ( \"rest/action\" , new PostObject (), null ); } All methods: Methods accept paths relative to server root. In the example above: \"http://localhost:8080/rest/sample\" Could return mapped response. For void calls, use null instead of the result type. In this case, only 200 and 204 (no content) responses would be considered successful POST and PUT also accept (body) object to send. But methods does not allow multipart execution. These methods could be used as examples for jersey client usage. There is also a new helper method: client.basePathRoot() returning the base server path (localhost + port);","title":"Simple methods"},{"location":"about/release-notes/#default-client","text":"JerseyClient used inside ClientSupport now automatically configures multipart feature if dropwizard-forms is in classpath (so the client could be used for sending multipart data). Request and response logging is enabled by default now to simplify writing (and debugging) tests. By default, all messages are written directly into console to guarantee client actions visibility (logging might not be configured in tests). Example output: [Client action]---------------------------------------------{ 1 * Sending client request on thread main 1 > GET http://localhost:8080/sample/get }---------------------------------------------------------- [Client action]---------------------------------------------{ 1 * Client response received on thread main 1 < 200 1 < Content-Length: 13 1 < Content-Type: application/json 1 < Date: Mon, 27 Nov 2023 10:00:40 GMT 1 < Vary: Accept-Encoding {\"foo\":\"get\"} }---------------------------------------------------------- Console output might be disabled with a system proprty: // shortcut sets DefaultTestClientFactory.USE_LOGGER property DefaultTestClientFactory . disableConsoleLog () With it, everything would be logged into ClientSupport logger under INFO (most likely, would be invisible in the most logger configurations, but could be enabled). To reset property (and get logs back into console) use: DefaultTestClientFactory . enableConsoleLog () Note Static methods added not directly into ClientSupport because this is the default client factory feature. You might use a completely different factory.","title":"Default client"},{"location":"about/release-notes/#custom-client-factory","text":"JerseyClient used in ClientSupport could be customized now using TestClientFactory implementation. Simple factory example: public class SimpleTestClientFactory implements TestClientFactory { @Override public JerseyClient create ( final DropwizardTestSupport <?> support ) { return new JerseyClientBuilder () . register ( new JacksonFeature ( support . getEnvironment (). getObjectMapper ())) . property ( ClientProperties . CONNECT_TIMEOUT , 1000 ) . property ( ClientProperties . READ_TIMEOUT , 5000 ) . property ( HttpUrlConnectorProvider . SET_METHOD_WORKAROUND , true ) . build (); } } Tip See DefaultTestClientFactory implementation (it's a bit more complex) Custom factory could be specified directly in test annotation (junit 5, spock 2): @TestDropwizardApp ( value = MyApp . class , clientFactory = CustomTestClientFactory . class ) All other builders also support client factory as an optional parameter.","title":"Custom client factory"},{"location":"about/release-notes/#improve-generic-testing","text":"","title":"Improve generic testing"},{"location":"about/release-notes/#generic-run-builder","text":"Generic builder was added to simplify application testing without test framework. It supports almost everything as junit 5 extensions. Example: RunResult result = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) . runCore () or with action: Object serviceValue = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) . runWeb ( injector -> { return injector . getInstance ( FooService . class ). getSomething (); }) Builder provide simple listener support to simplify setup and cleanup logic (without test framework): TestSupport . build ( App . class ) . listen ( new TestSupportBuilder . TestListener <> () { public void setup ( final DropwizardTestSupport < C > support ) throws Exception { // do before test } ... }) . runCore (); All listener methods are default so only required methods could be overridden. TestSupport run* and \"create\" methods ( coreApp , webApp ) are powered now with a new builder (and so many of them support string config overrides as parameter).","title":"Generic run builder"},{"location":"about/release-notes/#run-methods-improvements","text":"Extra run* methods added for simple cases (the same could be achieved with a new builder). Void methods now return RunResult object containing DropwizardTestSupport object and Injector - everything that could be required for assertions after application run: RunResult < MyConfig > res = TestSupport . runCoreApp ( MyApp . class ); Assertions . assertEquals ( 2 , res . getConfiguration (). foo ); Shortcut methods with config overrides: RunResult < MyConfig > res = TestSupport . runCoreApp ( MyApp . class , \"path/to/config.yml\" , // could be null \"foo: 2\" , \"bar: 11\" );","title":"Run methods improvements"},{"location":"about/release-notes/#capture-console-output","text":"There is now a utility to capture console output: String out = TestSupport . captureOutput (() -> { // run application inside TestSupport . runWebApp ( App . class , injector -> { ClientSupport client = TestSupport . getContextClient (); // call application api endpoint client . get ( \"sample/get\" , null ); return null ; }); }); // uses assert4j, test that client was called (just an example) Assertions . assertThat ( out ) . contains ( \"[Client action]---------------------------------------------{\" ); Returned output contains both System.out and System.err - same as it would be seen in console. All output is also printed into console to simplify visual validation Warning Such tests could not be run in parallel (due to system io overrides)","title":"Capture console output"},{"location":"about/release-notes/#support-commands-testing","text":"An easy way for testing commands was added: CommandTestSupport object is equivalent to DropwizardTestSupport , but for running commands. It uses dropwizard Cli for arguments recognition and command selection. The main difference with DropwizardTestSupport is that command execution is a short-lived process and all assertions are possible only after the execution. That's why command runner would include in the result all possible dropwizard objects, created during execution (because it would be impossible to reference them after execution). New builder (very similar to application execution builder, described above) was added to simplify commands execution: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); This runner could be used to run any command type (simple, configured, environment). The type of command would define what objects would be present ofter the command execution (for example, Injector would be available only for EnvironmentCommand ). Important Such run never fails with an exception: any appeared exception would be stored inside the response: Assertions . assertFalse ( result . isSuccessful ()); Assertions . assertEquals ( \"Error message\" , result . getException (). getMessage ());","title":"Support commands testing"},{"location":"about/release-notes/#io","text":"Runner use System.in/err/out replacement. All output is intercepted and could be asserted: Assertions . assertTrue ( result . getOutput (). contains ( \"some text\" )) result.getOutput() contains both out and err streams together (the same way as user would see it in console). Error output is also available separately with result.getErrorOutput() . Note All output is always printed to console, so you could always see it after test execution (without additional actions) Commands requiring user input could also be tested (with mocked input): CommandResult result = TestSupport . buildCommandRunner ( App . class ) . consoleInputs ( \"1\" , \"two\" , \"something else\" ) . run ( \"quiz\" ) At least, the required number of answers must be provided (otherwise error would be thrown, indicating not enough inputs) Warning Due to IO overrides, command tests could not run in parallel. For junit 5, such tests could be annotated with @Isolated (to prevent execution in parallel with other tests)","title":"IO"},{"location":"about/release-notes/#configuration","text":"Configuration could be applied the same way as in run builder: direct configuration instance, file or (with) overrides: // override only TestSupport . buildCommandRunner ( App . class ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // file with overrides TestSupport . buildCommandRunner ( App . class ) . config ( \"src/test/resources/path/to/config.yml\" ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // direct config object MyConfig config = new MyConfig (); TestSupport . buildCommandRunner ( App . class ) . config ( config ) . run ( \"cfg\" ); Note Config file should not be specified in command itself - builder would add it, if required. But still, it would not be a mistake to use config file directly in command: TestSupport . buildCommandRunner ( App . class ) // note .config(\"...\") was not used (otherwise two files would appear)! . run ( \"cfg\" , \"path/to/config.yml\" ); Using builder for config file configuration assumed to be a preferred way.","title":"Configuration"},{"location":"about/release-notes/#listener","text":"There is a simple listener support (like in application run builder) for setup-cleanup actions: TestSupport . buildCommandRunner ( App . class ) . listen ( new CommandRunBuilder . CommandListener <> () { public void setup ( String [] args ) { ... } public void cleanup ( CommandResult < TestConfiguration > result ) { ... } }) . run ( \"cmd\" )","title":"Listener"},{"location":"about/release-notes/#test-application-startup-fail","text":"Command runner could also be used for application startup fail tests: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"server\" ) or with the shortcut: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Note In case of application successful start, special check would immediately stop it by throwing exception (resulting object would contain it), so such test would never freeze. No additional mocks or extensions required because running like this would not cause System.exist(1) call, performed in Application class (see Application.onFatalError ).","title":"Test application startup fail"},{"location":"about/support/","text":"Support \u00b6 Github issues - bug reports / enhancement requests Github discussions - questions / propositions / discussions Gitter - chat","title":"Support"},{"location":"about/support/#support","text":"Github issues - bug reports / enhancement requests Github discussions - questions / propositions / discussions Gitter - chat","title":"Support"},{"location":"examples/authentication/","text":"Authentication \u00b6 Example of dropwizard authentication usage with guice. Simple auth \u00b6 Using dropwizard oauth example as basement. Other auth types are configured in similar way. @Provider public class OAuthDynamicFeature extends AuthDynamicFeature { @Inject public OAuthDynamicFeature ( OAuthAuthenticator authenticator , UserAuthorizer authorizer , Environment environment ) { super ( new OAuthCredentialAuthFilter . Builder < User > () . setAuthenticator ( authenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ()); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } // classes below may be external (internal for simplicity) @Singleton public static class OAuthAuthenticator implements Authenticator < String , User > { @Override public Optional < User > authenticate ( String credentials ) throws AuthenticationException { return Optional . fromNullable ( \"valid\" . equals ( credentials ) ? new User () : null ); } } @Singleton public static class UserAuthorizer implements Authorizer < User > { @Override public boolean authorize ( User user , String role ) { return user . getName (). equals ( \"good-guy\" ) && role . equals ( \"ADMIN\" ); } } } The class is automatically picked up by the jersey installer . OAuthAuthenticator and OAuthAuthorizer are simple guice beans (no special installation required). Constructor injection is used to obtain required guice managed instances and then configure authentication the same way as described in dropwizard docs. If autoconfiguration is enabled, then the class will be resolved and installed automatically. Complete OAuth example source Chained auth \u00b6 Chained auth can be used to support different authentication schemes. Integration approach is the same as in simple case: @Provider public class ChainedAuthDynamicFeature extends AuthDynamicFeature { @Inject public ChainedAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OAuthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( new ChainedAuthFilter ( Arrays . asList ( new BasicCredentialAuthFilter . Builder <> () . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Basic\" ) . buildAuthFilter (), new OAuthCredentialAuthFilter . Builder <> () . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter () ))); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } } Polymorphic auth \u00b6 Polymorphic auth allows using different auth schemes simultaneously. Integration approach is the same as in simple case: @Provider public class PolyAuthDynamicFeature extends PolymorphicAuthDynamicFeature { @Inject public PolyAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OauthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( ImmutableMap . of ( BasicPrincipal . class , new BasicCredentialAuthFilter . Builder < BasicPrincipal > () . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setRealm ( \"SUPER SECRET STUFF\" ) . buildAuthFilter (), OAuthPrincipal . class , new OAuthCredentialAuthFilter . Builder < OAuthPrincipal > () . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ())); final AbstractBinder binder = new PolymorphicAuthValueFactoryProvider . Binder <> ( ImmutableSet . of ( BasicPrincipal . class , OAuthPrincipal . class )); environment . jersey (). register ( binder ); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); } }","title":"Authentication"},{"location":"examples/authentication/#authentication","text":"Example of dropwizard authentication usage with guice.","title":"Authentication"},{"location":"examples/authentication/#simple-auth","text":"Using dropwizard oauth example as basement. Other auth types are configured in similar way. @Provider public class OAuthDynamicFeature extends AuthDynamicFeature { @Inject public OAuthDynamicFeature ( OAuthAuthenticator authenticator , UserAuthorizer authorizer , Environment environment ) { super ( new OAuthCredentialAuthFilter . Builder < User > () . setAuthenticator ( authenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ()); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } // classes below may be external (internal for simplicity) @Singleton public static class OAuthAuthenticator implements Authenticator < String , User > { @Override public Optional < User > authenticate ( String credentials ) throws AuthenticationException { return Optional . fromNullable ( \"valid\" . equals ( credentials ) ? new User () : null ); } } @Singleton public static class UserAuthorizer implements Authorizer < User > { @Override public boolean authorize ( User user , String role ) { return user . getName (). equals ( \"good-guy\" ) && role . equals ( \"ADMIN\" ); } } } The class is automatically picked up by the jersey installer . OAuthAuthenticator and OAuthAuthorizer are simple guice beans (no special installation required). Constructor injection is used to obtain required guice managed instances and then configure authentication the same way as described in dropwizard docs. If autoconfiguration is enabled, then the class will be resolved and installed automatically. Complete OAuth example source","title":"Simple auth"},{"location":"examples/authentication/#chained-auth","text":"Chained auth can be used to support different authentication schemes. Integration approach is the same as in simple case: @Provider public class ChainedAuthDynamicFeature extends AuthDynamicFeature { @Inject public ChainedAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OAuthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( new ChainedAuthFilter ( Arrays . asList ( new BasicCredentialAuthFilter . Builder <> () . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Basic\" ) . buildAuthFilter (), new OAuthCredentialAuthFilter . Builder <> () . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter () ))); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } }","title":"Chained auth"},{"location":"examples/authentication/#polymorphic-auth","text":"Polymorphic auth allows using different auth schemes simultaneously. Integration approach is the same as in simple case: @Provider public class PolyAuthDynamicFeature extends PolymorphicAuthDynamicFeature { @Inject public PolyAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OauthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( ImmutableMap . of ( BasicPrincipal . class , new BasicCredentialAuthFilter . Builder < BasicPrincipal > () . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setRealm ( \"SUPER SECRET STUFF\" ) . buildAuthFilter (), OAuthPrincipal . class , new OAuthCredentialAuthFilter . Builder < OAuthPrincipal > () . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ())); final AbstractBinder binder = new PolymorphicAuthValueFactoryProvider . Binder <> ( ImmutableSet . of ( BasicPrincipal . class , OAuthPrincipal . class )); environment . jersey (). register ( binder ); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); } }","title":"Polymorphic auth"},{"location":"examples/eventbus/","text":"Guava EventBus integration \u00b6 Example of guicey-eventbus extension usage. Example source code The eventbus extension is used for: automatic listeners registration binding eventbus instance in guice context (for publication) printing available listeners to console Configuration \u00b6 An additional dependency is required: implementation 'ru.vyarus.guicey:guicey-eventbus:5.10.0' Note guicey-eventbus version could be managed with BOM Register eventbus bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ()) Event \u00b6 Events are simple POJOs. Create event classes with properties you need (or without everything): public class FooEvent { private String something ; public FooEvent ( String something ) { this . something = something ; } public void getSomething () { return something ; } } Use event hierarchies, if appropriate: public abstract class BaseEvent {} public class FooEvent extends BaseEvent {} public class BarEvent extends BaseEvent {} For simplicity, properties are omitted. Publication \u00b6 Inject the eventbus instance to enable publication: @Inject EventBus eventbus ; public void someAction () { ... eventbus . post ( new FooEvent ()); } Listening \u00b6 Listener methods must be annotated with @Subscribe and contain only one parameter of the target event type: @Subscribe public void onFooEvent ( FooEvent event ) {} @Subscribe // listen for all events of type (FooEvent, BarEvent) public void onMultipleEvents ( BaseEvent event ) {} Attention Listener methods will only be registered for \"known\" guice beans. That means any extension or manually declared guice bean (using module) or bean created with guice AOT (because it's declared as dependency for other bean) will be searched for listener methods. See a complete example","title":"EventBus"},{"location":"examples/eventbus/#guava-eventbus-integration","text":"Example of guicey-eventbus extension usage. Example source code The eventbus extension is used for: automatic listeners registration binding eventbus instance in guice context (for publication) printing available listeners to console","title":"Guava EventBus integration"},{"location":"examples/eventbus/#configuration","text":"An additional dependency is required: implementation 'ru.vyarus.guicey:guicey-eventbus:5.10.0' Note guicey-eventbus version could be managed with BOM Register eventbus bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ())","title":"Configuration"},{"location":"examples/eventbus/#event","text":"Events are simple POJOs. Create event classes with properties you need (or without everything): public class FooEvent { private String something ; public FooEvent ( String something ) { this . something = something ; } public void getSomething () { return something ; } } Use event hierarchies, if appropriate: public abstract class BaseEvent {} public class FooEvent extends BaseEvent {} public class BarEvent extends BaseEvent {} For simplicity, properties are omitted.","title":"Event"},{"location":"examples/eventbus/#publication","text":"Inject the eventbus instance to enable publication: @Inject EventBus eventbus ; public void someAction () { ... eventbus . post ( new FooEvent ()); }","title":"Publication"},{"location":"examples/eventbus/#listening","text":"Listener methods must be annotated with @Subscribe and contain only one parameter of the target event type: @Subscribe public void onFooEvent ( FooEvent event ) {} @Subscribe // listen for all events of type (FooEvent, BarEvent) public void onMultipleEvents ( BaseEvent event ) {} Attention Listener methods will only be registered for \"known\" guice beans. That means any extension or manually declared guice bean (using module) or bean created with guice AOT (because it's declared as dependency for other bean) will be searched for listener methods. See a complete example","title":"Listening"},{"location":"examples/governator/","text":"Governator integration \u00b6 Include the Netflix Governator dependency: implementation \"com.netflix.governator:governator:1.17.8\" Governator owns injector creation , so we need to create custom guicey InjectorFactory public class GovernatorInjectorFactory implements InjectorFactory { public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return LifecycleInjector . builder (). withModules ( modules ). inStage ( stage ). build (). createInjector (); } } Configure the new factory in the guice bundle: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new GovernatorInjectorFactory ()) . enableAutoConfig ( \"com.mycompany.myapp\" ) ... . build () ); } Warning Guicey by default parses configured guice modules and so injector factory receives single synthetic module of parsed elements, instead of configured module instances. Some governator features may require exact module instances and so you may need to disable guicey analysis . Also, when using overriding modules configuration (with #modulesOverride configuration) injector factory also receives syntetic module after {@code Modules.override(modules).with(overridingModules)}. So you will have not to use this feature when direct module instances required (for some governator features). Note Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package). Governator Lifecycle \u00b6 Many Governator enhancements are only available when the Governator LifecycleManager is properly started and closed with the application. Use dropwizard's managed object to control governator lifecycle: import io.dropwizard.lifecycle.Managed ; import ru.vyarus.dropwizard.guice.GuiceBundle ; import com.netflix.governator.lifecycle.LifecycleManager ; import javax.inject.Inject ; public class GovernatorLifecycle implements Managed { @Inject private LifecycleManager manager ; @Override public void start () throws Exception { manager . start (); } @Override public void stop () throws Exception { manager . close (); } } Guicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard. This will \"bind\" the governator lifecycle to the dropwizard lifecycle. Note If you need to control the order which the managed beans are started, use the @Order annotation .","title":"Governator"},{"location":"examples/governator/#governator-integration","text":"Include the Netflix Governator dependency: implementation \"com.netflix.governator:governator:1.17.8\" Governator owns injector creation , so we need to create custom guicey InjectorFactory public class GovernatorInjectorFactory implements InjectorFactory { public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return LifecycleInjector . builder (). withModules ( modules ). inStage ( stage ). build (). createInjector (); } } Configure the new factory in the guice bundle: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new GovernatorInjectorFactory ()) . enableAutoConfig ( \"com.mycompany.myapp\" ) ... . build () ); } Warning Guicey by default parses configured guice modules and so injector factory receives single synthetic module of parsed elements, instead of configured module instances. Some governator features may require exact module instances and so you may need to disable guicey analysis . Also, when using overriding modules configuration (with #modulesOverride configuration) injector factory also receives syntetic module after {@code Modules.override(modules).with(overridingModules)}. So you will have not to use this feature when direct module instances required (for some governator features). Note Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).","title":"Governator integration"},{"location":"examples/governator/#governator-lifecycle","text":"Many Governator enhancements are only available when the Governator LifecycleManager is properly started and closed with the application. Use dropwizard's managed object to control governator lifecycle: import io.dropwizard.lifecycle.Managed ; import ru.vyarus.dropwizard.guice.GuiceBundle ; import com.netflix.governator.lifecycle.LifecycleManager ; import javax.inject.Inject ; public class GovernatorLifecycle implements Managed { @Inject private LifecycleManager manager ; @Override public void start () throws Exception { manager . start (); } @Override public void stop () throws Exception { manager . close (); } } Guicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard. This will \"bind\" the governator lifecycle to the dropwizard lifecycle. Note If you need to control the order which the managed beans are started, use the @Order annotation .","title":"Governator Lifecycle"},{"location":"examples/hibernate/","text":"Hibernate integration \u00b6 Example of dropwizard-hibernate bundle usage with guicey. Example source code Configuration \u00b6 Additional dependencies required: implementation 'io.dropwizard:dropwizard-hibernate:2.0.8' implementation 'com.h2database:h2:2.2.224' Note Both versions are managed by BOM For simplicity, an embedded H2 database is used. Overall configuration is exactly the same as described in dropwizard docs , but extracted to separate class for simplicity: public class HbnBundle extends HibernateBundle < HbnAppConfiguration > { public HbnBundle () { super ( Sample . class ); } @Override public PooledDataSourceFactory getDataSourceFactory ( HbnAppConfiguration configuration ) { return configuration . getDataSourceFactory (); } } Note All model classes are configured inside the constructor: super ( Sample . class ); Configuration class: public class HbnAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDataSourceFactory () { return database ; } } Configuration file for in-memory database and automatic schema creation: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:mem:sample properties : charSet : UTF-8 hibernate.dialect : org.hibernate.dialect.H2Dialect hibernate.hbm2ddl.auto : create Guice integration \u00b6 Guice module used to provide SessionFactory instance into guice context: public class HbnModule extends AbstractModule { private final HbnBundle hbnBundle ; public HbnModule ( HbnBundle hbnBundle ) { this . hbnBundle = hbnBundle ; } @Override protected void configure () { bind ( SessionFactory . class ). toInstance ( hbnBundle . getSessionFactory ()); } } Application: @Override public void initialize ( Bootstrap < HbnAppConfiguration > bootstrap ) { final HbnBundle hibernate = new HbnBundle (); // register hbn bundle before guice to make sure factory initialized before guice context start bootstrap . addBundle ( hibernate ); bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( \"com.myapp.package\" ) . modules ( new HbnModule ( hibernate )) . build ()); } Usage \u00b6 It is simpler to use dropwizard AbstractDAO for hibernate logic: public class SampleService extends AbstractDAO < Sample > { @Inject public SampleService ( SessionFactory factory ) { super ( factory ); } public void create ( Sample sample ) { return persist ( sample ); } public List < Sample > findAll () { return list ( currentSession (). createQuery ( \"from Sample\" )); } } You will need to use dropwizard @UnitOfWork annotation to declare transaction scope. For example: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private SampleService service ; @GET @Path ( \"/\" ) @Timed @UnitOfWork public Response doStaff () { final Sample sample = new Sample ( \"sample\" ); service . create ( sample ); final List < Sample > res = service . findAll (); // using response to render entities inside unit of work and avoid lazy load exceptions return Response . ok ( res ). build (); } }","title":"Hibernate"},{"location":"examples/hibernate/#hibernate-integration","text":"Example of dropwizard-hibernate bundle usage with guicey. Example source code","title":"Hibernate integration"},{"location":"examples/hibernate/#configuration","text":"Additional dependencies required: implementation 'io.dropwizard:dropwizard-hibernate:2.0.8' implementation 'com.h2database:h2:2.2.224' Note Both versions are managed by BOM For simplicity, an embedded H2 database is used. Overall configuration is exactly the same as described in dropwizard docs , but extracted to separate class for simplicity: public class HbnBundle extends HibernateBundle < HbnAppConfiguration > { public HbnBundle () { super ( Sample . class ); } @Override public PooledDataSourceFactory getDataSourceFactory ( HbnAppConfiguration configuration ) { return configuration . getDataSourceFactory (); } } Note All model classes are configured inside the constructor: super ( Sample . class ); Configuration class: public class HbnAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDataSourceFactory () { return database ; } } Configuration file for in-memory database and automatic schema creation: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:mem:sample properties : charSet : UTF-8 hibernate.dialect : org.hibernate.dialect.H2Dialect hibernate.hbm2ddl.auto : create","title":"Configuration"},{"location":"examples/hibernate/#guice-integration","text":"Guice module used to provide SessionFactory instance into guice context: public class HbnModule extends AbstractModule { private final HbnBundle hbnBundle ; public HbnModule ( HbnBundle hbnBundle ) { this . hbnBundle = hbnBundle ; } @Override protected void configure () { bind ( SessionFactory . class ). toInstance ( hbnBundle . getSessionFactory ()); } } Application: @Override public void initialize ( Bootstrap < HbnAppConfiguration > bootstrap ) { final HbnBundle hibernate = new HbnBundle (); // register hbn bundle before guice to make sure factory initialized before guice context start bootstrap . addBundle ( hibernate ); bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( \"com.myapp.package\" ) . modules ( new HbnModule ( hibernate )) . build ()); }","title":"Guice integration"},{"location":"examples/hibernate/#usage","text":"It is simpler to use dropwizard AbstractDAO for hibernate logic: public class SampleService extends AbstractDAO < Sample > { @Inject public SampleService ( SessionFactory factory ) { super ( factory ); } public void create ( Sample sample ) { return persist ( sample ); } public List < Sample > findAll () { return list ( currentSession (). createQuery ( \"from Sample\" )); } } You will need to use dropwizard @UnitOfWork annotation to declare transaction scope. For example: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private SampleService service ; @GET @Path ( \"/\" ) @Timed @UnitOfWork public Response doStaff () { final Sample sample = new Sample ( \"sample\" ); service . create ( sample ); final List < Sample > res = service . findAll (); // using response to render entities inside unit of work and avoid lazy load exceptions return Response . ok ( res ). build (); } }","title":"Usage"},{"location":"examples/jdbi/","text":"JDBI integration \u00b6 Example of guicey-jdbi extension usage. Example source code The JDBI extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation Configuration \u00b6 Additional dependencies required: implementation 'ru.vyarus.guicey:guicey-jdbi:5.10.0' implementation 'com.h2database:h2:2.2.224' Note guicey-jdbi version could be managed with BOM dropwizard-jdbi is used to configure and create dbi instance: public class JdbiAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. DBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle . < JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) Note You can use pre-build dbi instance instead. Repository definition \u00b6 Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public abstract class UserRepository extends Crud < User > { // have to use field injection because class is still used by dbi (which is no aware of guice) for proxy creation @Inject private RandomNameGenerator generator ; // sample of hybrid method in repository, using injected service public User createRandomUser () { final User user = new User (); user . setName ( generator . generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys public abstract long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override public abstract int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) public abstract List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) public abstract User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base class tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public abstract class Crud < T extends IdEntity > { @InTransaction public T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } public abstract long insert ( T entry ); public abstract int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use field injections: @Inject private RandomNameGenerator generator ; Result set mapper \u00b6 Result set mapper is used to map query result set to entity: public class UserMapper implements ResultSetMapper < User > { @Override public User map ( int index , ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the dbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you dont want to use auto configuration then you can register it manually in dbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @BindingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements BinderFactory < UserBind > { @Override public Binder build ( UserBind annotation ) { return ( Binder < UserBind , User > ) ( q , bind , arg ) -> { q . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by DBI. Usage \u00b6 Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"JDBI"},{"location":"examples/jdbi/#jdbi-integration","text":"Example of guicey-jdbi extension usage. Example source code The JDBI extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation","title":"JDBI integration"},{"location":"examples/jdbi/#configuration","text":"Additional dependencies required: implementation 'ru.vyarus.guicey:guicey-jdbi:5.10.0' implementation 'com.h2database:h2:2.2.224' Note guicey-jdbi version could be managed with BOM dropwizard-jdbi is used to configure and create dbi instance: public class JdbiAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. DBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle . < JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) Note You can use pre-build dbi instance instead.","title":"Configuration"},{"location":"examples/jdbi/#repository-definition","text":"Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public abstract class UserRepository extends Crud < User > { // have to use field injection because class is still used by dbi (which is no aware of guice) for proxy creation @Inject private RandomNameGenerator generator ; // sample of hybrid method in repository, using injected service public User createRandomUser () { final User user = new User (); user . setName ( generator . generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys public abstract long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override public abstract int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) public abstract List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) public abstract User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base class tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public abstract class Crud < T extends IdEntity > { @InTransaction public T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } public abstract long insert ( T entry ); public abstract int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use field injections: @Inject private RandomNameGenerator generator ;","title":"Repository definition"},{"location":"examples/jdbi/#result-set-mapper","text":"Result set mapper is used to map query result set to entity: public class UserMapper implements ResultSetMapper < User > { @Override public User map ( int index , ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the dbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you dont want to use auto configuration then you can register it manually in dbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @BindingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements BinderFactory < UserBind > { @Override public Binder build ( UserBind annotation ) { return ( Binder < UserBind , User > ) ( q , bind , arg ) -> { q . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by DBI.","title":"Result set mapper"},{"location":"examples/jdbi/#usage","text":"Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"Usage"},{"location":"examples/jdbi3/","text":"JDBI3 integration \u00b6 Example of guicey-jdbi3 extension usage. Example source code The JDBI3 extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation Configuration \u00b6 Additional dependencies required: implementation 'ru.vyarus.guicey:guicey-jdbi3:5.10.0' implementation 'com.h2database:h2:2.2.224' Note Both versions are managed by BOM dropwizard-jdbi3 is used to configure and create dbi instance: public class Jdbi3AppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. JDBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle . < JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) . withPlugins ( new H2DatabasePlugin ())) Note You can use pre-build jdbi instance instead. Repository definition \u00b6 Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public interface UserRepository extends Crud < User > { @Inject RandomNameGenerator getGenerator (); // sample of hybrid method in repository, using injected service default User createRandomUser () { final User user = new User (); user . setName ( getGenerator (). generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base interface tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public interface Crud < T extends IdEntity > { @InTransaction default T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } long insert ( T entry ); int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use getter injections: @Inject RandomNameGenerator getGenerator (); Row mapper \u00b6 Row mapper is used to map query result set to entity: public class UserMapper implements RowMapper < User > { @Override public User map ( ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the jdbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you don't want to use auto configuration then you can register it manually in jdbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @SqlStatementCustomizingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements SqlStatementCustomizerFactory { @Override public SqlStatementParameterCustomizer createForParameter ( Annotation annotation , Class <?> sqlObjectType , Method method , Parameter param , int index , Type paramType ) { return ( stmt , obj ) -> { User arg = ( User ) obj ; (( SqlStatement ) stmt ) . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by JDBI. Usage \u00b6 Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"JDBI3"},{"location":"examples/jdbi3/#jdbi3-integration","text":"Example of guicey-jdbi3 extension usage. Example source code The JDBI3 extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation","title":"JDBI3 integration"},{"location":"examples/jdbi3/#configuration","text":"Additional dependencies required: implementation 'ru.vyarus.guicey:guicey-jdbi3:5.10.0' implementation 'com.h2database:h2:2.2.224' Note Both versions are managed by BOM dropwizard-jdbi3 is used to configure and create dbi instance: public class Jdbi3AppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. JDBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle . < JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) . withPlugins ( new H2DatabasePlugin ())) Note You can use pre-build jdbi instance instead.","title":"Configuration"},{"location":"examples/jdbi3/#repository-definition","text":"Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public interface UserRepository extends Crud < User > { @Inject RandomNameGenerator getGenerator (); // sample of hybrid method in repository, using injected service default User createRandomUser () { final User user = new User (); user . setName ( getGenerator (). generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base interface tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public interface Crud < T extends IdEntity > { @InTransaction default T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } long insert ( T entry ); int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use getter injections: @Inject RandomNameGenerator getGenerator ();","title":"Repository definition"},{"location":"examples/jdbi3/#row-mapper","text":"Row mapper is used to map query result set to entity: public class UserMapper implements RowMapper < User > { @Override public User map ( ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the jdbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you don't want to use auto configuration then you can register it manually in jdbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @SqlStatementCustomizingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements SqlStatementCustomizerFactory { @Override public SqlStatementParameterCustomizer createForParameter ( Annotation annotation , Class <?> sqlObjectType , Method method , Parameter param , int index , Type paramType ) { return ( stmt , obj ) -> { User arg = ( User ) obj ; (( SqlStatement ) stmt ) . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by JDBI.","title":"Row mapper"},{"location":"examples/jdbi3/#usage","text":"Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"Usage"},{"location":"extras/admin-rest/","text":"Admin REST \u00b6 Mirror all resources in admin context: on admin side special servlet simply redirects all incoming requests into the jersey context. Hides admin-only resources from user context: resource is working under admin context and return 404 on user context. Such approach is better than registering a completely separate jersey context for admin rest because of no overhead and the simplicity of jersey extensions management. Features: * All user context rest available in admin context * Admin-only resources not visible in user context Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-admin-rest </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-admin-rest:5.10.0' Omit version if guicey BOM used Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( new AdminRestBundle ()); In this case, rest is registered either to '/api/ ', if main context rest is mapped to root ('/ ') or to the same path as main context rest. To register on a custom path: . bundles ( new AdminRestBundle ( \"/custom/*\" )); Note In case if multiple bundles registered, only first registration will be used (due to de-duplication ) Security \u00b6 In order to hide specific resource methods or entire resources on the main context, annotate resource methods or resource classes with the @AdminResource annotation. For example: @GET @Path ( \"/admin\" ) @AdminResource public String admin () { return \"admin\" } This (annotated) method will return 404 error when called from main context, but should function normally when called from the admin context.","title":"Admin REST"},{"location":"extras/admin-rest/#admin-rest","text":"Mirror all resources in admin context: on admin side special servlet simply redirects all incoming requests into the jersey context. Hides admin-only resources from user context: resource is working under admin context and return 404 on user context. Such approach is better than registering a completely separate jersey context for admin rest because of no overhead and the simplicity of jersey extensions management. Features: * All user context rest available in admin context * Admin-only resources not visible in user context","title":"Admin REST"},{"location":"extras/admin-rest/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-admin-rest </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-admin-rest:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/admin-rest/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( new AdminRestBundle ()); In this case, rest is registered either to '/api/ ', if main context rest is mapped to root ('/ ') or to the same path as main context rest. To register on a custom path: . bundles ( new AdminRestBundle ( \"/custom/*\" )); Note In case if multiple bundles registered, only first registration will be used (due to de-duplication )","title":"Usage"},{"location":"extras/admin-rest/#security","text":"In order to hide specific resource methods or entire resources on the main context, annotate resource methods or resource classes with the @AdminResource annotation. For example: @GET @Path ( \"/admin\" ) @AdminResource public String admin () { return \"admin\" } This (annotated) method will return 404 error when called from main context, but should function normally when called from the admin context.","title":"Security"},{"location":"extras/bom/","text":"Guicey BOM \u00b6 Maven BOM contains guicey and guicey ext modules versions. Also includes dropwizard and guice boms. Tip BOMs are useful for versions management. After including bom you can simply include required dependencies (dropwizard, guice, guicey, guicey-ext) without versions: bom will control all versions. Setup \u00b6 Maven: <!-- Implicitly imports Dropwizard and Guice BOMs --> <dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-bom </artifactId> <version> 5.10.0 </version> <type> pom </type> <scope> import </scope> </dependency> <!-- uncomment to override dropwizard and its dependencies versions <dependency> <groupId>io.dropwizard/groupId> <artifactId>dropwizard-dependencies</artifactId> <version>2.1.10</version> <type>pom</type> <scope>import</scope> </dependency> --> </dependencies> </dependencyManagement> <!-- declare guice and ext modules without versions --> <dependencies> <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> </dependency> <!-- For example, using dropwizard module (without version) --> <dependency> <groupId> io.dropwizard </groupId> <artifactId> dropwizard-auth </artifactId> </dependency> <!-- Example of extension module usage --> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> </dependency> </dependencies> Gradle: // declare guice and ext modules without versions dependencies { implementation platform ( 'ru.vyarus.guicey:guicey-bom:5.10.0' ) // uncomment to override dropwizard and its dependencies versions //implementation platform('io.dropwizard:dropwizard-dependencies:2.1.10') implementation 'ru.vyarus:dropwizard-guicey' // For example, using dropwizard module (without version) implementation 'io.dropwizard:dropwizard-auth' // Example of extension module usage implementation 'ru.vyarus.guicey:guicey-eventbus' } Bom includes: BOM Artifact Guicey modules ru.vyarus.guicey:guicey-[module] Dropwizard BOM io.dropwizard:dropwizard-bom Guice BOM com.google.inject:guice-bom HK2 bridge org.glassfish.hk2:guice-bridge Spock-junit5 ru.vyarus:spock-junit5 Dependencies override \u00b6 You may override BOM version for any dependency by simply specifying exact version in dependency declaration section. If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly: io.dropwizard:dropwizard-dependencies:$VERSION for dropwizard com.google.inject:guice-bom:$VERSION for guice","title":"BOM"},{"location":"extras/bom/#guicey-bom","text":"Maven BOM contains guicey and guicey ext modules versions. Also includes dropwizard and guice boms. Tip BOMs are useful for versions management. After including bom you can simply include required dependencies (dropwizard, guice, guicey, guicey-ext) without versions: bom will control all versions.","title":"Guicey BOM"},{"location":"extras/bom/#setup","text":"Maven: <!-- Implicitly imports Dropwizard and Guice BOMs --> <dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-bom </artifactId> <version> 5.10.0 </version> <type> pom </type> <scope> import </scope> </dependency> <!-- uncomment to override dropwizard and its dependencies versions <dependency> <groupId>io.dropwizard/groupId> <artifactId>dropwizard-dependencies</artifactId> <version>2.1.10</version> <type>pom</type> <scope>import</scope> </dependency> --> </dependencies> </dependencyManagement> <!-- declare guice and ext modules without versions --> <dependencies> <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> </dependency> <!-- For example, using dropwizard module (without version) --> <dependency> <groupId> io.dropwizard </groupId> <artifactId> dropwizard-auth </artifactId> </dependency> <!-- Example of extension module usage --> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> </dependency> </dependencies> Gradle: // declare guice and ext modules without versions dependencies { implementation platform ( 'ru.vyarus.guicey:guicey-bom:5.10.0' ) // uncomment to override dropwizard and its dependencies versions //implementation platform('io.dropwizard:dropwizard-dependencies:2.1.10') implementation 'ru.vyarus:dropwizard-guicey' // For example, using dropwizard module (without version) implementation 'io.dropwizard:dropwizard-auth' // Example of extension module usage implementation 'ru.vyarus.guicey:guicey-eventbus' } Bom includes: BOM Artifact Guicey modules ru.vyarus.guicey:guicey-[module] Dropwizard BOM io.dropwizard:dropwizard-bom Guice BOM com.google.inject:guice-bom HK2 bridge org.glassfish.hk2:guice-bridge Spock-junit5 ru.vyarus:spock-junit5","title":"Setup"},{"location":"extras/bom/#dependencies-override","text":"You may override BOM version for any dependency by simply specifying exact version in dependency declaration section. If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly: io.dropwizard:dropwizard-dependencies:$VERSION for dropwizard com.google.inject:guice-bom:$VERSION for guice","title":"Dependencies override"},{"location":"extras/eventbus/","text":"Guava EventBus integration \u00b6 Integrates Guava EventBus with guice. Features: EventBus available for injection (to publish events) Automatic registration of listener methods (annotated with @Subscribe ) Console reporting of registered listeners Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-eventbus:5.10.0' Omit version if guicey BOM used Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ()) ... Create event: public class MyEvent { // some state } Inject EventBus to publish new events. public class SomeService { @Inject private EventBus eventbus ; public void inSomeMethod () { evetbus . post ( new MyEvent ()); } } Listen for event: public class SomeOtherService { @Subscribe public void onEvent ( MyEvent event ) { // handle event } } After server start you should see all registered event listeners in the log: INFO [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = MyEvent com.foo.something.SomeOtherService Note Only subscriptions of beans registered at the time of injector startup will be shown. For example, if MyBean has a subscription method but a binding for it is not declared (and no-one depends on it), a JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs. Consuming multiple events \u00b6 Note that you can build event hierarchies and subscribe to some base event to receive any derived event. To receive all events use: @Subscribe public void onEvent ( Object event ){ } Event bus \u00b6 By default, events will be handled synchronously ( bus.push() waits while all subscribers process). If you want events to be async use custom eventbus: new EventBusBundle ( new AsyncEventBus ( someExecutor ) ) By default, event listeners are not considered thread safe and no parallel events processing (for single method) will be performed. To mark subscriber as thread safe use @AllowConcurrentEvents : @Subscribe @AllowConcurrentEvents public void onEvent ( MyEvent event ) If a listener method fails to process an event (throws an exception), then other listeners will still be processed and the exception will be logged. If you want to change this behaviour, set a custom exception handler by creating a custom eventbus instance: new EventBusBundle ( new EventBus ( customExceptionHandler ) ) Listeners recognition \u00b6 The guice type listener is used to intercept all bean instances and thus looks at every method in the class hierarchy; however, only beans that actually have @Subscribe rs will be registered with the event bus. This process is fast and usually causes no issues. If needed, you can reduce the scope with a custom class matcher: new EventBusBundle () . withMatcher ( Matchers . inSubpackage ( \"some.package\" )) If you want maximum performance, then you can add a marker annotation (e.g. @HasEvents ) and reduce scope to just annotated classes: new EventBusBundle () . withMatcher ( Matchers . annotatedWith ( HasEvents . class )) Console reporting \u00b6 You can switch off console reporting (for example, if you have too many listeners): new EventBusBundle (). noReport () Note Reporting has to use reflection to get subscribers list. If this fails with a newer guava version (not yet supported), then simply disable reporting and everything will work as expected. Subscribers info bean \u00b6 EventSubscribersInfo is a registered (available for injection) bean that provides active listeners and used event types. As described above, it uses reflection internally to access the eventbus listeners map. It may be useful for testing.","title":"Guava EventBus"},{"location":"extras/eventbus/#guava-eventbus-integration","text":"Integrates Guava EventBus with guice. Features: EventBus available for injection (to publish events) Automatic registration of listener methods (annotated with @Subscribe ) Console reporting of registered listeners","title":"Guava EventBus integration"},{"location":"extras/eventbus/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-eventbus:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/eventbus/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ()) ... Create event: public class MyEvent { // some state } Inject EventBus to publish new events. public class SomeService { @Inject private EventBus eventbus ; public void inSomeMethod () { evetbus . post ( new MyEvent ()); } } Listen for event: public class SomeOtherService { @Subscribe public void onEvent ( MyEvent event ) { // handle event } } After server start you should see all registered event listeners in the log: INFO [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = MyEvent com.foo.something.SomeOtherService Note Only subscriptions of beans registered at the time of injector startup will be shown. For example, if MyBean has a subscription method but a binding for it is not declared (and no-one depends on it), a JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs.","title":"Usage"},{"location":"extras/eventbus/#consuming-multiple-events","text":"Note that you can build event hierarchies and subscribe to some base event to receive any derived event. To receive all events use: @Subscribe public void onEvent ( Object event ){ }","title":"Consuming multiple events"},{"location":"extras/eventbus/#event-bus","text":"By default, events will be handled synchronously ( bus.push() waits while all subscribers process). If you want events to be async use custom eventbus: new EventBusBundle ( new AsyncEventBus ( someExecutor ) ) By default, event listeners are not considered thread safe and no parallel events processing (for single method) will be performed. To mark subscriber as thread safe use @AllowConcurrentEvents : @Subscribe @AllowConcurrentEvents public void onEvent ( MyEvent event ) If a listener method fails to process an event (throws an exception), then other listeners will still be processed and the exception will be logged. If you want to change this behaviour, set a custom exception handler by creating a custom eventbus instance: new EventBusBundle ( new EventBus ( customExceptionHandler ) )","title":"Event bus"},{"location":"extras/eventbus/#listeners-recognition","text":"The guice type listener is used to intercept all bean instances and thus looks at every method in the class hierarchy; however, only beans that actually have @Subscribe rs will be registered with the event bus. This process is fast and usually causes no issues. If needed, you can reduce the scope with a custom class matcher: new EventBusBundle () . withMatcher ( Matchers . inSubpackage ( \"some.package\" )) If you want maximum performance, then you can add a marker annotation (e.g. @HasEvents ) and reduce scope to just annotated classes: new EventBusBundle () . withMatcher ( Matchers . annotatedWith ( HasEvents . class ))","title":"Listeners recognition"},{"location":"extras/eventbus/#console-reporting","text":"You can switch off console reporting (for example, if you have too many listeners): new EventBusBundle (). noReport () Note Reporting has to use reflection to get subscribers list. If this fails with a newer guava version (not yet supported), then simply disable reporting and everything will work as expected.","title":"Console reporting"},{"location":"extras/eventbus/#subscribers-info-bean","text":"EventSubscribersInfo is a registered (available for injection) bean that provides active listeners and used event types. As described above, it uses reflection internally to access the eventbus listeners map. It may be useful for testing.","title":"Subscribers info bean"},{"location":"extras/gsp/","text":"Guicey Server Pages \u00b6 Brings the simplicity of JSP to dropwizard-views. Basement for pluggable and extendable ui applications (like dashboards). EXPERIMENTAL MODULE Features: Use standard dropwizard modules: dropwizard-views and dropwizard-assets Support direct templates rendering (without rest resource declaration) Static resources, direct templates and dropwizard-views rest endpoints are handled under the same url (like everything is stored in the same directory - easy to link css, js and other resources) Multiple ui applications declaration with individual errors handling (error pages declaration like in servlet api, but not global) Ability to extend applications (much like good old resources copying above exploded war in tomcat) Problem \u00b6 Suppose you want to serve your ui to from the root url, then you need to re-map rest: server : rootPath : '/rest/*' applicationContextPath : / Static resources are in classpath: com/something/ index.html style.css Using dropwizard assets bundle to configure application: bootstrap . addBundle ( new AssetsBundle ( \"/com/something/\" , \"/\" , \"index.html\" )); Note that index.html could reference css with relative path: < link href = \"style.css\" rel = \"stylesheet\" > Now if we want to use template instead of pure html we configure dropwizard views: bootstrap . addBundle ( new ViewBundle < MyConfiguration > ()); Renaming index.html to index.ftl and add view resource: @Path ( \"/ui/\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { public static class IndexView extends View { public IndexView () { super ( \"/com/something/index.ftl\" ); } } @GET public IndexView get () { return new IndexView (); } } As a result, index page url become /rest/ui/ so we need to link css resource with full path ( /style.css ) instead of relative (or even re-configure server to back rest mapping to into root). It is already obvious that asset servlet and templates are not play well together. Solution \u00b6 The solution is obvious: make assets servlet as major resources supplier and with an additional filter to detect template requests and redirect rendering to actual rest. So example above should become: com/something/ index.ftl style.css Where index.ftl could use < link href = \"style.css\" rel = \"stylesheet\" > because it is queried by url /index.ftl : no difference with usual index.html - template rendering is hidden (and direct template file even don't need custom resource). When we need custom resource (most likely, for parameters mapping) we can still use it: @Path ( \"/views/ui/\" ) @Template ( \"foo.ftl\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { @GET @Path ( \"/foo/{id}\" ) public IndexView get ( @PathParam ( \"id\" ) String id ) { return new TemplateView (); } } It would be accessible from assets root /foo/12 (more on naming and mapping details below). Under the hood /foo/12 will be recognized as template call and redirected (server redirect) to /rest/ui/foo/12 . As you can see rest endpoints and templates are now \"a part\" of static resources.. just like good-old JSP (powered with rest mappings). And it is still pure dropwizard views. GSP implements per-application error pages support so each application could use its own errors. In pure dropwizard-views such things should be implemented manually, which is not good for application encapsulation. Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-server-pages </artifactId> <version> 5.10.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-server-pages:5.10.0' Omit version if guicey BOM used Usage \u00b6 First of all, global GSP bundle must be installed in main application class. It configures and installs dropwizard-views (global). It supports the same configurations as pure dropwizard-views bundle. GuiceBundle . builder () . bundles ( ServerPagesBundle . builder (). build ()); Remove direct dropwizard-views bundle registrations ( ViewBundle ) if it was already used in application. Template engines \u00b6 Out of the box dropwizard provides freemarker and mustache engines support. You will need to add dependency to one of them (or both) in order to activate it (or, maybe, some third party engine): implementation ( io.dropwizard:dropwizard-views-freemarker ) implementation ( io.dropwizard:dropwizard-views-mustache ) Other template engines available as 3 rd party modules. If your template engine is not yet supported then simply implement io.dropwizard.views.ViewRenderer in order to support it. ViewRenderer implementations are loaded automatically using ServiceLoader mechanism. If your renderer is not declared as service then simply add it directly: . bundles ( ServerPagesBundle . builder () . addViewRenderers ( new MyTempateSupport ()) . build ()); Duplicate renderers are automatically removed. List of detected template engines will be printed to console. You can get list of used renderers from bundle instance ServerPagesBundle#getRenderers() Note This is pure dropwizard-views staff (everything is totally standard). Configuration \u00b6 Views yaml configuration binding is the same as in dropwizard-views. views : freemarker : strict_syntax : true mustache : cache : false Where freemarker and mustache are keys from installed template renderer io.dropwizard.views.ViewRenderer#getConfigurationKey() . public class AppConfig extends Configuration { @JsonProperty private Map < String , Map < String , String >> views ; public Map < String , Map < String , String >> getViews () { return views ;} } . bundles ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . build ()); If AppConfig#getViews return null then empty map will be used instead as config. Additionally, to direct yaml configuration binding, you can apply exact template engine modifications . bundles ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . viewsConfigurationModifier ( \"freemarker\" , map -> map . put ( \"cache_storage\" , \"freemarker.cache.NullCacheStorage\" )) . build ()); Modifier always receive not null map (empty map is created automatically in global configuration). Multiple modifiers could be applied (even for the same section). Each GSP application could also apply modifiers (this is useful to tune defaults: e.g. in case of freemarker, application may need to apply default imports). The final configuration (after all modifiers) could be printed to console with .printViewsConfiguration() . Also, configuration is accessible from the bundle instance: ServerPagesBundle#getViewsConfig() . Applications \u00b6 Each GSP application is registered as separate bundle in main or admin context: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . indexPage ( \"index.ftl\" ) . build ()) . bundles ( ServerPagesBundle . adminApp ( \"projectName-admin\" , \"com.app.admin\" , \"/admin\" ) . build ()) Unlimited number of applications may be registered on each context. app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) projectName-ui - unique(!) application name. Uniqueness is very important as name used for rest paths. To avoid collisions it's recommended to use domain-prefixed names to better identify application related resources. com.app.ui - classpath package with resources (application \"root\" folder; the same meaning as in dropwizard-assets); Also, it may be configured as /com/app/ui/ , but package notion is easier to understand / - application mapping url (in main or admin context; the same as in dropwizard-assets) (if context is prefixed ( server.applicationContextPath: /some or server.adminContextPath: /admin ) then GSP application will be available under this prefix) Warning It is a common desire to map ui on main context's root path ( / ), but, by default, dropwizard maps rest there and so you may see an error: java.lang.IllegalStateException: Multiple servlets map to path /*: app[mapped:JAVAX_API:null],io.dropwizard.jersey.setup.JerseyServletContainer-1280682[mapped:EMBEDDED:null] In this case simply re-map rest in yaml config: server : rootPath : '/rest/*' If application requires resources from multiple paths, use: ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.path1\" , \"/\" ) . attachAssets ( \"com.app.path1\" ) ... For example, this can be useful to attach some shared resources. To attach webjars there is a pre-defined shortcut . You can even attach resources path for exact sub url: ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.path1\" , \"/\" ) . attachAssets ( \"/sub/path/\" , \"com.app.path.sub\" ) ... And for urls starting from /sub/path/ application will look static resources (and templates) inside /com/app/path/sub/ first, and only after that under root paths. This way, you can map resources from different packages as you want. This is like if you copied everything from different packages into one place (like exploded war). Template engine constraint \u00b6 As GSP application declaration is separated from views configuration (GSP application may be even a 3 rd party bundle) then it must be able to check required template engines presence. For example, this application requires freemarker: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . requireRenderers ( \"freemarker\" ) . build ()) Template engine name is declared in io.dropwizard.views.ViewRenderer#getConfigurationKey() (same name used in configuration). Templates support \u00b6 As dropwizard-views is used under the hood, all templates are always rendered with rest endpoints. All these rest endpoints are part of global rest. It is recommended to start all view rest with /view/ to make it clearly distinguishable from application rest. Also, rest views, related to one GSP application must also start with a common prefix: for example, /view/projectName/ui/.. . You need to map required rest prefix in GSP application: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . mapViews ( \"/view/projectName/ui/\" ) This will \"map\" all view rest paths after prefix directly to GSP application root. So if you have view resource /view/projectName/ui/page1/action you can access it relatively to application mapping root (\"/\" in the example above) as /page1/action . By default, if views mapping is not declared manually, it would be set to application name ( /... -> /projectName-ui/... ) Under startup dropwizard logs all registered rest endpoints, so you can always see original rest mapping paths. For each registered GSP application list of \"visible\" paths will be logged as: INFO [2019-06-07 04:10:47,978] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /rest/views/projectName/ui/sample (com.project.ui.SampleViewResource) POST /rest/views/projectName/ui/other (com.project.ui.SampleViewResource) INFO [2019-06-07 04:10:47,982] ru.vyarus.guicey.gsp.app.ServerPagesApp: Server pages app 'com.project.ui' registered on uri '/*' in main context Static resources locations: com.app.ui Mapped handlers: GET /sample (com.project.ui.SampleViewResource #sample) POST /other (com.project.ui.SampleViewResource #other) Here you can see real rest mapping GET /rest/views/projectName/ui/sample and how it could be used relative to application path GET /sample . This report will always contain all correct view paths which must simplify overall understanding: if path not appear in the report - it's incorrectly mapped and when it's appear - always use the path from application report to access it. But that's not all: you can actually map other rest prefixed to sub urls: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . mapViews ( \"/sub/path/\" , \"/view/projectName2/ui/something/\" ) This way, it is possible to combine rest endpoints, written for different applications (or simply prepare common view resource groups). Just note that in contrast to resources mapping, only one prefix may be mapped on each url! You will also need to map static resources location accordingly if you use relative template paths. Direct templates \u00b6 You can also render template files without declaring view rest at all (good old jsp way). If we call supported template type directly like http://localhost:8080/template.ftl it will be recognized as direct template call and rendered. Template file must be placed under registered classpath path root: /com/app/ui/template.ftl . Templates in sub folders will be rendered the same way, e.g. http://localhost:8080/sub/path/template.ftl will render /com/app/ui/sub/path/template.ftl . Template rest declaration \u00b6 Declaration differences with pure dropwizard-views: @Path value must start with mapped prefix (see the chapter above) Resource class must be annotated with @Template (even without exact template declaration) TemplateView must be used instead of dropwizard View as a base class for view models. Suppose we declaring page for gsp application .app(\"projectName-ui\", \"com.app.ui\", \"/\") As in pure views, in most cases we will need custom model object: public class SampleView extends TemplateView { private String name ; public SampleView ( String name ) { this . name = name ; } public String getName () { return this . name ; } } Note Custom model is optional - you can use TemplateView directly, as default \"empty\" model. @Path ( \"/views/projectName/ui/sample/\" ) @Template ( \"sample.ftl\" ) public class SamplePage { @Path ( \"{name}\" ) public SampleView doSomething ( @PathParam ( \"name\" ) String name ) { return new SampleView ( name ); } } And example template: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Name: ${name} </body> </html> After application startup, new url must appear in GSP application console report. If we call new page with http://localhost:8080/sample/fred we should see Name: fred as a result. Note Can pure dropwizard-views resources be used like that? Actually, yes, but they must be annotated with @Template because not annotated resources are not considered as potential GSP application views (and will not be shown in console report). @Template \u00b6 @Template annotation must be used on ALL template resources. It may declare default template for all methods in resource ( @Template(\"sample.ftl\") ) or be just a marker annotation ( @Template ). Annotation differentiate template resources from other api resources and lets you declare jersey extension only for template resources: @Provider @Template public class MyExtensions implements ContainerRequestFilter { ... } This request filter will be applied only to template resources. Such targeting is used internally in order to not affect global api with GSP specific handling logic. Template path resolution: If path starts with / then it would be resolved from classpath root Resolution relative to resource class Resolution relative to static resources location ( /com/app/ui/ in the example above) Examples: @Template(\"/com/project/custom/path/sample.ftl\") - absolute declaration. @Template(\"sub/sample.ftl\") - relative declaration @Template(\"../sub/sample.ftl\") - relative declaration Even if template is configured in the annotation, exact resource method could specify it's own template directly in TemplateView constructor: @Path ( \"/views/projectName/ui/sample/\" ) @Template ( \"sample.ftl\" ) // default template public class SamplePage { @Path ( \"/\" ) public TemplateView doSomething () { // override template return new TemplateView ( \"otherTemplate.ftl\" ); } } Template path resolution rules are the same as with annotation. TemplateContext \u00b6 TemplateContext contains all template contextual information. It could be accessed inside template with model's getContext() , e.g.: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Current url: ${context.url} </body> </html> In rest view resources it could be accessed with a static lookup: TemplateContext.getInstance() . This way you can always know current gsp application name, original url (before redirection to rest), root application mapping prefix and get original request object (which may be required for error pages). Index page \u00b6 Index page is a page shown for root application url ( / ). It could be declared as: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . indexPage ( ' index . html ' ) . build ()) It could be: * Direct resource: index.html * Direct template: index.ftl * Rest powered template: /mapping/ Note By default, index page is set to \"\" because most likely your index page will be handled with rest and \"\" will redirect to root path (for current application): /com.project.ui/ Error pages \u00b6 Each GSP application could declare its own error pages (very similar to servlet api). It could be one global error page and different pages per status: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . errorPage ( ' error . html ' ) . errorPage ( 500 , ' 500. html ' ) . errorPage ( 401 , ' 401. html ' ) . build ()) As with index pages, error page may be direct static html, direct template or rest path. Important Error pages are shown ONLY if requested type was text/html and pass error as is in other cases. Simply because it is not correct to return html when client was expecting different type. Errors handling logic detects: Static resources errors (404) Exceptions during view resource processing (including rendering errors) Direct error codes return without exception ( Resounce.status(404).build() ) Error pages may use special view class (or extend it) ErrorTemplateView which collects additional error-related info. For example, even direct error template could show: <#-- @ftlvariable name=\"\" type=\"ru.vyarus.guicey.gsp.views.template.ErrorTemplateView\" --> <h3>Url ${erroredUrl} failed to render with ${errorCode} status code</h3> <div>Error: ${error.class.simpleName}</div> <pre> ${errorTrace} </pre> For rest-powered error page: @Path ( \"/views/projectName/ui/error/\" ) @Template ( \"error.ftl\" ) public class ErrorPage { @Path ( \"/\" ) public TemplateView render () { // it may be any extending class if additional properties are required (the same as usual) ErrorTemplateView view = new ErrorTemplateView (); WebApplicationException ex = view . getError (); // analyze error return view ; } } (this error page can be mapped as .errorPage(\"/error/\") ). view.getError() always return WebApplicationException so use ex.geCause() to get original exception. But there will not always be useful exception because direct exception is only one of error cases (see above). In order to differentiate useful exceptions, you can check: if ( ex instanceof TracelessException ) { // only status code availbale int status = (( TracelessException ) ex ). getStatus (); } else { // actually throwed exception to analyze Throwable actualCause = ex . getCause () } TracelessException may be either AssertError for static resource fail or TemplateRestCodeError for direct non 200 response code in rest. Important GSP errors handling override ExceptionMapper and views errors mechanisms because it intercept exceptions before them (using RequestEventListener )! So your ExceptionMapper will be called, but user will still see GSP error page. The motivation is simple: otherwise it would be very hard to write side effect free GSP applications because template resources exceptions could be intercepted with ExceptionMapper 's declared in dropwizard application. To overcome this limitation, you can disable errors handling with @ManuaErrorHandling . It may be applied on resource method or to resource class (to disable on all methods). For example: @Path ( \"/com.project.ui/error/\" ) @Template ( \"page.ftl\" ) public class ErrorPage { @ManualErrorHandling @Path ( \"/\" ) public TemplateView render () { // if exception appear inside this method, it would be handled with ExceptionMapper // GSP error page will not be used // Also, if method return non 200 error code (>=400) like // return Response.status(500).build() // it would be also not handled with GSP error mechanism (only pure dropwizard staff) } } Note that disabled errors will be indicated as [DISABLED ERRORS] in console report. SPA routing \u00b6 If you use Single Page Applications then you may face the need to recognize html5 client routing urls and redirect to index page. You can read more about it in guicey SPA module . As guicey SPA module can't be used directly with GSP, it's abilities is integrated directly and could be activated with: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . spaRouting () . build ()) Or, if custom detection regex is required: .spaRouting(customRegex) Most likely, usage use-case would be: index page requires some server-size templating. Template requests detection \u00b6 GSP must differentiate static resource calls from template calls. It assumes that static resources would always end with an extension (e.g. /something/some.ext ) and so: If request without extension - it's a template If extension is recognized as template extension - render as template Other cases are static resources The following regular expression used for extension detection: (?:^|/)([^/]+\\.(?:[a-zA-Z\\d]+))(?:\\?.+)?$ If it does not cover you specific cases, it could be changed using: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . filePattern ( \"(?:^|/)([^/]+\\\\.(?:[a-zA-Z\\\\d]+))(?:\\\\?.+)?$\" ) . build ()) In case when you have static files without extension, you can include them directly into detection regexp (using regex or (|) syntax). Pattern must return detected file name as first matched group (so direct template could be detected). Pattern is searched (find) inside path, not matched (so simple patterns will also work). Extending applications \u00b6 In \"war world\" there is a a very handy thing as overlays: when we can apply our resources \"above\" existing war. This way we can replace existing files (hack & tune) and add our own files so they would live inside app as they were always be there. In order to achieve similar goals there is a application extension mechanism. For example we application: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . build ()) With multiple pages inside: /com/app/ui/ page1.ftl page2.ftl style.css Each page could include style relatively as style.css . Most likely, there will even be master template (freemarker) which unifies styles and common script installation. This application is distributed as 3 rd party bundle (jar). If we need to add one more page to this application in our current dropwizard application, we can: . bundles ( ServerPagesBundle . extendApp ( \"projectName-ui\" ) . attachAssets ( \"com.otherApp.ui.ext\" ) . build ()) And put another page into classpath: /com/otherApp/ui/ext/ page3.ftl This page could also reference style.css relatively, the same as pages in the main application. On application startup, you will notice new resources location: Static resources locations: /com/app/ui/ /com/otherApp/ui/ext/ Now both locations are \"roots\" for the application. The same way as if we copied /com/otherApp/ui/ext/ into /com/app/ui/ . http://localhost:8080/page3.ftl would correctly render new page. There may be unlimited number of application extensions. If extended application is not available, it is not considered as an error: it's assumed as optional application extension, which will be activated if some 3 rd party jar with GSP application appear in classpath. You can also map addition rest prefixes: . bundles ( ServerPagesBundle . extendApp ( \"projectName-ui\" ) . mapViews ( \"/sub/folder/\" , \"/views/something/ext/\" ) . build ()) In some cases, extensions may depend on dropwizard configuration, but bundles created under initialization phase. To work around this you can use delayed extension init: . bundles ( ServerPagesBundle . extendApp ( \"projectName-ui\" ) . delayedConfiguration (( env , assets , views ) -> { if ( env . configuration (). isExtensionsEnabled ()) { assets . attach ( \"com.foo.bar\" ) } }) . build ()) Webjars usage \u00b6 If you want to use resources from webjars in GSP application: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . attachWebjars () . build ()) For example, to add jquery: implementation 'org.webjars.npm:jquery:3.4.1' And it could be referenced as: < script src = \"jquery/3.4.1/dist/jquery.min.js\" /> Under the hood .attachWebjars() use extensions mechanism and adds META-INF/resources/webjars/ as application resources path: ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) ... . attachAssets ( \"META-INF/resources/webjars/\" ) OR . bundles ( ServerPagesBundle . extendApp ( \"app name\" ) . attachAssets ( \"META-INF/resources/webjars/\" ) . build ()) Tip You can always see the content of webjar on webjars site by clicking on package \"Files\" column. Use everything after \"META-INF/resources/webjars/\" to reference file. Custom classloaders \u00b6 Very specific case There is a limited support for custom classloaders. Assumed case is when application resources could be loaded with different class loaders. Custom classloader could be specified during application registration, for example: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" , classLoader ) . build ()) The same for admin app and extension. Warning This will affect only static resources! Template engine will not be able to resolve resources because it is not aware of custom loaders. Info The main problem here is dropwizard's View class which accepts only file path (String), so even if correct URL object is known (which is enough to load resource) before view construction it can't be used further. To workaround this, resolved absolute template path passed to view constructor. GSP module is able to found correct resourse later in correct class loader, but it requires obvious changes to template engine templates resolution mechanism. To resolve this, special templates resolver is required. For freemarker it is provided out of the box, but must be enabled on main bundle: ServerPagesBundle . builder () . enableFreemarkerCustomClassLoadersSupport () ... For mustache module it is impossible to write such integration.","title":"Server Pages"},{"location":"extras/gsp/#guicey-server-pages","text":"Brings the simplicity of JSP to dropwizard-views. Basement for pluggable and extendable ui applications (like dashboards). EXPERIMENTAL MODULE Features: Use standard dropwizard modules: dropwizard-views and dropwizard-assets Support direct templates rendering (without rest resource declaration) Static resources, direct templates and dropwizard-views rest endpoints are handled under the same url (like everything is stored in the same directory - easy to link css, js and other resources) Multiple ui applications declaration with individual errors handling (error pages declaration like in servlet api, but not global) Ability to extend applications (much like good old resources copying above exploded war in tomcat)","title":"Guicey Server Pages"},{"location":"extras/gsp/#problem","text":"Suppose you want to serve your ui to from the root url, then you need to re-map rest: server : rootPath : '/rest/*' applicationContextPath : / Static resources are in classpath: com/something/ index.html style.css Using dropwizard assets bundle to configure application: bootstrap . addBundle ( new AssetsBundle ( \"/com/something/\" , \"/\" , \"index.html\" )); Note that index.html could reference css with relative path: < link href = \"style.css\" rel = \"stylesheet\" > Now if we want to use template instead of pure html we configure dropwizard views: bootstrap . addBundle ( new ViewBundle < MyConfiguration > ()); Renaming index.html to index.ftl and add view resource: @Path ( \"/ui/\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { public static class IndexView extends View { public IndexView () { super ( \"/com/something/index.ftl\" ); } } @GET public IndexView get () { return new IndexView (); } } As a result, index page url become /rest/ui/ so we need to link css resource with full path ( /style.css ) instead of relative (or even re-configure server to back rest mapping to into root). It is already obvious that asset servlet and templates are not play well together.","title":"Problem"},{"location":"extras/gsp/#solution","text":"The solution is obvious: make assets servlet as major resources supplier and with an additional filter to detect template requests and redirect rendering to actual rest. So example above should become: com/something/ index.ftl style.css Where index.ftl could use < link href = \"style.css\" rel = \"stylesheet\" > because it is queried by url /index.ftl : no difference with usual index.html - template rendering is hidden (and direct template file even don't need custom resource). When we need custom resource (most likely, for parameters mapping) we can still use it: @Path ( \"/views/ui/\" ) @Template ( \"foo.ftl\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { @GET @Path ( \"/foo/{id}\" ) public IndexView get ( @PathParam ( \"id\" ) String id ) { return new TemplateView (); } } It would be accessible from assets root /foo/12 (more on naming and mapping details below). Under the hood /foo/12 will be recognized as template call and redirected (server redirect) to /rest/ui/foo/12 . As you can see rest endpoints and templates are now \"a part\" of static resources.. just like good-old JSP (powered with rest mappings). And it is still pure dropwizard views. GSP implements per-application error pages support so each application could use its own errors. In pure dropwizard-views such things should be implemented manually, which is not good for application encapsulation.","title":"Solution"},{"location":"extras/gsp/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-server-pages </artifactId> <version> 5.10.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-server-pages:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/gsp/#usage","text":"First of all, global GSP bundle must be installed in main application class. It configures and installs dropwizard-views (global). It supports the same configurations as pure dropwizard-views bundle. GuiceBundle . builder () . bundles ( ServerPagesBundle . builder (). build ()); Remove direct dropwizard-views bundle registrations ( ViewBundle ) if it was already used in application.","title":"Usage"},{"location":"extras/gsp/#template-engines","text":"Out of the box dropwizard provides freemarker and mustache engines support. You will need to add dependency to one of them (or both) in order to activate it (or, maybe, some third party engine): implementation ( io.dropwizard:dropwizard-views-freemarker ) implementation ( io.dropwizard:dropwizard-views-mustache ) Other template engines available as 3 rd party modules. If your template engine is not yet supported then simply implement io.dropwizard.views.ViewRenderer in order to support it. ViewRenderer implementations are loaded automatically using ServiceLoader mechanism. If your renderer is not declared as service then simply add it directly: . bundles ( ServerPagesBundle . builder () . addViewRenderers ( new MyTempateSupport ()) . build ()); Duplicate renderers are automatically removed. List of detected template engines will be printed to console. You can get list of used renderers from bundle instance ServerPagesBundle#getRenderers() Note This is pure dropwizard-views staff (everything is totally standard).","title":"Template engines"},{"location":"extras/gsp/#configuration","text":"Views yaml configuration binding is the same as in dropwizard-views. views : freemarker : strict_syntax : true mustache : cache : false Where freemarker and mustache are keys from installed template renderer io.dropwizard.views.ViewRenderer#getConfigurationKey() . public class AppConfig extends Configuration { @JsonProperty private Map < String , Map < String , String >> views ; public Map < String , Map < String , String >> getViews () { return views ;} } . bundles ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . build ()); If AppConfig#getViews return null then empty map will be used instead as config. Additionally, to direct yaml configuration binding, you can apply exact template engine modifications . bundles ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . viewsConfigurationModifier ( \"freemarker\" , map -> map . put ( \"cache_storage\" , \"freemarker.cache.NullCacheStorage\" )) . build ()); Modifier always receive not null map (empty map is created automatically in global configuration). Multiple modifiers could be applied (even for the same section). Each GSP application could also apply modifiers (this is useful to tune defaults: e.g. in case of freemarker, application may need to apply default imports). The final configuration (after all modifiers) could be printed to console with .printViewsConfiguration() . Also, configuration is accessible from the bundle instance: ServerPagesBundle#getViewsConfig() .","title":"Configuration"},{"location":"extras/gsp/#applications","text":"Each GSP application is registered as separate bundle in main or admin context: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . indexPage ( \"index.ftl\" ) . build ()) . bundles ( ServerPagesBundle . adminApp ( \"projectName-admin\" , \"com.app.admin\" , \"/admin\" ) . build ()) Unlimited number of applications may be registered on each context. app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) projectName-ui - unique(!) application name. Uniqueness is very important as name used for rest paths. To avoid collisions it's recommended to use domain-prefixed names to better identify application related resources. com.app.ui - classpath package with resources (application \"root\" folder; the same meaning as in dropwizard-assets); Also, it may be configured as /com/app/ui/ , but package notion is easier to understand / - application mapping url (in main or admin context; the same as in dropwizard-assets) (if context is prefixed ( server.applicationContextPath: /some or server.adminContextPath: /admin ) then GSP application will be available under this prefix) Warning It is a common desire to map ui on main context's root path ( / ), but, by default, dropwizard maps rest there and so you may see an error: java.lang.IllegalStateException: Multiple servlets map to path /*: app[mapped:JAVAX_API:null],io.dropwizard.jersey.setup.JerseyServletContainer-1280682[mapped:EMBEDDED:null] In this case simply re-map rest in yaml config: server : rootPath : '/rest/*' If application requires resources from multiple paths, use: ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.path1\" , \"/\" ) . attachAssets ( \"com.app.path1\" ) ... For example, this can be useful to attach some shared resources. To attach webjars there is a pre-defined shortcut . You can even attach resources path for exact sub url: ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.path1\" , \"/\" ) . attachAssets ( \"/sub/path/\" , \"com.app.path.sub\" ) ... And for urls starting from /sub/path/ application will look static resources (and templates) inside /com/app/path/sub/ first, and only after that under root paths. This way, you can map resources from different packages as you want. This is like if you copied everything from different packages into one place (like exploded war).","title":"Applications"},{"location":"extras/gsp/#template-engine-constraint","text":"As GSP application declaration is separated from views configuration (GSP application may be even a 3 rd party bundle) then it must be able to check required template engines presence. For example, this application requires freemarker: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . requireRenderers ( \"freemarker\" ) . build ()) Template engine name is declared in io.dropwizard.views.ViewRenderer#getConfigurationKey() (same name used in configuration).","title":"Template engine constraint"},{"location":"extras/gsp/#templates-support","text":"As dropwizard-views is used under the hood, all templates are always rendered with rest endpoints. All these rest endpoints are part of global rest. It is recommended to start all view rest with /view/ to make it clearly distinguishable from application rest. Also, rest views, related to one GSP application must also start with a common prefix: for example, /view/projectName/ui/.. . You need to map required rest prefix in GSP application: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . mapViews ( \"/view/projectName/ui/\" ) This will \"map\" all view rest paths after prefix directly to GSP application root. So if you have view resource /view/projectName/ui/page1/action you can access it relatively to application mapping root (\"/\" in the example above) as /page1/action . By default, if views mapping is not declared manually, it would be set to application name ( /... -> /projectName-ui/... ) Under startup dropwizard logs all registered rest endpoints, so you can always see original rest mapping paths. For each registered GSP application list of \"visible\" paths will be logged as: INFO [2019-06-07 04:10:47,978] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /rest/views/projectName/ui/sample (com.project.ui.SampleViewResource) POST /rest/views/projectName/ui/other (com.project.ui.SampleViewResource) INFO [2019-06-07 04:10:47,982] ru.vyarus.guicey.gsp.app.ServerPagesApp: Server pages app 'com.project.ui' registered on uri '/*' in main context Static resources locations: com.app.ui Mapped handlers: GET /sample (com.project.ui.SampleViewResource #sample) POST /other (com.project.ui.SampleViewResource #other) Here you can see real rest mapping GET /rest/views/projectName/ui/sample and how it could be used relative to application path GET /sample . This report will always contain all correct view paths which must simplify overall understanding: if path not appear in the report - it's incorrectly mapped and when it's appear - always use the path from application report to access it. But that's not all: you can actually map other rest prefixed to sub urls: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . mapViews ( \"/sub/path/\" , \"/view/projectName2/ui/something/\" ) This way, it is possible to combine rest endpoints, written for different applications (or simply prepare common view resource groups). Just note that in contrast to resources mapping, only one prefix may be mapped on each url! You will also need to map static resources location accordingly if you use relative template paths.","title":"Templates support"},{"location":"extras/gsp/#direct-templates","text":"You can also render template files without declaring view rest at all (good old jsp way). If we call supported template type directly like http://localhost:8080/template.ftl it will be recognized as direct template call and rendered. Template file must be placed under registered classpath path root: /com/app/ui/template.ftl . Templates in sub folders will be rendered the same way, e.g. http://localhost:8080/sub/path/template.ftl will render /com/app/ui/sub/path/template.ftl .","title":"Direct templates"},{"location":"extras/gsp/#template-rest-declaration","text":"Declaration differences with pure dropwizard-views: @Path value must start with mapped prefix (see the chapter above) Resource class must be annotated with @Template (even without exact template declaration) TemplateView must be used instead of dropwizard View as a base class for view models. Suppose we declaring page for gsp application .app(\"projectName-ui\", \"com.app.ui\", \"/\") As in pure views, in most cases we will need custom model object: public class SampleView extends TemplateView { private String name ; public SampleView ( String name ) { this . name = name ; } public String getName () { return this . name ; } } Note Custom model is optional - you can use TemplateView directly, as default \"empty\" model. @Path ( \"/views/projectName/ui/sample/\" ) @Template ( \"sample.ftl\" ) public class SamplePage { @Path ( \"{name}\" ) public SampleView doSomething ( @PathParam ( \"name\" ) String name ) { return new SampleView ( name ); } } And example template: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Name: ${name} </body> </html> After application startup, new url must appear in GSP application console report. If we call new page with http://localhost:8080/sample/fred we should see Name: fred as a result. Note Can pure dropwizard-views resources be used like that? Actually, yes, but they must be annotated with @Template because not annotated resources are not considered as potential GSP application views (and will not be shown in console report).","title":"Template rest declaration"},{"location":"extras/gsp/#template","text":"@Template annotation must be used on ALL template resources. It may declare default template for all methods in resource ( @Template(\"sample.ftl\") ) or be just a marker annotation ( @Template ). Annotation differentiate template resources from other api resources and lets you declare jersey extension only for template resources: @Provider @Template public class MyExtensions implements ContainerRequestFilter { ... } This request filter will be applied only to template resources. Such targeting is used internally in order to not affect global api with GSP specific handling logic. Template path resolution: If path starts with / then it would be resolved from classpath root Resolution relative to resource class Resolution relative to static resources location ( /com/app/ui/ in the example above) Examples: @Template(\"/com/project/custom/path/sample.ftl\") - absolute declaration. @Template(\"sub/sample.ftl\") - relative declaration @Template(\"../sub/sample.ftl\") - relative declaration Even if template is configured in the annotation, exact resource method could specify it's own template directly in TemplateView constructor: @Path ( \"/views/projectName/ui/sample/\" ) @Template ( \"sample.ftl\" ) // default template public class SamplePage { @Path ( \"/\" ) public TemplateView doSomething () { // override template return new TemplateView ( \"otherTemplate.ftl\" ); } } Template path resolution rules are the same as with annotation.","title":"@Template"},{"location":"extras/gsp/#templatecontext","text":"TemplateContext contains all template contextual information. It could be accessed inside template with model's getContext() , e.g.: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Current url: ${context.url} </body> </html> In rest view resources it could be accessed with a static lookup: TemplateContext.getInstance() . This way you can always know current gsp application name, original url (before redirection to rest), root application mapping prefix and get original request object (which may be required for error pages).","title":"TemplateContext"},{"location":"extras/gsp/#index-page","text":"Index page is a page shown for root application url ( / ). It could be declared as: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . indexPage ( ' index . html ' ) . build ()) It could be: * Direct resource: index.html * Direct template: index.ftl * Rest powered template: /mapping/ Note By default, index page is set to \"\" because most likely your index page will be handled with rest and \"\" will redirect to root path (for current application): /com.project.ui/","title":"Index page"},{"location":"extras/gsp/#error-pages","text":"Each GSP application could declare its own error pages (very similar to servlet api). It could be one global error page and different pages per status: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . errorPage ( ' error . html ' ) . errorPage ( 500 , ' 500. html ' ) . errorPage ( 401 , ' 401. html ' ) . build ()) As with index pages, error page may be direct static html, direct template or rest path. Important Error pages are shown ONLY if requested type was text/html and pass error as is in other cases. Simply because it is not correct to return html when client was expecting different type. Errors handling logic detects: Static resources errors (404) Exceptions during view resource processing (including rendering errors) Direct error codes return without exception ( Resounce.status(404).build() ) Error pages may use special view class (or extend it) ErrorTemplateView which collects additional error-related info. For example, even direct error template could show: <#-- @ftlvariable name=\"\" type=\"ru.vyarus.guicey.gsp.views.template.ErrorTemplateView\" --> <h3>Url ${erroredUrl} failed to render with ${errorCode} status code</h3> <div>Error: ${error.class.simpleName}</div> <pre> ${errorTrace} </pre> For rest-powered error page: @Path ( \"/views/projectName/ui/error/\" ) @Template ( \"error.ftl\" ) public class ErrorPage { @Path ( \"/\" ) public TemplateView render () { // it may be any extending class if additional properties are required (the same as usual) ErrorTemplateView view = new ErrorTemplateView (); WebApplicationException ex = view . getError (); // analyze error return view ; } } (this error page can be mapped as .errorPage(\"/error/\") ). view.getError() always return WebApplicationException so use ex.geCause() to get original exception. But there will not always be useful exception because direct exception is only one of error cases (see above). In order to differentiate useful exceptions, you can check: if ( ex instanceof TracelessException ) { // only status code availbale int status = (( TracelessException ) ex ). getStatus (); } else { // actually throwed exception to analyze Throwable actualCause = ex . getCause () } TracelessException may be either AssertError for static resource fail or TemplateRestCodeError for direct non 200 response code in rest. Important GSP errors handling override ExceptionMapper and views errors mechanisms because it intercept exceptions before them (using RequestEventListener )! So your ExceptionMapper will be called, but user will still see GSP error page. The motivation is simple: otherwise it would be very hard to write side effect free GSP applications because template resources exceptions could be intercepted with ExceptionMapper 's declared in dropwizard application. To overcome this limitation, you can disable errors handling with @ManuaErrorHandling . It may be applied on resource method or to resource class (to disable on all methods). For example: @Path ( \"/com.project.ui/error/\" ) @Template ( \"page.ftl\" ) public class ErrorPage { @ManualErrorHandling @Path ( \"/\" ) public TemplateView render () { // if exception appear inside this method, it would be handled with ExceptionMapper // GSP error page will not be used // Also, if method return non 200 error code (>=400) like // return Response.status(500).build() // it would be also not handled with GSP error mechanism (only pure dropwizard staff) } } Note that disabled errors will be indicated as [DISABLED ERRORS] in console report.","title":"Error pages"},{"location":"extras/gsp/#spa-routing","text":"If you use Single Page Applications then you may face the need to recognize html5 client routing urls and redirect to index page. You can read more about it in guicey SPA module . As guicey SPA module can't be used directly with GSP, it's abilities is integrated directly and could be activated with: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . spaRouting () . build ()) Or, if custom detection regex is required: .spaRouting(customRegex) Most likely, usage use-case would be: index page requires some server-size templating.","title":"SPA routing"},{"location":"extras/gsp/#template-requests-detection","text":"GSP must differentiate static resource calls from template calls. It assumes that static resources would always end with an extension (e.g. /something/some.ext ) and so: If request without extension - it's a template If extension is recognized as template extension - render as template Other cases are static resources The following regular expression used for extension detection: (?:^|/)([^/]+\\.(?:[a-zA-Z\\d]+))(?:\\?.+)?$ If it does not cover you specific cases, it could be changed using: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . filePattern ( \"(?:^|/)([^/]+\\\\.(?:[a-zA-Z\\\\d]+))(?:\\\\?.+)?$\" ) . build ()) In case when you have static files without extension, you can include them directly into detection regexp (using regex or (|) syntax). Pattern must return detected file name as first matched group (so direct template could be detected). Pattern is searched (find) inside path, not matched (so simple patterns will also work).","title":"Template requests detection"},{"location":"extras/gsp/#extending-applications","text":"In \"war world\" there is a a very handy thing as overlays: when we can apply our resources \"above\" existing war. This way we can replace existing files (hack & tune) and add our own files so they would live inside app as they were always be there. In order to achieve similar goals there is a application extension mechanism. For example we application: . bundles ( ServerPagesBundle . app ( \"projectName-ui\" , \"com.app.ui\" , \"/\" ) . build ()) With multiple pages inside: /com/app/ui/ page1.ftl page2.ftl style.css Each page could include style relatively as style.css . Most likely, there will even be master template (freemarker) which unifies styles and common script installation. This application is distributed as 3 rd party bundle (jar). If we need to add one more page to this application in our current dropwizard application, we can: . bundles ( ServerPagesBundle . extendApp ( \"projectName-ui\" ) . attachAssets ( \"com.otherApp.ui.ext\" ) . build ()) And put another page into classpath: /com/otherApp/ui/ext/ page3.ftl This page could also reference style.css relatively, the same as pages in the main application. On application startup, you will notice new resources location: Static resources locations: /com/app/ui/ /com/otherApp/ui/ext/ Now both locations are \"roots\" for the application. The same way as if we copied /com/otherApp/ui/ext/ into /com/app/ui/ . http://localhost:8080/page3.ftl would correctly render new page. There may be unlimited number of application extensions. If extended application is not available, it is not considered as an error: it's assumed as optional application extension, which will be activated if some 3 rd party jar with GSP application appear in classpath. You can also map addition rest prefixes: . bundles ( ServerPagesBundle . extendApp ( \"projectName-ui\" ) . mapViews ( \"/sub/folder/\" , \"/views/something/ext/\" ) . build ()) In some cases, extensions may depend on dropwizard configuration, but bundles created under initialization phase. To work around this you can use delayed extension init: . bundles ( ServerPagesBundle . extendApp ( \"projectName-ui\" ) . delayedConfiguration (( env , assets , views ) -> { if ( env . configuration (). isExtensionsEnabled ()) { assets . attach ( \"com.foo.bar\" ) } }) . build ())","title":"Extending applications"},{"location":"extras/gsp/#webjars-usage","text":"If you want to use resources from webjars in GSP application: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . attachWebjars () . build ()) For example, to add jquery: implementation 'org.webjars.npm:jquery:3.4.1' And it could be referenced as: < script src = \"jquery/3.4.1/dist/jquery.min.js\" /> Under the hood .attachWebjars() use extensions mechanism and adds META-INF/resources/webjars/ as application resources path: ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) ... . attachAssets ( \"META-INF/resources/webjars/\" ) OR . bundles ( ServerPagesBundle . extendApp ( \"app name\" ) . attachAssets ( \"META-INF/resources/webjars/\" ) . build ()) Tip You can always see the content of webjar on webjars site by clicking on package \"Files\" column. Use everything after \"META-INF/resources/webjars/\" to reference file.","title":"Webjars usage"},{"location":"extras/gsp/#custom-classloaders","text":"Very specific case There is a limited support for custom classloaders. Assumed case is when application resources could be loaded with different class loaders. Custom classloader could be specified during application registration, for example: . bundles ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" , classLoader ) . build ()) The same for admin app and extension. Warning This will affect only static resources! Template engine will not be able to resolve resources because it is not aware of custom loaders. Info The main problem here is dropwizard's View class which accepts only file path (String), so even if correct URL object is known (which is enough to load resource) before view construction it can't be used further. To workaround this, resolved absolute template path passed to view constructor. GSP module is able to found correct resourse later in correct class loader, but it requires obvious changes to template engine templates resolution mechanism. To resolve this, special templates resolver is required. For freemarker it is provided out of the box, but must be enabled on main bundle: ServerPagesBundle . builder () . enableFreemarkerCustomClassLoadersSupport () ... For mustache module it is impossible to write such integration.","title":"Custom classloaders"},{"location":"extras/jdbi/","text":"JDBI integration \u00b6 Extensions project module DEPRECATED : because jdbi2 dropwizard module is deprecated and moved outside of core modules . Migrate to jdbi3 Integrates JDBI2 with guice. Based on dropwizard-jdbi integration. Features: DBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces and abstract classes): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. Automatic installation for custom ResultSetMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - result set mappers Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-jdbi:5.10.0' Omit version if guicey BOM used Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle . < ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default DBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build DBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) Unit of work \u00b6 Unit of work concept states for: every database related operation must be performed inside unit of work. In DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with DBI own's Transaction annotation and more common Transactional annotations). At the beginning of unit of work, DBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work. @InTransaction \u00b6 Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation. If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class ); Context Handle \u00b6 Inside unit of work you may reference current handle by using: @Inject Provider < Handle > Manual transaction definition \u00b6 You may define transaction (with unit of work) without annotation using: @Inject TransactionTenpate template ; ... template . inTrabsansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation. Repository \u00b6 Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. You can also use injection inside repositories, but only field injection: public abstract class MyRepo { @Inject SomeBean bean ; } Constructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able to construct proxy for class with constructor injection. Don't use DBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi.support.repository.SampleRepository) Result set mapper \u00b6 If you have custom implementations of ResultSetMapper , it may be registered automatically. You will be able to use injections there because mappers become ususal guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements ResutlSetMapper < Custom > { @Override public Cusom map ( int row , ResultSet rs , StatementContext ctx ) { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper) Manual unit of work definition \u00b6 If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started). Migration to jdbi3 \u00b6 Use guicey-jdbi3 Module package changed from ru.vyarus.guicey.jdbi to ru.vyarus.guicey.jdbi3 . Jdbi object was previously bind as DBI interface. Now it's bound as Jdbi (as interface was removed in jdbi3). New methods in JdbiBundle: withPlugins - install custom plugins withConfig - to simplify manual configuration In jdbi3 ResultSetMapper was changed to RowMapper (and ColumnMapper). Installer supports RowMapper automatic installation. If you were using binding annotations then: @BindingAnnotation -> @SqlStatementCustomizingAnnotation BindingFactory -> SqlStatementCustomizerFactory Sql object proxies must be interfaces now (jdbi3 restriction). But as java 8 interfaces support default methods, its not a big problem instead of field injection (to access other proxies), now getter annotated with @Inject must be used. See jdbi3 migration gude for other (pure jdbi related) differences","title":"JDBI"},{"location":"extras/jdbi/#jdbi-integration","text":"Extensions project module DEPRECATED : because jdbi2 dropwizard module is deprecated and moved outside of core modules . Migrate to jdbi3 Integrates JDBI2 with guice. Based on dropwizard-jdbi integration. Features: DBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces and abstract classes): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. Automatic installation for custom ResultSetMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - result set mappers","title":"JDBI integration"},{"location":"extras/jdbi/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-jdbi:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/jdbi/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle . < ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default DBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build DBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ())","title":"Usage"},{"location":"extras/jdbi/#unit-of-work","text":"Unit of work concept states for: every database related operation must be performed inside unit of work. In DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with DBI own's Transaction annotation and more common Transactional annotations). At the beginning of unit of work, DBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work.","title":"Unit of work"},{"location":"extras/jdbi/#intransaction","text":"Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation. If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class );","title":"@InTransaction"},{"location":"extras/jdbi/#context-handle","text":"Inside unit of work you may reference current handle by using: @Inject Provider < Handle >","title":"Context Handle"},{"location":"extras/jdbi/#manual-transaction-definition","text":"You may define transaction (with unit of work) without annotation using: @Inject TransactionTenpate template ; ... template . inTrabsansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation.","title":"Manual transaction definition"},{"location":"extras/jdbi/#repository","text":"Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. You can also use injection inside repositories, but only field injection: public abstract class MyRepo { @Inject SomeBean bean ; } Constructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able to construct proxy for class with constructor injection. Don't use DBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi.support.repository.SampleRepository)","title":"Repository"},{"location":"extras/jdbi/#result-set-mapper","text":"If you have custom implementations of ResultSetMapper , it may be registered automatically. You will be able to use injections there because mappers become ususal guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements ResutlSetMapper < Custom > { @Override public Cusom map ( int row , ResultSet rs , StatementContext ctx ) { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper)","title":"Result set mapper"},{"location":"extras/jdbi/#manual-unit-of-work-definition","text":"If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started).","title":"Manual unit of work definition"},{"location":"extras/jdbi/#migration-to-jdbi3","text":"Use guicey-jdbi3 Module package changed from ru.vyarus.guicey.jdbi to ru.vyarus.guicey.jdbi3 . Jdbi object was previously bind as DBI interface. Now it's bound as Jdbi (as interface was removed in jdbi3). New methods in JdbiBundle: withPlugins - install custom plugins withConfig - to simplify manual configuration In jdbi3 ResultSetMapper was changed to RowMapper (and ColumnMapper). Installer supports RowMapper automatic installation. If you were using binding annotations then: @BindingAnnotation -> @SqlStatementCustomizingAnnotation BindingFactory -> SqlStatementCustomizerFactory Sql object proxies must be interfaces now (jdbi3 restriction). But as java 8 interfaces support default methods, its not a big problem instead of field injection (to access other proxies), now getter annotated with @Inject must be used. See jdbi3 migration gude for other (pure jdbi related) differences","title":"Migration to jdbi3"},{"location":"extras/jdbi3/","text":"JDBI3 integration \u00b6 Integrates JDBI3 with guice. Based on dropwizard-jdbi3 integration. Features: JDBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. can reference guice beans (with annotated getters) Automatic installation for custom RowMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - row mappers Setup \u00b6 Important Since dropwizard 2.0.22 dropwizard-jdbi3 requires Java 11 by default , use guicey-jdbi3-jdk8 instead (meta package fixing classpath) for java 8 compatibility. Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi3 </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-jdbi3:5.10.0' Omit version if guicey BOM used Warning dropwizard-jdbi3 drops java 8 support in gradle because it leaks (through metrics-jdbi3) jdbi3 3.43.1, compiled for java 11, so, for java 8 compatibility, you'll have to manually force the correct version: implementation ( 'org.jdbi:jdbi3-core' ) { version { strictly '3.39.1' } } H2 If BOM used, be aware that dropwizard-dependencies force H2 2.2 version, so if you need to use 1.4 then force version manually: in gradle: implementation ( 'com.h2database:h2' ) { version { strictly '1.4.196' } } In maven: put a correct version as top-level dependency Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle . < ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default JDBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build JDBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) Jdbi3 introduce plugins concept. Dropwizard will automatically register SqlObjectPlugin , GuavaPlugin , JodaTimePlugin . If you need to install custom plugin: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withPlugins ( new H2DatabasePlugin ()) Also, If custom registration must be performed on jdbi instance: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withConfig (( jdbi ) -> { jdbi . callSomething () }) Such configuration block will be called just after jdbi instance creation (but before injector creation). Unit of work \u00b6 Unit of work concept states for: every database related operation must be performed inside unit of work. In JDBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with JDBI's own Transaction annotation and more common Transactional annotations). At the beginning of unit of work, JDBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work. @InTransaction \u00b6 Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation. Transaction configuration \u00b6 Transaction isolation level and readonly flag could be defined with annotation: @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) @InTransaction ( readOnly = true ) In case of nested transactions error will be thrown if: Current transaction level is different from the nested one Current transaction is read only and nested transaction is not (note that some drivers, like h2, ignore readOnly flag completely) For example: @InTransaction public void action () { nestedAction (); } @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) public void nestedAction () { ... } When action() method called new transaction is created with default level (usually READ_COMMITTED). When nestedAction() is called exception will be thrown because it's transaction level requirement (READ_UNCOMMITTED) contradict with current transaction. Custom transactional annotation \u00b6 If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class ); If you need to support transaction configuration (level and read only settings) with your annotation then: Add required properties into annotation itself (see @InTransaction as example). Create implementation of TxConfigFactory (see InTransactionTxConfigFactory as example) Register factory inside your annotation with @TxConfigSupport(MyCustomAnnotationTxConfigFactory.class) Your factory will be instantiated as guice bean so annotate it as Singleton, if possible to avoid redundant instances creation. Configuration is resolved just once for each method, so yur factory will be called just once for each annotated (with your custom annotation) method. Context Handle \u00b6 Inside unit of work you may reference current handle by using: @Inject Provider < Handle > Manual transaction definition \u00b6 You may define transaction (with unit of work) without annotation using: @Inject TransactionTempate template ; ... template . inTrasansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation. You can also specify transaction config (if required): @Inject TransactionTempate template ; ... template . inTrasansaction ( new TxConfig (). level ( TransactionIsolationLevel . READ_UNCOMMITTED ), ( handle ) -> doSomething ()) Repository \u00b6 Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Note singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope its repository itself). It will make beans \"feel the same\" as usual JDBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. Warning Don't use JDBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi3.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi3.support.repository.SampleRepository) Manual bindings \u00b6 Repository can't be recognized from guice binding because repository type is abstract and guice would complain about it. But repository can be recognized from the chain. For example, suppose there is a base interface Storage and JDBI implementation is only one possible implementation: JdbiStorage extends Storage . In this case you can bind: bind(Storage.class).to(JdbiStorage.class) and use everywhere in code @Inject Storage storage; (installer would bind interface to implementation and guice would be able to correctly track binding to the generated instance). Only in this case repository class could be recognized from guice binding (even if it's not declared as extension and classpath scan not used). In all other cases, repository declaration would cause an error (to identify incorrect declaration). Laziness \u00b6 By default, JDBI proxies for declared repositories created only on first repository method call. Lazy behaviour is important to take into account all registered JDBI extensions. Laziness also slightly speeds up application startup. If required, you can enable eager initialization during bundle construction: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withEagerInitialization () In the eager mode all proxies would be constructed after application initialization (before web part initialization). Guice beans access \u00b6 You can access guice beans by annotating getter with @Inject (javax or guice): @JdbiRepository @InTransaction public interface MyRepository { @Inject MyOtherRepository getOtherRepo (); @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); default String doSomething ( int id ) { String name = findNameById ( id ); return getOtherRepo (). doSOmethingWithName ( name ); } } Here call to getOtherRepo() will return MyOtherRepository guice bean, which is actually another proxy. Row mapper \u00b6 If you have custom implementations of RowMapper , it may be registered automatically. You will be able to use injections there because mappers become usual guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements RowMapper < Custom > { @Override Custom map ( ResultSet rs , StatementContext ctx ) throws SQLException { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi3.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi3.support.mapper.SampleMapper) Manual unit of work definition \u00b6 If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started).","title":"JDBI3"},{"location":"extras/jdbi3/#jdbi3-integration","text":"Integrates JDBI3 with guice. Based on dropwizard-jdbi3 integration. Features: JDBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. can reference guice beans (with annotated getters) Automatic installation for custom RowMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - row mappers","title":"JDBI3 integration"},{"location":"extras/jdbi3/#setup","text":"Important Since dropwizard 2.0.22 dropwizard-jdbi3 requires Java 11 by default , use guicey-jdbi3-jdk8 instead (meta package fixing classpath) for java 8 compatibility. Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi3 </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-jdbi3:5.10.0' Omit version if guicey BOM used Warning dropwizard-jdbi3 drops java 8 support in gradle because it leaks (through metrics-jdbi3) jdbi3 3.43.1, compiled for java 11, so, for java 8 compatibility, you'll have to manually force the correct version: implementation ( 'org.jdbi:jdbi3-core' ) { version { strictly '3.39.1' } } H2 If BOM used, be aware that dropwizard-dependencies force H2 2.2 version, so if you need to use 1.4 then force version manually: in gradle: implementation ( 'com.h2database:h2' ) { version { strictly '1.4.196' } } In maven: put a correct version as top-level dependency","title":"Setup"},{"location":"extras/jdbi3/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle . < ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default JDBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build JDBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) Jdbi3 introduce plugins concept. Dropwizard will automatically register SqlObjectPlugin , GuavaPlugin , JodaTimePlugin . If you need to install custom plugin: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withPlugins ( new H2DatabasePlugin ()) Also, If custom registration must be performed on jdbi instance: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withConfig (( jdbi ) -> { jdbi . callSomething () }) Such configuration block will be called just after jdbi instance creation (but before injector creation).","title":"Usage"},{"location":"extras/jdbi3/#unit-of-work","text":"Unit of work concept states for: every database related operation must be performed inside unit of work. In JDBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with JDBI's own Transaction annotation and more common Transactional annotations). At the beginning of unit of work, JDBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work.","title":"Unit of work"},{"location":"extras/jdbi3/#intransaction","text":"Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation.","title":"@InTransaction"},{"location":"extras/jdbi3/#transaction-configuration","text":"Transaction isolation level and readonly flag could be defined with annotation: @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) @InTransaction ( readOnly = true ) In case of nested transactions error will be thrown if: Current transaction level is different from the nested one Current transaction is read only and nested transaction is not (note that some drivers, like h2, ignore readOnly flag completely) For example: @InTransaction public void action () { nestedAction (); } @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) public void nestedAction () { ... } When action() method called new transaction is created with default level (usually READ_COMMITTED). When nestedAction() is called exception will be thrown because it's transaction level requirement (READ_UNCOMMITTED) contradict with current transaction.","title":"Transaction configuration"},{"location":"extras/jdbi3/#custom-transactional-annotation","text":"If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class ); If you need to support transaction configuration (level and read only settings) with your annotation then: Add required properties into annotation itself (see @InTransaction as example). Create implementation of TxConfigFactory (see InTransactionTxConfigFactory as example) Register factory inside your annotation with @TxConfigSupport(MyCustomAnnotationTxConfigFactory.class) Your factory will be instantiated as guice bean so annotate it as Singleton, if possible to avoid redundant instances creation. Configuration is resolved just once for each method, so yur factory will be called just once for each annotated (with your custom annotation) method.","title":"Custom transactional annotation"},{"location":"extras/jdbi3/#context-handle","text":"Inside unit of work you may reference current handle by using: @Inject Provider < Handle >","title":"Context Handle"},{"location":"extras/jdbi3/#manual-transaction-definition","text":"You may define transaction (with unit of work) without annotation using: @Inject TransactionTempate template ; ... template . inTrasansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation. You can also specify transaction config (if required): @Inject TransactionTempate template ; ... template . inTrasansaction ( new TxConfig (). level ( TransactionIsolationLevel . READ_UNCOMMITTED ), ( handle ) -> doSomething ())","title":"Manual transaction definition"},{"location":"extras/jdbi3/#repository","text":"Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Note singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope its repository itself). It will make beans \"feel the same\" as usual JDBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. Warning Don't use JDBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi3.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi3.support.repository.SampleRepository)","title":"Repository"},{"location":"extras/jdbi3/#manual-bindings","text":"Repository can't be recognized from guice binding because repository type is abstract and guice would complain about it. But repository can be recognized from the chain. For example, suppose there is a base interface Storage and JDBI implementation is only one possible implementation: JdbiStorage extends Storage . In this case you can bind: bind(Storage.class).to(JdbiStorage.class) and use everywhere in code @Inject Storage storage; (installer would bind interface to implementation and guice would be able to correctly track binding to the generated instance). Only in this case repository class could be recognized from guice binding (even if it's not declared as extension and classpath scan not used). In all other cases, repository declaration would cause an error (to identify incorrect declaration).","title":"Manual bindings"},{"location":"extras/jdbi3/#laziness","text":"By default, JDBI proxies for declared repositories created only on first repository method call. Lazy behaviour is important to take into account all registered JDBI extensions. Laziness also slightly speeds up application startup. If required, you can enable eager initialization during bundle construction: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withEagerInitialization () In the eager mode all proxies would be constructed after application initialization (before web part initialization).","title":"Laziness"},{"location":"extras/jdbi3/#guice-beans-access","text":"You can access guice beans by annotating getter with @Inject (javax or guice): @JdbiRepository @InTransaction public interface MyRepository { @Inject MyOtherRepository getOtherRepo (); @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); default String doSomething ( int id ) { String name = findNameById ( id ); return getOtherRepo (). doSOmethingWithName ( name ); } } Here call to getOtherRepo() will return MyOtherRepository guice bean, which is actually another proxy.","title":"Guice beans access"},{"location":"extras/jdbi3/#row-mapper","text":"If you have custom implementations of RowMapper , it may be registered automatically. You will be able to use injections there because mappers become usual guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements RowMapper < Custom > { @Override Custom map ( ResultSet rs , StatementContext ctx ) throws SQLException { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi3.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi3.support.mapper.SampleMapper)","title":"Row mapper"},{"location":"extras/jdbi3/#manual-unit-of-work-definition","text":"If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started).","title":"Manual unit of work definition"},{"location":"extras/lifecycle-annotations/","text":"Lifecycle annotations \u00b6 Allows using lifecycle annotations for initialization/destruction methods in guice beans. Main motivation is to replace Managed usage in places where it's simpler to just annotate method, rather than register extension. @PostCostruct - same as Managed.start() @PostStartup - called after server startup (application completely started) @PreDestroy - same as Managed.stop() Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-lifecycle-annotations </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:lifecycle-annotations:5.10.0' Omit version if guicey BOM used Usage \u00b6 By default, no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work. import javax.annotation.PostConstruct ; import javax.annotation.PreDestroy ; import ru.vyarus.guicey.annotations.lifecycle.PostStartup ; public class SampleBean { @PostConstruct private void start () { // same time as Managed.start() } @PostStartup private void afterStartup () { // application completely started } @PreDestroy private void stop () { // same time as Managed.stop() } } Annotated methods must not contain parameters. Method could have any visibility. @PostConstruct or @PostStartup methods fail fails entire application startup (fail fast) @PreDestroy method fails are just logged to guarantee that all destroy methods will be processed If both current class and super class have annotated methods - both methods will be executed (the only obvious exception is overridden methods) Important If bean is created on demand (lazy creation by guice JIT), annotated methods will still be called, even if actual lifecycle event was already passed. Warning log message will be printed to indicate this \"not quite correct\" execution, but you can be sure that your methods will always be processed. Reducing scope \u00b6 Annotations are applied using guice TypeListener api which means that all guice beans are introspected for annotated methods. If you want to limit the scope of processed beans then register bundle manually (in this case lookup will be ignored): GuiceBundle . builder () . bundles ( new LifecycleAnnotationsBundle ( \"package.to.apply\" )) . build () In this example only beans lying in specified package will be checked. Also, direct Matcher implementation could be specified for more sophisticated cases. For example, if I want to exclude only one class: new LifecycleAnnotationsBundle ( new AbstractMatcher < TypeLiteral <?>> () { @Override public boolean matches ( TypeLiteral <?> o ) { return o . getRawType () != SomeExcludedBean . class ; } })","title":"Lifecycle annotations"},{"location":"extras/lifecycle-annotations/#lifecycle-annotations","text":"Allows using lifecycle annotations for initialization/destruction methods in guice beans. Main motivation is to replace Managed usage in places where it's simpler to just annotate method, rather than register extension. @PostCostruct - same as Managed.start() @PostStartup - called after server startup (application completely started) @PreDestroy - same as Managed.stop()","title":"Lifecycle annotations"},{"location":"extras/lifecycle-annotations/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-lifecycle-annotations </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:lifecycle-annotations:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/lifecycle-annotations/#usage","text":"By default, no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work. import javax.annotation.PostConstruct ; import javax.annotation.PreDestroy ; import ru.vyarus.guicey.annotations.lifecycle.PostStartup ; public class SampleBean { @PostConstruct private void start () { // same time as Managed.start() } @PostStartup private void afterStartup () { // application completely started } @PreDestroy private void stop () { // same time as Managed.stop() } } Annotated methods must not contain parameters. Method could have any visibility. @PostConstruct or @PostStartup methods fail fails entire application startup (fail fast) @PreDestroy method fails are just logged to guarantee that all destroy methods will be processed If both current class and super class have annotated methods - both methods will be executed (the only obvious exception is overridden methods) Important If bean is created on demand (lazy creation by guice JIT), annotated methods will still be called, even if actual lifecycle event was already passed. Warning log message will be printed to indicate this \"not quite correct\" execution, but you can be sure that your methods will always be processed.","title":"Usage"},{"location":"extras/lifecycle-annotations/#reducing-scope","text":"Annotations are applied using guice TypeListener api which means that all guice beans are introspected for annotated methods. If you want to limit the scope of processed beans then register bundle manually (in this case lookup will be ignored): GuiceBundle . builder () . bundles ( new LifecycleAnnotationsBundle ( \"package.to.apply\" )) . build () In this example only beans lying in specified package will be checked. Also, direct Matcher implementation could be specified for more sophisticated cases. For example, if I want to exclude only one class: new LifecycleAnnotationsBundle ( new AbstractMatcher < TypeLiteral <?>> () { @Override public boolean matches ( TypeLiteral <?> o ) { return o . getRawType () != SomeExcludedBean . class ; } })","title":"Reducing scope"},{"location":"extras/spa/","text":"Single page applications support \u00b6 Provides a replacement for dropwizard-assets bundle for single page applications (SPA) to properly handle html5 client routing. Features: Pure dropwizard bundle, but can be used with guicey bundles Build above dropwizard-assets servlet Support registration on main and admin contexts Multiple apps could be registered Sets no-cache headers for index page Regex could be used to tune routes detection Problem \u00b6 The problem with SPA is html5 routing. For example, suppose your app base url is /app and client route url is /app/someroute (before there were no problem because route would look like /app/#!/someroute ). When user hit refresh (or bookmark) such route, server is actually called with route url. Server must recognize it and return index page. For example, Angular 2 router use html5 mode my default. Solution \u00b6 The problem consists of two points: Correctly process resource calls (css, js, images, etc) and return 404 for missed resources Recognize application routes and return index page instead Bundles register dropwizard-assets servlet with special filter above it. Filter tries to process all incoming urls. This approach grants that all calls to resources will be processed and index page will not be returned instead of resource (solves problem 1). If resource is not found - index page returned. To avoid redirection in case of bad resources request, filter will redirect only requests accepting 'text/html'. Additional regexp (configurable) is used to recognize most resource calls and avoid redirection (show correct 404). From example above, /app/someroute will return index page and /app/css/some.css will return css. /app/css/unknown.css will return 404 as resource call will be recognized and css file is not exists. Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-spa </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-spa:5.10.0' Omit version if guicey BOM used Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build ()); This will register app with name \"app\" (name is used to name servlets and filters and must be unique). Application files are located in \"app\" package in classpath (e.g. resources inside jar). Application is mapped to root context (note that this will work only if rest is mapped to some sub context: e.g. with server.rootPath: '/rest/*' configuration). http://localhost:8080/ -> app index http://loclahost:8080/css/app.css -> application resource, located at /app/css/app.css in classpath http://localhost:8080/someroute -> application client route - index page returned Example registration to admin context: . bundles ( SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build ()); Register \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager\" admin context (note that admin root is already used by dropwizard admin servlet). Tip Resources location can be declared both as path ( /com/mycompany/adminapp/ ) or as package ( com.mycompany.adminapp ). http://localhost:8081/manager -> admin app index You can register as many apps as you like. They just must use different urls and have different names: . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build (), SpaBundle . app ( \"app2\" , \"/app2\" , \"/\" ). build (), SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build (), SpaBundle . adminApp ( \"admin2\" , \"/com/mycompany/adminapp2/\" , \"/manager2\" ). build ()); Note If you publish SPA application not in the root path, don't forget to set appropriate <base href=\"/path/\"/> tag. All modern client side routers rely on it. Pay attention that path in base tag must end with / . Index page \u00b6 By default, index page assumed to be \"index.html\". Could be changed with: . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). indexPage ( \"main.html\" ). build ()); Prevent redirect regex \u00b6 By default, the following regex is used to prevent resources redirection (to not send index for missed resource): \\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$ Could be changed with: . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ) . preventRedirectRegex ( \"\\\\.\\\\w{2,5}(\\\\?.*)?$\" ) . build ()); This regexp implements naive assumption that all app routes does not contain \"extension\". Note: regexp is applied with find so use ^ or $ to apply boundaries.","title":"SPA"},{"location":"extras/spa/#single-page-applications-support","text":"Provides a replacement for dropwizard-assets bundle for single page applications (SPA) to properly handle html5 client routing. Features: Pure dropwizard bundle, but can be used with guicey bundles Build above dropwizard-assets servlet Support registration on main and admin contexts Multiple apps could be registered Sets no-cache headers for index page Regex could be used to tune routes detection","title":"Single page applications support"},{"location":"extras/spa/#problem","text":"The problem with SPA is html5 routing. For example, suppose your app base url is /app and client route url is /app/someroute (before there were no problem because route would look like /app/#!/someroute ). When user hit refresh (or bookmark) such route, server is actually called with route url. Server must recognize it and return index page. For example, Angular 2 router use html5 mode my default.","title":"Problem"},{"location":"extras/spa/#solution","text":"The problem consists of two points: Correctly process resource calls (css, js, images, etc) and return 404 for missed resources Recognize application routes and return index page instead Bundles register dropwizard-assets servlet with special filter above it. Filter tries to process all incoming urls. This approach grants that all calls to resources will be processed and index page will not be returned instead of resource (solves problem 1). If resource is not found - index page returned. To avoid redirection in case of bad resources request, filter will redirect only requests accepting 'text/html'. Additional regexp (configurable) is used to recognize most resource calls and avoid redirection (show correct 404). From example above, /app/someroute will return index page and /app/css/some.css will return css. /app/css/unknown.css will return 404 as resource call will be recognized and css file is not exists.","title":"Solution"},{"location":"extras/spa/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-spa </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-spa:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/spa/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build ()); This will register app with name \"app\" (name is used to name servlets and filters and must be unique). Application files are located in \"app\" package in classpath (e.g. resources inside jar). Application is mapped to root context (note that this will work only if rest is mapped to some sub context: e.g. with server.rootPath: '/rest/*' configuration). http://localhost:8080/ -> app index http://loclahost:8080/css/app.css -> application resource, located at /app/css/app.css in classpath http://localhost:8080/someroute -> application client route - index page returned Example registration to admin context: . bundles ( SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build ()); Register \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager\" admin context (note that admin root is already used by dropwizard admin servlet). Tip Resources location can be declared both as path ( /com/mycompany/adminapp/ ) or as package ( com.mycompany.adminapp ). http://localhost:8081/manager -> admin app index You can register as many apps as you like. They just must use different urls and have different names: . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build (), SpaBundle . app ( \"app2\" , \"/app2\" , \"/\" ). build (), SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build (), SpaBundle . adminApp ( \"admin2\" , \"/com/mycompany/adminapp2/\" , \"/manager2\" ). build ()); Note If you publish SPA application not in the root path, don't forget to set appropriate <base href=\"/path/\"/> tag. All modern client side routers rely on it. Pay attention that path in base tag must end with / .","title":"Usage"},{"location":"extras/spa/#index-page","text":"By default, index page assumed to be \"index.html\". Could be changed with: . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). indexPage ( \"main.html\" ). build ());","title":"Index page"},{"location":"extras/spa/#prevent-redirect-regex","text":"By default, the following regex is used to prevent resources redirection (to not send index for missed resource): \\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$ Could be changed with: . bundles ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ) . preventRedirectRegex ( \"\\\\.\\\\w{2,5}(\\\\?.*)?$\" ) . build ()); This regexp implements naive assumption that all app routes does not contain \"extension\". Note: regexp is applied with find so use ^ or $ to apply boundaries.","title":"Prevent redirect regex"},{"location":"extras/validation/","text":"Validation \u00b6 By default, dropwizard allows you to use validation annotations on rest services . This module allows you to use validation annotations the same way on any guice bean method. Bundle is actually a wrapper for guice-validator project. Setup \u00b6 Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-validation </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-validation:5.10.0' Omit version if guicey BOM used Usage \u00b6 By default, no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work. For example: import javax.annotation.PostConstruct ; import javax.annotation.PreDestroy ; import ru.vyarus.guicey.annotations.lifecycle.PostStartup ; public class SampleBean { private void doSomething ( @NotNull String param ) { } } Call bean.doSomething(null) will fail with ConstraintValidationException . For more usage examples see guice-validator documentation Explicit mode \u00b6 By default, validations work in implicit mode: any method containing validation annotations would trigger validation on call. If you want more explicitly mark methods requiring validation then register bundle manually: . bundles ( new ValidationBundle () . validateAnnotatedOnly ()) Now, only methods annotated with @ValidateOnExecution (or all methods in annotated class) will trigger validation. If you want, you can use your own annotation: . bundles ( new ValidationBundle () . validateAnnotatedOnly ( MyAnnotation . class )) Reducing scope \u00b6 By default, validation is not applied to resource classes (annotated with @Path ) because dropwizard already performs validation there. And rest methods, annotated with @GET , @POST , etc. are skipped (required for complex declaration cases, like dynamic resource mappings or sub resources). You can reduce this scope even further: . bundles ( new ValidationBundle () . targetClasses ( Matchers . subclassesOf ( SomeService . class ) . and ( Matchers . not ( Matchers . annotatedWith ( Path . class ))))) Here SomeService is excluded from validation (its methods would not trigger validation). Note that default condition (not resource) is appended. Or excluding methods: . bundles ( new ValidationBundle () . targetMethods ( Matchers . annotatedWith ( SuppressValidation . class ) . and ( new DirectMethodMatcher ()))) Now methods annotated with @SuppressValidation will not be validated. Note that .and(new DirectMethodMatcher()) condition was added to also exclude synthetic and bridge methods (jvm generated methods). Note You can verify AOP appliance with guicey .printGuiceAopMap() report. Validation groups \u00b6 By default, Default validation group is always enabled allowing you to not specify groups for each call. This could be disabled with bundle option: . bundles ( new ValidationBundle (). strictGroupsDeclaration ()) Read more in guice-validator docs .","title":"Validation"},{"location":"extras/validation/#validation","text":"By default, dropwizard allows you to use validation annotations on rest services . This module allows you to use validation annotations the same way on any guice bean method. Bundle is actually a wrapper for guice-validator project.","title":"Validation"},{"location":"extras/validation/#setup","text":"Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-validation </artifactId> <version> 5.10.0 </version> </dependency> Gradle: implementation 'ru.vyarus.guicey:guicey-validation:5.10.0' Omit version if guicey BOM used","title":"Setup"},{"location":"extras/validation/#usage","text":"By default, no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work. For example: import javax.annotation.PostConstruct ; import javax.annotation.PreDestroy ; import ru.vyarus.guicey.annotations.lifecycle.PostStartup ; public class SampleBean { private void doSomething ( @NotNull String param ) { } } Call bean.doSomething(null) will fail with ConstraintValidationException . For more usage examples see guice-validator documentation","title":"Usage"},{"location":"extras/validation/#explicit-mode","text":"By default, validations work in implicit mode: any method containing validation annotations would trigger validation on call. If you want more explicitly mark methods requiring validation then register bundle manually: . bundles ( new ValidationBundle () . validateAnnotatedOnly ()) Now, only methods annotated with @ValidateOnExecution (or all methods in annotated class) will trigger validation. If you want, you can use your own annotation: . bundles ( new ValidationBundle () . validateAnnotatedOnly ( MyAnnotation . class ))","title":"Explicit mode"},{"location":"extras/validation/#reducing-scope","text":"By default, validation is not applied to resource classes (annotated with @Path ) because dropwizard already performs validation there. And rest methods, annotated with @GET , @POST , etc. are skipped (required for complex declaration cases, like dynamic resource mappings or sub resources). You can reduce this scope even further: . bundles ( new ValidationBundle () . targetClasses ( Matchers . subclassesOf ( SomeService . class ) . and ( Matchers . not ( Matchers . annotatedWith ( Path . class ))))) Here SomeService is excluded from validation (its methods would not trigger validation). Note that default condition (not resource) is appended. Or excluding methods: . bundles ( new ValidationBundle () . targetMethods ( Matchers . annotatedWith ( SuppressValidation . class ) . and ( new DirectMethodMatcher ()))) Now methods annotated with @SuppressValidation will not be validated. Note that .and(new DirectMethodMatcher()) condition was added to also exclude synthetic and bridge methods (jvm generated methods). Note You can verify AOP appliance with guicey .printGuiceAopMap() report.","title":"Reducing scope"},{"location":"extras/validation/#validation-groups","text":"By default, Default validation group is always enabled allowing you to not specify groups for each call. This could be disabled with bundle option: . bundles ( new ValidationBundle (). strictGroupsDeclaration ()) Read more in guice-validator docs .","title":"Validation groups"},{"location":"guide/bundles/","text":"Guicey bundles \u00b6 Analogous to Dropwizard Bundles, Guicey has its own GuiceyBundle . These bundles contain many of the same options as the main GuiceBundle builder . The purpose of Guicey Bundles is the same as Dropwizard Bundles: encapsulate logic by grouping installers, extensions and guice modules related to specific features and libraries. Note Guicey bundles are assumed to be used instead of dropwizard bundles in guicey-powered application. It does not mean that drowpizard bundles can't be used - of course they can! There are many existing dropwizard bundles and it would be insane to get rid of them. It is not possible to register guice modules and use many guicey features from dropwizard bundles. Guicey and Dropwizard Bundles share the same lifecycle : public interface ConfiguredBundle < T > { default void initialize ( Bootstrap <?> bootstrap ) {} default void run ( T configuration , Environment environment ) throws Exception {} } public interface GuiceyBundle { default void initialize ( GuiceyBootstrap bootstrap ) {} default void run ( GuiceyEnvironment environment ) throws Exception {} } Guicey Bundles are an extension to dropwizard bundles (without restrictions), so it is extremely simple to switch from dropwizard bundles. Tip With Guicey Bundles, it is possible to implement plug-and-play bundles to automatically install a bundle when its jar appears on the classpath. Example Guicey bundle: public class MyFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . installers ( MyFeatureExtensionInstaller . class ) // dropwizard bundle usage . dropwizardBundle ( new RequiredDwBundle ()) . modules ( new MyFeatureModule ()); // dropwizard bootstrap access bootstrap . bootstrap (). addCommand ( new MyFeatureCommand ()); } @Override public void run ( GuiceyEnvironment environment ) throws Exception { // configuration access environment . modules ( new SpecialModle ( environment . configuration (). getSomeValue ())) . onApplicationStartup (() -> logger . info ( \"Application started!\" )); // dropwizard environment access environment . environment (). setValidator ( new MyCustomValudatior ()); } } bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new MyFeatureBundle ()) . build () ); Example bundles can be found in Guicey itself: CoreInstallersBundle - all default installers WebInstallersBundle - servlet and filter annotations support HK2DebugBundle - guice - HK2 scope debug tool Even more examples are in extensions modules Configuration \u00b6 See all bundle configuration options Note Most configurations only appear during the initialization phase. This was done in order to follow dropwizard conventions (all configuration during init and all initialization on run). The only exception to this rule is the registration of guice modules. Bundles are allowed to register modules in both phases. Guice modules often require direct configuration values. Without this exception, Guicey Bundle authors would be required to create wrappers around guicey-aware modules for proper guice registrations. Dropwizard itself shares a similar exception in that HK2 modules may only be registered during the run phase. Bundle De-duplication \u00b6 Your bundles may be installed multiple times, and you must always think of what should be expected behaviour in these cases. For example: . bundles ( new MyBundle (), new MyBundle ()) Bundles are often intended to be used multiple times (for example, spa bundle ). But in some cases, only one bundle instance must be installed. For example, eventbus bundle must be installed just once. The opposite may be true: a common bundle could be installed by multiple other bundles. In order to manage these cases guicey provides a de-duplication mechanism . To avoid redundant bundle instances, you can: extend UniqueGuiceyBundle to allow only one bundle instance implement equals method (where you can implement any deduplication rules (e.g. based on bundles constructor arguments)) Note Deduplication could also help in case when your bundle is available through lookup with default configuration, but could be registered with customized configuration. In this case, you can also use UniqueGuiceyBundle : manually registered bundle will always be registered first, and bundle obtained with lookup mechansm would be considered as duplicate and not used (for example, eventbus bundle use this) Bundle Lookup \u00b6 The bundle lookup mechanism is used to lookup guicey bundles in various sources. It may be used to activate specific bundles in tests (e.g. HK2 scope control bundle ) or to install 3 rd party extensions from classpath. Bundle lookup is equivalent to registering bundle directly using builder bundles method. Note Bundles from lookup will always be registered after all manually registered bundles, so you can use de-duplication to accept manual instance and deny lookup. By default, two lookup mechanisms active: by property and with service loader . All found bundles are logged into console: INFO [2019-10-17 14:50:14,304] ru.vyarus.dropwizard.guice.bundle.DefaultBundleLookup: guicey bundles lookup = ru.vyarus.dropwizard.guice.diagnostic.support.bundle.LookupBundle You can disable default look-ups with: bootstrap . addBundle ( GuiceBundle . builder () . disableBundleLookup () . build () System property lookup \u00b6 System property guicey.bundles could contain comma separated list of guicey bundle classes. These bundles must have no-args constructor. For example, activate HK2 debug bundle for tests: java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle Alternatively, system property may be set in code: PropertyBundleLookup . enableBundles ( HK2DebugBundle . class ) Service loader lookup \u00b6 Using default java ServiceLoader mechanism, loads all GuiceyBundle services. This is useful for automatically installing 3 rd party extensions (additional installers, extensions, guice modules). Note This could be used to install bundles with default configuration and proper de-duplication . If a user register custom bundle version, it will be used and bundle from lookup will be ignored. For example, eventbus bundle works like this 3 rd party jar must contain services file: META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle The file must contain one GuiceyBundle implementation per line. For example: com.foo.Bundle1 com.foo.Bundle2 Then Bundle1, Bundle2 would be loaded automatically on startup and appear in logs. Customizing lookup mechanism \u00b6 Custom bundle lookup must implement GuiceyBundleLookup interface: public class CustomBundleLookup implements GuiceyBundleLookup { @Override public List < GuiceyBundle > lookup () { List < GuiceyBundle > bundles = Lists . newArrayList (); ... return bundles ; } } Custom lookup implementation may be registered through: bootstrap . addBundle ( GuiceBundle . builder () . bundleLookup ( new CustomBundleLookup ()) . build () But it's better to register it through default implementation DefaultBundleLookup , which performs composition of multiple lookup implementations and logs resolved bundles to console. bootstrap . addBundle ( GuiceBundle . builder () . bundleLookup ( new DefaultBundleLookup (). addLookup ( new CustomBundleLookup ())) . build () To override the list of default look-ups: bootstrap . addBundle ( GuiceBundle . builder () . bundleLookup ( new DefaultBundleLookup ( new ServiceLoaderBundleLookup (), new CustomBundleLookup ())) . build () Here, only two lookup mechanisms registered (property lookup is not registered and will not be implicitly added). Dropwizard bundles \u00b6 Dropwizard bundles can be used as before, registered directly in Bootstrap . Guicey provides direct api for dropwizard bundles registration: GuiceBundle . builder () . dropwizardBundles ( new MyDwBundle ()) and in bundles: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundle ( new MyDwBundle ()); } } Note The most common case is extending some existing 3 rd party integration (Dropwizard Bundle) with guice bindings (or adding guicey installers for simplified usage). public class XIntegratuionBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundle ( new DropwizardXBundle ()); . modules ( new XBindingsModule ()) } } JDBI bundle could be king of such example: it does not use dropwizard bundle, but it defines additional extension types to simplify configuration. When you register dropwizard bundles through guicey api: Bundle (and all transitive bundles) appear in report Bundle itself or any transitive bundle could be disabled De-duplication mechanism will work for a bundle, and its transitive bundles So, if you have a \"common bundle\" problem (when 2 bundles register some common bundle and so you can use these bundles together) it could be solved just by registering bundle through the guicey api with proper configuration . Transitive bundles tracking \u00b6 Transitive dropwizard bundles are tracked with a Bootstrap object proxy so guicey could intercept the addBundle call. If you have problems with the proxy, you can switch off transitive bundles tracking: . option ( GuiceyOptions . TrackDropwizardBundles , false ) If you don't want to switch off tracking, but still have problems registering some bundle, you can always register it directly in bootstrap object: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bootstrap (). addBundle ( new MyDwBundle ()); } } bootstrap.bootstrap() - is a raw bootstrap (not a proxy).","title":"Bundles"},{"location":"guide/bundles/#guicey-bundles","text":"Analogous to Dropwizard Bundles, Guicey has its own GuiceyBundle . These bundles contain many of the same options as the main GuiceBundle builder . The purpose of Guicey Bundles is the same as Dropwizard Bundles: encapsulate logic by grouping installers, extensions and guice modules related to specific features and libraries. Note Guicey bundles are assumed to be used instead of dropwizard bundles in guicey-powered application. It does not mean that drowpizard bundles can't be used - of course they can! There are many existing dropwizard bundles and it would be insane to get rid of them. It is not possible to register guice modules and use many guicey features from dropwizard bundles. Guicey and Dropwizard Bundles share the same lifecycle : public interface ConfiguredBundle < T > { default void initialize ( Bootstrap <?> bootstrap ) {} default void run ( T configuration , Environment environment ) throws Exception {} } public interface GuiceyBundle { default void initialize ( GuiceyBootstrap bootstrap ) {} default void run ( GuiceyEnvironment environment ) throws Exception {} } Guicey Bundles are an extension to dropwizard bundles (without restrictions), so it is extremely simple to switch from dropwizard bundles. Tip With Guicey Bundles, it is possible to implement plug-and-play bundles to automatically install a bundle when its jar appears on the classpath. Example Guicey bundle: public class MyFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . installers ( MyFeatureExtensionInstaller . class ) // dropwizard bundle usage . dropwizardBundle ( new RequiredDwBundle ()) . modules ( new MyFeatureModule ()); // dropwizard bootstrap access bootstrap . bootstrap (). addCommand ( new MyFeatureCommand ()); } @Override public void run ( GuiceyEnvironment environment ) throws Exception { // configuration access environment . modules ( new SpecialModle ( environment . configuration (). getSomeValue ())) . onApplicationStartup (() -> logger . info ( \"Application started!\" )); // dropwizard environment access environment . environment (). setValidator ( new MyCustomValudatior ()); } } bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new MyFeatureBundle ()) . build () ); Example bundles can be found in Guicey itself: CoreInstallersBundle - all default installers WebInstallersBundle - servlet and filter annotations support HK2DebugBundle - guice - HK2 scope debug tool Even more examples are in extensions modules","title":"Guicey bundles"},{"location":"guide/bundles/#configuration","text":"See all bundle configuration options Note Most configurations only appear during the initialization phase. This was done in order to follow dropwizard conventions (all configuration during init and all initialization on run). The only exception to this rule is the registration of guice modules. Bundles are allowed to register modules in both phases. Guice modules often require direct configuration values. Without this exception, Guicey Bundle authors would be required to create wrappers around guicey-aware modules for proper guice registrations. Dropwizard itself shares a similar exception in that HK2 modules may only be registered during the run phase.","title":"Configuration"},{"location":"guide/bundles/#bundle-de-duplication","text":"Your bundles may be installed multiple times, and you must always think of what should be expected behaviour in these cases. For example: . bundles ( new MyBundle (), new MyBundle ()) Bundles are often intended to be used multiple times (for example, spa bundle ). But in some cases, only one bundle instance must be installed. For example, eventbus bundle must be installed just once. The opposite may be true: a common bundle could be installed by multiple other bundles. In order to manage these cases guicey provides a de-duplication mechanism . To avoid redundant bundle instances, you can: extend UniqueGuiceyBundle to allow only one bundle instance implement equals method (where you can implement any deduplication rules (e.g. based on bundles constructor arguments)) Note Deduplication could also help in case when your bundle is available through lookup with default configuration, but could be registered with customized configuration. In this case, you can also use UniqueGuiceyBundle : manually registered bundle will always be registered first, and bundle obtained with lookup mechansm would be considered as duplicate and not used (for example, eventbus bundle use this)","title":"Bundle De-duplication"},{"location":"guide/bundles/#bundle-lookup","text":"The bundle lookup mechanism is used to lookup guicey bundles in various sources. It may be used to activate specific bundles in tests (e.g. HK2 scope control bundle ) or to install 3 rd party extensions from classpath. Bundle lookup is equivalent to registering bundle directly using builder bundles method. Note Bundles from lookup will always be registered after all manually registered bundles, so you can use de-duplication to accept manual instance and deny lookup. By default, two lookup mechanisms active: by property and with service loader . All found bundles are logged into console: INFO [2019-10-17 14:50:14,304] ru.vyarus.dropwizard.guice.bundle.DefaultBundleLookup: guicey bundles lookup = ru.vyarus.dropwizard.guice.diagnostic.support.bundle.LookupBundle You can disable default look-ups with: bootstrap . addBundle ( GuiceBundle . builder () . disableBundleLookup () . build ()","title":"Bundle Lookup"},{"location":"guide/bundles/#system-property-lookup","text":"System property guicey.bundles could contain comma separated list of guicey bundle classes. These bundles must have no-args constructor. For example, activate HK2 debug bundle for tests: java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle Alternatively, system property may be set in code: PropertyBundleLookup . enableBundles ( HK2DebugBundle . class )","title":"System property lookup"},{"location":"guide/bundles/#service-loader-lookup","text":"Using default java ServiceLoader mechanism, loads all GuiceyBundle services. This is useful for automatically installing 3 rd party extensions (additional installers, extensions, guice modules). Note This could be used to install bundles with default configuration and proper de-duplication . If a user register custom bundle version, it will be used and bundle from lookup will be ignored. For example, eventbus bundle works like this 3 rd party jar must contain services file: META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle The file must contain one GuiceyBundle implementation per line. For example: com.foo.Bundle1 com.foo.Bundle2 Then Bundle1, Bundle2 would be loaded automatically on startup and appear in logs.","title":"Service loader lookup"},{"location":"guide/bundles/#customizing-lookup-mechanism","text":"Custom bundle lookup must implement GuiceyBundleLookup interface: public class CustomBundleLookup implements GuiceyBundleLookup { @Override public List < GuiceyBundle > lookup () { List < GuiceyBundle > bundles = Lists . newArrayList (); ... return bundles ; } } Custom lookup implementation may be registered through: bootstrap . addBundle ( GuiceBundle . builder () . bundleLookup ( new CustomBundleLookup ()) . build () But it's better to register it through default implementation DefaultBundleLookup , which performs composition of multiple lookup implementations and logs resolved bundles to console. bootstrap . addBundle ( GuiceBundle . builder () . bundleLookup ( new DefaultBundleLookup (). addLookup ( new CustomBundleLookup ())) . build () To override the list of default look-ups: bootstrap . addBundle ( GuiceBundle . builder () . bundleLookup ( new DefaultBundleLookup ( new ServiceLoaderBundleLookup (), new CustomBundleLookup ())) . build () Here, only two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).","title":"Customizing lookup mechanism"},{"location":"guide/bundles/#dropwizard-bundles","text":"Dropwizard bundles can be used as before, registered directly in Bootstrap . Guicey provides direct api for dropwizard bundles registration: GuiceBundle . builder () . dropwizardBundles ( new MyDwBundle ()) and in bundles: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundle ( new MyDwBundle ()); } } Note The most common case is extending some existing 3 rd party integration (Dropwizard Bundle) with guice bindings (or adding guicey installers for simplified usage). public class XIntegratuionBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . dropwizardBundle ( new DropwizardXBundle ()); . modules ( new XBindingsModule ()) } } JDBI bundle could be king of such example: it does not use dropwizard bundle, but it defines additional extension types to simplify configuration. When you register dropwizard bundles through guicey api: Bundle (and all transitive bundles) appear in report Bundle itself or any transitive bundle could be disabled De-duplication mechanism will work for a bundle, and its transitive bundles So, if you have a \"common bundle\" problem (when 2 bundles register some common bundle and so you can use these bundles together) it could be solved just by registering bundle through the guicey api with proper configuration .","title":"Dropwizard bundles"},{"location":"guide/bundles/#transitive-bundles-tracking","text":"Transitive dropwizard bundles are tracked with a Bootstrap object proxy so guicey could intercept the addBundle call. If you have problems with the proxy, you can switch off transitive bundles tracking: . option ( GuiceyOptions . TrackDropwizardBundles , false ) If you don't want to switch off tracking, but still have problems registering some bundle, you can always register it directly in bootstrap object: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bootstrap (). addBundle ( new MyDwBundle ()); } } bootstrap.bootstrap() - is a raw bootstrap (not a proxy).","title":"Transitive bundles tracking"},{"location":"guide/commands/","text":"Dropwizard commands support \u00b6 Guice injections \u00b6 Guicey calls injector.injectMembers(command) for all registered EnvironmentCommand s, so you can inject guice beans directly: public class MyCommand extends EnvironmentCommand < MyConfiguration > { @Inject private MyService myservice ; public MyCommand ( Application application ) { super ( application , \"mycli\" , \"my super useful cli\" ); } @Override protected void run ( Environment environment , Namespace namespace , MyConfiguration configuration ) throws Exception { myservice . doSomething (); } } Note It doesn't matter if command was registered manually, by some bundle or with commands search (see below). Warning You can use guice injections only in EnvironmentCommand s because only these commands start bundles (and so launch guice context creation). Automatic installation \u00b6 Automatic scan for commands is disabled by default. It could be enabled by: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) . searchCommands () When enabled, all classes extending Command are instantiated using default constructor and registered in dropwizard bootstrap object. Simple commands \u00b6 For example, if command below would be inside scanned package, then guicey will automatically register it. public class MyCommand extends Command { public MyCommand () { super ( \"hello\" , \"Prints a greeting\" ); } @Override public void run ( Bootstrap <?> bootstrap , Namespace namespace ) throws Exception { System . out . println ( \"Hello world\" ); } } Environment commands \u00b6 Important EnvironmentCommand must have constructor with Application argument. public class SyncCommand extends EnvironmentCommand < AppConfiguration > { @Inject private RemoteSynchronizer synchronizer ; @Inject private DbManager manager ; public SyncCommand ( Application < AppConfiguration > application ) { super ( application , \"sync\" , \"Perform remote synchronization\" ); } @Override protected void run ( Environment environment , Namespace namespace , AppConfiguration configuration ) throws Exception { manager . start (); try { synchronizer . synchronize (); } finally { manager . stop (); } } } This example shows workaround for managed initialization in commands: DbManager is some Managed bean which would run automatically in server mode. But commands never call managed objects, so we have to manually start and stop them.","title":"Commands"},{"location":"guide/commands/#dropwizard-commands-support","text":"","title":"Dropwizard commands support"},{"location":"guide/commands/#guice-injections","text":"Guicey calls injector.injectMembers(command) for all registered EnvironmentCommand s, so you can inject guice beans directly: public class MyCommand extends EnvironmentCommand < MyConfiguration > { @Inject private MyService myservice ; public MyCommand ( Application application ) { super ( application , \"mycli\" , \"my super useful cli\" ); } @Override protected void run ( Environment environment , Namespace namespace , MyConfiguration configuration ) throws Exception { myservice . doSomething (); } } Note It doesn't matter if command was registered manually, by some bundle or with commands search (see below). Warning You can use guice injections only in EnvironmentCommand s because only these commands start bundles (and so launch guice context creation).","title":"Guice injections"},{"location":"guide/commands/#automatic-installation","text":"Automatic scan for commands is disabled by default. It could be enabled by: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) . searchCommands () When enabled, all classes extending Command are instantiated using default constructor and registered in dropwizard bootstrap object.","title":"Automatic installation"},{"location":"guide/commands/#simple-commands","text":"For example, if command below would be inside scanned package, then guicey will automatically register it. public class MyCommand extends Command { public MyCommand () { super ( \"hello\" , \"Prints a greeting\" ); } @Override public void run ( Bootstrap <?> bootstrap , Namespace namespace ) throws Exception { System . out . println ( \"Hello world\" ); } }","title":"Simple commands"},{"location":"guide/commands/#environment-commands","text":"Important EnvironmentCommand must have constructor with Application argument. public class SyncCommand extends EnvironmentCommand < AppConfiguration > { @Inject private RemoteSynchronizer synchronizer ; @Inject private DbManager manager ; public SyncCommand ( Application < AppConfiguration > application ) { super ( application , \"sync\" , \"Perform remote synchronization\" ); } @Override protected void run ( Environment environment , Namespace namespace , AppConfiguration configuration ) throws Exception { manager . start (); try { synchronizer . synchronize (); } finally { manager . stop (); } } } This example shows workaround for managed initialization in commands: DbManager is some Managed bean which would run automatically in server mode. But commands never call managed objects, so we have to manually start and stop them.","title":"Environment commands"},{"location":"guide/configuration/","text":"Configuration \u00b6 Guicey main dropwizard bundle must be registered: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () // <configuration methods> . build ()); } Guicey could be configured through: Main (dropwizard) bundle Bundles Hooks Main bundle \u00b6 Tip Bundle builder contains shortcuts for all guicey features, so required function may be found only by looking at available methods (and reading javadoc). Configuration items \u00b6 . enableAutoConfig ( String ... basePackages ) Enable classpath scan for automatic extension registration, custom installers search and commands search (if enabled) . enableAutoConfig () Shortcut for enabling classpath scan on application package . modules ( Module ... modules ) Guice modules registration Here guice modules are created in initialization phase, when Configuration and Environment are not yet available. If they are required for module either use \"Aware\" interfaces or register module in GuiceyBundle's run method (under run phase). . modulesOverride ( Module ... modules ) Overriding registered guice modules bindings (using guice Modules.override() api) Extensions are not recognized in overriding modules (intentionally)! . installers ( Class <? extends FeatureInstaller > ... installers ) Guicey extension installers registration. Required if you have custom installers or to specify installers after disabling all default installers: . noDefaultInstallers () Custom installers are registered automatically when classpath scan is enabled. . extensions ( Class <?> ... extensionClasses ) Manual extension registration. May be used together with classpath scan and binding extensions . extensionsOptional ( Class <?> ... extensionClasses ) Optional extension registration. The difference with .extensions is that such extensions will be automatically disabled if there are no compatible installers (instead of throwing exception). . bundles ( GuiceyBundle ... bundles ) Guicey bundles registration. . bundleLookup ( GuiceyBundleLookup bundleLookup ) Custom lookup mechanism for guicey bundles. By default, lookup by system property and ServiceLoader are enabled. To disable all look-ups use: . disableBundleLookup () . dropwizardBundles ( ConfiguredBundle ... bundles ) Shortcut for dropwizard bundles registration. This way guicey could apply disable and de-duplication rules to registered bundles (and, also, registered bundles appear in reports ) . searchCommands () Search and register custom dropwizard commands. Requires enabled classpath scan Disable items \u00b6 Registered configuration items could be disabled . This is mostly useful for tests where entire application parts could be disabled and replaced (e.g. with mocks) this way. Could be also useful to \"hack\" third party items. . disableInstallers ( Class <? extends FeatureInstaller > ... installers ) . disableExtensions ( Class <?> ... extensions ) . disableModules ( Class <? extends Module > ... modules ) Affects transitive guice modules . disableBundles ( Class <? extends GuiceyBundle > ... bundles ) . disableDropwizardBundles ( Class <? extends ConfiguredBundle > ... bundles ) Affects only dropwizard bundles registered through guicey api and their transitive bundles . disable ( Predicate < ItemInfo > ... predicates ) Custom disable predicate useful to disable groups of items (by some sign) Items de-duplication \u00b6 Guicey detects instances of the same type (bundles, modules). By default, two instances considered as duplicates if they are equal, so duplicates could be controlled with proper equals method implementation. When it's not possible, custom de-duplication implementation could be used. Tip Special base classes are available with correct equals implementations: UniqueModule (for guice modules) and UniqueGuiceyBundle (for bundles). . duplicateConfigDetector ( DuplicateConfigDetector detector ) Special implementation provided to replicate legacy guicey behaviour \"one instance per class\": duplicateConfigDetector ( new LegacyModeDuplicatesDetector ()) . uniqueItems ( Class <?> ... configurationItems ) Register special de-duplication implementation which will allow only one instance of provided types. Options \u00b6 Guicey generic options mechanism may be used for guicey (or other 3 rd party bundles) fine-tuning. Guicey option enums: GuiceyOptions and InstallersOptions . option ( K option , Object value ) Set option value (override default) . options ( Map < Enum , Object > options ) Set multiple options at once (e.g. map system properties as option values) GuiceyOptions \u00b6 Note Some options are configured through main bundle shortcut methods and so they are not shown in the table below. Option Type Default Description BindConfigurationByPath Boolean true Introspect configuration to be able to bind separate values TrackDropwizardBundles Boolean true Recognize transitive dropwizard bundles (for bundles registered through guicey api) AnalyzeGuiceModules Boolean true Extension recognition in guice bindings, transitive modules disable support GuiceFilterRegistration EnumSet<DispatcherType> [REQUEST] Guice filter registration options UseHkBridge Boolean false Activates HK2-guice bridge (bridge dependency must be available on the classpath) InstallersOptions \u00b6 Option Type Default Description DenyServletRegistrationWithClash Boolean false Throw error if @WebServlet annotated servlets clash with already registered servlets DenySessionListenersWithoutSession Boolean false Throw error for registered SessionListener (annotated @WebListener ) if sessions support not enabled (default) ForceSingletonForJerseyExtensions Boolean true Force singleton scope for registered jersey extensions (resources, exception handlers etc) if no explicit scope declared Injector \u00b6 . injectorFactory ( InjectorFactory injectorFactory ) Use custom injector factory implementation. May be useful for tests or for integration of 3 rd party library (like governator ) . build ( Stage stage ) Build bundle with custom guice stage (by default, Production ) . build () Build bundle with default guice stage Lifecycle \u00b6 . listen ( GuiceyLifecycleListener ... listeners ) Listen for guicey lifecycle events . noGuiceFilter () Disable GuiceFilter registration. This will remove guice request and session scopes and also it would become impossible to use ServletModule s . strictScopeControl () Explicitly detect when guice bean is instantiated with HK2 and vice versa. Bean target container is defined with @JerseyManaged and @GuiceManaged annotations or default (either guice or hk2 used as default (for jersey extensions)) . useHK2ForJerseyExtensions () Use HK2 by default for jersey extensions (change default). With this @GuiceManaged annotation may be used to override default for bean. Beans managed by HK2 can't use guice AOP, so AOP-based features will not work with such beans Danger In the next version guicey will get rid of HK2 and so all HK2 related options will be removed (only guice will be used). Also, .noGuiceFilter() will be removed because request scope will be required. Diagnostic tools \u00b6 Guicey provide many bundled console reports to help with problems diagnostic (or to simply clarify how application works) during development, like: . printDiagnosticInfo () See diagnostic section for a full list of available reports. Hooks-related \u00b6 . hookAlias ( String name , Class <? extends GuiceyConfigurationHook > hook ) Hook alias registration for simplified usage (various diagnostic tools quick enabling with a system property) . withSharedState ( Consumer < SharedConfigurationState > stateAction ) This method is mainly useful for hooks, because it's the only way to access application shared state from hook . Guicey bundle \u00b6 GuiceyBundle s are like dropwizard bundles, but with greater abilities . Supposed to be used instead of dropwizard bundles. Bundles are registered either directly (in main bundle or other guicey bundle) or resolved by bundles lookup. Initialization \u00b6 public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { ... } } Bundle initialization share many methods in common with main guice bundle : . modules ( Module ... modules ) . modulesOverride ( Module ... modules ) . installers ( Class <? extends FeatureInstaller > ... installers ) . extensions ( Class <?> ... extensionClasses ) . extensionsOptional ( Class <?> ... extensionClasses ) . bundles ( GuiceyBundle ... bundles ) . dropwizardBundles ( ConfiguredBundle ... bundles ) . disableInstallers ( Class <? extends FeatureInstaller > ... installers ) . disableExtensions ( Class <?> ... extensions ) . disableModules ( Class <? extends Module > ... modules ) No disable for bundles because at this moment some bundles were already executed and so real state could be inconsistent with configuration (and highly depend on processing order). . listen ( GuiceyLifecycleListener ... listeners ) Listener registered in bundle will \"hear\" only events starting with GuiceyLifecycle#BundlesInitialized Shortcuts: . bootstrap () . application () Option value access: . option ( T option ) Bundle can't declare option value because it would make options state not predictable (highly dependent on initialization order) Shared state access: . shareState ( Class <?> key , Object value ) Declare shared state ( primary module scenario) . sharedState ( Class <?> key , Supplier < T > defaultValue ) Get or init shared state ( equal bundles scenario) . sharedStateOrFail ( Class <?> key , String message , Object ... args ) Shortcut to get shared state or immediately fail if not declared Run \u00b6 public class MyBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) { ... } } Everything is configured under initialization phase. On run phase bundle allows only modules registration and extensions disable. Shortcuts: . configuration () . environment () . application () . register ( Object ... items ) Shortcut for environment (). jersey (). register ( Object ) . register ( Class <?> ... items ) Shortcut for environment (). jersey (). register ( Class ) . manage ( Managed managed ) Shortcut for environment (). lifecycle (). manage () . listenServer ( ServerLifecycleListener listener ) Shortcut for environment (). lifecycle (). addServerLifecycleListener () . listenJetty ( LifeCycle . Listener listener ) Shortcut for environment (). lifecycle (). addLifeCycleListener () Extended configuration access: . configuration ( String yamlPath ) . configuration ( Class < T > type ) . configurations ( Class < T > type ) . annotatedConfiguration ( ann ) . annotatedConfiguration ( Class ) . configurationTree () Modules registration: . modules ( Module ... modules ) Only here modules may be created directly with configuration values . modulesOverride ( Module ... modules ) Disables : . disableExtensions ( final Class <?> ... extensions ) . disableModules ( Class <? extends Module > ... modules ) Option value access: . option ( T option ) Shared state : . sharedStateOrFail ( Class <?> key , String message , Object ... args ) . sharedState ( Class <?> key ) Guicey listeners : . listen ( GuiceyLifecycleListener ... listeners ) Listener registered in run phase will \"hear\" only events starting with GuiceyLifecycle#BundlesStarted . onGuiceyStartup ( GuiceyStartupListener listener ) Shortcut for manual configuration under run phase with available injector . onApplicationStartup ( ApplicationStartupListener listener ) Shortcut for manual actions after complete application start (jetty started) It is also called after guicey initialization in lightweight guicey tests Hooks \u00b6 Guicey hooks are registered statically before main guice bundle registration: public class MyHook implements GuiceyConfigurationHook { @Override public void configure ( final GuiceBundle . Builder builder ) { builder . printDiagnosticInfo (); } } // static registration new MyHook (). register () On execution hook receives the same builder as used in main GuiceBundle . So hooks could configure everything . Hooks are intended to be used in tests and to implement a pluggable diagnostic tools activated with system property -Dguicey.hooks=... (as an example, see guicey DiagnosticHook ).","title":"Configuration"},{"location":"guide/configuration/#configuration","text":"Guicey main dropwizard bundle must be registered: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () // <configuration methods> . build ()); } Guicey could be configured through: Main (dropwizard) bundle Bundles Hooks","title":"Configuration"},{"location":"guide/configuration/#main-bundle","text":"Tip Bundle builder contains shortcuts for all guicey features, so required function may be found only by looking at available methods (and reading javadoc).","title":"Main bundle"},{"location":"guide/configuration/#configuration-items","text":". enableAutoConfig ( String ... basePackages ) Enable classpath scan for automatic extension registration, custom installers search and commands search (if enabled) . enableAutoConfig () Shortcut for enabling classpath scan on application package . modules ( Module ... modules ) Guice modules registration Here guice modules are created in initialization phase, when Configuration and Environment are not yet available. If they are required for module either use \"Aware\" interfaces or register module in GuiceyBundle's run method (under run phase). . modulesOverride ( Module ... modules ) Overriding registered guice modules bindings (using guice Modules.override() api) Extensions are not recognized in overriding modules (intentionally)! . installers ( Class <? extends FeatureInstaller > ... installers ) Guicey extension installers registration. Required if you have custom installers or to specify installers after disabling all default installers: . noDefaultInstallers () Custom installers are registered automatically when classpath scan is enabled. . extensions ( Class <?> ... extensionClasses ) Manual extension registration. May be used together with classpath scan and binding extensions . extensionsOptional ( Class <?> ... extensionClasses ) Optional extension registration. The difference with .extensions is that such extensions will be automatically disabled if there are no compatible installers (instead of throwing exception). . bundles ( GuiceyBundle ... bundles ) Guicey bundles registration. . bundleLookup ( GuiceyBundleLookup bundleLookup ) Custom lookup mechanism for guicey bundles. By default, lookup by system property and ServiceLoader are enabled. To disable all look-ups use: . disableBundleLookup () . dropwizardBundles ( ConfiguredBundle ... bundles ) Shortcut for dropwizard bundles registration. This way guicey could apply disable and de-duplication rules to registered bundles (and, also, registered bundles appear in reports ) . searchCommands () Search and register custom dropwizard commands. Requires enabled classpath scan","title":"Configuration items"},{"location":"guide/configuration/#disable-items","text":"Registered configuration items could be disabled . This is mostly useful for tests where entire application parts could be disabled and replaced (e.g. with mocks) this way. Could be also useful to \"hack\" third party items. . disableInstallers ( Class <? extends FeatureInstaller > ... installers ) . disableExtensions ( Class <?> ... extensions ) . disableModules ( Class <? extends Module > ... modules ) Affects transitive guice modules . disableBundles ( Class <? extends GuiceyBundle > ... bundles ) . disableDropwizardBundles ( Class <? extends ConfiguredBundle > ... bundles ) Affects only dropwizard bundles registered through guicey api and their transitive bundles . disable ( Predicate < ItemInfo > ... predicates ) Custom disable predicate useful to disable groups of items (by some sign)","title":"Disable items"},{"location":"guide/configuration/#items-de-duplication","text":"Guicey detects instances of the same type (bundles, modules). By default, two instances considered as duplicates if they are equal, so duplicates could be controlled with proper equals method implementation. When it's not possible, custom de-duplication implementation could be used. Tip Special base classes are available with correct equals implementations: UniqueModule (for guice modules) and UniqueGuiceyBundle (for bundles). . duplicateConfigDetector ( DuplicateConfigDetector detector ) Special implementation provided to replicate legacy guicey behaviour \"one instance per class\": duplicateConfigDetector ( new LegacyModeDuplicatesDetector ()) . uniqueItems ( Class <?> ... configurationItems ) Register special de-duplication implementation which will allow only one instance of provided types.","title":"Items de-duplication"},{"location":"guide/configuration/#options","text":"Guicey generic options mechanism may be used for guicey (or other 3 rd party bundles) fine-tuning. Guicey option enums: GuiceyOptions and InstallersOptions . option ( K option , Object value ) Set option value (override default) . options ( Map < Enum , Object > options ) Set multiple options at once (e.g. map system properties as option values)","title":"Options"},{"location":"guide/configuration/#guiceyoptions","text":"Note Some options are configured through main bundle shortcut methods and so they are not shown in the table below. Option Type Default Description BindConfigurationByPath Boolean true Introspect configuration to be able to bind separate values TrackDropwizardBundles Boolean true Recognize transitive dropwizard bundles (for bundles registered through guicey api) AnalyzeGuiceModules Boolean true Extension recognition in guice bindings, transitive modules disable support GuiceFilterRegistration EnumSet<DispatcherType> [REQUEST] Guice filter registration options UseHkBridge Boolean false Activates HK2-guice bridge (bridge dependency must be available on the classpath)","title":"GuiceyOptions"},{"location":"guide/configuration/#installersoptions","text":"Option Type Default Description DenyServletRegistrationWithClash Boolean false Throw error if @WebServlet annotated servlets clash with already registered servlets DenySessionListenersWithoutSession Boolean false Throw error for registered SessionListener (annotated @WebListener ) if sessions support not enabled (default) ForceSingletonForJerseyExtensions Boolean true Force singleton scope for registered jersey extensions (resources, exception handlers etc) if no explicit scope declared","title":"InstallersOptions"},{"location":"guide/configuration/#injector","text":". injectorFactory ( InjectorFactory injectorFactory ) Use custom injector factory implementation. May be useful for tests or for integration of 3 rd party library (like governator ) . build ( Stage stage ) Build bundle with custom guice stage (by default, Production ) . build () Build bundle with default guice stage","title":"Injector"},{"location":"guide/configuration/#lifecycle","text":". listen ( GuiceyLifecycleListener ... listeners ) Listen for guicey lifecycle events . noGuiceFilter () Disable GuiceFilter registration. This will remove guice request and session scopes and also it would become impossible to use ServletModule s . strictScopeControl () Explicitly detect when guice bean is instantiated with HK2 and vice versa. Bean target container is defined with @JerseyManaged and @GuiceManaged annotations or default (either guice or hk2 used as default (for jersey extensions)) . useHK2ForJerseyExtensions () Use HK2 by default for jersey extensions (change default). With this @GuiceManaged annotation may be used to override default for bean. Beans managed by HK2 can't use guice AOP, so AOP-based features will not work with such beans Danger In the next version guicey will get rid of HK2 and so all HK2 related options will be removed (only guice will be used). Also, .noGuiceFilter() will be removed because request scope will be required.","title":"Lifecycle"},{"location":"guide/configuration/#diagnostic-tools","text":"Guicey provide many bundled console reports to help with problems diagnostic (or to simply clarify how application works) during development, like: . printDiagnosticInfo () See diagnostic section for a full list of available reports.","title":"Diagnostic tools"},{"location":"guide/configuration/#hooks-related","text":". hookAlias ( String name , Class <? extends GuiceyConfigurationHook > hook ) Hook alias registration for simplified usage (various diagnostic tools quick enabling with a system property) . withSharedState ( Consumer < SharedConfigurationState > stateAction ) This method is mainly useful for hooks, because it's the only way to access application shared state from hook .","title":"Hooks-related"},{"location":"guide/configuration/#guicey-bundle","text":"GuiceyBundle s are like dropwizard bundles, but with greater abilities . Supposed to be used instead of dropwizard bundles. Bundles are registered either directly (in main bundle or other guicey bundle) or resolved by bundles lookup.","title":"Guicey bundle"},{"location":"guide/configuration/#initialization","text":"public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { ... } } Bundle initialization share many methods in common with main guice bundle : . modules ( Module ... modules ) . modulesOverride ( Module ... modules ) . installers ( Class <? extends FeatureInstaller > ... installers ) . extensions ( Class <?> ... extensionClasses ) . extensionsOptional ( Class <?> ... extensionClasses ) . bundles ( GuiceyBundle ... bundles ) . dropwizardBundles ( ConfiguredBundle ... bundles ) . disableInstallers ( Class <? extends FeatureInstaller > ... installers ) . disableExtensions ( Class <?> ... extensions ) . disableModules ( Class <? extends Module > ... modules ) No disable for bundles because at this moment some bundles were already executed and so real state could be inconsistent with configuration (and highly depend on processing order). . listen ( GuiceyLifecycleListener ... listeners ) Listener registered in bundle will \"hear\" only events starting with GuiceyLifecycle#BundlesInitialized Shortcuts: . bootstrap () . application () Option value access: . option ( T option ) Bundle can't declare option value because it would make options state not predictable (highly dependent on initialization order) Shared state access: . shareState ( Class <?> key , Object value ) Declare shared state ( primary module scenario) . sharedState ( Class <?> key , Supplier < T > defaultValue ) Get or init shared state ( equal bundles scenario) . sharedStateOrFail ( Class <?> key , String message , Object ... args ) Shortcut to get shared state or immediately fail if not declared","title":"Initialization"},{"location":"guide/configuration/#run","text":"public class MyBundle implements GuiceyBundle { @Override public void run ( GuiceyEnvironment environment ) { ... } } Everything is configured under initialization phase. On run phase bundle allows only modules registration and extensions disable. Shortcuts: . configuration () . environment () . application () . register ( Object ... items ) Shortcut for environment (). jersey (). register ( Object ) . register ( Class <?> ... items ) Shortcut for environment (). jersey (). register ( Class ) . manage ( Managed managed ) Shortcut for environment (). lifecycle (). manage () . listenServer ( ServerLifecycleListener listener ) Shortcut for environment (). lifecycle (). addServerLifecycleListener () . listenJetty ( LifeCycle . Listener listener ) Shortcut for environment (). lifecycle (). addLifeCycleListener () Extended configuration access: . configuration ( String yamlPath ) . configuration ( Class < T > type ) . configurations ( Class < T > type ) . annotatedConfiguration ( ann ) . annotatedConfiguration ( Class ) . configurationTree () Modules registration: . modules ( Module ... modules ) Only here modules may be created directly with configuration values . modulesOverride ( Module ... modules ) Disables : . disableExtensions ( final Class <?> ... extensions ) . disableModules ( Class <? extends Module > ... modules ) Option value access: . option ( T option ) Shared state : . sharedStateOrFail ( Class <?> key , String message , Object ... args ) . sharedState ( Class <?> key ) Guicey listeners : . listen ( GuiceyLifecycleListener ... listeners ) Listener registered in run phase will \"hear\" only events starting with GuiceyLifecycle#BundlesStarted . onGuiceyStartup ( GuiceyStartupListener listener ) Shortcut for manual configuration under run phase with available injector . onApplicationStartup ( ApplicationStartupListener listener ) Shortcut for manual actions after complete application start (jetty started) It is also called after guicey initialization in lightweight guicey tests","title":"Run"},{"location":"guide/configuration/#hooks","text":"Guicey hooks are registered statically before main guice bundle registration: public class MyHook implements GuiceyConfigurationHook { @Override public void configure ( final GuiceBundle . Builder builder ) { builder . printDiagnosticInfo (); } } // static registration new MyHook (). register () On execution hook receives the same builder as used in main GuiceBundle . So hooks could configure everything . Hooks are intended to be used in tests and to implement a pluggable diagnostic tools activated with system property -Dguicey.hooks=... (as an example, see guicey DiagnosticHook ).","title":"Hooks"},{"location":"guide/deduplication/","text":"Configuration de-duplication \u00b6 Guice modules, bundles and dropwizard bundles allow registration of multiple instance of the same type. For example: . modules ( new MyModule ( \"one\" ), new MyModule ( \"two\" )) Note Before, guice did not allow to register multiple modules of the same type, but multiple instances support is more logical in context of dropwizard, because dropwizard itself allows registration of multiple bundles of the same type. Duplicates \u00b6 But in some cases it is desirable to avoid such registrations. For example, if two bundles install the same common bundle it would be installed twice: public class Feature1Bundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ); } } public class Feature2Bundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ); } } GuiceBundle . buider () . bundles ( new Feature1Bundle (). new Feature2Bundle ()) ... To work around such cases deduplication mechanism* was introduced: instances of the same type are considered duplicate if they are equal. Equals method \u00b6 In order to resolve \"common bundle/module problem\" bundle/module must only properly implement equals method: public class CommonBundle implements GuiceyBundle { ... @Override public boolean equals ( final Object obj ) { return obj != null && getClass (). equals ( obj . getClass ()); } } Tip Guicey provide base classes for such cases: UniqueGuiceyBundle for unique bundles and UniqueModule (or UniqueDropwizardAwareModule ) for unique guice modules. So bundle above could be simplified to: public class CommonBundle extends UniqueGuiceyBundle { ... } Equals logic could be more complicated: for example, it may involve constructor parameters comparison to treat as duplicates only instances with the same parameters. Unique items \u00b6 When it is impossible to properly implement equals method (for example, because target bundle or module is 3 rd party) you can simply explicitly declare them as unique: GuiceBundle . builder () . uniqueItems ( Some3rdPartyBundle . class , Some3rdPartyModule . class ) Now only one instance of Some3rdPartyBundle and Some3rdPartyModule will be registered and all other instances considered as duplicate. General unique logic \u00b6 .uniqueItems() method above is actually a shortcut for custom deduplication mechanism registration (most common case). But you can implement your own deduplication logic and register with: GuiceBundle . builder () ... . duplicateConfigDetector (( List < Object > registered , Object newItem ) -> { if ( newItem isntanceof Some3rdPartyBundle ) { // decide if item collide with provided registered instances (of the same type) return detectedDuplicate // instance that registered is duplicate to or null to accept item } // allow instance registration return null ; }) Important This does not override equals method logic: custom de-duplication mechanism is called only after equals check. Warning You can't use .duplicateConfigDetector() and .uniqueItems() at the same time - one would override another (depends on order). In case of override you will only see warning in logs. Legacy mode \u00b6 Old guicey \"1 instance per class\" behaviour could be recovered with bundled detector: . duplicateConfigDetector ( new LegacyModeDuplicatesDetector ()) Reporting \u00b6 Configuration diagnostic report ( .printDiagnosticInfo() ) shows all registered instances and ignored duplicates. For example, if we have module declared to be unique by constructor value: public class VMod extends AbstractModule { private int value ; public VMod ( int value ) { this . value = value ; } @Override public boolean equals ( Object obj ) { return obj instanceof VMod && value . equals ( obj . value ); } } If modules are registered like this: GuiceBundle . builder () . modules ( new VMod ( 1 ), new VMod ( 1 ), new VMod ( 2 ), new VMod ( 2 )) . printDiagnosticInfo () . build () Report would contain: GUICE MODULES = VMod (com.mycompany) *REG(2/4) APPLICATION \u251c\u2500\u2500 module VMod (com.mycompany) \u251c\u2500\u2500 module -VMod (com.mycompany) *DUPLICATE \u251c\u2500\u2500 module VMod#2 (com.mycompany) \u251c\u2500\u2500 module -VMod#2 (com.mycompany) *DUPLICATE Where you can see that 2 of 4 registered modules of type VMod were registered. Note that instances are numbered (#2) in order of registration (without duplicates) so you can always see what bundle were considered as original (and see registration order when bundles of the same type are registered in different bundles). Limitations \u00b6 Guice modules \u00b6 Transitive guice modules are not counted during de-duplication. For example, public class MyModule extends AbstractModule {} public class SomeModule extends AbstractModule { @Override public void configure () { // transitive module install ( new MyModule ()); } } GuiceBindle . builder () . modules ( new OtherModule (), new MyModule ()) . uniqueItems ( MyModule . class ) This will not work because guicey is not aware of transitive modules (guicey can only know modules tree on class level, but can't see exact instances). BUT guice natively support de-duplication of equal modules , so if your module have proper equals public class MyModule extends UniqueModule {} Then guice will perform de-duplication itself. Warning Guice will perform de-duplication itself only if both equals and hashCode properly implemented (like in UniqueModule ) Note Guice can also de-duplicate bindings : if bindings from different module instances are the same then guice will simply ignore duplicate bindings. Dropwizard bundles \u00b6 Guicey can see transitive dropwizard bundles and properly apply de-duplication logic. For example, public class MyBundle implements ConfiguredBundle {} public class OtherBundle implements ConfiguredBundle { @Override public void initialize ( Bootstrap bootstrap ) { // transitive bundle bootstrap . addBundle ( new MyBundle ()); } } GuiceBindle . builder () . dropwizardBundles ( new OtherBundle (), new MyBundle ()) . uniqueItems ( MyBundle . class ) This will work because guicey use special proxy to intercept transitive registrations (so, essentially, transitive registrations are treated the same as direct) Note This means that if you have \"common dropwizard bundle\" problem, then you can simply register it with guicey and it will be able to properly de-duplicate it. BUT guicey does not \"see\" directly installed bundles (intentionally!). For example, bootstrap . addBundle ( new MyBundle ()) bootstrap . addBundle ( GuiceBindle . builder () . dropwizardBundles ( new OtherBundle ()) . uniqueItems ( MyBundle . class ) . build ()) This will not work because guicey see only directly registered bundles: OtherBundle and transitive MyBundle , and so MyBundle would be registered twice.","title":"De-duplication"},{"location":"guide/deduplication/#configuration-de-duplication","text":"Guice modules, bundles and dropwizard bundles allow registration of multiple instance of the same type. For example: . modules ( new MyModule ( \"one\" ), new MyModule ( \"two\" )) Note Before, guice did not allow to register multiple modules of the same type, but multiple instances support is more logical in context of dropwizard, because dropwizard itself allows registration of multiple bundles of the same type.","title":"Configuration de-duplication"},{"location":"guide/deduplication/#duplicates","text":"But in some cases it is desirable to avoid such registrations. For example, if two bundles install the same common bundle it would be installed twice: public class Feature1Bundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ); } } public class Feature2Bundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . bundles ( new CommonBundle ); } } GuiceBundle . buider () . bundles ( new Feature1Bundle (). new Feature2Bundle ()) ... To work around such cases deduplication mechanism* was introduced: instances of the same type are considered duplicate if they are equal.","title":"Duplicates"},{"location":"guide/deduplication/#equals-method","text":"In order to resolve \"common bundle/module problem\" bundle/module must only properly implement equals method: public class CommonBundle implements GuiceyBundle { ... @Override public boolean equals ( final Object obj ) { return obj != null && getClass (). equals ( obj . getClass ()); } } Tip Guicey provide base classes for such cases: UniqueGuiceyBundle for unique bundles and UniqueModule (or UniqueDropwizardAwareModule ) for unique guice modules. So bundle above could be simplified to: public class CommonBundle extends UniqueGuiceyBundle { ... } Equals logic could be more complicated: for example, it may involve constructor parameters comparison to treat as duplicates only instances with the same parameters.","title":"Equals method"},{"location":"guide/deduplication/#unique-items","text":"When it is impossible to properly implement equals method (for example, because target bundle or module is 3 rd party) you can simply explicitly declare them as unique: GuiceBundle . builder () . uniqueItems ( Some3rdPartyBundle . class , Some3rdPartyModule . class ) Now only one instance of Some3rdPartyBundle and Some3rdPartyModule will be registered and all other instances considered as duplicate.","title":"Unique items"},{"location":"guide/deduplication/#general-unique-logic","text":".uniqueItems() method above is actually a shortcut for custom deduplication mechanism registration (most common case). But you can implement your own deduplication logic and register with: GuiceBundle . builder () ... . duplicateConfigDetector (( List < Object > registered , Object newItem ) -> { if ( newItem isntanceof Some3rdPartyBundle ) { // decide if item collide with provided registered instances (of the same type) return detectedDuplicate // instance that registered is duplicate to or null to accept item } // allow instance registration return null ; }) Important This does not override equals method logic: custom de-duplication mechanism is called only after equals check. Warning You can't use .duplicateConfigDetector() and .uniqueItems() at the same time - one would override another (depends on order). In case of override you will only see warning in logs.","title":"General unique logic"},{"location":"guide/deduplication/#legacy-mode","text":"Old guicey \"1 instance per class\" behaviour could be recovered with bundled detector: . duplicateConfigDetector ( new LegacyModeDuplicatesDetector ())","title":"Legacy mode"},{"location":"guide/deduplication/#reporting","text":"Configuration diagnostic report ( .printDiagnosticInfo() ) shows all registered instances and ignored duplicates. For example, if we have module declared to be unique by constructor value: public class VMod extends AbstractModule { private int value ; public VMod ( int value ) { this . value = value ; } @Override public boolean equals ( Object obj ) { return obj instanceof VMod && value . equals ( obj . value ); } } If modules are registered like this: GuiceBundle . builder () . modules ( new VMod ( 1 ), new VMod ( 1 ), new VMod ( 2 ), new VMod ( 2 )) . printDiagnosticInfo () . build () Report would contain: GUICE MODULES = VMod (com.mycompany) *REG(2/4) APPLICATION \u251c\u2500\u2500 module VMod (com.mycompany) \u251c\u2500\u2500 module -VMod (com.mycompany) *DUPLICATE \u251c\u2500\u2500 module VMod#2 (com.mycompany) \u251c\u2500\u2500 module -VMod#2 (com.mycompany) *DUPLICATE Where you can see that 2 of 4 registered modules of type VMod were registered. Note that instances are numbered (#2) in order of registration (without duplicates) so you can always see what bundle were considered as original (and see registration order when bundles of the same type are registered in different bundles).","title":"Reporting"},{"location":"guide/deduplication/#limitations","text":"","title":"Limitations"},{"location":"guide/deduplication/#guice-modules","text":"Transitive guice modules are not counted during de-duplication. For example, public class MyModule extends AbstractModule {} public class SomeModule extends AbstractModule { @Override public void configure () { // transitive module install ( new MyModule ()); } } GuiceBindle . builder () . modules ( new OtherModule (), new MyModule ()) . uniqueItems ( MyModule . class ) This will not work because guicey is not aware of transitive modules (guicey can only know modules tree on class level, but can't see exact instances). BUT guice natively support de-duplication of equal modules , so if your module have proper equals public class MyModule extends UniqueModule {} Then guice will perform de-duplication itself. Warning Guice will perform de-duplication itself only if both equals and hashCode properly implemented (like in UniqueModule ) Note Guice can also de-duplicate bindings : if bindings from different module instances are the same then guice will simply ignore duplicate bindings.","title":"Guice modules"},{"location":"guide/deduplication/#dropwizard-bundles","text":"Guicey can see transitive dropwizard bundles and properly apply de-duplication logic. For example, public class MyBundle implements ConfiguredBundle {} public class OtherBundle implements ConfiguredBundle { @Override public void initialize ( Bootstrap bootstrap ) { // transitive bundle bootstrap . addBundle ( new MyBundle ()); } } GuiceBindle . builder () . dropwizardBundles ( new OtherBundle (), new MyBundle ()) . uniqueItems ( MyBundle . class ) This will work because guicey use special proxy to intercept transitive registrations (so, essentially, transitive registrations are treated the same as direct) Note This means that if you have \"common dropwizard bundle\" problem, then you can simply register it with guicey and it will be able to properly de-duplicate it. BUT guicey does not \"see\" directly installed bundles (intentionally!). For example, bootstrap . addBundle ( new MyBundle ()) bootstrap . addBundle ( GuiceBindle . builder () . dropwizardBundles ( new OtherBundle ()) . uniqueItems ( MyBundle . class ) . build ()) This will not work because guicey see only directly registered bundles: OtherBundle and transitive MyBundle , and so MyBundle would be registered twice.","title":"Dropwizard bundles"},{"location":"guide/disables/","text":"Disables \u00b6 Guicey allows disabling (removing) of any registered configuration items: Extensions Installers Guice modules Bundles Dropwizard bundles This is mostly useful in tests, where you can easily modify application context (replacing entire application parts with hooks ). But it also could be used for workarounds: when 3 rd party item contains bug or does not fit well - it could be always disabled and replaced by different item. For example, bundle may register some other optional bundle, which you doesn't need - it could be simply disabled to avoid installation. Note It doesn't matter if item was already registered or not (in time of disabling). Item may not be registered at all. Disables are available in main bundle and in guicey bundles . Warning Disable is performed by class, so disabling modules and bundles disables all instances of type. The only way to disable exact instance is to use disable by predicate . Disable extensions \u00b6 . disableExtensions ( ExtensionOne . class , ExtensionTwo . class ) It doesn't matter if extension was already registered or not (it may be not registered at all) or what source used (manual, classpath scan or binding). Note Extension disable will work for extensions, declared in guice modules! In this case guicey will simply remove such binding. Tip Extension disable may be also used when classpath scanner detected class you don't need to be installed and you can't use @InvisibleForScanner annotation on it. Generally, all configuration must appear under initialization phase, but it is allowed to disable extensions under run phase inside guicey bundle to be able to disable features by configuration values (because it's almost never possible to not register, based on configuration values, so disables is the only way to switch off features, based on configuration). Disable installers \u00b6 . disableInstallers ( ManagedInstaller . class , ResourceInstaller . class ) Installer is the core guicey concept because installers implement dropwizard integration - properly register guice beans in dropwizard. It may appear that existing installer does not fit your needs or simply contains bug. You can easily remove it and register replacement (probably fixed version): GuiceBundle . builder () ... . disableInstallers ( ResourceInstaller . class ) . installers ( CustomizedResourceInstaller . class ) Tip Custom installers are detected automatically by classpath scan (if enabled). This could also be used to change installers order (declared with @Order annotation on each installer). Disable guice modules \u00b6 . disableInstallers ( ModleOne . class , ModuleTwo . class ) Disabling affects both normal ( .modules() ) and overriding ( .modulesOverride() ) modules. Important Disabling affect transitive modules! public class MyModule extends AbstractModule { @Override public void configure () { install ( new TransitiveModule ()); } } GuiceBindle . builder () . disableModules ( TrannsitiveModule . clas ) ... Will remove TransitiveModule (actually, guicey will remove all bindings of this module, but result is the same) Modules disable could be used to prevent some additional module installation by 3 rd party bundle (or to override such module). Disable bundles \u00b6 Guicey bundles could be disabled only in main bundle , because bundle must be disabled before it's execution and transitive bundles are registered during execution (so disable may appear too late) . disableBundles ( MyBundle . class ) Could be used to disable some not required transitive bundle, installed by 3 rd party bundle. Disable dropwizard bundles \u00b6 . disableDropwizardBundles ( MyBundle . class ) Warning Only bundles registered through guicey api could be disabled! bootstrap . addBundle ( new MyBundle ()) bootstrap . addBundle ( GuiceBindle . builder () . disableDropwizardBundles ( MyBundle . class ) . build ()) Disable wIll not work becuase MyBundle is not registered through guicey api. Important Disable affects transitive bundles! public class MyBundle implements ConfiguredBundle { @Override public void initialize ( Bootstrap bootstrap ) { bootstrap . addBundle ( new TransitiveBundle ()); } } GuiceBindle . builder () . disableDropwizardBundles ( TransitiveBundle . class ) ... Will remove TransitiveBundle (this works due to bootsrap object proxying for bundles registered through guicey api). Disable by predicate \u00b6 There is also a generic disable method using predicate. With it you can disable items (bundles, modules, installers, extensions) by package or by installation bundle or some other custom condition (e.g. introduce your disabling annotation and handle it with predicate). Note This is the only way to register exact module or bundle instance (if you have multiple items of the same type). import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( inPackage ( \"com.foo.feature\" , \"com.foo.feature2\" )); Disable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module. If you use package by feature approach then you can easily switch off entire features in tests. import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( installer () . and ( registeredBy ( Application . class )) . and ( type ( SomeInstallerType . class ). negate ()); Disable all installers, directly registered in main bundle except SomeInstallerType import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( type ( MyExtension . class , MyInstaller . class , MyBundle . class , MyModule . class )); Simply disable items by type. The condition is java Predicate . Use Predicate#and(Predicate) , Predicate#or(Predicate) and Predicate#negate() to compose complex conditions from simple ones. Most common predicates could be build with ru.vyarus.dropwizard.guice.module.context.Disables utility (examples above). Reporting \u00b6 Configuration diagnostic report ( .printDiagnosticInfo() ) shows all disables and disabled items. For example: \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) ... \u251c\u2500\u2500 installer -LifeCycleInstaller (r.v.d.g.m.i.feature) *DISABLED","title":"Disables"},{"location":"guide/disables/#disables","text":"Guicey allows disabling (removing) of any registered configuration items: Extensions Installers Guice modules Bundles Dropwizard bundles This is mostly useful in tests, where you can easily modify application context (replacing entire application parts with hooks ). But it also could be used for workarounds: when 3 rd party item contains bug or does not fit well - it could be always disabled and replaced by different item. For example, bundle may register some other optional bundle, which you doesn't need - it could be simply disabled to avoid installation. Note It doesn't matter if item was already registered or not (in time of disabling). Item may not be registered at all. Disables are available in main bundle and in guicey bundles . Warning Disable is performed by class, so disabling modules and bundles disables all instances of type. The only way to disable exact instance is to use disable by predicate .","title":"Disables"},{"location":"guide/disables/#disable-extensions","text":". disableExtensions ( ExtensionOne . class , ExtensionTwo . class ) It doesn't matter if extension was already registered or not (it may be not registered at all) or what source used (manual, classpath scan or binding). Note Extension disable will work for extensions, declared in guice modules! In this case guicey will simply remove such binding. Tip Extension disable may be also used when classpath scanner detected class you don't need to be installed and you can't use @InvisibleForScanner annotation on it. Generally, all configuration must appear under initialization phase, but it is allowed to disable extensions under run phase inside guicey bundle to be able to disable features by configuration values (because it's almost never possible to not register, based on configuration values, so disables is the only way to switch off features, based on configuration).","title":"Disable extensions"},{"location":"guide/disables/#disable-installers","text":". disableInstallers ( ManagedInstaller . class , ResourceInstaller . class ) Installer is the core guicey concept because installers implement dropwizard integration - properly register guice beans in dropwizard. It may appear that existing installer does not fit your needs or simply contains bug. You can easily remove it and register replacement (probably fixed version): GuiceBundle . builder () ... . disableInstallers ( ResourceInstaller . class ) . installers ( CustomizedResourceInstaller . class ) Tip Custom installers are detected automatically by classpath scan (if enabled). This could also be used to change installers order (declared with @Order annotation on each installer).","title":"Disable installers"},{"location":"guide/disables/#disable-guice-modules","text":". disableInstallers ( ModleOne . class , ModuleTwo . class ) Disabling affects both normal ( .modules() ) and overriding ( .modulesOverride() ) modules. Important Disabling affect transitive modules! public class MyModule extends AbstractModule { @Override public void configure () { install ( new TransitiveModule ()); } } GuiceBindle . builder () . disableModules ( TrannsitiveModule . clas ) ... Will remove TransitiveModule (actually, guicey will remove all bindings of this module, but result is the same) Modules disable could be used to prevent some additional module installation by 3 rd party bundle (or to override such module).","title":"Disable guice modules"},{"location":"guide/disables/#disable-bundles","text":"Guicey bundles could be disabled only in main bundle , because bundle must be disabled before it's execution and transitive bundles are registered during execution (so disable may appear too late) . disableBundles ( MyBundle . class ) Could be used to disable some not required transitive bundle, installed by 3 rd party bundle.","title":"Disable bundles"},{"location":"guide/disables/#disable-dropwizard-bundles","text":". disableDropwizardBundles ( MyBundle . class ) Warning Only bundles registered through guicey api could be disabled! bootstrap . addBundle ( new MyBundle ()) bootstrap . addBundle ( GuiceBindle . builder () . disableDropwizardBundles ( MyBundle . class ) . build ()) Disable wIll not work becuase MyBundle is not registered through guicey api. Important Disable affects transitive bundles! public class MyBundle implements ConfiguredBundle { @Override public void initialize ( Bootstrap bootstrap ) { bootstrap . addBundle ( new TransitiveBundle ()); } } GuiceBindle . builder () . disableDropwizardBundles ( TransitiveBundle . class ) ... Will remove TransitiveBundle (this works due to bootsrap object proxying for bundles registered through guicey api).","title":"Disable dropwizard bundles"},{"location":"guide/disables/#disable-by-predicate","text":"There is also a generic disable method using predicate. With it you can disable items (bundles, modules, installers, extensions) by package or by installation bundle or some other custom condition (e.g. introduce your disabling annotation and handle it with predicate). Note This is the only way to register exact module or bundle instance (if you have multiple items of the same type). import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( inPackage ( \"com.foo.feature\" , \"com.foo.feature2\" )); Disable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module. If you use package by feature approach then you can easily switch off entire features in tests. import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( installer () . and ( registeredBy ( Application . class )) . and ( type ( SomeInstallerType . class ). negate ()); Disable all installers, directly registered in main bundle except SomeInstallerType import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( type ( MyExtension . class , MyInstaller . class , MyBundle . class , MyModule . class )); Simply disable items by type. The condition is java Predicate . Use Predicate#and(Predicate) , Predicate#or(Predicate) and Predicate#negate() to compose complex conditions from simple ones. Most common predicates could be build with ru.vyarus.dropwizard.guice.module.context.Disables utility (examples above).","title":"Disable by predicate"},{"location":"guide/disables/#reporting","text":"Configuration diagnostic report ( .printDiagnosticInfo() ) shows all disables and disabled items. For example: \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) ... \u251c\u2500\u2500 installer -LifeCycleInstaller (r.v.d.g.m.i.feature) *DISABLED","title":"Reporting"},{"location":"guide/events/","text":"Guicey lifecycle events \u00b6 Guicey broadcast lifecycle events in all major points. Each event provides access to all available state at this point. Events could be used for configuration analysis, reporting or to add some special post processing for configuration items (e.g. post process modules before injector creation). Important Event listeners could not modify configuration itself (can't add new extensions, installers, bundles or disable anything). Events \u00b6 All events are listed in GuiceyLifecycle enum (in execution order). Event Description Possible usage Dropwizard initialization phase ConfigurationHooksProcessed ? Called after all registered hooks processing. Not called when no hooks used. Only for info DropwizardBundlesInitialized ? Called after dropwizard bundles initialization (for dropwizard bundles registered through guicey api). Not called if no bundles were registered. Logging, bundle instances modification (to affect run method) BundlesFromLookupResolved ? Called after resolution bundles through lookup mechanism. Not called if no bundles found. Logging or post processing of found bundles. BundlesResolved Called with all known top-level bundles (transitive bundles are not yet known). Always called to indicate configuration state. Could be used to modify top-level bundle instances BundlesInitialized ? Called after all bundles initialization (including transitive, so list of bundles could be bigger). Not called when no bundles registered. Logging, post processing CommandsResolved ? Called if commands search is enabled and at least one command found Logging InstallersResolved Called when all configured (and resolved by classpath scan) installers initialized Potentially could be used to configure installer instances ManualExtensionsValidated ? Called when all manually registered extension classes are recognized by installers (validated). But only extensions, known to be enabled at that time are actually validated (this way it is possible to exclude extensions for non existing installers). Called only if at least one manual extension registered. Logging, assertions ClasspathExtensionsResolved ? Called when classes from classpath scan analyzed and all extensions detected (if extension is also registered manually it would be also counted as from classpath scan). Called only if classpath scan is enabled and at least one extension detected. Logging, assertions Initialized Meta event, called after GuiceBundle initialization (most of configuration done). Pure marker event, indicating guicey work finished under dropwizard configuration phase. Last chance to modify Bootstrap Dropwizard run phase BeforeRun Meta event, called before any guicey actions just to indicate first point where Environment, Configuration and introspected configuration are available For example, used by bundle.printConfigurationBindings() to print configuration bindings before injector start (help with missed bindings debug) BundlesStarted ? Called after bundles start (run method call). Not called if no bundles were used at all. Called only if bindings analysis is not disabled. Logging ModulesAnalyzed Called after guice modules analysis and repackaging. Reveals all detected extensions and removed bindings info. Logging, analysis validation logic ExtensionsResolved Called to indicate all enabled extensions (manual, from classpath scan and modules). Always called to indicate configuration state. Logging or remembering list of all enabled extensions (classes only) InjectorCreation Called just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called. Logging. Note that it is useless to modify module instance here, because they were already processed. Guice injector created ExtensionsInstalledBy Called when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later. Logging of installed extensions. Extension instance could be obtained from injector and post processed. ExtensionsInstalled ? Called after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled) Logging or extensions post processing ApplicationRun Meta event, called when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty would be started yet) and all guice singletons initialized. At this point injection to registered commands is performed (this may be important if custom command run application instead of \"server\"). Point is just before Application.run method. Ideal point for jersey and jetty listeners installation (with shortcut methods in event). Jersey initialization JerseyConfiguration Jersey context starting. Both jersey and jetty are starting. First point where jersey's InjectionManager (and ServiceLocator ) become available JerseyExtensionsInstalledBy Called when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty) Logging of installed extensions. Extension instance could be obtained from injector/locator and post processed. JerseyExtensionsInstalled ? Called after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions) Logging or extensions post processing ApplicationStarted Meta event, called after complete dropwizard startup. This event also will be fired in guicey lightweight tests May be used as assured \"started\" point (after all initializations). For example, for reporting. ApplicationShutdown Meta event, called on server shutdown start. This event also will be fired in guicey lightweight tests May be used for shutdown logic. ApplicationStoppedEvent Meta event, called after application shutdown. This event also will be fired in guicey lightweight tests May be used in rare cases to cleanup fs resources after application stop. ? - event may not be called Listeners \u00b6 Events listener registration: GuiceBundle . builder () . listen ( new MyListener (), new MyOtherListener ()) ... . build () Note Listeners could be also registered in guicey bundle, but they will not receive all events: >= BundlesInitialized for listeners registered in initialization method >= BundlesStarted for listeners registered in run method Event listener could implement generic event interface GuiceyLifecycleListener and use enum to differentiate required events: public class MyListener implements GuiceyLifecycleListener { public void onEvent ( GuiceyLifecycleEvent event ) { switch ( event . getType ()) { case InjectorCreation : InjectorCreationEvent e = ( InjectorCreationEvent ) event ; ... } } } Or use GuiceyLifecycleAdapter adapter and override only required methods: public class MyListener extends GuiceyLifecycleAdapter { @Override protected void injectorCreation ( final InjectorCreationEvent event ) { ... } } Tip In ApplicationStarted and ApplicationShutdown events lightweight guicey test environment may be differentiated from real server startup with .isJettyStarted() method. De-duplication \u00b6 Event listeners are also support de-duplication to prevent unnecessary duplicates usage (for example, two bundles may register one listener because they are not always used together). But it is not the same mechanism as configuration items de-duplication. Simply listeners are registered in the LinkedHashSet and so listeners could control de-duplication with a proper equals and hashCode implementations Many reports use this feature (because all of them are based on listeners). For example, diagnostic report use the following implementations: @Override public boolean equals ( final Object obj ) { // allow only one instance with the same title return obj instanceof ConfigurationDiagnostic && reportTitle . equals ((( ConfigurationDiagnostic ) obj ). reportTitle ); } @Override public int hashCode () { return reportTitle . hashCode (); } And with it, .printDiagnosticInfo() can be called multiple times and still only one report will be actually printed. Events hierarchy \u00b6 All event classes inherit from some base event classes. Base event classes are extending each other: as lifecycle phases go, more objects become available. So you can access any available (at this point) object from event instance. Base event Description GuiceyLifecycleEvent The lowest event type. Provides access to event type and options. ConfigurationPhaseEvent Initialization phase event. Provides access to Bootstrap. RunPhaseEvent Dropwizard run phase. Provides access to Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer InjectorPhaseEvent Guice injector created. Available injector and GuiceyConfigurationInfo (guicey configuration). Shortcuts for configuration reports renderer JerseyPhaseEvent Jersey starting. Jersey's InjectionManager available.","title":"Events"},{"location":"guide/events/#guicey-lifecycle-events","text":"Guicey broadcast lifecycle events in all major points. Each event provides access to all available state at this point. Events could be used for configuration analysis, reporting or to add some special post processing for configuration items (e.g. post process modules before injector creation). Important Event listeners could not modify configuration itself (can't add new extensions, installers, bundles or disable anything).","title":"Guicey lifecycle events"},{"location":"guide/events/#events","text":"All events are listed in GuiceyLifecycle enum (in execution order). Event Description Possible usage Dropwizard initialization phase ConfigurationHooksProcessed ? Called after all registered hooks processing. Not called when no hooks used. Only for info DropwizardBundlesInitialized ? Called after dropwizard bundles initialization (for dropwizard bundles registered through guicey api). Not called if no bundles were registered. Logging, bundle instances modification (to affect run method) BundlesFromLookupResolved ? Called after resolution bundles through lookup mechanism. Not called if no bundles found. Logging or post processing of found bundles. BundlesResolved Called with all known top-level bundles (transitive bundles are not yet known). Always called to indicate configuration state. Could be used to modify top-level bundle instances BundlesInitialized ? Called after all bundles initialization (including transitive, so list of bundles could be bigger). Not called when no bundles registered. Logging, post processing CommandsResolved ? Called if commands search is enabled and at least one command found Logging InstallersResolved Called when all configured (and resolved by classpath scan) installers initialized Potentially could be used to configure installer instances ManualExtensionsValidated ? Called when all manually registered extension classes are recognized by installers (validated). But only extensions, known to be enabled at that time are actually validated (this way it is possible to exclude extensions for non existing installers). Called only if at least one manual extension registered. Logging, assertions ClasspathExtensionsResolved ? Called when classes from classpath scan analyzed and all extensions detected (if extension is also registered manually it would be also counted as from classpath scan). Called only if classpath scan is enabled and at least one extension detected. Logging, assertions Initialized Meta event, called after GuiceBundle initialization (most of configuration done). Pure marker event, indicating guicey work finished under dropwizard configuration phase. Last chance to modify Bootstrap Dropwizard run phase BeforeRun Meta event, called before any guicey actions just to indicate first point where Environment, Configuration and introspected configuration are available For example, used by bundle.printConfigurationBindings() to print configuration bindings before injector start (help with missed bindings debug) BundlesStarted ? Called after bundles start (run method call). Not called if no bundles were used at all. Called only if bindings analysis is not disabled. Logging ModulesAnalyzed Called after guice modules analysis and repackaging. Reveals all detected extensions and removed bindings info. Logging, analysis validation logic ExtensionsResolved Called to indicate all enabled extensions (manual, from classpath scan and modules). Always called to indicate configuration state. Logging or remembering list of all enabled extensions (classes only) InjectorCreation Called just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called. Logging. Note that it is useless to modify module instance here, because they were already processed. Guice injector created ExtensionsInstalledBy Called when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later. Logging of installed extensions. Extension instance could be obtained from injector and post processed. ExtensionsInstalled ? Called after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled) Logging or extensions post processing ApplicationRun Meta event, called when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty would be started yet) and all guice singletons initialized. At this point injection to registered commands is performed (this may be important if custom command run application instead of \"server\"). Point is just before Application.run method. Ideal point for jersey and jetty listeners installation (with shortcut methods in event). Jersey initialization JerseyConfiguration Jersey context starting. Both jersey and jetty are starting. First point where jersey's InjectionManager (and ServiceLocator ) become available JerseyExtensionsInstalledBy Called when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty) Logging of installed extensions. Extension instance could be obtained from injector/locator and post processed. JerseyExtensionsInstalled ? Called after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions) Logging or extensions post processing ApplicationStarted Meta event, called after complete dropwizard startup. This event also will be fired in guicey lightweight tests May be used as assured \"started\" point (after all initializations). For example, for reporting. ApplicationShutdown Meta event, called on server shutdown start. This event also will be fired in guicey lightweight tests May be used for shutdown logic. ApplicationStoppedEvent Meta event, called after application shutdown. This event also will be fired in guicey lightweight tests May be used in rare cases to cleanup fs resources after application stop. ? - event may not be called","title":"Events"},{"location":"guide/events/#listeners","text":"Events listener registration: GuiceBundle . builder () . listen ( new MyListener (), new MyOtherListener ()) ... . build () Note Listeners could be also registered in guicey bundle, but they will not receive all events: >= BundlesInitialized for listeners registered in initialization method >= BundlesStarted for listeners registered in run method Event listener could implement generic event interface GuiceyLifecycleListener and use enum to differentiate required events: public class MyListener implements GuiceyLifecycleListener { public void onEvent ( GuiceyLifecycleEvent event ) { switch ( event . getType ()) { case InjectorCreation : InjectorCreationEvent e = ( InjectorCreationEvent ) event ; ... } } } Or use GuiceyLifecycleAdapter adapter and override only required methods: public class MyListener extends GuiceyLifecycleAdapter { @Override protected void injectorCreation ( final InjectorCreationEvent event ) { ... } } Tip In ApplicationStarted and ApplicationShutdown events lightweight guicey test environment may be differentiated from real server startup with .isJettyStarted() method.","title":"Listeners"},{"location":"guide/events/#de-duplication","text":"Event listeners are also support de-duplication to prevent unnecessary duplicates usage (for example, two bundles may register one listener because they are not always used together). But it is not the same mechanism as configuration items de-duplication. Simply listeners are registered in the LinkedHashSet and so listeners could control de-duplication with a proper equals and hashCode implementations Many reports use this feature (because all of them are based on listeners). For example, diagnostic report use the following implementations: @Override public boolean equals ( final Object obj ) { // allow only one instance with the same title return obj instanceof ConfigurationDiagnostic && reportTitle . equals ((( ConfigurationDiagnostic ) obj ). reportTitle ); } @Override public int hashCode () { return reportTitle . hashCode (); } And with it, .printDiagnosticInfo() can be called multiple times and still only one report will be actually printed.","title":"De-duplication"},{"location":"guide/events/#events-hierarchy","text":"All event classes inherit from some base event classes. Base event classes are extending each other: as lifecycle phases go, more objects become available. So you can access any available (at this point) object from event instance. Base event Description GuiceyLifecycleEvent The lowest event type. Provides access to event type and options. ConfigurationPhaseEvent Initialization phase event. Provides access to Bootstrap. RunPhaseEvent Dropwizard run phase. Provides access to Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer InjectorPhaseEvent Guice injector created. Available injector and GuiceyConfigurationInfo (guicey configuration). Shortcuts for configuration reports renderer JerseyPhaseEvent Jersey starting. Jersey's InjectionManager available.","title":"Events hierarchy"},{"location":"guide/extensions/","text":"Extensions \u00b6 Extensions mechanism supposed to be used in guicey for all dropwizard specific features registration (instead of manual registrations). All extensions are recognized and installed with appropriate installer . This page supposed to reference declaration examples of most common extensions. See installers section for details. Warning Extension is recognized only by one installer (according to installers order), even if it contains multiple signs! See installers report for installers order. Declaration sources: Classpath scan Manual declaration Guice binding Tip More installers (and so supported extensions types) could be available due to installed extension bundles . Use installers report to see all available installers. Some extensins support order declaration with @Order() - see report. Note If you have problems with injection inside extensions (NPE errors) first check that you did not register extension manually! It is a quite often mistake (especially with jersey extensions): environment . jersey (). register ( new MyResource ()) This way MyResource will not be managed by guice and so injections inside it will not work Use constructor injection to prevent such errors (manual places will reveal immediately): @Path ( \"/\" ) public class MyResource { private final MyService service ; @Inject public MyResource ( MyService service ) { this . service = service ; } } Resource \u00b6 @Path ( \"/res\" ) @Produces ( ' application / json ' ) @Singleton class SampleResource { @Inject private MyService service ; @GET @Path ( \"/sample\" ) public Response sample () { return Response . ok ( service . result ()). build (); } } Recognized by @Path annotation on class or implemented interface. Task \u00b6 @Singleton public class MyTask extends Task { @Inject private MyService service ; public TruncateDatabaseTask () { super ( \"mytask\" ); } @Override public void execute ( ImmutableMultimap < String , String > parameters , PrintWriter output ) throws Exception { service . doSomething (); } } Recognized by base Task class. Managed \u00b6 @Singleton public class MyService implements Managed { @Override public void start () throws Exception { ... } @Override public void stop () throws Exception { ... } } Recognized by Managed base class. Health check \u00b6 @Singleton public class MyHealthCheck extends NamedHealthCheck { @Inject private MyService service ; @Override protected Result check () throws Exception { if ( service . isOk ()) { return Result . healthy (); } else { return Result . unhealthy ( \"Service is not ok\" ); } } @Override public String getName () { return \"my-service\" ; } } Recognized by base NamedHealthCheck class. Custom guicey base class used because it would be impossible to automatically register health check without name. Jersey extensions \u00b6 All jersey extensions are recognized by javax.ws.rs.ext.Provider jersey annotation. There are many extensions supported. @Provider @Singleton public class DummyExceptionMapper implements ExceptionMapper < RuntimeException > { private final Logger logger = LoggerFactory . getLogger ( DummyExceptionMapper . class ); @Override public Response toResponse ( RuntimeException e ) { logger . debug ( \"Problem while executing\" , e ); return Response . status ( Response . Status . BAD_REQUEST ) . type ( MediaType . TEXT_PLAIN ) . entity ( e . getMessage ()) . build (); } } or @Provider @Singleton public class MyContainerRequestFilter implements ContainerRequestFilter { @Override public void filter ( ContainerRequestContext requestContext ) throws IOException { } } Eager singleton \u00b6 @EagerSingleton public class MyService {} Recognized by @EagerSingleton annotation. Replacement of manual bind ( MyService . class ). asEagerSingleton () . More \u00b6 This was only subset of supported extensions - see installers section. You can add additional extensions support with a custom installer .","title":"Extensions"},{"location":"guide/extensions/#extensions","text":"Extensions mechanism supposed to be used in guicey for all dropwizard specific features registration (instead of manual registrations). All extensions are recognized and installed with appropriate installer . This page supposed to reference declaration examples of most common extensions. See installers section for details. Warning Extension is recognized only by one installer (according to installers order), even if it contains multiple signs! See installers report for installers order. Declaration sources: Classpath scan Manual declaration Guice binding Tip More installers (and so supported extensions types) could be available due to installed extension bundles . Use installers report to see all available installers. Some extensins support order declaration with @Order() - see report. Note If you have problems with injection inside extensions (NPE errors) first check that you did not register extension manually! It is a quite often mistake (especially with jersey extensions): environment . jersey (). register ( new MyResource ()) This way MyResource will not be managed by guice and so injections inside it will not work Use constructor injection to prevent such errors (manual places will reveal immediately): @Path ( \"/\" ) public class MyResource { private final MyService service ; @Inject public MyResource ( MyService service ) { this . service = service ; } }","title":"Extensions"},{"location":"guide/extensions/#resource","text":"@Path ( \"/res\" ) @Produces ( ' application / json ' ) @Singleton class SampleResource { @Inject private MyService service ; @GET @Path ( \"/sample\" ) public Response sample () { return Response . ok ( service . result ()). build (); } } Recognized by @Path annotation on class or implemented interface.","title":"Resource"},{"location":"guide/extensions/#task","text":"@Singleton public class MyTask extends Task { @Inject private MyService service ; public TruncateDatabaseTask () { super ( \"mytask\" ); } @Override public void execute ( ImmutableMultimap < String , String > parameters , PrintWriter output ) throws Exception { service . doSomething (); } } Recognized by base Task class.","title":"Task"},{"location":"guide/extensions/#managed","text":"@Singleton public class MyService implements Managed { @Override public void start () throws Exception { ... } @Override public void stop () throws Exception { ... } } Recognized by Managed base class.","title":"Managed"},{"location":"guide/extensions/#health-check","text":"@Singleton public class MyHealthCheck extends NamedHealthCheck { @Inject private MyService service ; @Override protected Result check () throws Exception { if ( service . isOk ()) { return Result . healthy (); } else { return Result . unhealthy ( \"Service is not ok\" ); } } @Override public String getName () { return \"my-service\" ; } } Recognized by base NamedHealthCheck class. Custom guicey base class used because it would be impossible to automatically register health check without name.","title":"Health check"},{"location":"guide/extensions/#jersey-extensions","text":"All jersey extensions are recognized by javax.ws.rs.ext.Provider jersey annotation. There are many extensions supported. @Provider @Singleton public class DummyExceptionMapper implements ExceptionMapper < RuntimeException > { private final Logger logger = LoggerFactory . getLogger ( DummyExceptionMapper . class ); @Override public Response toResponse ( RuntimeException e ) { logger . debug ( \"Problem while executing\" , e ); return Response . status ( Response . Status . BAD_REQUEST ) . type ( MediaType . TEXT_PLAIN ) . entity ( e . getMessage ()) . build (); } } or @Provider @Singleton public class MyContainerRequestFilter implements ContainerRequestFilter { @Override public void filter ( ContainerRequestContext requestContext ) throws IOException { } }","title":"Jersey extensions"},{"location":"guide/extensions/#eager-singleton","text":"@EagerSingleton public class MyService {} Recognized by @EagerSingleton annotation. Replacement of manual bind ( MyService . class ). asEagerSingleton () .","title":"Eager singleton"},{"location":"guide/extensions/#more","text":"This was only subset of supported extensions - see installers section. You can add additional extensions support with a custom installer .","title":"More"},{"location":"guide/hk2/","text":"HK2 \u00b6 Danger Guicey will get rid of HK2 usage completely in the next version and all HK2-related api and features would be removed. All api supposed to be removed is marked as deprecated now. But there are no replacemenets provided. Please try to avoid using HK2 at all. By default, guicey manage all extensions under guice context and only register extensions in HK2 by instance. Normally you shouldn't know about HK2 at all. Jersey objects \u00b6 Guice started before HK2 and so all jersey-related beans could be registered in guice context only with lazy providers: binder . bind ( jerseyType ). toProvider ( new JerseyComponentProvider ( injectorProvider , jerseyType )); This provider will use jersey's InjectionManager to lookup bean: injectionManagerInstance . getInstance ( type ); See more details in jersey bindings module . Access HK2 context from guice \u00b6 Jersey's InjectionManager is available for injection inside guice context: @Inject Provider < InjectionManager > jerseyInjector ; Provider is important because jersey starts after guice. Note InjectionManager is jersey's new DI-agnostic api. You can obtain HK2 ServiceLocator from it, if required: ServiceLocator locator = jerseyInjector . getInstance ( ServiceLocator . class ); Jersey extensions \u00b6 Jersey-related extensions ( resources , features and providers ) are registered in HK2 with lazy factories (laziness is important to respect scopes and help with cycled initialization cases (when guice beans depend on HK2 beans)): binder . bindFactory ( new GuiceComponentFactory <> ( injector , guiceType )). to ( guiceType ) And internally this factory will obtain instance from guice injector: guiceInjector . getInstance ( guiceType ); To see more details on how it works look jersey providers installer . HK2 delegation \u00b6 You can delegate extension instance management into HK2 with @JerseyManaged annotation: @Provider @JerseyManaged public class MapperManagedByHK2 implements ExceptionMapper { ... } Now this extension will not be instantiated by guice - HK2 will instantiate it. Warning Delegated beans will not be affected with guice AOP and will not see guice beans (if bridge not activated ) Tip You can use .strictScopeControl() to make sure that beans are nto instantiated by both DI containers. HK2 guice bridge \u00b6 HK2 bridge may be required ONLY if you delegate some beans creation to HK2 (instead of guice) but beans still require guice-managed beans injection (HK2 must be able to see guice bindings). To activate bridge: Add dependency: org.glassfish.hk2:guice-bridge:2.6.1 (version must match HK2 version, used by dropwizard) Enable option: . option ( GuiceyOptions . UseHkBridge , true ) After that, HK2 beans could inject guice beans: @JerseyManaged public class HkService { @Inject private GuiceService service ; } Use HK2 for jersey extensions \u00b6 By default, guice is used to construct all extensions, including jersey related ( resources , features and providers ) which are registered in HK2 context as instances. If you want to delegate all jersey extensions to HK2 then use: GuiceBundle . builder () ... . useHK2ForJerseyExtensions () . build () (It is the same as if you annotate all jersey extensions with @JerseyManaged ) After enabling, all jersey extensions will be created by HK2. Option requires HK2-guice bridge (error will be thrown if bridge is not available in classpath) to use guice services inside HK2 managed beans. Warning Guice AOP will work only for instances created by guice, so after enabling this option you will not be able to use aop on jersey extensions. By analogy with @JerseyManaged , you can use @GuiceManaged to mark exceptional extensions, which must be still managed by guice. HK2 scope debug \u00b6 Special HK2DebugBundle bundle is provided to check that beans properly instantiated by guice or HK2 (and no beans are instantiated by both). It could be activated with shortcut: . strictScopeControl (); Affects only beans installed by installers implementing JerseyInstaller ( ResourceInstaller , JerseyProviderInstaller etc) because other extensions does not support delegation to HK2. Checks that beans annotated with @GuiceManaged are instantiated by guice and beans annotated with @JerseyManaged are created by HK2. In default guice-first mode non annotated beans are assumed to be instantiated in guice (and so error thrown if bean created in HK2 context). In HK2-first mode, error will be thrown if non annotated jersey extension is created by guice.","title":"HK2"},{"location":"guide/hk2/#hk2","text":"Danger Guicey will get rid of HK2 usage completely in the next version and all HK2-related api and features would be removed. All api supposed to be removed is marked as deprecated now. But there are no replacemenets provided. Please try to avoid using HK2 at all. By default, guicey manage all extensions under guice context and only register extensions in HK2 by instance. Normally you shouldn't know about HK2 at all.","title":"HK2"},{"location":"guide/hk2/#jersey-objects","text":"Guice started before HK2 and so all jersey-related beans could be registered in guice context only with lazy providers: binder . bind ( jerseyType ). toProvider ( new JerseyComponentProvider ( injectorProvider , jerseyType )); This provider will use jersey's InjectionManager to lookup bean: injectionManagerInstance . getInstance ( type ); See more details in jersey bindings module .","title":"Jersey objects"},{"location":"guide/hk2/#access-hk2-context-from-guice","text":"Jersey's InjectionManager is available for injection inside guice context: @Inject Provider < InjectionManager > jerseyInjector ; Provider is important because jersey starts after guice. Note InjectionManager is jersey's new DI-agnostic api. You can obtain HK2 ServiceLocator from it, if required: ServiceLocator locator = jerseyInjector . getInstance ( ServiceLocator . class );","title":"Access HK2 context from guice"},{"location":"guide/hk2/#jersey-extensions","text":"Jersey-related extensions ( resources , features and providers ) are registered in HK2 with lazy factories (laziness is important to respect scopes and help with cycled initialization cases (when guice beans depend on HK2 beans)): binder . bindFactory ( new GuiceComponentFactory <> ( injector , guiceType )). to ( guiceType ) And internally this factory will obtain instance from guice injector: guiceInjector . getInstance ( guiceType ); To see more details on how it works look jersey providers installer .","title":"Jersey extensions"},{"location":"guide/hk2/#hk2-delegation","text":"You can delegate extension instance management into HK2 with @JerseyManaged annotation: @Provider @JerseyManaged public class MapperManagedByHK2 implements ExceptionMapper { ... } Now this extension will not be instantiated by guice - HK2 will instantiate it. Warning Delegated beans will not be affected with guice AOP and will not see guice beans (if bridge not activated ) Tip You can use .strictScopeControl() to make sure that beans are nto instantiated by both DI containers.","title":"HK2 delegation"},{"location":"guide/hk2/#hk2-guice-bridge","text":"HK2 bridge may be required ONLY if you delegate some beans creation to HK2 (instead of guice) but beans still require guice-managed beans injection (HK2 must be able to see guice bindings). To activate bridge: Add dependency: org.glassfish.hk2:guice-bridge:2.6.1 (version must match HK2 version, used by dropwizard) Enable option: . option ( GuiceyOptions . UseHkBridge , true ) After that, HK2 beans could inject guice beans: @JerseyManaged public class HkService { @Inject private GuiceService service ; }","title":"HK2 guice bridge"},{"location":"guide/hk2/#use-hk2-for-jersey-extensions","text":"By default, guice is used to construct all extensions, including jersey related ( resources , features and providers ) which are registered in HK2 context as instances. If you want to delegate all jersey extensions to HK2 then use: GuiceBundle . builder () ... . useHK2ForJerseyExtensions () . build () (It is the same as if you annotate all jersey extensions with @JerseyManaged ) After enabling, all jersey extensions will be created by HK2. Option requires HK2-guice bridge (error will be thrown if bridge is not available in classpath) to use guice services inside HK2 managed beans. Warning Guice AOP will work only for instances created by guice, so after enabling this option you will not be able to use aop on jersey extensions. By analogy with @JerseyManaged , you can use @GuiceManaged to mark exceptional extensions, which must be still managed by guice.","title":"Use HK2 for jersey extensions"},{"location":"guide/hk2/#hk2-scope-debug","text":"Special HK2DebugBundle bundle is provided to check that beans properly instantiated by guice or HK2 (and no beans are instantiated by both). It could be activated with shortcut: . strictScopeControl (); Affects only beans installed by installers implementing JerseyInstaller ( ResourceInstaller , JerseyProviderInstaller etc) because other extensions does not support delegation to HK2. Checks that beans annotated with @GuiceManaged are instantiated by guice and beans annotated with @JerseyManaged are created by HK2. In default guice-first mode non annotated beans are assumed to be instantiated in guice (and so error thrown if bean created in HK2 context). In HK2-first mode, error will be thrown if non annotated jersey extension is created by guice.","title":"HK2 scope debug"},{"location":"guide/hooks/","text":"Configuration hooks \u00b6 Guicey provides special mechanism for external configuration: public class MyHook implements GuiceyConfigurationHook { @Override public void configure ( GuiceBundle . Builder builder ) { builder . bundles ( new AdditinoalBundle ()); } } Hook implementation receive the same builder instance as used in GuiceBundle and so it is able to change everything (for example, GuiceyBundle abilities are limited). Note Hooks intended to be used in tests (e.g. to activate some diagnostic tools or disable application parts) and to activate diagnostic/tracking tools on compiled application. Registration \u00b6 When hook implemented as separate class it could be registered directly: new MyHook (). register () For lambda-hook registration use: ConfigurationHooksSupport . register ( builder -> { // do modifications }) Lifecycle \u00b6 All hooks are executed just before guice bundle builder finalization (when you call last .build() method of GuiceBundle ). Hooks registered after this moment will simply be never used. Tests \u00b6 Note For hooks usage in tests there is a special test support (spock and junit). In context of tests, the most important hook modifications are: Change options Disable any bundle, installer, extension, module Register disable predicate (to disable features by package, registration source etc.) Override guice bindings Register additional bundles, extensions, modules (usually test-specific, for example guicey tests register additional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations)) Diagnostic \u00b6 Hooks could be activated on compiled application with a system property: -Dguicey.hooks=com.company.MyHook1,com.company.MyHook2 To simplify usage you can register hook alias: GuiceBindle . builder () . hookAlias ( \"alias1\" , MyHook1 . class ) . hookAlias ( \"alias2\" , MyHook2 . class ) Now, hooks could be activated as: -Dguicey.hooks=alias1,alias2 Moreover, you will always see these aliases in application startup logs (to not forget about this abilities): INFO [2019-09-16 16:26:35,229] ru.vyarus.dropwizard.guice.hook.ConfigurationHooksSupport: Available hook aliases [ -Dguicey.hooks=alias ]: alias1 com.company.MyHook1 alias2 com.company.MyHook2 Note By default, guicey register diagnostic hook to easily activate diagnostic reports on compiled application: -Dguicey.hooks=diagnistic","title":"Hooks"},{"location":"guide/hooks/#configuration-hooks","text":"Guicey provides special mechanism for external configuration: public class MyHook implements GuiceyConfigurationHook { @Override public void configure ( GuiceBundle . Builder builder ) { builder . bundles ( new AdditinoalBundle ()); } } Hook implementation receive the same builder instance as used in GuiceBundle and so it is able to change everything (for example, GuiceyBundle abilities are limited). Note Hooks intended to be used in tests (e.g. to activate some diagnostic tools or disable application parts) and to activate diagnostic/tracking tools on compiled application.","title":"Configuration hooks"},{"location":"guide/hooks/#registration","text":"When hook implemented as separate class it could be registered directly: new MyHook (). register () For lambda-hook registration use: ConfigurationHooksSupport . register ( builder -> { // do modifications })","title":"Registration"},{"location":"guide/hooks/#lifecycle","text":"All hooks are executed just before guice bundle builder finalization (when you call last .build() method of GuiceBundle ). Hooks registered after this moment will simply be never used.","title":"Lifecycle"},{"location":"guide/hooks/#tests","text":"Note For hooks usage in tests there is a special test support (spock and junit). In context of tests, the most important hook modifications are: Change options Disable any bundle, installer, extension, module Register disable predicate (to disable features by package, registration source etc.) Override guice bindings Register additional bundles, extensions, modules (usually test-specific, for example guicey tests register additional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations))","title":"Tests"},{"location":"guide/hooks/#diagnostic","text":"Hooks could be activated on compiled application with a system property: -Dguicey.hooks=com.company.MyHook1,com.company.MyHook2 To simplify usage you can register hook alias: GuiceBindle . builder () . hookAlias ( \"alias1\" , MyHook1 . class ) . hookAlias ( \"alias2\" , MyHook2 . class ) Now, hooks could be activated as: -Dguicey.hooks=alias1,alias2 Moreover, you will always see these aliases in application startup logs (to not forget about this abilities): INFO [2019-09-16 16:26:35,229] ru.vyarus.dropwizard.guice.hook.ConfigurationHooksSupport: Available hook aliases [ -Dguicey.hooks=alias ]: alias1 com.company.MyHook1 alias2 com.company.MyHook2 Note By default, guicey register diagnostic hook to easily activate diagnostic reports on compiled application: -Dguicey.hooks=diagnistic","title":"Diagnostic"},{"location":"guide/installers/","text":"Installers \u00b6 Installer is a core integration concept: every extension point has its own installer. Installers are registered manually or detected by classpath scan . Default installers \u00b6 Rest resource Dropwizard task Dropwizard managed object Jetty lifecycle Health check Jersey extensions Jersey feature @EagerSingleton Plugins support Http servlet Http filter Servlet context, request, session listener Tip In real application more installers may be available due to 3 rd party bundles. Use installers report to see all available installers. How it works \u00b6 All registered manually extensions , classes from classpath scan and unqualified guice bindings are recognized by registered installers: public class FeatureInstaller { boolean matches ( Class <?> type ); } Detected extensions are bound to guice context either with default binder.bind(foundClass) or by installer itself (default binding is required to support guice .requireExplicitBindings() option). After injector creation, installers register extension in dropwizard (not necessary, but most often). For example, installation of extension instance (obtained from injector injector . getInstance ( foundClass ) ): public interface InstanceInstaller < T > { void install ( Environment environment , T instance ); } Jersey-related extensions are installed later, during jersey context startup: public interface JerseyInstaller < T > { void install ( AbstractBinder binder , Injector injector , Class < T > type ); } Installers are ordered . Each extension is installed by only one installer! If extension could be recognized by more then one installers, it will be installed only by first matching installer (according to installers order). Writing custom installer \u00b6 Just for example, suppose we have some scheduling framework and we want to detect extensions, implementing ScheduledTask class. First of all, installer must implement FeatureInstaller interface. Here extension detection must be implemented public class ScheduledInstaller implements FeatureInstaller { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , ScheduledTask . class ); } // NOTE: report() method will describe later } Next, installer must register extension somehow. There may be different options: BindingInstaller allows custom guice bindings. If installer doesn't implement this interface simple bind(type) will be called to register in guice. TypeInstaller used for registration based on type (no instance created during installation). InstanceInstaller used for instance registration. Instance created using injector.getInstance(type) . JerseyInstaller used for registration of bindings in HK2 context. Note that extensions may use @LazyBinding annotation. In general case such extensions will not be registered in guice. In case of BindingInstaller , special hint will be passed and installer should decide how to handle it (may throw exception as not supported). BindingInstaller called in time of injector creation, whereas TypeInstaller and InstanceInstaller are called just after injector creation. JerseyInstaller is called on jersey start. Installers are not guice beans! So injections can't be used inside them. This is because installers also used during initialization phase and instantiated before injector creation. For example, our installer would register extension instance into some scheduler framework: public class ScheduledInstaller implements FeatureInstaller , InstanceInstaller < ScheduledTask > { ... @Override public void install ( Environment environment , ScheduledTask instance ) { SchedulerFramework . registerTask ( instance ); } } Tip TypeInstaller and InstanceInstaller could access injector with InjectorLookup . getInjector ( environment ). get (); And shared state : SharedConfigurationState . get ( environment ). get (); The last remaining part is reporting - we must see all installed beans in console: public class ScheduledInstaller implements FeatureInstaller , InstanceInstaller < ScheduledTask > { private final Reporter reporter = new Reporter ( ScheduledInstaller . class , \"scheduled tasks =\" ); ... @Override public void install ( Environment environment , ScheduledTask instance ) { SchedulerFramework . registerTask ( instance ); // register for reporting reporter . line ( \"(%s)\" , FeatureUtils . getInstanceClass ( instance ). getName ()); } @Override public void report () { reporter . report (); } } Report method will be called automatically after all extensions installation. More complex installers may require special reporter (like jersey extensions installer). Another example, suppose CustomFeature is a base class for our jersey extensions. Then installer will be: public class CustomInstaller implements FeatureInstaller , JerseyInstaller < CustomFeature > { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , CustomFeature . class ); } @Override public void install ( final AbstractBinder binder , final Class < CustomFeature > type ) { JerseyBinding . bindComponent ( binder , type , false , false ); ... } @Override public void report () { ... } } Jersey extensions are more usually complex due to binding aspects (especially for native jersey extensions). But, hopefully you'll never need to do it yourself. Tip For jersey installers see AbstractJerseyInstaller base class, containing common utilities. Ordering \u00b6 In order to support ordering , installer must implement Ordered interface. Important If installer doesn't implement Ordering extensions will not be sorted, even if extensions has @Order annotations. As example, see ManagedInstaller Options \u00b6 Installer could also use guicey options : it must implement WithOptions marker interface or extend form InstallerOptionsSupport base class (implemented boilerplate) Reporting \u00b6 Installers report() method will be called after it finish installation of all found extensions. Report provides user visibility of installed extensions. To simplify reporting use predefined Reporter class. See example usage in ManagedInstaller INFO [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.support.feature.DummyManaged) For complex cases, reporter may be extended to better handle installed extensions. As examples see plugin installer reporter and provider installer reporter INFO [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins = Set<PluginInterface> (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1) (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2) Map<DummyPluginKey, PluginInterface> ONE (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1) TWO (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2) Generics \u00b6 Guicey brings generics-resolver which you can use in installers implementation. For example, to get extension interface parametrization: interface Extension < V > {} class ListExtension implements Extension < List < String >> {} GenericsResolver . resolve ( ListExtension . class ) . type ( Extension . class ) . genericType ( \"V\" ) == List < String > // (ParameterizedType) Guicey itself use it for: types resolution during configuration introspection ( ConfigTreeBuilder ) to introspect type hierarchy and recognize all jersey extensions ( JerseyProviderInstaller ) format type for console reporting ( ProviderReporter ) bing jersey extensions to correct types ( JerseyBinding )","title":"Installers"},{"location":"guide/installers/#installers","text":"Installer is a core integration concept: every extension point has its own installer. Installers are registered manually or detected by classpath scan .","title":"Installers"},{"location":"guide/installers/#default-installers","text":"Rest resource Dropwizard task Dropwizard managed object Jetty lifecycle Health check Jersey extensions Jersey feature @EagerSingleton Plugins support Http servlet Http filter Servlet context, request, session listener Tip In real application more installers may be available due to 3 rd party bundles. Use installers report to see all available installers.","title":"Default installers"},{"location":"guide/installers/#how-it-works","text":"All registered manually extensions , classes from classpath scan and unqualified guice bindings are recognized by registered installers: public class FeatureInstaller { boolean matches ( Class <?> type ); } Detected extensions are bound to guice context either with default binder.bind(foundClass) or by installer itself (default binding is required to support guice .requireExplicitBindings() option). After injector creation, installers register extension in dropwizard (not necessary, but most often). For example, installation of extension instance (obtained from injector injector . getInstance ( foundClass ) ): public interface InstanceInstaller < T > { void install ( Environment environment , T instance ); } Jersey-related extensions are installed later, during jersey context startup: public interface JerseyInstaller < T > { void install ( AbstractBinder binder , Injector injector , Class < T > type ); } Installers are ordered . Each extension is installed by only one installer! If extension could be recognized by more then one installers, it will be installed only by first matching installer (according to installers order).","title":"How it works"},{"location":"guide/installers/#writing-custom-installer","text":"Just for example, suppose we have some scheduling framework and we want to detect extensions, implementing ScheduledTask class. First of all, installer must implement FeatureInstaller interface. Here extension detection must be implemented public class ScheduledInstaller implements FeatureInstaller { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , ScheduledTask . class ); } // NOTE: report() method will describe later } Next, installer must register extension somehow. There may be different options: BindingInstaller allows custom guice bindings. If installer doesn't implement this interface simple bind(type) will be called to register in guice. TypeInstaller used for registration based on type (no instance created during installation). InstanceInstaller used for instance registration. Instance created using injector.getInstance(type) . JerseyInstaller used for registration of bindings in HK2 context. Note that extensions may use @LazyBinding annotation. In general case such extensions will not be registered in guice. In case of BindingInstaller , special hint will be passed and installer should decide how to handle it (may throw exception as not supported). BindingInstaller called in time of injector creation, whereas TypeInstaller and InstanceInstaller are called just after injector creation. JerseyInstaller is called on jersey start. Installers are not guice beans! So injections can't be used inside them. This is because installers also used during initialization phase and instantiated before injector creation. For example, our installer would register extension instance into some scheduler framework: public class ScheduledInstaller implements FeatureInstaller , InstanceInstaller < ScheduledTask > { ... @Override public void install ( Environment environment , ScheduledTask instance ) { SchedulerFramework . registerTask ( instance ); } } Tip TypeInstaller and InstanceInstaller could access injector with InjectorLookup . getInjector ( environment ). get (); And shared state : SharedConfigurationState . get ( environment ). get (); The last remaining part is reporting - we must see all installed beans in console: public class ScheduledInstaller implements FeatureInstaller , InstanceInstaller < ScheduledTask > { private final Reporter reporter = new Reporter ( ScheduledInstaller . class , \"scheduled tasks =\" ); ... @Override public void install ( Environment environment , ScheduledTask instance ) { SchedulerFramework . registerTask ( instance ); // register for reporting reporter . line ( \"(%s)\" , FeatureUtils . getInstanceClass ( instance ). getName ()); } @Override public void report () { reporter . report (); } } Report method will be called automatically after all extensions installation. More complex installers may require special reporter (like jersey extensions installer). Another example, suppose CustomFeature is a base class for our jersey extensions. Then installer will be: public class CustomInstaller implements FeatureInstaller , JerseyInstaller < CustomFeature > { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , CustomFeature . class ); } @Override public void install ( final AbstractBinder binder , final Class < CustomFeature > type ) { JerseyBinding . bindComponent ( binder , type , false , false ); ... } @Override public void report () { ... } } Jersey extensions are more usually complex due to binding aspects (especially for native jersey extensions). But, hopefully you'll never need to do it yourself. Tip For jersey installers see AbstractJerseyInstaller base class, containing common utilities.","title":"Writing custom installer"},{"location":"guide/installers/#ordering","text":"In order to support ordering , installer must implement Ordered interface. Important If installer doesn't implement Ordering extensions will not be sorted, even if extensions has @Order annotations. As example, see ManagedInstaller","title":"Ordering"},{"location":"guide/installers/#options","text":"Installer could also use guicey options : it must implement WithOptions marker interface or extend form InstallerOptionsSupport base class (implemented boilerplate)","title":"Options"},{"location":"guide/installers/#reporting","text":"Installers report() method will be called after it finish installation of all found extensions. Report provides user visibility of installed extensions. To simplify reporting use predefined Reporter class. See example usage in ManagedInstaller INFO [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.support.feature.DummyManaged) For complex cases, reporter may be extended to better handle installed extensions. As examples see plugin installer reporter and provider installer reporter INFO [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins = Set<PluginInterface> (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1) (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2) Map<DummyPluginKey, PluginInterface> ONE (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1) TWO (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)","title":"Reporting"},{"location":"guide/installers/#generics","text":"Guicey brings generics-resolver which you can use in installers implementation. For example, to get extension interface parametrization: interface Extension < V > {} class ListExtension implements Extension < List < String >> {} GenericsResolver . resolve ( ListExtension . class ) . type ( Extension . class ) . genericType ( \"V\" ) == List < String > // (ParameterizedType) Guicey itself use it for: types resolution during configuration introspection ( ConfigTreeBuilder ) to introspect type hierarchy and recognize all jersey extensions ( JerseyProviderInstaller ) format type for console reporting ( ProviderReporter ) bing jersey extensions to correct types ( JerseyBinding )","title":"Generics"},{"location":"guide/lifecycle/","text":"Guicey lifecycle \u00b6 Tip Guicey broadcast events in all major points. You can see most of them with enabled lifecycle report . Configuration phase \u00b6 Note All manual registrations must be performed under this phase (the only exception is guice modules). All bundles are registered and initialized only under configuration phase. Everything below happens under bundle registration call: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () ... . build ()); // everything here will be called after all steps below } Main bundle configuration Apply configuration hooks All option values set and can't be modified anymore. Apply registered dropwizard bundles (init delayed to count dropwizard bundle disables ). Perform classpath scan (if configured). Scan resolve all classes in configured packages to use them later for detection. Perform bundles lookup Initialize bundles Search for commands (if classpath scan enabled) Prepare installers : Detect installers with classpath scan (if configured) Instantiate not disabled installers Resolve extensions : Validate all enabled manually registered extensions: one of prepared installers must recognize extension or error will be thrown. Recognize extensions from classpath scan classes (if configured) Run phase \u00b6 Run bundles Guice modules may be registered here Extensions may still be disabled Autowire modules Analyze enabled modules Detect extensions from bindings Remove disabled modules and disabled extensions Re-package modules (to avoid duplicate modules parsing by guice) Register GuiceBootsrapModule Apply overriding modules Create injector (with injector factory ) GuiceBootsrapModule configures: Additional bindings (like environment , configuration and jersey-objects ) Performs extensions registration (either default binding or specific, performed by BindingInstaller ) Register GuiceFeature (jersey Feature ), which will perform jersey initialization Activate guice ServletModule support Since that moment injector could be referenced statically Install extensions (except jersey extensions) Inject commands Note As dropwizard bundles were registered under GuiceBundle configuration, they will be run by dropwizard after GuiceBundle . Note Your Application.run() method will be called after guicey startup, so you can use created injector there. Jersey startup \u00b6 Note Jersey startup will initiate hk2 context creation Managed beans started hk2 context creation activates GuiceFeature (registered earlier) Apply guice bridge (if required) Run jersey specific installers ( resource , extension ): installers will register required bindings in hk2 context Note Any EnvironmentCommand did no start jersey, so managed objects will not be started (but you can start required services manually ). Also, all jersey related extensions will not be started. Still, core guice context will be completely operable. When guice context is created, jersey context doesn't exist and when jersey context is created it doesn't aware of guice existence .","title":"Lifecycle"},{"location":"guide/lifecycle/#guicey-lifecycle","text":"Tip Guicey broadcast events in all major points. You can see most of them with enabled lifecycle report .","title":"Guicey lifecycle"},{"location":"guide/lifecycle/#configuration-phase","text":"Note All manual registrations must be performed under this phase (the only exception is guice modules). All bundles are registered and initialized only under configuration phase. Everything below happens under bundle registration call: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () ... . build ()); // everything here will be called after all steps below } Main bundle configuration Apply configuration hooks All option values set and can't be modified anymore. Apply registered dropwizard bundles (init delayed to count dropwizard bundle disables ). Perform classpath scan (if configured). Scan resolve all classes in configured packages to use them later for detection. Perform bundles lookup Initialize bundles Search for commands (if classpath scan enabled) Prepare installers : Detect installers with classpath scan (if configured) Instantiate not disabled installers Resolve extensions : Validate all enabled manually registered extensions: one of prepared installers must recognize extension or error will be thrown. Recognize extensions from classpath scan classes (if configured)","title":"Configuration phase"},{"location":"guide/lifecycle/#run-phase","text":"Run bundles Guice modules may be registered here Extensions may still be disabled Autowire modules Analyze enabled modules Detect extensions from bindings Remove disabled modules and disabled extensions Re-package modules (to avoid duplicate modules parsing by guice) Register GuiceBootsrapModule Apply overriding modules Create injector (with injector factory ) GuiceBootsrapModule configures: Additional bindings (like environment , configuration and jersey-objects ) Performs extensions registration (either default binding or specific, performed by BindingInstaller ) Register GuiceFeature (jersey Feature ), which will perform jersey initialization Activate guice ServletModule support Since that moment injector could be referenced statically Install extensions (except jersey extensions) Inject commands Note As dropwizard bundles were registered under GuiceBundle configuration, they will be run by dropwizard after GuiceBundle . Note Your Application.run() method will be called after guicey startup, so you can use created injector there.","title":"Run phase"},{"location":"guide/lifecycle/#jersey-startup","text":"Note Jersey startup will initiate hk2 context creation Managed beans started hk2 context creation activates GuiceFeature (registered earlier) Apply guice bridge (if required) Run jersey specific installers ( resource , extension ): installers will register required bindings in hk2 context Note Any EnvironmentCommand did no start jersey, so managed objects will not be started (but you can start required services manually ). Also, all jersey related extensions will not be started. Still, core guice context will be completely operable. When guice context is created, jersey context doesn't exist and when jersey context is created it doesn't aware of guice existence .","title":"Jersey startup"},{"location":"guide/modules/","text":"Modules \u00b6 Module Description Admin REST Admin context rest support. Lifecycle annotations @PostConstruct , @PostStartup , @PreDestroy support EventBus Guava eventbus integration JDBI JDBI integration (based on dropwizard-jdbi) JDBI3 JDBI3 integration (based on dropwizard-jdbi3) SPA HTML5 routing support for single page applications Server pages JSP-like templates support (based on dropwizard-views) Validation use validation annotations on guice beans (same behaviour as rest)","title":"Extra integrations"},{"location":"guide/modules/#modules","text":"Module Description Admin REST Admin context rest support. Lifecycle annotations @PostConstruct , @PostStartup , @PreDestroy support EventBus Guava eventbus integration JDBI JDBI integration (based on dropwizard-jdbi) JDBI3 JDBI3 integration (based on dropwizard-jdbi3) SPA HTML5 routing support for single page applications Server pages JSP-like templates support (based on dropwizard-views) Validation use validation annotations on guice beans (same behaviour as rest)","title":"Modules"},{"location":"guide/options/","text":"Options \u00b6 Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific, options are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours. Options are declared with enums. Enums used to naturally group options (also cause pretty reporting). Enums must implement Option interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum), but provides required option info). Guicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through GuiceyOptions enum (for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle). Another use is in web installers to change default behaviour though InstallersOptions enum. Custom options may be defined for 3 rd party bundle or even application. Options is a general mechanism providing configuration and access points with standard reporting (part of diagnostic reporting ). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize application state in tests (just to name a few). Usage \u00b6 Options may be set only in main GuiceBundle using .option method. This is important to let configuration parts to see the same values. For example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and, for sure, this will eventually lead to inconsistent behaviour. Option could not be set to null. Option could be null only if it's default value is null and custom value not set. Custom option value is checked for compatibility with option type (from option definition) and error thrown if does not match. Of course, type checking is limited to top class and generics are ignored (so List<String> could not be specified and so can't be checked), but it's a compromise between complexity and easy of use (the same as Enum & Option pair). Options could be accessed by: Guicey bundles using bootstrap.option() Installer by implementing WithOptions interface Any guice bean could inject Options bean and use it to access options. Guice module could access options by implementing OptionsAwareModule marker interface Guicey tracks options definition and usage and report all used options as part of diagnostic reporting . Pay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options. Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used. Try to consume options closer to actual usage to let user be aware if option not used with current configuration. For example, GuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used. Custom options \u00b6 Options must be enum and implement Option interface, like this: enum MyOptions implements Option { DoExtraWork ( Boolean , true ), EnableDebug ( Boolean , false ), InternalConfig ( String [] , new String [] { \"one\" , \"two\" , \"three\" }); private Class type private Object value // generic used only to check type - value correctness < T > SampleOptions ( Class < T > type , T value ) { this . type = type this . value = value } @Override public Class getType () { return type } @Override public Object getDefaultValue () { return value } } Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value. This will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []). Now you can use option, for example, in bean: import static MyOptions.DoExtraWork ; public class MyBean { @Inject Options options ; pulic void someMethod () { ... if ( options . get ( DoExtraWork )) { // extra work impl } } } To provide custom option value: GuiceBundle . builder () . option ( DoExtraWork , false ) ... Options lookup \u00b6 Guicey provides simple mapping utility to map properties to system properties, environment variables or simply bind from string (obtained manually somewhere). GuiceBundle . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . env ( \"STAGE\" , GuiceyOptions . InjectorStage ) . string ( Myoptions . SomeOtherOption , \"property value\" ) . map ()) . build () Here: Myoptions.SomeOption could be changed with \"myprop\" system property ( -Dmyprop=something ) GuiceyOptions.InjectorStage could be changed with environment variable \"STAGE\" Myoptions.SomeOtherOption set from string (string could be obtained somewhere else manually) Important Missed mappings are ignored: e.g. if system property or environment variable is not defined - option will remain with default value (null will not be set!) Supported conversions \u00b6 Each option declares required option type Mapper could automatically convert string to: String Boolean Integer Double Short Byte Enum constant: If option type is exact enum then value must be constant name If option type is generic Enum then value must be 'fullEnumClass.constantName' Array or any type (from above): values must be separated by comma (\"one, two, three\") EnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName') Tip You can use sting conversion directly somewhere else, if required: StringConverter.convert(TargetType, stringValue) Exception is thrown when type is not supported for conversion. In this case use manual converter: new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . map () Converter is actually any java.util.Function (here, lambda with method call ( ::convertVal )). System properties \u00b6 As shown before, you can bind single system property to option. But you can also allow to set any option with system property: new OptionsMapper (). props (). map () It will bind all properties in format: option.enumClasName.enumValue . For example, -Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true Different prefix could be used: .props(\"myprefix\") Warning All properties with matched prefix must be mappable to option (target enum exists), otherwise error will be thrown. If any property requires custom value conversion then bind it before with converter and it will be ignored during mass mapping by prefix: new OptionsMapper () . prop ( \"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\" , GuiceyOptions . UseHkBridge , val - > convert ( val )) . props () . map () Debug \u00b6 You can enable mapped options print with .printMappings() : new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . printMappings () . map () When enabled, all mapped options will be printed to console (logger is not used because it's not yet initialized). Example output: env: VAR Opts.OptInt = 1 prop: foo Opts.OptStr = bar Opts.OptBool = true for mapper: new OptionsMapper () . printMappings () . env ( \"VAR\" , Opts . OptInt ) . env ( \"VAR2\" , Opts . OptDbl ) . prop ( \"foo\" , Opts . OptStr ) . prop ( \"foo2\" , Opts . OptShort ) . string ( Opts . OptBool , \"true\" ) . map () Here \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped. Custom lookup \u00b6 You can directly specify map of options ( .options(Map<Enum, Object>) ) or write your own lookup mechanism: GuiceBundle . builder () . options ( new MyOptionsLookup (). getOptions ()) ... .options() method contract simplified for just Enum , excluding Option for simpler usage, but still only option enums must be provided","title":"Options"},{"location":"guide/options/#options","text":"Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific, options are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours. Options are declared with enums. Enums used to naturally group options (also cause pretty reporting). Enums must implement Option interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum), but provides required option info). Guicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through GuiceyOptions enum (for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle). Another use is in web installers to change default behaviour though InstallersOptions enum. Custom options may be defined for 3 rd party bundle or even application. Options is a general mechanism providing configuration and access points with standard reporting (part of diagnostic reporting ). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize application state in tests (just to name a few).","title":"Options"},{"location":"guide/options/#usage","text":"Options may be set only in main GuiceBundle using .option method. This is important to let configuration parts to see the same values. For example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and, for sure, this will eventually lead to inconsistent behaviour. Option could not be set to null. Option could be null only if it's default value is null and custom value not set. Custom option value is checked for compatibility with option type (from option definition) and error thrown if does not match. Of course, type checking is limited to top class and generics are ignored (so List<String> could not be specified and so can't be checked), but it's a compromise between complexity and easy of use (the same as Enum & Option pair). Options could be accessed by: Guicey bundles using bootstrap.option() Installer by implementing WithOptions interface Any guice bean could inject Options bean and use it to access options. Guice module could access options by implementing OptionsAwareModule marker interface Guicey tracks options definition and usage and report all used options as part of diagnostic reporting . Pay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options. Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used. Try to consume options closer to actual usage to let user be aware if option not used with current configuration. For example, GuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.","title":"Usage"},{"location":"guide/options/#custom-options","text":"Options must be enum and implement Option interface, like this: enum MyOptions implements Option { DoExtraWork ( Boolean , true ), EnableDebug ( Boolean , false ), InternalConfig ( String [] , new String [] { \"one\" , \"two\" , \"three\" }); private Class type private Object value // generic used only to check type - value correctness < T > SampleOptions ( Class < T > type , T value ) { this . type = type this . value = value } @Override public Class getType () { return type } @Override public Object getDefaultValue () { return value } } Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value. This will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []). Now you can use option, for example, in bean: import static MyOptions.DoExtraWork ; public class MyBean { @Inject Options options ; pulic void someMethod () { ... if ( options . get ( DoExtraWork )) { // extra work impl } } } To provide custom option value: GuiceBundle . builder () . option ( DoExtraWork , false ) ...","title":"Custom options"},{"location":"guide/options/#options-lookup","text":"Guicey provides simple mapping utility to map properties to system properties, environment variables or simply bind from string (obtained manually somewhere). GuiceBundle . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . env ( \"STAGE\" , GuiceyOptions . InjectorStage ) . string ( Myoptions . SomeOtherOption , \"property value\" ) . map ()) . build () Here: Myoptions.SomeOption could be changed with \"myprop\" system property ( -Dmyprop=something ) GuiceyOptions.InjectorStage could be changed with environment variable \"STAGE\" Myoptions.SomeOtherOption set from string (string could be obtained somewhere else manually) Important Missed mappings are ignored: e.g. if system property or environment variable is not defined - option will remain with default value (null will not be set!)","title":"Options lookup"},{"location":"guide/options/#supported-conversions","text":"Each option declares required option type Mapper could automatically convert string to: String Boolean Integer Double Short Byte Enum constant: If option type is exact enum then value must be constant name If option type is generic Enum then value must be 'fullEnumClass.constantName' Array or any type (from above): values must be separated by comma (\"one, two, three\") EnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName') Tip You can use sting conversion directly somewhere else, if required: StringConverter.convert(TargetType, stringValue) Exception is thrown when type is not supported for conversion. In this case use manual converter: new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . map () Converter is actually any java.util.Function (here, lambda with method call ( ::convertVal )).","title":"Supported conversions"},{"location":"guide/options/#system-properties","text":"As shown before, you can bind single system property to option. But you can also allow to set any option with system property: new OptionsMapper (). props (). map () It will bind all properties in format: option.enumClasName.enumValue . For example, -Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true Different prefix could be used: .props(\"myprefix\") Warning All properties with matched prefix must be mappable to option (target enum exists), otherwise error will be thrown. If any property requires custom value conversion then bind it before with converter and it will be ignored during mass mapping by prefix: new OptionsMapper () . prop ( \"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\" , GuiceyOptions . UseHkBridge , val - > convert ( val )) . props () . map ()","title":"System properties"},{"location":"guide/options/#debug","text":"You can enable mapped options print with .printMappings() : new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . printMappings () . map () When enabled, all mapped options will be printed to console (logger is not used because it's not yet initialized). Example output: env: VAR Opts.OptInt = 1 prop: foo Opts.OptStr = bar Opts.OptBool = true for mapper: new OptionsMapper () . printMappings () . env ( \"VAR\" , Opts . OptInt ) . env ( \"VAR2\" , Opts . OptDbl ) . prop ( \"foo\" , Opts . OptStr ) . prop ( \"foo2\" , Opts . OptShort ) . string ( Opts . OptBool , \"true\" ) . map () Here \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped.","title":"Debug"},{"location":"guide/options/#custom-lookup","text":"You can directly specify map of options ( .options(Map<Enum, Object>) ) or write your own lookup mechanism: GuiceBundle . builder () . options ( new MyOptionsLookup (). getOptions ()) ... .options() method contract simplified for just Enum , excluding Option for simpler usage, but still only option enums must be provided","title":"Custom lookup"},{"location":"guide/ordering/","text":"Ordering \u00b6 Note Guicey always preserve items registration order, which may be changed only by using explicit @Order annotation). General \u00b6 Order is natural. For example, @Order(10) will be before @Order(20) . When no annotation present, class order set to Integer . MAX_VALUE , so all classes without order annotation are always goes last . Extensions order \u00b6 Note Not all extensions supports ordering: look specific installer page or installers report . For example, managed , servlets and filters installers support order. The most common case for ordering is ordering managed objects. For example: @Order ( 20 ) public class Managed1 implements Managed { ... } @Order ( 10 ) public class Managed2 implements Managed { ... } public class Managed3 implements Managed { ... } Will be ordered as: Managed2 , Managed1 , Managed3 Note Guicey remembers extensions registration order: . extensions ( Ext1 . class , Ext2 . class ) So when no explicit ordering defined (or for elements with the same order value) registration order will be preserved. Tip You can use diagnostic report to see actual extensions order. Installers order \u00b6 All bundled installers are ordered from 0 to ~110 with gap 10 between them to let you easily put your installers between (if required). Use @Order annotation to order custom installer, otherwise it will go after all default installers. Tip You can use installers report to see actual installers order. Bundles order \u00b6 Attention Bundles can't be explicitly ordered. Bundles are transitive and transitive registrations appear at the middle of bundle configuration, so it is physically impossible to order bundles. Still there are implicit order of bundle processing: Manually registered bundles (including transitive) Bundles lookup But, again, don't count on this order because, for example, bundle resolved through lookup mechanism could be also manually registered and so processed with manual bundles. Modules order \u00b6 Attention Modules can't be explicitly ordered. According to guice guice: modules should not contain conditional logic So modules should only register bindings and order does not matter in that case.","title":"Ordering"},{"location":"guide/ordering/#ordering","text":"Note Guicey always preserve items registration order, which may be changed only by using explicit @Order annotation).","title":"Ordering"},{"location":"guide/ordering/#general","text":"Order is natural. For example, @Order(10) will be before @Order(20) . When no annotation present, class order set to Integer . MAX_VALUE , so all classes without order annotation are always goes last .","title":"General"},{"location":"guide/ordering/#extensions-order","text":"Note Not all extensions supports ordering: look specific installer page or installers report . For example, managed , servlets and filters installers support order. The most common case for ordering is ordering managed objects. For example: @Order ( 20 ) public class Managed1 implements Managed { ... } @Order ( 10 ) public class Managed2 implements Managed { ... } public class Managed3 implements Managed { ... } Will be ordered as: Managed2 , Managed1 , Managed3 Note Guicey remembers extensions registration order: . extensions ( Ext1 . class , Ext2 . class ) So when no explicit ordering defined (or for elements with the same order value) registration order will be preserved. Tip You can use diagnostic report to see actual extensions order.","title":"Extensions order"},{"location":"guide/ordering/#installers-order","text":"All bundled installers are ordered from 0 to ~110 with gap 10 between them to let you easily put your installers between (if required). Use @Order annotation to order custom installer, otherwise it will go after all default installers. Tip You can use installers report to see actual installers order.","title":"Installers order"},{"location":"guide/ordering/#bundles-order","text":"Attention Bundles can't be explicitly ordered. Bundles are transitive and transitive registrations appear at the middle of bundle configuration, so it is physically impossible to order bundles. Still there are implicit order of bundle processing: Manually registered bundles (including transitive) Bundles lookup But, again, don't count on this order because, for example, bundle resolved through lookup mechanism could be also manually registered and so processed with manual bundles.","title":"Bundles order"},{"location":"guide/ordering/#modules-order","text":"Attention Modules can't be explicitly ordered. According to guice guice: modules should not contain conditional logic So modules should only register bindings and order does not matter in that case.","title":"Modules order"},{"location":"guide/scan/","text":"Classpath scan \u00b6 Summary Use scan only for application package. When part of application extracted to its own library (usually already mature part) create guicey bundle for it with explicit extensions definition. Use manual bundles installation or bundle lookup mechanism to install custom bundles. Configuration \u00b6 Classpath scanning is activated by specifying package to scan in bundle: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) Or multiple packages: GuiceBundle . builder () . enableAutoConfig ( \"com.mycompany.pkg1\" , \"com.mycompany.pkg2\" ) If no packages specified, classpath scan would be activated for application package: GuiceBundle . builder () . enableAutoConfig () (equivalent to .enableAutoConfig(getClass().getPackage().getName()) How it works \u00b6 When auto scan enabled: Extension installers are searched in classpath (classes implementing FeatureInstaller ). Extensions are searched using registered installers ( FeatureInstaller#matches method). If commands search is enabled ( .searchCommands() ), performs search for all classes extending Command and install them into bootstrap . Classes are searched in specified packages and all their subpackages. Abstract classes are ignored. Inner static classes are also resolved: public abstract class AbstractExceptionMapper < T extends Exception > implements ExceptionMapper < T > { @Provider public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } @Provider public static class BarExceptionMapper extends AbstractExceptionMapper < ServletException > { ... } } FooExceptionMapper and BarExceptionMapper would be detected and installed. Hide class from scan \u00b6 @InvisibleForScanner annotation hides class from scanner (for example, to install it manually or to avoid installation at all) @Provider @InvisibleForScanner public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } In this case FooExceptionMapper will be ignored by classpath scanner. But you still can install extension manually. Tip If you can't use annotation on extension for some reason, you can simply disable extension Motivation \u00b6 Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like reflections , fast scanner or even jersey's internal classpath scan parse class structure instead of loading classes. In general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. Moreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple). Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer. Actual application configuration could always be checked with diagnostic output ), so there should not be any problems for using classpath scan for production too. Warning It's a bad idea to use classpath scan for resolving extensions from 3 rd party jars. Group extensions from external jars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, so it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions. If you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup (enabled by default) which could load bundles with service loader definition .","title":"Classpath scan"},{"location":"guide/scan/#classpath-scan","text":"Summary Use scan only for application package. When part of application extracted to its own library (usually already mature part) create guicey bundle for it with explicit extensions definition. Use manual bundles installation or bundle lookup mechanism to install custom bundles.","title":"Classpath scan"},{"location":"guide/scan/#configuration","text":"Classpath scanning is activated by specifying package to scan in bundle: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) Or multiple packages: GuiceBundle . builder () . enableAutoConfig ( \"com.mycompany.pkg1\" , \"com.mycompany.pkg2\" ) If no packages specified, classpath scan would be activated for application package: GuiceBundle . builder () . enableAutoConfig () (equivalent to .enableAutoConfig(getClass().getPackage().getName())","title":"Configuration"},{"location":"guide/scan/#how-it-works","text":"When auto scan enabled: Extension installers are searched in classpath (classes implementing FeatureInstaller ). Extensions are searched using registered installers ( FeatureInstaller#matches method). If commands search is enabled ( .searchCommands() ), performs search for all classes extending Command and install them into bootstrap . Classes are searched in specified packages and all their subpackages. Abstract classes are ignored. Inner static classes are also resolved: public abstract class AbstractExceptionMapper < T extends Exception > implements ExceptionMapper < T > { @Provider public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } @Provider public static class BarExceptionMapper extends AbstractExceptionMapper < ServletException > { ... } } FooExceptionMapper and BarExceptionMapper would be detected and installed.","title":"How it works"},{"location":"guide/scan/#hide-class-from-scan","text":"@InvisibleForScanner annotation hides class from scanner (for example, to install it manually or to avoid installation at all) @Provider @InvisibleForScanner public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } In this case FooExceptionMapper will be ignored by classpath scanner. But you still can install extension manually. Tip If you can't use annotation on extension for some reason, you can simply disable extension","title":"Hide class from scan"},{"location":"guide/scan/#motivation","text":"Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like reflections , fast scanner or even jersey's internal classpath scan parse class structure instead of loading classes. In general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. Moreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple). Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer. Actual application configuration could always be checked with diagnostic output ), so there should not be any problems for using classpath scan for production too. Warning It's a bad idea to use classpath scan for resolving extensions from 3 rd party jars. Group extensions from external jars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, so it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions. If you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup (enabled by default) which could load bundles with service loader definition .","title":"Motivation"},{"location":"guide/shared/","text":"Shared configuration state \u00b6 Sometimes, it is required to pass configuration values between different application parts or implement bundles communication. In these cases usually you have to use ThreadLocal (direct static fields can't be used because it will make problems for tests). Attention Use it only when it's not possible to avoid. Guicey adds shared state support in order to replace all current and future hacks (and so avoid unexpected side effects for tests). Shared state is created together with GuiceBundle creation and destroyed with application shutdown. Internally it is implemented as static map with value reference by application instance. Note Shared state content is intentionally not logged (there is no report for that) because it is an internal state. Don't abuse it! It must be used only for edge cases. Guicey use it for storing Injector object lookup ( InjectorLookup is actually a shortcut). Also, all main dropwizard objects are stored there for direct reference. SPA and GSP bundles use it for bundles communication. Utility \u00b6 During startup shared state could be obtained with a static call: SharedConfigurationState . getStartupInstance () Static reference is possible only from the main application thread (which is always the case during initialization) Shared state holds references to the main dropwizard objects, see methods: getBootstrap() getApplication() getEnvironment() getConfiguration() getConfigurationTree() All of them return providers: e.g. SharedConfigurationState.getStartupInstance().getBootsrap() would return Provider<Bootstrap> . This is required because target object might not be available yet, still there would be a way to initialize some logic with \"lazy object\" (to call it later, when object would be available) at any configuration stage. Shared state restrictions \u00b6 Internally shared state is a Map<Class, Object> . Class is used as key because assumed usage scope is bundle and it will force you to use bundle class as a key (or any holder object class). Moreover, non string key reduce dummy typos (internally, values are stored by string class name to unify keys from different class loaders). Other restrictions: State value can be set just once ! This is simply to avoid hard to track problems with overridden state. State value can't be null! Again, to avoid problems with NPE errors. It is assumed that state will be used not for simple values, but for shared configuration objects. But there is no direct restrictions. Main bundle \u00b6 It is assumed that there should be no need to access shared state from main bundle . So the only state-related method actually assumed to be used by hooks : static class XHook implements GuiceyConfigurationHook { @Override void configure ( GuiceBundle . Builder builder ) { builder . withSharedState ( state -> { state . put ( XHook , new SharedObject ()); }); } } Guicey bundle \u00b6 Shared state is assumed to be used by bundles. Bundle provides special shortcut methods for accessing state. It is assumed that state is declared under initialization phase and could be accessed under both phases (but not restricted, so state could be declared in run phase too). For usage examples see decomposition section . Guice modules \u00b6 Shared state is not intended to be used in guice modules, but it is possible. To simplify usage there are shortcuts available in dropwizard aware module base class. Static access \u00b6 If required, shared state could be accessed statically everywhere: SharedConfigurationState . get ( application ) Direct static access ( SharedConfigurationState.getStartupInstance() ) is available only during startup, at runtime you can reference state only with Environment or Application objects. Or direct value access: SharedConfigurationState . lookup ( application , XBundle . class ) And it is possible to use Environment instance for access: SharedConfigurationState . get ( environment ) SharedConfigurationState . lookup ( environment , XBundle . class ) Special shortcut methods may be used for \"get or fail behaviour\": SharedConfigurationState . lookupOrFail ( app , XBundle . class , \"Failed to lookup %s service\" , XBundle . class . getSimpleName ()) It will throw IllegalStateException if shared context is not available or no value. Note that message is formatted with String.format . Tests \u00b6 Shared state is referenced by application instance, so there should not be any problems with tests. The only possible side effect is when you test many application startup error situations, when application did not shutdown properly and so some shared contexts may not be removed. If it (hard to imagine how) will affect your tests, you can forcefully clean all states: SharedConfigurationState . clear () Default objects \u00b6 The following objects are available in shared state just in case: Bootstrap Environment Configuration ConfigurationTree So any of it could be accessed statically with application or environment instance: Optional < Bootstrap > bootstrap = SharedConfigurationState . lookup ( environment , Bootstrap . class ); or Bootstrap bootstrap = SharedConfigurationState . lookupOrFail ( environment , Bootstrap . class , \"No bootstrap available\" ); Tip During startup these objects might be referenced as lazy objects with shortcuts","title":"Shared state"},{"location":"guide/shared/#shared-configuration-state","text":"Sometimes, it is required to pass configuration values between different application parts or implement bundles communication. In these cases usually you have to use ThreadLocal (direct static fields can't be used because it will make problems for tests). Attention Use it only when it's not possible to avoid. Guicey adds shared state support in order to replace all current and future hacks (and so avoid unexpected side effects for tests). Shared state is created together with GuiceBundle creation and destroyed with application shutdown. Internally it is implemented as static map with value reference by application instance. Note Shared state content is intentionally not logged (there is no report for that) because it is an internal state. Don't abuse it! It must be used only for edge cases. Guicey use it for storing Injector object lookup ( InjectorLookup is actually a shortcut). Also, all main dropwizard objects are stored there for direct reference. SPA and GSP bundles use it for bundles communication.","title":"Shared configuration state"},{"location":"guide/shared/#utility","text":"During startup shared state could be obtained with a static call: SharedConfigurationState . getStartupInstance () Static reference is possible only from the main application thread (which is always the case during initialization) Shared state holds references to the main dropwizard objects, see methods: getBootstrap() getApplication() getEnvironment() getConfiguration() getConfigurationTree() All of them return providers: e.g. SharedConfigurationState.getStartupInstance().getBootsrap() would return Provider<Bootstrap> . This is required because target object might not be available yet, still there would be a way to initialize some logic with \"lazy object\" (to call it later, when object would be available) at any configuration stage.","title":"Utility"},{"location":"guide/shared/#shared-state-restrictions","text":"Internally shared state is a Map<Class, Object> . Class is used as key because assumed usage scope is bundle and it will force you to use bundle class as a key (or any holder object class). Moreover, non string key reduce dummy typos (internally, values are stored by string class name to unify keys from different class loaders). Other restrictions: State value can be set just once ! This is simply to avoid hard to track problems with overridden state. State value can't be null! Again, to avoid problems with NPE errors. It is assumed that state will be used not for simple values, but for shared configuration objects. But there is no direct restrictions.","title":"Shared state restrictions"},{"location":"guide/shared/#main-bundle","text":"It is assumed that there should be no need to access shared state from main bundle . So the only state-related method actually assumed to be used by hooks : static class XHook implements GuiceyConfigurationHook { @Override void configure ( GuiceBundle . Builder builder ) { builder . withSharedState ( state -> { state . put ( XHook , new SharedObject ()); }); } }","title":"Main bundle"},{"location":"guide/shared/#guicey-bundle","text":"Shared state is assumed to be used by bundles. Bundle provides special shortcut methods for accessing state. It is assumed that state is declared under initialization phase and could be accessed under both phases (but not restricted, so state could be declared in run phase too). For usage examples see decomposition section .","title":"Guicey bundle"},{"location":"guide/shared/#guice-modules","text":"Shared state is not intended to be used in guice modules, but it is possible. To simplify usage there are shortcuts available in dropwizard aware module base class.","title":"Guice modules"},{"location":"guide/shared/#static-access","text":"If required, shared state could be accessed statically everywhere: SharedConfigurationState . get ( application ) Direct static access ( SharedConfigurationState.getStartupInstance() ) is available only during startup, at runtime you can reference state only with Environment or Application objects. Or direct value access: SharedConfigurationState . lookup ( application , XBundle . class ) And it is possible to use Environment instance for access: SharedConfigurationState . get ( environment ) SharedConfigurationState . lookup ( environment , XBundle . class ) Special shortcut methods may be used for \"get or fail behaviour\": SharedConfigurationState . lookupOrFail ( app , XBundle . class , \"Failed to lookup %s service\" , XBundle . class . getSimpleName ()) It will throw IllegalStateException if shared context is not available or no value. Note that message is formatted with String.format .","title":"Static access"},{"location":"guide/shared/#tests","text":"Shared state is referenced by application instance, so there should not be any problems with tests. The only possible side effect is when you test many application startup error situations, when application did not shutdown properly and so some shared contexts may not be removed. If it (hard to imagine how) will affect your tests, you can forcefully clean all states: SharedConfigurationState . clear ()","title":"Tests"},{"location":"guide/shared/#default-objects","text":"The following objects are available in shared state just in case: Bootstrap Environment Configuration ConfigurationTree So any of it could be accessed statically with application or environment instance: Optional < Bootstrap > bootstrap = SharedConfigurationState . lookup ( environment , Bootstrap . class ); or Bootstrap bootstrap = SharedConfigurationState . lookupOrFail ( environment , Bootstrap . class , \"No bootstrap available\" ); Tip During startup these objects might be referenced as lazy objects with shortcuts","title":"Default objects"},{"location":"guide/web/","text":"Web features \u00b6 Servlets, filters \u00b6 Servlets and filters could be registered either with guice ServletModule or using extensions . Guice servlet module \u00b6 Example: public class WebModule extends ServletModule { @Override protected void configureServlets () { filter ( \"/*\" ). through ( MyFilter . class ); serve ( \"/myservlet\" ). with ( MyServlet . class ); } } Pros Only ServletModule allows mappings by regexp : serveRegex ( \"(.)*ajax(.)*\" ). with ( MyAjaxServlet . class ) Warning It is important to note that GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and so you may have problems combining servlets from ServletModule with filters in main scope. It is never a blocking issues, but often \"not obvious to understand\" situations. Web extensions \u00b6 Extensions declared with standard javax.servlet annotations. Servlet registration: @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Extension recognized by @WebServlet annotation. Could be registered on admin context: @WebServlet ( \"/mapped\" ) @AdminContext public class MyServlet extends HttpServlet { ... } Or even on both contexts at the same time: @AdminContext ( andAdmin = true ) . Filter: @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Extension recognized by @WebFilter annotation. Web listeners (servlet, request, session): @WebListener public class MyListener implements ServletContextListener {...} Extension recognized by @WebListener annotation. Pros Installation through extensions has more abilities comparing to ServletModule : Installation into admin context Async support Filter may be applied to exact servlet(s) ( @WebFilter ( servletNames = \"servletName\" ) ) Request, servlet context or session listeners installation If you don't want to use web installers or have problems with it (e.g. because they use javax.servlet annotations) you can disable all of them at once by disabling bundle: GuiceBundle . builder () . disableBindles ( WebInstallersBundle . class ) ... Manual registration \u00b6 Alternatively, you can always register servlet or filter manually with dropwizard api: public class App extends Application { public void initialize ( Bootstrap bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder (). build ()); } public void run ( Configuration configuration , Environment environment ) { final MyFilter filter = InjectorLookup . getInstance ( this , MyFilterBean . class ). get (); environment . servlets (). addFilter ( \"manualFilter\" , filter ) . addMappingForUrlPatterns ( EnumSet . of ( DispatcherType . REQUEST ), false , \"/*\" ); } } Resources \u00b6 Dropwizard provides AssetsBundle for serving static files from classpath: bootstrap . addBundle ( new AssetsBundle ( \"/assets/app/\" , \"/\" , \"index.html\" )); http://localhost:8080/foo.css \u2192 src/main/resources/assets/app/foo.css http://localhost:8080/ \u2192 src/main/resources/assets/app/index.html HTML5 routing \u00b6 But, if you develop SPA application with HTML5 routes, server will not handle these routes properly. Use guicey SPA bundle which adds proper SPA routing support above dropwizard AssetBundle GuiceBundle . builder () . bundles ( SpaBundle . app ( \"spaApp\" , \"/assets/app/\" , \"/\" ). build ()); http://localhost:8080/ \u2192 src/main/resources/assets/app/index.html http://localhost:8080/route/path \u2192 src/main/resources/assets/app/index.html Templates \u00b6 Dropwizard provides ViewBundle for handling templates (freemarker and mustache out of the box, more engines could be plugged). bootstrap . addBundle ( new ViewBundle ()); Which allows you to serve rendered templates from rest endpoints . Templates + resources \u00b6 But it is not quite handful to use it together with static resources ( AssetsBundle ) because static resources will have different urls (as they are not served from rest). If you would like to have JSP-like behaviour (when templates and resources live at the same location and so could easily reference each other) - then use guicey GSP bundle (which is actually just a \"glue\" for dropwizard ViewBundle and AssetsBundle ). com / exmaple / app / person . ftl foo . ftl style . css < #-- Sample template without model (/foo.ftl) --> < html > < body > < h1 > Hello, it's a template: ${12+22}! </ h1 > </ body > </ html > < #-- Template with model, rendered by rest endpoint (/person/) --> < #-- @ftlvariable name=\"\" type=\"com.example.views.PersonView\" --> < html > < head > < link href = \"/style.css\" rel = \"stylesheet\" > </ head > < body > <!-- calls getPerson().getName() and sanitizes it --> < h1 > Hello, ${person.name?html}! </ h1 > </ body > </ html > public class PersonView extends TemplateView { private final Person person ; public PersonView ( Person person ) { super ( ' person . ftl ' ); this . person = person ; } public Person getPerson () { return person ; } } // Path starts with application name @Path ( \"/com.example.app/person/\" ) @Produces ( MediaType . TEXT_HTML ) // Important marker @Template public class PersonPage { @Inject private PersonDAO dao ; @GET @Path ( \"/\" ) public PersonView getMaster () { return new PersonView ( dao . find ( 1 )); } @GET @Path ( \"/{id}\" ) public PersonView getPerson ( @PathParam ( \"id\" ) String id ) { return new PersonView ( dao . find ( id )); } } GuiceBundle . builder () . bundles ( // global views support ServerPagesBundle . builder (). build (), // application registration ServerPagesBundle . app ( \"com.example.app\" , \"/com/example/app/\" , \"/\" ) // rest path as index page . indexPage ( \"person/\" ) . build ()); Static resource call: http://localhost:8080/style.css \u2192 src/main/resources/com/example/app/style.css Direct template call: http://localhost:8080/foo.ftl \u2192 src/main/resources/com/example/app/foo.ftl Rest-driven template call: http://localhost:8080/person/12 \u2192 /rest/com.example.app/person/12 Index page: http://localhost:8080/ \u2192 /rest/com.example.app/person/ Summary Declaration differences from pure dropwizard views: Model extends TemplateView Rest endpoints always annotated with @Template Rest endpoints paths starts with registered application name ( ServerPagesBundle . app ( \"com.example.app\" ) to be able to differentiate rest for different UI applications Warning Standard errors handling in views ( templates , custom pages ) is replaced by custom mechanism , required to implement per-ui-app errors support.","title":"Web"},{"location":"guide/web/#web-features","text":"","title":"Web features"},{"location":"guide/web/#servlets-filters","text":"Servlets and filters could be registered either with guice ServletModule or using extensions .","title":"Servlets, filters"},{"location":"guide/web/#guice-servlet-module","text":"Example: public class WebModule extends ServletModule { @Override protected void configureServlets () { filter ( \"/*\" ). through ( MyFilter . class ); serve ( \"/myservlet\" ). with ( MyServlet . class ); } } Pros Only ServletModule allows mappings by regexp : serveRegex ( \"(.)*ajax(.)*\" ). with ( MyAjaxServlet . class ) Warning It is important to note that GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and so you may have problems combining servlets from ServletModule with filters in main scope. It is never a blocking issues, but often \"not obvious to understand\" situations.","title":"Guice servlet module"},{"location":"guide/web/#web-extensions","text":"Extensions declared with standard javax.servlet annotations. Servlet registration: @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Extension recognized by @WebServlet annotation. Could be registered on admin context: @WebServlet ( \"/mapped\" ) @AdminContext public class MyServlet extends HttpServlet { ... } Or even on both contexts at the same time: @AdminContext ( andAdmin = true ) . Filter: @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Extension recognized by @WebFilter annotation. Web listeners (servlet, request, session): @WebListener public class MyListener implements ServletContextListener {...} Extension recognized by @WebListener annotation. Pros Installation through extensions has more abilities comparing to ServletModule : Installation into admin context Async support Filter may be applied to exact servlet(s) ( @WebFilter ( servletNames = \"servletName\" ) ) Request, servlet context or session listeners installation If you don't want to use web installers or have problems with it (e.g. because they use javax.servlet annotations) you can disable all of them at once by disabling bundle: GuiceBundle . builder () . disableBindles ( WebInstallersBundle . class ) ...","title":"Web extensions"},{"location":"guide/web/#manual-registration","text":"Alternatively, you can always register servlet or filter manually with dropwizard api: public class App extends Application { public void initialize ( Bootstrap bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder (). build ()); } public void run ( Configuration configuration , Environment environment ) { final MyFilter filter = InjectorLookup . getInstance ( this , MyFilterBean . class ). get (); environment . servlets (). addFilter ( \"manualFilter\" , filter ) . addMappingForUrlPatterns ( EnumSet . of ( DispatcherType . REQUEST ), false , \"/*\" ); } }","title":"Manual registration"},{"location":"guide/web/#resources","text":"Dropwizard provides AssetsBundle for serving static files from classpath: bootstrap . addBundle ( new AssetsBundle ( \"/assets/app/\" , \"/\" , \"index.html\" )); http://localhost:8080/foo.css \u2192 src/main/resources/assets/app/foo.css http://localhost:8080/ \u2192 src/main/resources/assets/app/index.html","title":"Resources"},{"location":"guide/web/#html5-routing","text":"But, if you develop SPA application with HTML5 routes, server will not handle these routes properly. Use guicey SPA bundle which adds proper SPA routing support above dropwizard AssetBundle GuiceBundle . builder () . bundles ( SpaBundle . app ( \"spaApp\" , \"/assets/app/\" , \"/\" ). build ()); http://localhost:8080/ \u2192 src/main/resources/assets/app/index.html http://localhost:8080/route/path \u2192 src/main/resources/assets/app/index.html","title":"HTML5 routing"},{"location":"guide/web/#templates","text":"Dropwizard provides ViewBundle for handling templates (freemarker and mustache out of the box, more engines could be plugged). bootstrap . addBundle ( new ViewBundle ()); Which allows you to serve rendered templates from rest endpoints .","title":"Templates"},{"location":"guide/web/#templates-resources","text":"But it is not quite handful to use it together with static resources ( AssetsBundle ) because static resources will have different urls (as they are not served from rest). If you would like to have JSP-like behaviour (when templates and resources live at the same location and so could easily reference each other) - then use guicey GSP bundle (which is actually just a \"glue\" for dropwizard ViewBundle and AssetsBundle ). com / exmaple / app / person . ftl foo . ftl style . css < #-- Sample template without model (/foo.ftl) --> < html > < body > < h1 > Hello, it's a template: ${12+22}! </ h1 > </ body > </ html > < #-- Template with model, rendered by rest endpoint (/person/) --> < #-- @ftlvariable name=\"\" type=\"com.example.views.PersonView\" --> < html > < head > < link href = \"/style.css\" rel = \"stylesheet\" > </ head > < body > <!-- calls getPerson().getName() and sanitizes it --> < h1 > Hello, ${person.name?html}! </ h1 > </ body > </ html > public class PersonView extends TemplateView { private final Person person ; public PersonView ( Person person ) { super ( ' person . ftl ' ); this . person = person ; } public Person getPerson () { return person ; } } // Path starts with application name @Path ( \"/com.example.app/person/\" ) @Produces ( MediaType . TEXT_HTML ) // Important marker @Template public class PersonPage { @Inject private PersonDAO dao ; @GET @Path ( \"/\" ) public PersonView getMaster () { return new PersonView ( dao . find ( 1 )); } @GET @Path ( \"/{id}\" ) public PersonView getPerson ( @PathParam ( \"id\" ) String id ) { return new PersonView ( dao . find ( id )); } } GuiceBundle . builder () . bundles ( // global views support ServerPagesBundle . builder (). build (), // application registration ServerPagesBundle . app ( \"com.example.app\" , \"/com/example/app/\" , \"/\" ) // rest path as index page . indexPage ( \"person/\" ) . build ()); Static resource call: http://localhost:8080/style.css \u2192 src/main/resources/com/example/app/style.css Direct template call: http://localhost:8080/foo.ftl \u2192 src/main/resources/com/example/app/foo.ftl Rest-driven template call: http://localhost:8080/person/12 \u2192 /rest/com.example.app/person/12 Index page: http://localhost:8080/ \u2192 /rest/com.example.app/person/ Summary Declaration differences from pure dropwizard views: Model extends TemplateView Rest endpoints always annotated with @Template Rest endpoints paths starts with registered application name ( ServerPagesBundle . app ( \"com.example.app\" ) to be able to differentiate rest for different UI applications Warning Standard errors handling in views ( templates , custom pages ) is replaced by custom mechanism , required to implement per-ui-app errors support.","title":"Templates + resources"},{"location":"guide/yaml-values/","text":"Yaml values \u00b6 Guicey introspects Configuration object instance using jackson serialization api to allow direct access to yaml configuration values. Introspected configuration is accessible as: Direct guice bindigs for unique sub objects, and all properties Bindings for manually qualified properties ConfigurationTree object (binding) containing all introspection data (could be used for manual searches and, for example, for reports) Guice modules and guicey bundles could access introspected configuration with help of ConfigurationAwareModule interface and GuiceyEnvironment object. Warning Jackson will see all properties that either have getter and setter or annotated with @JsonProperty . For example, public class MyConfig extends Configuration { private String one // visible (getter and setter) @JsonProperty private String two // visible (annotation) private String three // invisible (no getter) public void setOne ( String one ) { ... } public String getOne () { ... } public void setTwo ( String two ) { ... } public void setThree ( String three ) { ... } } Tip To prevent binding of configuration property use @JsonIgnore on property getter private String prop // dropwizard will set value from yaml public void setProp ( Stirng prop ) { ... } // property will not be available as path binding @JsonIgnore public String getProp () { ... } Important Guice does not allow null value bindings by default, so if you bind configuration property with null value injector creation would fail. To workaround it, use @javax.inject.Nullable for injected field. Unique sub configuration \u00b6 It is quite common to group configuration properties into sub objects like: public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; @JsonProperty DbConfig db ; } Guicey detects such unique objects and provides direct bindings for them: @Inject @Config AuthConfig auth ; @Inject @Config DbConfig db ; This is very useful for re-usable modules, which are not aware of your configuration object structure, but require only one sub configuration object: public class MyConfig extends Configuration { @JsonProperty FeatureXConfig featureX ; } Somewhere in module service: public class FeatureXService { @Inject @Config FeatureXConfig featureX ; } Important Sub configuration object uniqueness is checked as direct match, so you may have @JsonProperty SubConfig sub @JsonProperty SubConfigExt subExt where class SubConfigExt extends SubConfig , but still both objects would be considered unique. Whereas @JsonProperty SubConfig sub1 @JsonProperty SubConfig sub2 will not. Tip Guicey bundles and guice modules also could use sub configuration objects directly: GuiceyEnvironment # configuration ( SubConfig . class ) DropwizardAwareModule # configuration ( SubConfig . class ) Qualified bindings \u00b6 Automatic unique objects bindings require using guicey binding annotation. In some cases, this is not possible: for example, generic 3 rd party guice module. You can use qualified bindings then. The idea is simple: just annotate any configuration property or getter with a qualified annotation and it would be bound in guice context. Moreover, if multiple properties (same type!) would be annotated with the same annotation - they would be bound as Set . For example, public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); Tip Custom qualifying annotation must be annotated with guice @BindingAnnotation or javax (jakarta) @Qualifier (see guice and javax (jakarta) @Named annotations as an example). @Retention ( RetentionPolicy . RUNTIME ) @Target ({ ElementType . FIELD , ElementType . PARAMETER , ElementType . METHOD }) @BindingAnnotation public @interface CustomQualifier {} Would mean two additional bindings: @Inject @Named ( \"custom\" ) String prop1 ; @Inject @CustomQualifier SubObj obj1 ; Important If you expect null values then identify it (otherwise injector creation would fail for null value): @Inject @Named(\"custom\") @javax.inject.Nullable String prop1; And binding like this: @Named ( \"sub-prop\" ) private String prop2 ; @Named ( \"sub-prop\" ) private String prop3 ; Would result in aggregated binding: @Inject @Named ( \"sub-prop\" ) Set < String > prop23 ; Note Qualifying annotations may be used on any configuration depth (not only in the root configuration object). Core dropwizard objects could also be bound with a qualified overridden getter: @Named ( \"metrics\" ) @Override MetricsFactory getMetricsFactory () { return super . getMetricsFactory (); } Note All custom bindings are visible in the configuration report: .printCustomConfigurationBindings() Tip Guicey bundles and guice modules also could use qualified configuration values directly: GuiceyEnvironment # annotatedConfiguration ( Ann . class ) DropwizardAwareModule # annotatedConfiguration ( Ann . class ) Configuration by path \u00b6 All visible configuration paths values are directly bindable: public class MyConfig extends Configuration { SubConf sub ; } public class SubConf { String smth ; List < String > values ; } @Inject @Config ( \"sub\" ) SubConf sub ; @Inject @Config ( \"sub.smth\" ) String smth ; @Inject @Config ( \"sub.values\" ) List < String > values ; Note Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations). The only exception is conditional mapping like dropwizard \"server\" when available paths could change, depending on configuration (what configuration class will be used) Note Generified types are bound only with generics (with all available type information). If you will have SubConf<T> sub in config, then it will be bound with correct generic SubConfig<String> (suppose generic T is declared as String). Value type, declared in configuration class is used for binding, but there are two exceptions. If declared type is declared as collection (Set, List, Map) implementation then binding will use base collection interface: ArrayList < String > value @Inject @Config ( \"value\" ) List < String > vlaue ; If, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence: @Config(\"path\") Object val - when value is null @Config(\"path\") ValueType val - actual value type, when value is not null It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\"). Tip You can declare you own additional bindings using ConfigurationTree (accessible from guice module), which contains all paths information (including declaration and actual types with generics). Introspected configuration \u00b6 ConfigurationTree object provides access for introspected configuration tree: getRootTypes() - all classes in configuration hierarchy (including interfaces) getPaths() - all paths (including all steps (\"sub\", \"sub.value\")) getUniqueTypePaths() - paths of unique sub configuration types Each path item ( ConfigPath ) contains: Root path reference (\"sub.value\" reference \"sub\") Child sub-paths (\"sub\" reference \"sub.value\") Declaration class (type used in configuration class) Value type (type of actual value; when value null - declaration type (but they still could be different for collections)) Current path name Current path value Generics for declaration and value types (may be incomplete for value type) Custom type marker: contains sub paths or just looks like sub configuration Declaration type (class where property was declared - configuration object containing property) You can traverse up or down from any path (tree structure). ConfigurationTree provides basic search methods (more as usage example): findByPath(String) - search path by case-insensitive match findAllByType(Class) - find all paths with assignable declared value findAllFrom(Class<? extends Configuration>) - find all paths, started in specified configuration class findAllRootPaths() - get all root paths (1 st level paths) findAllRootPathsFrom(Class<? extends Configuration>) - all 1 st level paths of configuration class valueByPath(String) - return path value or null if value null or path not exists valuesByType(Class) - all not null values with assignable type valueByType(Class) - first not null value with assignable type valueByUniqueDeclaredType(Class) - value of unique sub configuration or null if value is null or config is not unique Methods to work with qualified configurations: findAllByAnnotation(ann | Class) - find all annotated properties by annotation instance or annotation class findByAnnotation(ann | Class) - find exactly one annotated property or throw error if more then one found annotatatedValues(ann | Class) - all non-null values from annotated properties annotatatedValue(ann | Class) - an annotated property value (throw error if more properties annotated) Tip Searching by annotation instance if required for annotations with \"state\". For example, @Named(\"something\") and @Named(\"other\") are different qualifying annotations, and searching only by type would be incorrect in this case. It is not possible to directly create annotation instance, but any annotation is and interface and could be implemented. It is important that real annotation (from class) and provided object would be equal. As an example see how guice Names.named() consrtructs \"@Named\" insatnces. Paths are sorted by configuration class (to put custom properties upper) and by path name (for predictable paths order). Disable configuration introspection \u00b6 Introspection process should not fail application startup. In worse case it will show warning log that property can't be introspected: WARN [2018-07-23 09:11:13,034] ru.vyarus.dropwizard.guice.module.yaml.ConfigTreeBuilder: Can't bind configuration path 'sub.sample' due to IllegalArgumentException: Failed to getValue() with method ru.vyarus.dropwizard.guice.yaml.support.FailedGetterConfig#getSample(0 params): null. Enable debug logs to see complete stack trace or use @JsonIgnore on property getter. Such warnings could be hidden by using @JsonIgnore on property getter. If this is not enough, or you need to avoid configuration introspection for other reasons, you can disable introspection completely with option: GuiceBundle . builder () . option ( GuiceyOptions . BindConfigurationByPath , false ) ... When introspection disabled, only configuration object would be bound and bindings by path would not be available. Note that even ConfigurationTree object will not contain configuration paths (option completely disables introspection mechanism).","title":"Yaml values"},{"location":"guide/yaml-values/#yaml-values","text":"Guicey introspects Configuration object instance using jackson serialization api to allow direct access to yaml configuration values. Introspected configuration is accessible as: Direct guice bindigs for unique sub objects, and all properties Bindings for manually qualified properties ConfigurationTree object (binding) containing all introspection data (could be used for manual searches and, for example, for reports) Guice modules and guicey bundles could access introspected configuration with help of ConfigurationAwareModule interface and GuiceyEnvironment object. Warning Jackson will see all properties that either have getter and setter or annotated with @JsonProperty . For example, public class MyConfig extends Configuration { private String one // visible (getter and setter) @JsonProperty private String two // visible (annotation) private String three // invisible (no getter) public void setOne ( String one ) { ... } public String getOne () { ... } public void setTwo ( String two ) { ... } public void setThree ( String three ) { ... } } Tip To prevent binding of configuration property use @JsonIgnore on property getter private String prop // dropwizard will set value from yaml public void setProp ( Stirng prop ) { ... } // property will not be available as path binding @JsonIgnore public String getProp () { ... } Important Guice does not allow null value bindings by default, so if you bind configuration property with null value injector creation would fail. To workaround it, use @javax.inject.Nullable for injected field.","title":"Yaml values"},{"location":"guide/yaml-values/#unique-sub-configuration","text":"It is quite common to group configuration properties into sub objects like: public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; @JsonProperty DbConfig db ; } Guicey detects such unique objects and provides direct bindings for them: @Inject @Config AuthConfig auth ; @Inject @Config DbConfig db ; This is very useful for re-usable modules, which are not aware of your configuration object structure, but require only one sub configuration object: public class MyConfig extends Configuration { @JsonProperty FeatureXConfig featureX ; } Somewhere in module service: public class FeatureXService { @Inject @Config FeatureXConfig featureX ; } Important Sub configuration object uniqueness is checked as direct match, so you may have @JsonProperty SubConfig sub @JsonProperty SubConfigExt subExt where class SubConfigExt extends SubConfig , but still both objects would be considered unique. Whereas @JsonProperty SubConfig sub1 @JsonProperty SubConfig sub2 will not. Tip Guicey bundles and guice modules also could use sub configuration objects directly: GuiceyEnvironment # configuration ( SubConfig . class ) DropwizardAwareModule # configuration ( SubConfig . class )","title":"Unique sub configuration"},{"location":"guide/yaml-values/#qualified-bindings","text":"Automatic unique objects bindings require using guicey binding annotation. In some cases, this is not possible: for example, generic 3 rd party guice module. You can use qualified bindings then. The idea is simple: just annotate any configuration property or getter with a qualified annotation and it would be bound in guice context. Moreover, if multiple properties (same type!) would be annotated with the same annotation - they would be bound as Set . For example, public class MyConfig extends Configuration { @Named ( \"custom\" ) private String prop1 ; @CustomQualifier private SubObj obj1 = new SubObj (); Tip Custom qualifying annotation must be annotated with guice @BindingAnnotation or javax (jakarta) @Qualifier (see guice and javax (jakarta) @Named annotations as an example). @Retention ( RetentionPolicy . RUNTIME ) @Target ({ ElementType . FIELD , ElementType . PARAMETER , ElementType . METHOD }) @BindingAnnotation public @interface CustomQualifier {} Would mean two additional bindings: @Inject @Named ( \"custom\" ) String prop1 ; @Inject @CustomQualifier SubObj obj1 ; Important If you expect null values then identify it (otherwise injector creation would fail for null value): @Inject @Named(\"custom\") @javax.inject.Nullable String prop1; And binding like this: @Named ( \"sub-prop\" ) private String prop2 ; @Named ( \"sub-prop\" ) private String prop3 ; Would result in aggregated binding: @Inject @Named ( \"sub-prop\" ) Set < String > prop23 ; Note Qualifying annotations may be used on any configuration depth (not only in the root configuration object). Core dropwizard objects could also be bound with a qualified overridden getter: @Named ( \"metrics\" ) @Override MetricsFactory getMetricsFactory () { return super . getMetricsFactory (); } Note All custom bindings are visible in the configuration report: .printCustomConfigurationBindings() Tip Guicey bundles and guice modules also could use qualified configuration values directly: GuiceyEnvironment # annotatedConfiguration ( Ann . class ) DropwizardAwareModule # annotatedConfiguration ( Ann . class )","title":"Qualified bindings"},{"location":"guide/yaml-values/#configuration-by-path","text":"All visible configuration paths values are directly bindable: public class MyConfig extends Configuration { SubConf sub ; } public class SubConf { String smth ; List < String > values ; } @Inject @Config ( \"sub\" ) SubConf sub ; @Inject @Config ( \"sub.smth\" ) String smth ; @Inject @Config ( \"sub.values\" ) List < String > values ; Note Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations). The only exception is conditional mapping like dropwizard \"server\" when available paths could change, depending on configuration (what configuration class will be used) Note Generified types are bound only with generics (with all available type information). If you will have SubConf<T> sub in config, then it will be bound with correct generic SubConfig<String> (suppose generic T is declared as String). Value type, declared in configuration class is used for binding, but there are two exceptions. If declared type is declared as collection (Set, List, Map) implementation then binding will use base collection interface: ArrayList < String > value @Inject @Config ( \"value\" ) List < String > vlaue ; If, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence: @Config(\"path\") Object val - when value is null @Config(\"path\") ValueType val - actual value type, when value is not null It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\"). Tip You can declare you own additional bindings using ConfigurationTree (accessible from guice module), which contains all paths information (including declaration and actual types with generics).","title":"Configuration by path"},{"location":"guide/yaml-values/#introspected-configuration","text":"ConfigurationTree object provides access for introspected configuration tree: getRootTypes() - all classes in configuration hierarchy (including interfaces) getPaths() - all paths (including all steps (\"sub\", \"sub.value\")) getUniqueTypePaths() - paths of unique sub configuration types Each path item ( ConfigPath ) contains: Root path reference (\"sub.value\" reference \"sub\") Child sub-paths (\"sub\" reference \"sub.value\") Declaration class (type used in configuration class) Value type (type of actual value; when value null - declaration type (but they still could be different for collections)) Current path name Current path value Generics for declaration and value types (may be incomplete for value type) Custom type marker: contains sub paths or just looks like sub configuration Declaration type (class where property was declared - configuration object containing property) You can traverse up or down from any path (tree structure). ConfigurationTree provides basic search methods (more as usage example): findByPath(String) - search path by case-insensitive match findAllByType(Class) - find all paths with assignable declared value findAllFrom(Class<? extends Configuration>) - find all paths, started in specified configuration class findAllRootPaths() - get all root paths (1 st level paths) findAllRootPathsFrom(Class<? extends Configuration>) - all 1 st level paths of configuration class valueByPath(String) - return path value or null if value null or path not exists valuesByType(Class) - all not null values with assignable type valueByType(Class) - first not null value with assignable type valueByUniqueDeclaredType(Class) - value of unique sub configuration or null if value is null or config is not unique Methods to work with qualified configurations: findAllByAnnotation(ann | Class) - find all annotated properties by annotation instance or annotation class findByAnnotation(ann | Class) - find exactly one annotated property or throw error if more then one found annotatatedValues(ann | Class) - all non-null values from annotated properties annotatatedValue(ann | Class) - an annotated property value (throw error if more properties annotated) Tip Searching by annotation instance if required for annotations with \"state\". For example, @Named(\"something\") and @Named(\"other\") are different qualifying annotations, and searching only by type would be incorrect in this case. It is not possible to directly create annotation instance, but any annotation is and interface and could be implemented. It is important that real annotation (from class) and provided object would be equal. As an example see how guice Names.named() consrtructs \"@Named\" insatnces. Paths are sorted by configuration class (to put custom properties upper) and by path name (for predictable paths order).","title":"Introspected configuration"},{"location":"guide/yaml-values/#disable-configuration-introspection","text":"Introspection process should not fail application startup. In worse case it will show warning log that property can't be introspected: WARN [2018-07-23 09:11:13,034] ru.vyarus.dropwizard.guice.module.yaml.ConfigTreeBuilder: Can't bind configuration path 'sub.sample' due to IllegalArgumentException: Failed to getValue() with method ru.vyarus.dropwizard.guice.yaml.support.FailedGetterConfig#getSample(0 params): null. Enable debug logs to see complete stack trace or use @JsonIgnore on property getter. Such warnings could be hidden by using @JsonIgnore on property getter. If this is not enough, or you need to avoid configuration introspection for other reasons, you can disable introspection completely with option: GuiceBundle . builder () . option ( GuiceyOptions . BindConfigurationByPath , false ) ... When introspection disabled, only configuration object would be bound and bindings by path would not be available. Note that even ConfigurationTree object will not contain configuration paths (option completely disables introspection mechanism).","title":"Disable configuration introspection"},{"location":"guide/diagnostic/aop-report/","text":"AOP report \u00b6 Guice AOP report shows all registered aop handlers and how (what order) they apply to guice beans. GuiceBundle . builder () ... . printGuiceAopMap () . build () Example output: 2 AOP handlers declared \u251c\u2500\u2500 AopModule/Interceptor1 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.AopModule.configure(AopModule.java:23) \u2514\u2500\u2500 AopModule/Interceptor2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.AopModule.configure(AopModule.java:24) 1 bindings affected by AOP \u2502 \u2514\u2500\u2500 Service (r.v.d.g.d.r.g.s.AopModule) \u251c\u2500\u2500 something() Interceptor1 \u2514\u2500\u2500 somethingElse(List) Interceptor1, Interceptor2 This report shows all affected beans with all methods. In real application it may lead to the giant report. In real life it would be more suitable to always fine-tune report as a tool . Important Report is build using guice SPI from raw modules because it's the only way to detect registered aop listeners. But this also cause an additional execution of configure() method of all modules when report is enabled. In most cases, this is not a problem (modules should only declare bindings). Report use stage TOOL , so, if required, you can easilly avoid duplicate execution for sensitive logic: if ( binder . currentStage () != Stage . TOOL ) { // do only on normal run } For example, guicey itself use this in installers to avoid duplicate console output on startup when report enabled. Kotlin If you're using kotlin, keep in mind that it makes methods final by default so guice will not be able to apply aop . The workaround is to put open keyword before method . Tool \u00b6 Important Report is intended to be used as a tool in order to reveal aop on exact bean or even method (or showing appliances of exact handler). Partial aop map activation: . printGuiceAopMap ( new GuiceAopConfig () . types (...) . methods (...) . interceptors (...)) Where usual guice matchers used for type and method matching. For example, to see only bindings of exact bean: . printGuiceAopMap ( new GuiceAopConfig () . types ( Matchers . subclassesOf ( MyService . class ))) All methods returning List : . printGuiceAopMap ( new GuiceAopConfig () . methods ( Matchers . returns ( Matchers . subclassesOf ( List )))) All appliances of exact interceptor: . printGuiceAopMap ( new GuiceAopConfig () . hideDeclarationsBlock () . interceptors ( MyInterceptor )) Note In the last case still all handlers applied to filtered methods will be shown (to see overall picture). Report customization \u00b6 Report is implemented as a guicey event listener , so you can register it directly in your bundle if required (without main bundle shortcuts): listen ( new GuiceAopDiagnostic ( new GuiceAopConfig ())); Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation. For examples of direct renderer usage see events implementation: InjectorPhaseEvent.ReportRenderer","title":"AOP"},{"location":"guide/diagnostic/aop-report/#aop-report","text":"Guice AOP report shows all registered aop handlers and how (what order) they apply to guice beans. GuiceBundle . builder () ... . printGuiceAopMap () . build () Example output: 2 AOP handlers declared \u251c\u2500\u2500 AopModule/Interceptor1 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.AopModule.configure(AopModule.java:23) \u2514\u2500\u2500 AopModule/Interceptor2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.AopModule.configure(AopModule.java:24) 1 bindings affected by AOP \u2502 \u2514\u2500\u2500 Service (r.v.d.g.d.r.g.s.AopModule) \u251c\u2500\u2500 something() Interceptor1 \u2514\u2500\u2500 somethingElse(List) Interceptor1, Interceptor2 This report shows all affected beans with all methods. In real application it may lead to the giant report. In real life it would be more suitable to always fine-tune report as a tool . Important Report is build using guice SPI from raw modules because it's the only way to detect registered aop listeners. But this also cause an additional execution of configure() method of all modules when report is enabled. In most cases, this is not a problem (modules should only declare bindings). Report use stage TOOL , so, if required, you can easilly avoid duplicate execution for sensitive logic: if ( binder . currentStage () != Stage . TOOL ) { // do only on normal run } For example, guicey itself use this in installers to avoid duplicate console output on startup when report enabled. Kotlin If you're using kotlin, keep in mind that it makes methods final by default so guice will not be able to apply aop . The workaround is to put open keyword before method .","title":"AOP report"},{"location":"guide/diagnostic/aop-report/#tool","text":"Important Report is intended to be used as a tool in order to reveal aop on exact bean or even method (or showing appliances of exact handler). Partial aop map activation: . printGuiceAopMap ( new GuiceAopConfig () . types (...) . methods (...) . interceptors (...)) Where usual guice matchers used for type and method matching. For example, to see only bindings of exact bean: . printGuiceAopMap ( new GuiceAopConfig () . types ( Matchers . subclassesOf ( MyService . class ))) All methods returning List : . printGuiceAopMap ( new GuiceAopConfig () . methods ( Matchers . returns ( Matchers . subclassesOf ( List )))) All appliances of exact interceptor: . printGuiceAopMap ( new GuiceAopConfig () . hideDeclarationsBlock () . interceptors ( MyInterceptor )) Note In the last case still all handlers applied to filtered methods will be shown (to see overall picture).","title":"Tool"},{"location":"guide/diagnostic/aop-report/#report-customization","text":"Report is implemented as a guicey event listener , so you can register it directly in your bundle if required (without main bundle shortcuts): listen ( new GuiceAopDiagnostic ( new GuiceAopConfig ())); Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation. For examples of direct renderer usage see events implementation: InjectorPhaseEvent.ReportRenderer","title":"Report customization"},{"location":"guide/diagnostic/configuration-model/","text":"Configuration model \u00b6 All recorder guicey configuration is accessible as: @Inject GuiceyConfigurationInfo info ; Configuration items Startup stats Option values and usage info Parsed configuration values Configuration items \u00b6 Identity \u00b6 Attention Configuration items (extensions, installers, bundles etc) are identified with special ItemId objects. This is important because guicey supports multiple instances of the same type. ItemId object equals behaviour may seem non intuitive (see below). For classes ItemId is essentially the same as class: ItemId . from ( SomeClass . class ). equals ( ItemId . from ( SomeClass . class )) == true For instances, item id compute object hash (using System.identityHashCode() ). ItemId could be always created from object instance: ItemId . from ( instance ). equals ( ItemId . from ( instance )) == true but for different instances obviously: ItemId . from ( instance ). equals ( ItemId . from ( otherInstance )) == false But instance identity myst also be recognized by class, because otherwise it is hard to analyze items, so: ItemId . from ( instance . getClass ()). equals ( ItemId . from ( otherInstance )) == true Class identity equals all instance identities of the same class . This allows you to use ItemId.from(MyBundle.class) to get all instance configs for required bundle types. Model \u00b6 Each configuration item is stored using model object. All model classes are inherited from ItemInfo : Model class Description ItemInfo Base class for all models ClassItemInfo Base class for class-based models: extension, installer InstanceItemInfo Base class for instance-based models: bundles, modules ExtensionItemInfo Extension model InstallerItemInfo Installer model ModuleItemInfo Module model GuiceyBundleItemInfo Guicey bundle model DropwizardBundleItemInfo Dropwizard bundle model For example, when you configure extension: . extensions ( MyExtension , class ) Guicey will create new instance of ExtensionItemInfo to store item registration data. For each registered item registration scope is tracked. It could be Application (if item registered in main bundle) Guicey bundle class (for items registered in this bundle) ClasspathScan (for classes from classpath scan) etc .. All scopes are described in ConfigScope enum. Note ItemId is also used for scopes, because we may have multiple bundles of the same type and so need to differentiate them as different scopes. For class based extensions only one model instance will be created for all registrations of the same type . But all registration scopes will be preserved, so it is possible to know all extension duplicate points (and you can see it on diagnostic report ) For instance based extensions , different model instances will be created for different items. So if some object was detected as duplicate , it's id will be only added to original object model ( InstanceItemInfo#getDuplicates() ) to be able to track duplicates. Querying model \u00b6 All raw data is actually available through: GuiceyConfigurationInfo#getData() , but GuiceyConfigurationInfo provides many shortcut methods to simplify raw data querying. Data querying is based on java Predicate usage. Filters class provides common predicate builders. Many examples of its usage may be found in code. Note For some reports it is important to know only types of used configuration items, ignoring duplicates. Special helper is included directly inside ItemId : ItemId.typesOnly(...) For example, getInstallers() from GuiceyConfigurationInfo : public List < Class < FeatureInstaller >> getInstallers () { return typesOnly ( getData (). getItems ( ConfigItem . Installer , Filters . enabled ())); } More advanced queries are applied with predicate composition: public List < Class < Object >> getExtensionsRegisteredManually () { return typesOnly ( getData (). getItems ( ConfigItem . Extension , Filters . < ExtensionItemInfo > enabled () . and ( it -> it . getRegistrationScopeType (). equals ( ConfigScope . Application ) || it . getRegistrationScopeType (). equals ( ConfigScope . GuiceyBundle )))); } For exact configuration item type you can always get its configuration model: @Inject GuiceyConfigurationInfo info ; ItemInfo model = info . getInfo ( MyExtension . class ) For instance-based items, you can receive all models for instances of type: List < BundleItemInfo > models = info . getInfos ( MyBundle . class ) And the last example is if you know exact extension instance and wasn't to get its info: BundleItemInfo model = info . getData (). getInfo ( ItemId . from ( myBundleInstance )) Instances \u00b6 Bundles and modules are configured by instance and this instance is stored in configuration model. For example, to obtain all configured (and not disabled ) guice modules: @Inject GuiceConfigurationInfo info ; List < Module > modules = info . getModuleIds (). stream () . map ( it -> info . getData (). < ModuleItemInfo > getInfo ( it ). getInstance ()) . collect ( Collectors . toList ()); Here all used module ids ( ItemId ) obtained. Then complete configuration model loaded for each item and instance obtained from model. Note It may look overcomplicated to load ids first and only later obtain instances, but it is actually a restriction of the model: correct registration order is preserved on id level and so this way is the only way to get all instances in registration order. Note Direct model object load by id shortcut was not added directly to GuiceyConfigurationInfo intentionally to avoid mistakes by accidentally using class-based info loading instead of id-based (which may lead to configuration items loss in your reporting or analysis). Startup stats \u00b6 Startup stats ar available through: GuiceyConfigurationInfo#getStats() . All available stats are listed in Stat enum. Usage examples see in bundles report renderers. Options \u00b6 Options usage info is available through: GuiceyConfigurationInfo#getOptions() . Apart from actual option values, it could tell if custom option value was set and if this option value was ever queried (by application). Configuration tree \u00b6 Parsed configuration object is available through GuiceyConfigurationInfo#getConfigurationTree()","title":"Configuration model"},{"location":"guide/diagnostic/configuration-model/#configuration-model","text":"All recorder guicey configuration is accessible as: @Inject GuiceyConfigurationInfo info ; Configuration items Startup stats Option values and usage info Parsed configuration values","title":"Configuration model"},{"location":"guide/diagnostic/configuration-model/#configuration-items","text":"","title":"Configuration items"},{"location":"guide/diagnostic/configuration-model/#identity","text":"Attention Configuration items (extensions, installers, bundles etc) are identified with special ItemId objects. This is important because guicey supports multiple instances of the same type. ItemId object equals behaviour may seem non intuitive (see below). For classes ItemId is essentially the same as class: ItemId . from ( SomeClass . class ). equals ( ItemId . from ( SomeClass . class )) == true For instances, item id compute object hash (using System.identityHashCode() ). ItemId could be always created from object instance: ItemId . from ( instance ). equals ( ItemId . from ( instance )) == true but for different instances obviously: ItemId . from ( instance ). equals ( ItemId . from ( otherInstance )) == false But instance identity myst also be recognized by class, because otherwise it is hard to analyze items, so: ItemId . from ( instance . getClass ()). equals ( ItemId . from ( otherInstance )) == true Class identity equals all instance identities of the same class . This allows you to use ItemId.from(MyBundle.class) to get all instance configs for required bundle types.","title":"Identity"},{"location":"guide/diagnostic/configuration-model/#model","text":"Each configuration item is stored using model object. All model classes are inherited from ItemInfo : Model class Description ItemInfo Base class for all models ClassItemInfo Base class for class-based models: extension, installer InstanceItemInfo Base class for instance-based models: bundles, modules ExtensionItemInfo Extension model InstallerItemInfo Installer model ModuleItemInfo Module model GuiceyBundleItemInfo Guicey bundle model DropwizardBundleItemInfo Dropwizard bundle model For example, when you configure extension: . extensions ( MyExtension , class ) Guicey will create new instance of ExtensionItemInfo to store item registration data. For each registered item registration scope is tracked. It could be Application (if item registered in main bundle) Guicey bundle class (for items registered in this bundle) ClasspathScan (for classes from classpath scan) etc .. All scopes are described in ConfigScope enum. Note ItemId is also used for scopes, because we may have multiple bundles of the same type and so need to differentiate them as different scopes. For class based extensions only one model instance will be created for all registrations of the same type . But all registration scopes will be preserved, so it is possible to know all extension duplicate points (and you can see it on diagnostic report ) For instance based extensions , different model instances will be created for different items. So if some object was detected as duplicate , it's id will be only added to original object model ( InstanceItemInfo#getDuplicates() ) to be able to track duplicates.","title":"Model"},{"location":"guide/diagnostic/configuration-model/#querying-model","text":"All raw data is actually available through: GuiceyConfigurationInfo#getData() , but GuiceyConfigurationInfo provides many shortcut methods to simplify raw data querying. Data querying is based on java Predicate usage. Filters class provides common predicate builders. Many examples of its usage may be found in code. Note For some reports it is important to know only types of used configuration items, ignoring duplicates. Special helper is included directly inside ItemId : ItemId.typesOnly(...) For example, getInstallers() from GuiceyConfigurationInfo : public List < Class < FeatureInstaller >> getInstallers () { return typesOnly ( getData (). getItems ( ConfigItem . Installer , Filters . enabled ())); } More advanced queries are applied with predicate composition: public List < Class < Object >> getExtensionsRegisteredManually () { return typesOnly ( getData (). getItems ( ConfigItem . Extension , Filters . < ExtensionItemInfo > enabled () . and ( it -> it . getRegistrationScopeType (). equals ( ConfigScope . Application ) || it . getRegistrationScopeType (). equals ( ConfigScope . GuiceyBundle )))); } For exact configuration item type you can always get its configuration model: @Inject GuiceyConfigurationInfo info ; ItemInfo model = info . getInfo ( MyExtension . class ) For instance-based items, you can receive all models for instances of type: List < BundleItemInfo > models = info . getInfos ( MyBundle . class ) And the last example is if you know exact extension instance and wasn't to get its info: BundleItemInfo model = info . getData (). getInfo ( ItemId . from ( myBundleInstance ))","title":"Querying model"},{"location":"guide/diagnostic/configuration-model/#instances","text":"Bundles and modules are configured by instance and this instance is stored in configuration model. For example, to obtain all configured (and not disabled ) guice modules: @Inject GuiceConfigurationInfo info ; List < Module > modules = info . getModuleIds (). stream () . map ( it -> info . getData (). < ModuleItemInfo > getInfo ( it ). getInstance ()) . collect ( Collectors . toList ()); Here all used module ids ( ItemId ) obtained. Then complete configuration model loaded for each item and instance obtained from model. Note It may look overcomplicated to load ids first and only later obtain instances, but it is actually a restriction of the model: correct registration order is preserved on id level and so this way is the only way to get all instances in registration order. Note Direct model object load by id shortcut was not added directly to GuiceyConfigurationInfo intentionally to avoid mistakes by accidentally using class-based info loading instead of id-based (which may lead to configuration items loss in your reporting or analysis).","title":"Instances"},{"location":"guide/diagnostic/configuration-model/#startup-stats","text":"Startup stats ar available through: GuiceyConfigurationInfo#getStats() . All available stats are listed in Stat enum. Usage examples see in bundles report renderers.","title":"Startup stats"},{"location":"guide/diagnostic/configuration-model/#options","text":"Options usage info is available through: GuiceyConfigurationInfo#getOptions() . Apart from actual option values, it could tell if custom option value was set and if this option value was ever queried (by application).","title":"Options"},{"location":"guide/diagnostic/configuration-model/#configuration-tree","text":"Parsed configuration object is available through GuiceyConfigurationInfo#getConfigurationTree()","title":"Configuration tree"},{"location":"guide/diagnostic/configuration-report/","text":"Configuration report \u00b6 Note During startup guicey records startup metrics and remembers all details of configuration process. All this information is available through GuiceyConfigurationInfo bean: @Inject GuiceyConfigurationInfo info ; For usage details see conifguration model Configuration diagnostic report is the most commonly used report allowing you to see guicey startup and configuration details (the last is especially important for de-duplication logic diagnostic). GuiceBundle . builder () ... . printDiagnosticInfo () . build ()); Report intended to answer: How guicey spent time What options used What was configured From where configuration items come from Example report: INFO [2019-10-11 04:25:47,022] ru.vyarus.dropwizard.guice.debug.ConfigurationDiagnostic: Diagnostic report ---------------------------------------------------------------------------[STARTUP STATS] GUICEY started in 431.2 ms (150.2 ms config / 279.4 ms run / 1.594 ms jersey) \u2502 \u251c\u2500\u2500 [0.70%] CLASSPATH scanned in 3.088 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) \u2502 \u251c\u2500\u2500 [24%] BUNDLES processed in 105.8 ms \u2502 \u251c\u2500\u2500 1 resolved in 12.22 ms \u2502 \u251c\u2500\u2500 7 initialized in 23.75 ms \u2502 \u2514\u2500\u2500 1 dropwizard bundles initialized in 69.58 ms \u2502 \u251c\u2500\u2500 [2.6%] COMMANDS processed in 11.34 ms \u2502 \u2514\u2500\u2500 registered 2 commands \u2502 \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms \u2502 \u251c\u2500\u2500 7 modules autowired \u2502 \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms \u2502 \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings \u2502 \u251c\u2500\u2500 [7.4%] INSTALLERS processed in 32.60 ms \u2502 \u251c\u2500\u2500 registered 12 installers \u2502 \u2514\u2500\u2500 4 extensions recognized from 10 classes in 11.63 ms \u2502 \u251c\u2500\u2500 [47%] INJECTOR created in 204.2 ms \u2502 \u251c\u2500\u2500 Module execution: 124 ms \u2502 \u251c\u2500\u2500 Interceptors creation: 2 ms \u2502 \u251c\u2500\u2500 TypeListeners & ProvisionListener creation: 2 ms \u2502 \u251c\u2500\u2500 Scopes creation: 1 ms \u2502 \u251c\u2500\u2500 Binding creation: 20 ms \u2502 \u251c\u2500\u2500 Module annotated method scanners creation: 1 ms \u2502 \u251c\u2500\u2500 Binding initialization: 29 ms \u2502 \u251c\u2500\u2500 Collecting injection requests: 2 ms \u2502 \u251c\u2500\u2500 Static validation: 3 ms \u2502 \u251c\u2500\u2500 Instance member validation: 3 ms \u2502 \u251c\u2500\u2500 Provider verification: 1 ms \u2502 \u251c\u2500\u2500 Static member injection: 7 ms \u2502 \u251c\u2500\u2500 Instance injection: 3 ms \u2502 \u2514\u2500\u2500 Preloading singletons: 4 ms \u2502 \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms \u2502 \u251c\u2500\u2500 4 extensions installed \u2502 \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding \u2502 \u251c\u2500\u2500 [0.23%] JERSEY bridged in 1.594 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 3 jersey extensions installed in 501.8 \u03bcs \u2502 \u2514\u2500\u2500 [7.4%] remaining 32 ms ---------------------------------------------------------------------------[OPTIONS] Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true BindConfigurationByPath = true TrackDropwizardBundles = true AnalyzeGuiceModules = true InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] UseHkBridge = false Installers (r.v.d.g.m.i.InstallersOptions) JerseyExtensionsManagedByGuice = true ForceSingletonForJerseyExtensions = true ---------------------------------------------------------------------------[CONFIGURATION] COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN, GUICE_ENABLED BUNDLES = FooDwBundle (r.v.d.g.d.s.dwbundle) *DW Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *HOOK, REG(1/2) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *HOOK CoreInstallersBundle (r.v.d.g.m.installer) WebInstallersBundle (r.v.d.g.m.installer) LookupBundle (r.v.d.g.d.s.bundle) *LOOKUP INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(1/2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(1/3) FooResource (r.v.d.g.d.s.features) *SCAN ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) *BINDING GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2/2) ModuleWithExtensions (r.v.d.g.d.s.module) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) OverridingModule (r.v.d.g.d.s.module) *OVERRIDE GuiceBootstrapModule (r.v.d.guice.module) ---------------------------------------------------------------------------[CONFIGURATION TREE] APPLICATION \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) \u251c\u2500\u2500 module ModuleWithExtensions (r.v.d.g.d.s.module) \u251c\u2500\u2500 module GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 FooDwBundle (r.v.d.g.d.s.dwbundle) *DW \u2502 \u251c\u2500\u2500 Foo2Bundle (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE \u2502 \u251c\u2500\u2500 module FooBundleModule (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 -disable ManagedInstaller (r.v.d.g.m.i.feature) \u2502 \u2502 \u2502 \u2514\u2500\u2500 FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module FooModule#2 (r.v.d.g.d.s.features) \u2502 \u251c\u2500\u2500 HK2DebugBundle (r.v.d.g.m.j.debug) \u2502 \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u251c\u2500\u2500 extension HK2DebugFeature (r.v.d.g.m.j.d.service) \u2502 \u2514\u2500\u2500 module HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) \u2502 \u251c\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 installer -JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) *DUPLICATE \u2502 \u251c\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u2514\u2500\u2500 WebInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 BUNDLES LOOKUP \u2502 \u2502 \u2502 \u2514\u2500\u2500 LookupBundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module OverridingModule (r.v.d.g.d.s.module) \u2502 \u251c\u2500\u2500 CLASSPATH SCAN \u2502 \u2514\u2500\u2500 extension FooResource (r.v.d.g.d.s.features) \u2502 \u251c\u2500\u2500 GUICE BINDINGS \u2502 \u2502 \u2502 \u2514\u2500\u2500 ModuleWithExtensions (r.v.d.g.d.s.module) \u2502 \u2514\u2500\u2500 extension ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) \u2502 \u2514\u2500\u2500 HOOKS \u251c\u2500\u2500 -HK2DebugBundle (r.v.d.g.m.j.debug) *DUPLICATE \u2502 \u2514\u2500\u2500 GuiceRestrictedConfigBundle (r.v.d.g.support.util) \u2514\u2500\u2500 module GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) Timings \u00b6 Note There are also another \"time-report\" available which shows entire application startup timings. Startup timings \u00b6 GUICEY started in 431.2 ms (150.2 ms config / 279.4 ms run / 1.594 ms jersey) Guicey time ( 431.2 ms ) is measured as GuiceBundle methods plus part of jersey configuration time (jersey started after bundle). It also shows time spent on each application starting phase: 150.2 ms configuration (initialization), 279.4 ms run and 1.594 ms during jersey startup. All items below represent guicey time details. Each child item always includes the time detail of the direct parent. Tip Application startup during development may be improved with VM options: -XX:TieredStopAtLevel=1 -noverify It does not show a big difference on test sample, but it's already a notable change (~20% faster): GUICEY started in 304.0 ms (88.18 ms config / 214.6 ms run / 1.130 ms jersey) Classpath scan \u00b6 \u251c\u2500\u2500 [0.70%] CLASSPATH scanned in 3.088 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) Classpath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. scanned 5 classes means that 5 classed were found (overall) in configured packages. recognized 4 classes show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command). Note Classpath scan time will be obviously bigger for real applications (with larger classes count). But most of this time spent on class loading (because guicey loads all classes during scan and not just parse class structure). If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time will just move to other places (where classes are used). Bundles \u00b6 \u251c\u2500\u2500 [24%] BUNDLES processed in 105.8 ms \u2502 \u251c\u2500\u2500 1 resolved in 12.22 ms \u2502 \u251c\u2500\u2500 7 initialized in 23.75 ms \u2502 \u2514\u2500\u2500 1 dropwizard bundles initialized in 69.58 ms Bundles time includes bundles lookup time (if not .disableBundleLookup()), bundles execution (both init and run) and dropwizard bundles (known by guicey) init time (run time is not tracked because it appears after GuiceBundle.run ). 1 resolved indicated bundles resolved with guicey bundle lookup. 7 initialized overall processed bundles (all registered bundles, including transitives). Time cover both init and run. 1 dropwizard bundles initialized dropwizard bundles (registered through guicey api!) initialization time. Dropwizard bundles always include ~50ms overhead of Bootstrap object proxying, required for transitive bundles tracking. Commands \u00b6 \u251c\u2500\u2500 [2.6%] COMMANDS processed in 11.34 ms \u2502 \u2514\u2500\u2500 registered 2 commands Commands time includes time spent on commands search (in classes from already performed classpath scan), and calling .injectMemebers on found environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled) Note Most of commands time will be command objects instantiation (reflection). Modules \u00b6 \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms \u2502 \u251c\u2500\u2500 7 modules autowired \u2502 \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms \u2502 \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings 7 modules autowired Aware* interfaces processing for registered modules (user modules + overrides + 1 guicey module) 8 elements found in 5 user modules Guicey performs modules introspection before injector creation (with guice SPI) and shows all found elements. Only user modules are introspected (except override and guicey module). 1 extensions detected from 3 acceptable bindings Shows detected extensions from bindings. Note that overall modules elements count include aop, listeners etc. Also, bindings are searched only in direct class bindings, so acceptable elements count will almost always be lower then overall elements count. Installers \u00b6 \u251c\u2500\u2500 [7.4%] INSTALLERS processed in 32.60 ms \u2502 \u251c\u2500\u2500 registered 12 installers \u2502 \u2514\u2500\u2500 4 extensions recognized from 10 classes in 11.63 ms Shows installers initialization and processing time. registered 12 installers Overall count of used installers (core and custom, without disables). 4 extensions recognized from 10 classes Overall recognition time (potential extension classes introspection time). Includes class from classpath scan, all manual extension classes and checked (acceptable) bindings. Injector \u00b6 \u251c\u2500\u2500 [47%] INJECTOR created in 204.2 ms \u2502 \u251c\u2500\u2500 Module execution: 124 ms \u2502 \u251c\u2500\u2500 Interceptors creation: 2 ms \u2502 \u251c\u2500\u2500 TypeListeners & ProvisionListener creation: 2 ms \u2502 \u251c\u2500\u2500 Scopes creation: 1 ms \u2502 \u251c\u2500\u2500 Binding creation: 20 ms \u2502 \u251c\u2500\u2500 Module annotated method scanners creation: 1 ms \u2502 \u251c\u2500\u2500 Binding initialization: 29 ms \u2502 \u251c\u2500\u2500 Collecting injection requests: 2 ms \u2502 \u251c\u2500\u2500 Static validation: 3 ms \u2502 \u251c\u2500\u2500 Instance member validation: 3 ms \u2502 \u251c\u2500\u2500 Provider verification: 1 ms \u2502 \u251c\u2500\u2500 Static member injection: 7 ms \u2502 \u251c\u2500\u2500 Instance injection: 3 ms \u2502 \u2514\u2500\u2500 Preloading singletons: 4 ms Pure injector creation time. Sub logs are intercepted guice internal logs (from com.google.inject.internal.util ). Only lines with non 0 time are shown. Extensions \u00b6 \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms \u2502 \u251c\u2500\u2500 4 extensions installed \u2502 \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding Extensions are installed just after injector creation. Time represent installers installation logic time. 4 extensions installed All used (installed, not disabled) extensions declared as: 2 manual, 1 scan, 1 binding Extensions sources: manual registration, classpath scan, bindings in guice modules. One extension could appear multiple times in counters (if it was detected in multiple sources) Jersey \u00b6 \u251c\u2500\u2500 [0.23%] JERSEY bridged in 1.594 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 3 jersey extensions installed in 501.8 \u03bcs Jersey starts after dropwizard bundles processing and so after GuiceBundle execution. Guicey register required HK2 bindings (and some HK2 beans in guice) and executes jersey installers (installers implementing JerseyInstaller ) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires HK2 specific bindings). using 2 jersey installers All jersey feature installers (not disabled) 3 jersey extensions installed All jersey extensions (not disabled) Note that extensions installation time is so tiny ( 501.8 \u03bcs ) just because empty resources (without methods) were used. In real application installation time will be bigger. Remaining \u00b6 \u2514\u2500\u2500 [7.4%] remaining 32 ms Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown. Used options \u00b6 Shows all guicey options set or requested (by application logic). If you use your own options here they will also be printed. Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true BindConfigurationByPath = true TrackDropwizardBundles = true AnalyzeGuiceModules = true InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] UseHkBridge = false Installers (r.v.d.g.m.i.InstallersOptions) JerseyExtensionsManagedByGuice = true ForceSingletonForJerseyExtensions = true Used markers: CUSTOM - option value set by user NOT_USED - option was set by user but never used Note NOT_USED marker just indicates that option is \"not yet\" used. Options may be consumed lazily by application logic, so it is possible that it's not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario). Configuration summary \u00b6 Section intended to show all configuration summary (to quickly see what was configured). This and the next sections used condensed package notion: CoreInstallersBundle (r.v.d.g.m.installer) Assumed that all classes in application will be uniquely identifiable by name so package info shown just to be able to understand exact class location. Logback shrinker used. Report indicates duplicate registrations and items of the same type registrations: REG(1/3) , where first number is accepted instances count and last number is overall registrations count. For extensions it's always 1/N , but for instances (modules, bundles) it indicates de-duplication mechanism work. Commands \u00b6 COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN, GUICE_ENABLED Shows commands resolved with classpath scan (enabled with .searchCommands() ). The following markers used: SCAN - item from classpath scan (always) GUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts) Bundles \u00b6 BUNDLES = FooDwBundle (r.v.d.g.d.s.dwbundle) *DW Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *HOOK, REG(1/2) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *HOOK CoreInstallersBundle (r.v.d.g.m.installer) WebInstallersBundle (r.v.d.g.m.installer) LookupBundle (r.v.d.g.d.s.bundle) *LOOKUP All registered bundles are shown as a tree (to indicate transitive bundles). Markers used: LOOKUP - bundle resolved with bundle lookup mechanism DW - dropwizard bundle HOOK - registered by configuration hook Installers and extensions \u00b6 INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(1/2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(1/3) FooResource (r.v.d.g.d.s.features) *SCAN ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) *BINDING Shows used installers (only installers which install extensions) and installed extensions. Both installers and extensions are shown in the processing order (sorted according to @Order annotations). Markers used: SCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan) LAZY - extensions annotated with @LazyBinding JERSEY - extension annotated with @JerseyManaged HOOK - registered by configuration hook BINDING - extension recognized from guice binding Modules \u00b6 GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2/2) ModuleWithExtensions (r.v.d.g.d.s.module) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) OverridingModule (r.v.d.g.d.s.module) *OVERRIDE GuiceBootstrapModule (r.v.d.guice.module) All registered guice modules: user modules + override modules + guicey GuiceBootstrapModule . Overriding modules are marked with OVERRIDE . Configuration tree \u00b6 Configuration tree is useful to understand from where configuration items come from. Note Configuration tree shows both guicey bundles and dropwizard bundle trees (for dropwizard bundles, registered through guicey api). Dropwizard bundles are identified with marker DW . There are several sections in tree: APPLICATION - for everything registered in GuiceBundle BUNDLES LOOKUP - for bundles resolved with lookup mechanism CLASSPATH SCAN - for items resolved by classpath scan GUICE BINDINGS - for extensions resolved from guice module bindings HOOKS - for registered hooks Markers: DW - dropwizard bundle DISABLED - item manually disabled DUPLICATE - item considered as duplicate for already registered item Disables \u00b6 Manual disable is identified (to quickly understand who disabled item) as: \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) And disabled items would be also identified: \u251c\u2500\u2500 installer -LifeCycleInstaller (r.v.d.g.m.i.feature) *DISABLED Disabled bundles are shown without context (to identify disable): -HK2DebugBundle (r.v.d.g.m.j.debug) *DISABLED De-duplication \u00b6 Duplicate registration or instance de-duplications are identified as: \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE If extension is registered more then once in the same context, it would be identified: \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE If more then one instance (in this context) is considered to be duplicate then number will appear: \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE(3) When multiple instances of the same type is registered (form modules or bundles), they would be numbered in order of registration (to differentiate): APPLICATION \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) ... \u2502 \u2514\u2500\u2500 FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module FooModule#2 (r.v.d.g.d.s.features) In order to better track duplicates, items, recognized as duplicates, will be shown with registered instance they considered to be duplicate to. For example, for above sample, if another FooModule registered and it would be considered as duplicate to second instance, it would be printed as: \u2514\u2500\u2500 module -FooModule#2 (r.v.d.g.d.s.features) *DUPLICATE Guice bindings \u00b6 Extensions detected from guice bindings are shown as a sub tree: \u251c\u2500\u2500 GUICE BINDINGS \u2502 \u2502 \u2502 \u2514\u2500\u2500 ModuleWithExtensions (r.v.d.g.d.s.module) \u2502 \u2514\u2500\u2500 extension ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) Note Extensions are shown relative to top-most registered modules! For example, if ModuleWithExtensions internally install module ExtensionModule which actually contains extension bingind, then still ExtensionModule will not be shown and extension will remain under ModuleWithExtensions (on report). This was done to not confuse users: report shows guicey configration and user must clearly see configuration source. Bindings are not shown under main configuration tree (where modules are registered) because guicey only knows about the module class, but actually multiple module instances could be registered and so it is impossible to known what module instance extension is related to. Tip Detailed guice modules tree could be seen on guice report Customization \u00b6 .printDiagnosticInfo() shortcut register report with default settings. If you need customized report then register report listener directly. For example, installers report is a configured configuration report: . listen ( ConfigurationDiagnostic . builder ( \"Available installers report\" ) . printConfiguration ( new DiagnosticConfig () . printInstallers () . printNotUsedInstallers () . printInstallerInterfaceMarkers ()) . printContextTree ( new ContextTreeConfig () . hideCommands () . hideDuplicateRegistrations () . hideEmptyBundles () . hideExtensions () . hideModules ()) . build ()); Report rendering logic may also be used directly as all sub-reports provide separate renderer object implementing ReportRenderer . Renderers not bound to guice context and assume direct instantiation. For examples of direct renderers usage see events implementation: InjectorPhaseEvent.ReportRenderer","title":"Configuration"},{"location":"guide/diagnostic/configuration-report/#configuration-report","text":"Note During startup guicey records startup metrics and remembers all details of configuration process. All this information is available through GuiceyConfigurationInfo bean: @Inject GuiceyConfigurationInfo info ; For usage details see conifguration model Configuration diagnostic report is the most commonly used report allowing you to see guicey startup and configuration details (the last is especially important for de-duplication logic diagnostic). GuiceBundle . builder () ... . printDiagnosticInfo () . build ()); Report intended to answer: How guicey spent time What options used What was configured From where configuration items come from Example report: INFO [2019-10-11 04:25:47,022] ru.vyarus.dropwizard.guice.debug.ConfigurationDiagnostic: Diagnostic report ---------------------------------------------------------------------------[STARTUP STATS] GUICEY started in 431.2 ms (150.2 ms config / 279.4 ms run / 1.594 ms jersey) \u2502 \u251c\u2500\u2500 [0.70%] CLASSPATH scanned in 3.088 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) \u2502 \u251c\u2500\u2500 [24%] BUNDLES processed in 105.8 ms \u2502 \u251c\u2500\u2500 1 resolved in 12.22 ms \u2502 \u251c\u2500\u2500 7 initialized in 23.75 ms \u2502 \u2514\u2500\u2500 1 dropwizard bundles initialized in 69.58 ms \u2502 \u251c\u2500\u2500 [2.6%] COMMANDS processed in 11.34 ms \u2502 \u2514\u2500\u2500 registered 2 commands \u2502 \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms \u2502 \u251c\u2500\u2500 7 modules autowired \u2502 \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms \u2502 \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings \u2502 \u251c\u2500\u2500 [7.4%] INSTALLERS processed in 32.60 ms \u2502 \u251c\u2500\u2500 registered 12 installers \u2502 \u2514\u2500\u2500 4 extensions recognized from 10 classes in 11.63 ms \u2502 \u251c\u2500\u2500 [47%] INJECTOR created in 204.2 ms \u2502 \u251c\u2500\u2500 Module execution: 124 ms \u2502 \u251c\u2500\u2500 Interceptors creation: 2 ms \u2502 \u251c\u2500\u2500 TypeListeners & ProvisionListener creation: 2 ms \u2502 \u251c\u2500\u2500 Scopes creation: 1 ms \u2502 \u251c\u2500\u2500 Binding creation: 20 ms \u2502 \u251c\u2500\u2500 Module annotated method scanners creation: 1 ms \u2502 \u251c\u2500\u2500 Binding initialization: 29 ms \u2502 \u251c\u2500\u2500 Collecting injection requests: 2 ms \u2502 \u251c\u2500\u2500 Static validation: 3 ms \u2502 \u251c\u2500\u2500 Instance member validation: 3 ms \u2502 \u251c\u2500\u2500 Provider verification: 1 ms \u2502 \u251c\u2500\u2500 Static member injection: 7 ms \u2502 \u251c\u2500\u2500 Instance injection: 3 ms \u2502 \u2514\u2500\u2500 Preloading singletons: 4 ms \u2502 \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms \u2502 \u251c\u2500\u2500 4 extensions installed \u2502 \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding \u2502 \u251c\u2500\u2500 [0.23%] JERSEY bridged in 1.594 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 3 jersey extensions installed in 501.8 \u03bcs \u2502 \u2514\u2500\u2500 [7.4%] remaining 32 ms ---------------------------------------------------------------------------[OPTIONS] Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true BindConfigurationByPath = true TrackDropwizardBundles = true AnalyzeGuiceModules = true InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] UseHkBridge = false Installers (r.v.d.g.m.i.InstallersOptions) JerseyExtensionsManagedByGuice = true ForceSingletonForJerseyExtensions = true ---------------------------------------------------------------------------[CONFIGURATION] COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN, GUICE_ENABLED BUNDLES = FooDwBundle (r.v.d.g.d.s.dwbundle) *DW Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *HOOK, REG(1/2) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *HOOK CoreInstallersBundle (r.v.d.g.m.installer) WebInstallersBundle (r.v.d.g.m.installer) LookupBundle (r.v.d.g.d.s.bundle) *LOOKUP INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(1/2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(1/3) FooResource (r.v.d.g.d.s.features) *SCAN ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) *BINDING GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2/2) ModuleWithExtensions (r.v.d.g.d.s.module) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) OverridingModule (r.v.d.g.d.s.module) *OVERRIDE GuiceBootstrapModule (r.v.d.guice.module) ---------------------------------------------------------------------------[CONFIGURATION TREE] APPLICATION \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) \u251c\u2500\u2500 module ModuleWithExtensions (r.v.d.g.d.s.module) \u251c\u2500\u2500 module GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 FooDwBundle (r.v.d.g.d.s.dwbundle) *DW \u2502 \u251c\u2500\u2500 Foo2Bundle (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE \u2502 \u251c\u2500\u2500 module FooBundleModule (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 -disable ManagedInstaller (r.v.d.g.m.i.feature) \u2502 \u2502 \u2502 \u2514\u2500\u2500 FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module FooModule#2 (r.v.d.g.d.s.features) \u2502 \u251c\u2500\u2500 HK2DebugBundle (r.v.d.g.m.j.debug) \u2502 \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u251c\u2500\u2500 extension HK2DebugFeature (r.v.d.g.m.j.d.service) \u2502 \u2514\u2500\u2500 module HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) \u2502 \u251c\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 installer -JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) *DUPLICATE \u2502 \u251c\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u2514\u2500\u2500 WebInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 BUNDLES LOOKUP \u2502 \u2502 \u2502 \u2514\u2500\u2500 LookupBundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module OverridingModule (r.v.d.g.d.s.module) \u2502 \u251c\u2500\u2500 CLASSPATH SCAN \u2502 \u2514\u2500\u2500 extension FooResource (r.v.d.g.d.s.features) \u2502 \u251c\u2500\u2500 GUICE BINDINGS \u2502 \u2502 \u2502 \u2514\u2500\u2500 ModuleWithExtensions (r.v.d.g.d.s.module) \u2502 \u2514\u2500\u2500 extension ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) \u2502 \u2514\u2500\u2500 HOOKS \u251c\u2500\u2500 -HK2DebugBundle (r.v.d.g.m.j.debug) *DUPLICATE \u2502 \u2514\u2500\u2500 GuiceRestrictedConfigBundle (r.v.d.g.support.util) \u2514\u2500\u2500 module GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle)","title":"Configuration report"},{"location":"guide/diagnostic/configuration-report/#timings","text":"Note There are also another \"time-report\" available which shows entire application startup timings.","title":"Timings"},{"location":"guide/diagnostic/configuration-report/#startup-timings","text":"GUICEY started in 431.2 ms (150.2 ms config / 279.4 ms run / 1.594 ms jersey) Guicey time ( 431.2 ms ) is measured as GuiceBundle methods plus part of jersey configuration time (jersey started after bundle). It also shows time spent on each application starting phase: 150.2 ms configuration (initialization), 279.4 ms run and 1.594 ms during jersey startup. All items below represent guicey time details. Each child item always includes the time detail of the direct parent. Tip Application startup during development may be improved with VM options: -XX:TieredStopAtLevel=1 -noverify It does not show a big difference on test sample, but it's already a notable change (~20% faster): GUICEY started in 304.0 ms (88.18 ms config / 214.6 ms run / 1.130 ms jersey)","title":"Startup timings"},{"location":"guide/diagnostic/configuration-report/#classpath-scan","text":"\u251c\u2500\u2500 [0.70%] CLASSPATH scanned in 3.088 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) Classpath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. scanned 5 classes means that 5 classed were found (overall) in configured packages. recognized 4 classes show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command). Note Classpath scan time will be obviously bigger for real applications (with larger classes count). But most of this time spent on class loading (because guicey loads all classes during scan and not just parse class structure). If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time will just move to other places (where classes are used).","title":"Classpath scan"},{"location":"guide/diagnostic/configuration-report/#bundles","text":"\u251c\u2500\u2500 [24%] BUNDLES processed in 105.8 ms \u2502 \u251c\u2500\u2500 1 resolved in 12.22 ms \u2502 \u251c\u2500\u2500 7 initialized in 23.75 ms \u2502 \u2514\u2500\u2500 1 dropwizard bundles initialized in 69.58 ms Bundles time includes bundles lookup time (if not .disableBundleLookup()), bundles execution (both init and run) and dropwizard bundles (known by guicey) init time (run time is not tracked because it appears after GuiceBundle.run ). 1 resolved indicated bundles resolved with guicey bundle lookup. 7 initialized overall processed bundles (all registered bundles, including transitives). Time cover both init and run. 1 dropwizard bundles initialized dropwizard bundles (registered through guicey api!) initialization time. Dropwizard bundles always include ~50ms overhead of Bootstrap object proxying, required for transitive bundles tracking.","title":"Bundles"},{"location":"guide/diagnostic/configuration-report/#commands","text":"\u251c\u2500\u2500 [2.6%] COMMANDS processed in 11.34 ms \u2502 \u2514\u2500\u2500 registered 2 commands Commands time includes time spent on commands search (in classes from already performed classpath scan), and calling .injectMemebers on found environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled) Note Most of commands time will be command objects instantiation (reflection).","title":"Commands"},{"location":"guide/diagnostic/configuration-report/#modules","text":"\u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms \u2502 \u251c\u2500\u2500 7 modules autowired \u2502 \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms \u2502 \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings 7 modules autowired Aware* interfaces processing for registered modules (user modules + overrides + 1 guicey module) 8 elements found in 5 user modules Guicey performs modules introspection before injector creation (with guice SPI) and shows all found elements. Only user modules are introspected (except override and guicey module). 1 extensions detected from 3 acceptable bindings Shows detected extensions from bindings. Note that overall modules elements count include aop, listeners etc. Also, bindings are searched only in direct class bindings, so acceptable elements count will almost always be lower then overall elements count.","title":"Modules"},{"location":"guide/diagnostic/configuration-report/#installers","text":"\u251c\u2500\u2500 [7.4%] INSTALLERS processed in 32.60 ms \u2502 \u251c\u2500\u2500 registered 12 installers \u2502 \u2514\u2500\u2500 4 extensions recognized from 10 classes in 11.63 ms Shows installers initialization and processing time. registered 12 installers Overall count of used installers (core and custom, without disables). 4 extensions recognized from 10 classes Overall recognition time (potential extension classes introspection time). Includes class from classpath scan, all manual extension classes and checked (acceptable) bindings.","title":"Installers"},{"location":"guide/diagnostic/configuration-report/#injector","text":"\u251c\u2500\u2500 [47%] INJECTOR created in 204.2 ms \u2502 \u251c\u2500\u2500 Module execution: 124 ms \u2502 \u251c\u2500\u2500 Interceptors creation: 2 ms \u2502 \u251c\u2500\u2500 TypeListeners & ProvisionListener creation: 2 ms \u2502 \u251c\u2500\u2500 Scopes creation: 1 ms \u2502 \u251c\u2500\u2500 Binding creation: 20 ms \u2502 \u251c\u2500\u2500 Module annotated method scanners creation: 1 ms \u2502 \u251c\u2500\u2500 Binding initialization: 29 ms \u2502 \u251c\u2500\u2500 Collecting injection requests: 2 ms \u2502 \u251c\u2500\u2500 Static validation: 3 ms \u2502 \u251c\u2500\u2500 Instance member validation: 3 ms \u2502 \u251c\u2500\u2500 Provider verification: 1 ms \u2502 \u251c\u2500\u2500 Static member injection: 7 ms \u2502 \u251c\u2500\u2500 Instance injection: 3 ms \u2502 \u2514\u2500\u2500 Preloading singletons: 4 ms Pure injector creation time. Sub logs are intercepted guice internal logs (from com.google.inject.internal.util ). Only lines with non 0 time are shown.","title":"Injector"},{"location":"guide/diagnostic/configuration-report/#extensions","text":"\u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms \u2502 \u251c\u2500\u2500 4 extensions installed \u2502 \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding Extensions are installed just after injector creation. Time represent installers installation logic time. 4 extensions installed All used (installed, not disabled) extensions declared as: 2 manual, 1 scan, 1 binding Extensions sources: manual registration, classpath scan, bindings in guice modules. One extension could appear multiple times in counters (if it was detected in multiple sources)","title":"Extensions"},{"location":"guide/diagnostic/configuration-report/#jersey","text":"\u251c\u2500\u2500 [0.23%] JERSEY bridged in 1.594 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 3 jersey extensions installed in 501.8 \u03bcs Jersey starts after dropwizard bundles processing and so after GuiceBundle execution. Guicey register required HK2 bindings (and some HK2 beans in guice) and executes jersey installers (installers implementing JerseyInstaller ) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires HK2 specific bindings). using 2 jersey installers All jersey feature installers (not disabled) 3 jersey extensions installed All jersey extensions (not disabled) Note that extensions installation time is so tiny ( 501.8 \u03bcs ) just because empty resources (without methods) were used. In real application installation time will be bigger.","title":"Jersey"},{"location":"guide/diagnostic/configuration-report/#remaining","text":"\u2514\u2500\u2500 [7.4%] remaining 32 ms Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.","title":"Remaining"},{"location":"guide/diagnostic/configuration-report/#used-options","text":"Shows all guicey options set or requested (by application logic). If you use your own options here they will also be printed. Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true BindConfigurationByPath = true TrackDropwizardBundles = true AnalyzeGuiceModules = true InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] UseHkBridge = false Installers (r.v.d.g.m.i.InstallersOptions) JerseyExtensionsManagedByGuice = true ForceSingletonForJerseyExtensions = true Used markers: CUSTOM - option value set by user NOT_USED - option was set by user but never used Note NOT_USED marker just indicates that option is \"not yet\" used. Options may be consumed lazily by application logic, so it is possible that it's not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario).","title":"Used options"},{"location":"guide/diagnostic/configuration-report/#configuration-summary","text":"Section intended to show all configuration summary (to quickly see what was configured). This and the next sections used condensed package notion: CoreInstallersBundle (r.v.d.g.m.installer) Assumed that all classes in application will be uniquely identifiable by name so package info shown just to be able to understand exact class location. Logback shrinker used. Report indicates duplicate registrations and items of the same type registrations: REG(1/3) , where first number is accepted instances count and last number is overall registrations count. For extensions it's always 1/N , but for instances (modules, bundles) it indicates de-duplication mechanism work.","title":"Configuration summary"},{"location":"guide/diagnostic/configuration-report/#commands_1","text":"COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN, GUICE_ENABLED Shows commands resolved with classpath scan (enabled with .searchCommands() ). The following markers used: SCAN - item from classpath scan (always) GUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)","title":"Commands"},{"location":"guide/diagnostic/configuration-report/#bundles_1","text":"BUNDLES = FooDwBundle (r.v.d.g.d.s.dwbundle) *DW Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *HOOK, REG(1/2) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *HOOK CoreInstallersBundle (r.v.d.g.m.installer) WebInstallersBundle (r.v.d.g.m.installer) LookupBundle (r.v.d.g.d.s.bundle) *LOOKUP All registered bundles are shown as a tree (to indicate transitive bundles). Markers used: LOOKUP - bundle resolved with bundle lookup mechanism DW - dropwizard bundle HOOK - registered by configuration hook","title":"Bundles"},{"location":"guide/diagnostic/configuration-report/#installers-and-extensions","text":"INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(1/2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(1/3) FooResource (r.v.d.g.d.s.features) *SCAN ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) *BINDING Shows used installers (only installers which install extensions) and installed extensions. Both installers and extensions are shown in the processing order (sorted according to @Order annotations). Markers used: SCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan) LAZY - extensions annotated with @LazyBinding JERSEY - extension annotated with @JerseyManaged HOOK - registered by configuration hook BINDING - extension recognized from guice binding","title":"Installers and extensions"},{"location":"guide/diagnostic/configuration-report/#modules_1","text":"GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2/2) ModuleWithExtensions (r.v.d.g.d.s.module) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) OverridingModule (r.v.d.g.d.s.module) *OVERRIDE GuiceBootstrapModule (r.v.d.guice.module) All registered guice modules: user modules + override modules + guicey GuiceBootstrapModule . Overriding modules are marked with OVERRIDE .","title":"Modules"},{"location":"guide/diagnostic/configuration-report/#configuration-tree","text":"Configuration tree is useful to understand from where configuration items come from. Note Configuration tree shows both guicey bundles and dropwizard bundle trees (for dropwizard bundles, registered through guicey api). Dropwizard bundles are identified with marker DW . There are several sections in tree: APPLICATION - for everything registered in GuiceBundle BUNDLES LOOKUP - for bundles resolved with lookup mechanism CLASSPATH SCAN - for items resolved by classpath scan GUICE BINDINGS - for extensions resolved from guice module bindings HOOKS - for registered hooks Markers: DW - dropwizard bundle DISABLED - item manually disabled DUPLICATE - item considered as duplicate for already registered item","title":"Configuration tree"},{"location":"guide/diagnostic/configuration-report/#disables","text":"Manual disable is identified (to quickly understand who disabled item) as: \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) And disabled items would be also identified: \u251c\u2500\u2500 installer -LifeCycleInstaller (r.v.d.g.m.i.feature) *DISABLED Disabled bundles are shown without context (to identify disable): -HK2DebugBundle (r.v.d.g.m.j.debug) *DISABLED","title":"Disables"},{"location":"guide/diagnostic/configuration-report/#de-duplication","text":"Duplicate registration or instance de-duplications are identified as: \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE If extension is registered more then once in the same context, it would be identified: \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE If more then one instance (in this context) is considered to be duplicate then number will appear: \u251c\u2500\u2500 extension -FooBundleResource (r.v.d.g.d.s.bundle) *DUPLICATE(3) When multiple instances of the same type is registered (form modules or bundles), they would be numbered in order of registration (to differentiate): APPLICATION \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) ... \u2502 \u2514\u2500\u2500 FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module FooModule#2 (r.v.d.g.d.s.features) In order to better track duplicates, items, recognized as duplicates, will be shown with registered instance they considered to be duplicate to. For example, for above sample, if another FooModule registered and it would be considered as duplicate to second instance, it would be printed as: \u2514\u2500\u2500 module -FooModule#2 (r.v.d.g.d.s.features) *DUPLICATE","title":"De-duplication"},{"location":"guide/diagnostic/configuration-report/#guice-bindings","text":"Extensions detected from guice bindings are shown as a sub tree: \u251c\u2500\u2500 GUICE BINDINGS \u2502 \u2502 \u2502 \u2514\u2500\u2500 ModuleWithExtensions (r.v.d.g.d.s.module) \u2502 \u2514\u2500\u2500 extension ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) Note Extensions are shown relative to top-most registered modules! For example, if ModuleWithExtensions internally install module ExtensionModule which actually contains extension bingind, then still ExtensionModule will not be shown and extension will remain under ModuleWithExtensions (on report). This was done to not confuse users: report shows guicey configration and user must clearly see configuration source. Bindings are not shown under main configuration tree (where modules are registered) because guicey only knows about the module class, but actually multiple module instances could be registered and so it is impossible to known what module instance extension is related to. Tip Detailed guice modules tree could be seen on guice report","title":"Guice bindings"},{"location":"guide/diagnostic/configuration-report/#customization","text":".printDiagnosticInfo() shortcut register report with default settings. If you need customized report then register report listener directly. For example, installers report is a configured configuration report: . listen ( ConfigurationDiagnostic . builder ( \"Available installers report\" ) . printConfiguration ( new DiagnosticConfig () . printInstallers () . printNotUsedInstallers () . printInstallerInterfaceMarkers ()) . printContextTree ( new ContextTreeConfig () . hideCommands () . hideDuplicateRegistrations () . hideEmptyBundles () . hideExtensions () . hideModules ()) . build ()); Report rendering logic may also be used directly as all sub-reports provide separate renderer object implementing ReportRenderer . Renderers not bound to guice context and assume direct instantiation. For examples of direct renderers usage see events implementation: InjectorPhaseEvent.ReportRenderer","title":"Customization"},{"location":"guide/diagnostic/diagnostic-tools/","text":"Diagnostic tools \u00b6 Guicey provide many bundled console reports to help with problems diagnostic (or to simply clarify how application works) during development. All reports may be enabled on main guice bundle: . printExtensionsHelp () Extensions recognition help . printDiagnosticInfo () Detailed guicey configuration information . printAvailableInstallers () Prints available installers (helps understanding supported extensions) . printCustomConfigurationBindings () . printConfigurationBindings () Show yaml config introspection result (shows available yaml value bindings) . printGuiceBindings () . printAllGuiceBindings () Guice bindings from registered modules . printGuiceAopMap () . printGuiceAopMap ( GuiceAopConfig config ) AOP appliance map . printWebMappings () Prints all registered servlets and filters (including guice ServletModule declarations) . printJerseyConfig () Prints all registered jersey extensions (exception mappers, filters etc.): including everything registered by dropwizard itself and all direct manual registrations. . printLifecyclePhases () . printLifecyclePhasesDetailed () Guicey lifecycle stages (separates logs to clearly see what messages relates to what phase) . strictScopeControl () In case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation, you can enable strict control which will throw exception in case of wrong owner. Diagnostic hook \u00b6 It is obviously impossible to enable diagnostic reports without application re-compilation. But, sometimes, it is required to validate installed application. To work around this situation, guicey provides special diagnostic hook, which can be enabled with a system property: -Dguicey.hooks=diagnostic Hook activates the most commonly used reports: public class DiagnosticHook implements GuiceyConfigurationHook { public void configure ( final GuiceBundle . Builder builder ) { builder . printDiagnosticInfo () . printLifecyclePhasesDetailed () . printCustomConfigurationBindings () . printGuiceBindings () . printWebMappings () . printJerseyConfig (); } } Tip If provided hook doesn't cover all required reports, you can always make your own hook and register it's shortcut for simplified usage Reports implementation \u00b6 Report is implemented as guicey event listener . All sub-reports provide additional configuration options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, available installers report is re-configured configuration report: public Builder < T > printAvailableInstallers () { return listen ( ConfigurationDiagnostic . builder ( \"Available installers report\" ) . printConfiguration ( new DiagnosticConfig () . printInstallers () . printNotUsedInstallers () . printInstallerInterfaceMarkers ()) . printContextTree ( new ContextTreeConfig () . hideCommands () . hideDuplicateRegistrations () . hideEmptyBundles () . hideExtensions () . hideModules ()) . build ()); } Report rendering logic may also be used directly as all reports (except lifecycle) provide separate renderer object implementing ReportRenderer . Renderers not bound to guice context and assume direct instantiation. For examples of direct renderers usage see events implementation: RunPhaseEvent.renderConfigurationBindings() InjectorPhaseEvent.ReportRenderer Note These shortcut methods allow easy render of report into string using received event object (in listener).","title":"Tools"},{"location":"guide/diagnostic/diagnostic-tools/#diagnostic-tools","text":"Guicey provide many bundled console reports to help with problems diagnostic (or to simply clarify how application works) during development. All reports may be enabled on main guice bundle: . printExtensionsHelp () Extensions recognition help . printDiagnosticInfo () Detailed guicey configuration information . printAvailableInstallers () Prints available installers (helps understanding supported extensions) . printCustomConfigurationBindings () . printConfigurationBindings () Show yaml config introspection result (shows available yaml value bindings) . printGuiceBindings () . printAllGuiceBindings () Guice bindings from registered modules . printGuiceAopMap () . printGuiceAopMap ( GuiceAopConfig config ) AOP appliance map . printWebMappings () Prints all registered servlets and filters (including guice ServletModule declarations) . printJerseyConfig () Prints all registered jersey extensions (exception mappers, filters etc.): including everything registered by dropwizard itself and all direct manual registrations. . printLifecyclePhases () . printLifecyclePhasesDetailed () Guicey lifecycle stages (separates logs to clearly see what messages relates to what phase) . strictScopeControl () In case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation, you can enable strict control which will throw exception in case of wrong owner.","title":"Diagnostic tools"},{"location":"guide/diagnostic/diagnostic-tools/#diagnostic-hook","text":"It is obviously impossible to enable diagnostic reports without application re-compilation. But, sometimes, it is required to validate installed application. To work around this situation, guicey provides special diagnostic hook, which can be enabled with a system property: -Dguicey.hooks=diagnostic Hook activates the most commonly used reports: public class DiagnosticHook implements GuiceyConfigurationHook { public void configure ( final GuiceBundle . Builder builder ) { builder . printDiagnosticInfo () . printLifecyclePhasesDetailed () . printCustomConfigurationBindings () . printGuiceBindings () . printWebMappings () . printJerseyConfig (); } } Tip If provided hook doesn't cover all required reports, you can always make your own hook and register it's shortcut for simplified usage","title":"Diagnostic hook"},{"location":"guide/diagnostic/diagnostic-tools/#reports-implementation","text":"Report is implemented as guicey event listener . All sub-reports provide additional configuration options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, available installers report is re-configured configuration report: public Builder < T > printAvailableInstallers () { return listen ( ConfigurationDiagnostic . builder ( \"Available installers report\" ) . printConfiguration ( new DiagnosticConfig () . printInstallers () . printNotUsedInstallers () . printInstallerInterfaceMarkers ()) . printContextTree ( new ContextTreeConfig () . hideCommands () . hideDuplicateRegistrations () . hideEmptyBundles () . hideExtensions () . hideModules ()) . build ()); } Report rendering logic may also be used directly as all reports (except lifecycle) provide separate renderer object implementing ReportRenderer . Renderers not bound to guice context and assume direct instantiation. For examples of direct renderers usage see events implementation: RunPhaseEvent.renderConfigurationBindings() InjectorPhaseEvent.ReportRenderer Note These shortcut methods allow easy render of report into string using received event object (in listener).","title":"Reports implementation"},{"location":"guide/diagnostic/extensions-report/","text":"Extensions help \u00b6 Shows extension signs recognized by registered installers. GuiceBundle . builder () ... . printExtensionsHelp () . build () Example report: INFO [2022-12-28 14:57:01,445] ru.vyarus.dropwizard.guice.debug.ExtensionsHelpDiagnostic: Recognized extension signs lifecycle (r.v.d.g.m.i.f.LifeCycleInstaller) implements LifeCycle managed (r.v.d.g.m.i.feature.ManagedInstaller) implements Managed jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) implements Feature jerseyprovider (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) @Provider on class implements ExceptionMapper implements ParamConverterProvider implements ContextResolver implements MessageBodyReader implements MessageBodyWriter implements ReaderInterceptor implements WriterInterceptor implements ContainerRequestFilter implements ContainerResponseFilter implements DynamicFeature implements ValueParamProvider implements InjectionResolver implements ApplicationEventListener implements ModelProcessor resource (r.v.d.g.m.i.f.j.ResourceInstaller) @Path on class @Path on implemented interface eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) @EagerSingleton on class healthcheck (r.v.d.g.m.i.f.h.HealthCheckInstaller) extends NamedHealthCheck task (r.v.d.g.m.i.feature.TaskInstaller) extends Task plugin (r.v.d.g.m.i.f.plugin.PluginInstaller) @Plugin on class custom annotation on class, annotated with @Plugin webservlet (r.v.d.g.m.i.f.w.WebServletInstaller) extends HttpServlet + @WebServlet webfilter (r.v.d.g.m.i.f.web.WebFilterInstaller) implements Filter + @WebFilter weblistener (r.v.d.g.m.i.f.w.l.WebListenerInstaller) implements EventListener + @WebListener All signs are grouped by installer. Installers listed in processing order, which is important, because first installer recognized extension \"owns\" it (even if extension contains signs, recognizable by other installers). Custom installers \u00b6 Custom installers should implement new method to participate in report (not required!). Example implementation from singleton installer: public class EagerSingletonInstaller implements FeatureInstaller { ... @Override public List < String > getRecognizableSigns () { return Collections . singletonList ( \"@\" + EagerSingleton . class . getSimpleName () + \" on class\" ); } }","title":"Extensions help"},{"location":"guide/diagnostic/extensions-report/#extensions-help","text":"Shows extension signs recognized by registered installers. GuiceBundle . builder () ... . printExtensionsHelp () . build () Example report: INFO [2022-12-28 14:57:01,445] ru.vyarus.dropwizard.guice.debug.ExtensionsHelpDiagnostic: Recognized extension signs lifecycle (r.v.d.g.m.i.f.LifeCycleInstaller) implements LifeCycle managed (r.v.d.g.m.i.feature.ManagedInstaller) implements Managed jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) implements Feature jerseyprovider (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) @Provider on class implements ExceptionMapper implements ParamConverterProvider implements ContextResolver implements MessageBodyReader implements MessageBodyWriter implements ReaderInterceptor implements WriterInterceptor implements ContainerRequestFilter implements ContainerResponseFilter implements DynamicFeature implements ValueParamProvider implements InjectionResolver implements ApplicationEventListener implements ModelProcessor resource (r.v.d.g.m.i.f.j.ResourceInstaller) @Path on class @Path on implemented interface eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) @EagerSingleton on class healthcheck (r.v.d.g.m.i.f.h.HealthCheckInstaller) extends NamedHealthCheck task (r.v.d.g.m.i.feature.TaskInstaller) extends Task plugin (r.v.d.g.m.i.f.plugin.PluginInstaller) @Plugin on class custom annotation on class, annotated with @Plugin webservlet (r.v.d.g.m.i.f.w.WebServletInstaller) extends HttpServlet + @WebServlet webfilter (r.v.d.g.m.i.f.web.WebFilterInstaller) implements Filter + @WebFilter weblistener (r.v.d.g.m.i.f.w.l.WebListenerInstaller) implements EventListener + @WebListener All signs are grouped by installer. Installers listed in processing order, which is important, because first installer recognized extension \"owns\" it (even if extension contains signs, recognizable by other installers).","title":"Extensions help"},{"location":"guide/diagnostic/extensions-report/#custom-installers","text":"Custom installers should implement new method to participate in report (not required!). Example implementation from singleton installer: public class EagerSingletonInstaller implements FeatureInstaller { ... @Override public List < String > getRecognizableSigns () { return Collections . singletonList ( \"@\" + EagerSingleton . class . getSimpleName () + \" on class\" ); } }","title":"Custom installers"},{"location":"guide/diagnostic/guice-report/","text":"Guice bindings report \u00b6 Guice bindings report show all available guice bindings. GuiceBundle . builder () ... . printGuiceBindings () // or printAllGuiceBindings() to see also guicey bindings (from GuiceBootstrapModule) . build () Example report: 1 MODULES with 3 bindings \u2502 \u2514\u2500\u2500 CasesModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 <typelistener> CustomTypeListener at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:19) \u251c\u2500\u2500 <provisionlistener> CustomProvisionListener at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:26) \u251c\u2500\u2500 <aop> CustomAop at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:33) \u251c\u2500\u2500 untargetted [@Singleton] AopedService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:36) *AOP \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:37) *OVERRIDDEN \u2514\u2500\u2500 instance [@Singleton] BindService2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:38) *OVERRIDDEN 1 OVERRIDING MODULES with 2 bindings \u2502 \u2514\u2500\u2500 OverrideModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:16) *OVERRIDE \u2514\u2500\u2500 instance [@Singleton] BindService2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:17) *OVERRIDE 1 UNDECLARED bindings \u2514\u2500\u2500 JitService (r.v.d.g.d.r.g.s.exts) BINDING CHAINS \u2514\u2500\u2500 BindService --[linked]--> OverrideService Important Report is build using guice SPI from raw modules and that's why it shows everything that modules configure (listeners, aop). But this also cause an additional execution of configure() method of all modules when report is enabled. In most cases, this is not a problem (modules should only declare bindings). Report use stage TOOL , so, if required, you can easilly avoid duplicate execution for sensitive logic: if ( binder . currentStage () != Stage . TOOL ) { // do only on normal run } For example, guicey itself use this in installers to avoid duplicate console output on startup when report enabled. Tip If you run application in IDE then binding traces (on the right) should be clickable in console (strange format of \"at + full class name\" used exactly to activate such links because IDE will consider these lines as stacktrace elements). Note You may use multiple modules of the same type (e.g. .modules(new MyModule(), new MyModule()) ) but report will always show each module only once (because it's impossible to know exact instance for binding, only module class). Report contains 4 sections: Bindings of modules (registered with .modules() ) Overriding bindings (from modules in .modulesOverride() ) Undeclared bindings - JIT bindings (not declared in modules, but existing in runtime due to injection request) Binding chains. In most cases it's connection of interface to implementation like bind(MyIface.class).to(MyIFaceImpl.class) . Especially useful for binding overrides because show actual chain (with applied override). Used markers: EXTENSION - recognized extension binding REMOVED - extension or module disabled and binding(s) removed AOP - bean affected by guice AOP OVERRIDDEN (only in modules tree) - binding is overridden with binding from overriding module OVERRIDES (only in overriding modules tree) - binding override something in main modules WEB - indicates modules extending ServletModule PRIVATE - indicates private module Binding types \u00b6 Note All non-binding declarations (listeners, aop handlers) are put into square braces (e.g. `lt;typelistener>) Name Example <scope> bindScope (..) <aop> bindInterceptor (..) <typelistener> bindListener (..) <provisionlistener> bindListener (..) <typeconverter> convertToTypes (..) <filterkey> filter ( \"/1/*\" ). through ( MyFilter . class ) (in ServletModule ) <filterinstance> filter ( \"/1/*\" ). through ( new MyFilter ()) (in ServletModule ) <servletkey> serve ( \"/1/foo\" ). with ( MyServlet . class ) (in ServletModule ) <servletinstance> serve ( \"/1/foo\" ). with ( new MyServlet ()) (in ServletModule ) instance bing ( Smth . class ). toInstance ( obj ) providerinstance bind ( Smth . class ). toProvider ( obj ) linkedkey bind ( Smth . class ). to ( Other . class ) ( Other may be already declared with separate binding) providerkey bind ( Smth . class ). toProvider ( DmthProv . class ) untargeted bind ( Smth . class ) providermethod Module method annotated with @Provides exposed expose ( PrivateService . class ) (service expose in PrivateModule ) Warning Multibindings extension bindings are showed as raw bindings. There are no special support to aggregate them (maybe will be added later). MultibindingsModule ( r . v . d . g . d . r . g . support ) \u251c\u2500\u2500 linkedkey [ @Prototype ] @Element Plugin ( multibinding ) at ru . vyarus . dropwizard . guice . debug . renderer . guice . support . MultibindingsModule . configure ( MultibindingsModule . java : 17 ) \u251c\u2500\u2500 instance [ @Singleton ] @Element Plugin ( multibinding ) at ru . vyarus . dropwizard . guice . debug . renderer . guice . support . MultibindingsModule . configure ( MultibindingsModule . java : 18 ) for Multibinder . newSetBinder ( binder (), Plugin . class ). addBinding (). to ( MyPlugin . class ) Overrides \u00b6 Report explicitly marks overridden bindings (by overriding modules). For example, in the report above, module binding \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:37) *OVERRIDDEN is overridden by \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:16) *OVERRIDE Important Report lines are long so you'll have to scroll report blocks to the right to see markers. Aop \u00b6 Report shows all beans affected with aop: \u251c\u2500\u2500 untargetted [@Singleton] AopedService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:36) *AOP Tip Use AOP report to see what exact handlers were applied and with what order. Private modules \u00b6 For private guice modules report will show all internal bindings: INFO [2019-10-13 09:21:21,080] ru.vyarus.dropwizard.guice.debug.GuiceBindingsDiagnostic: Guice bindings = 4 MODULES with 4 bindings \u2502 \u2514\u2500\u2500 OuterModule (r.v.d.g.d.r.g.s.privt) \u2502 \u2514\u2500\u2500 InnerModule (r.v.d.g.d.r.g.s.privt) *PRIVATE \u251c\u2500\u2500 untargetted [@Prototype] InnerService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:14) \u251c\u2500\u2500 untargetted [@Prototype] OuterService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:15) *EXPOSED \u251c\u2500\u2500 exposed [@Prototype] OuterService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:17) \u2502 \u2514\u2500\u2500 Inner2Module (r.v.d.g.d.r.g.s.privt) \u251c\u2500\u2500 untargetted [@Prototype] InnerService2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.Inner2Module.configure(Inner2Module.java:14) \u2502 \u2514\u2500\u2500 Inner3Module (r.v.d.g.d.r.g.s.privt) *PRIVATE \u2514\u2500\u2500 untargetted [@Prototype] OutServ at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.Inner3Module.configure(Inner3Module.java:13) *EXPOSED where public class OuterModule extends AbstractModule { @Override protected void configure () { install ( new InnerModule ()); } } public class InnerModule extends PrivateModule { @Override protected void configure () { install ( new Inner2Module ()); bind ( InnerService . class ); bind ( OuterService . class ); expose ( OuterService . class ); } } public class Inner2Module extends AbstractModule { @Override protected void configure () { install ( new Inner3Module ()); bind ( InnerService2 . class ); } } public class Inner3Module extends PrivateModule { @Override protected void configure () { bind ( OutServ . class ); expose ( OutServ . class ); } } Warning Exposed service from inner private module expose(OutServ.class); is not shown in report! It is hidden intentionally to clarify which bindings are visible by application (only exposed bindings after the top-most private module). Removed bindings \u00b6 For recognized extensions and transitive modules guicey can apply disable rules: so when you disable extension ( .disableExtensions ) or guice module ( .disableModules ) it will physically remove relative bindings. All removed are indicated on report. For example: INFO [2019-10-13 09:26:59,502] ru.vyarus.dropwizard.guice.debug.GuiceBindingsDiagnostic: Guice bindings = 2 MODULES with 2 bindings \u2502 \u2514\u2500\u2500 TransitiveModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 untargetted [@Prototype] Res1 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:15) *EXTENSION \u251c\u2500\u2500 untargetted [@Prototype] Res2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:16) *EXTENSION, REMOVED \u2514\u2500\u2500 Inner (r.v.d.g.d.r.g.s.TransitiveModule) *REMOVED where: public class TransitiveModule extends AbstractModule { @Override protected void configure () { bind ( Res1 . class ); bind ( Res2 . class ); install ( new Inner ()); } public static class Inner extends AbstractModule { @Override protected void configure () { ... } } } GuiceBundle . builder () . modules ( new TransitiveModule ()) . disableExtensions ( TransitiveModule . Res2 ) . disableModules ( TransitiveModule . Inner ) . printGuiceBindings () . build () Report customization \u00b6 Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, guice bindings report without library bindings is configured like this: listen ( new GuiceBindingsDiagnostic ( new GuiceConfig () . hideGuiceBindings () . hideGuiceyBindings ()) Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation. For examples of direct renderer usage see events implementation: InjectorPhaseEvent.ReportRenderer","title":"Guice"},{"location":"guide/diagnostic/guice-report/#guice-bindings-report","text":"Guice bindings report show all available guice bindings. GuiceBundle . builder () ... . printGuiceBindings () // or printAllGuiceBindings() to see also guicey bindings (from GuiceBootstrapModule) . build () Example report: 1 MODULES with 3 bindings \u2502 \u2514\u2500\u2500 CasesModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 <typelistener> CustomTypeListener at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:19) \u251c\u2500\u2500 <provisionlistener> CustomProvisionListener at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:26) \u251c\u2500\u2500 <aop> CustomAop at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:33) \u251c\u2500\u2500 untargetted [@Singleton] AopedService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:36) *AOP \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:37) *OVERRIDDEN \u2514\u2500\u2500 instance [@Singleton] BindService2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:38) *OVERRIDDEN 1 OVERRIDING MODULES with 2 bindings \u2502 \u2514\u2500\u2500 OverrideModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:16) *OVERRIDE \u2514\u2500\u2500 instance [@Singleton] BindService2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:17) *OVERRIDE 1 UNDECLARED bindings \u2514\u2500\u2500 JitService (r.v.d.g.d.r.g.s.exts) BINDING CHAINS \u2514\u2500\u2500 BindService --[linked]--> OverrideService Important Report is build using guice SPI from raw modules and that's why it shows everything that modules configure (listeners, aop). But this also cause an additional execution of configure() method of all modules when report is enabled. In most cases, this is not a problem (modules should only declare bindings). Report use stage TOOL , so, if required, you can easilly avoid duplicate execution for sensitive logic: if ( binder . currentStage () != Stage . TOOL ) { // do only on normal run } For example, guicey itself use this in installers to avoid duplicate console output on startup when report enabled. Tip If you run application in IDE then binding traces (on the right) should be clickable in console (strange format of \"at + full class name\" used exactly to activate such links because IDE will consider these lines as stacktrace elements). Note You may use multiple modules of the same type (e.g. .modules(new MyModule(), new MyModule()) ) but report will always show each module only once (because it's impossible to know exact instance for binding, only module class). Report contains 4 sections: Bindings of modules (registered with .modules() ) Overriding bindings (from modules in .modulesOverride() ) Undeclared bindings - JIT bindings (not declared in modules, but existing in runtime due to injection request) Binding chains. In most cases it's connection of interface to implementation like bind(MyIface.class).to(MyIFaceImpl.class) . Especially useful for binding overrides because show actual chain (with applied override). Used markers: EXTENSION - recognized extension binding REMOVED - extension or module disabled and binding(s) removed AOP - bean affected by guice AOP OVERRIDDEN (only in modules tree) - binding is overridden with binding from overriding module OVERRIDES (only in overriding modules tree) - binding override something in main modules WEB - indicates modules extending ServletModule PRIVATE - indicates private module","title":"Guice bindings report"},{"location":"guide/diagnostic/guice-report/#binding-types","text":"Note All non-binding declarations (listeners, aop handlers) are put into square braces (e.g. `lt;typelistener>) Name Example <scope> bindScope (..) <aop> bindInterceptor (..) <typelistener> bindListener (..) <provisionlistener> bindListener (..) <typeconverter> convertToTypes (..) <filterkey> filter ( \"/1/*\" ). through ( MyFilter . class ) (in ServletModule ) <filterinstance> filter ( \"/1/*\" ). through ( new MyFilter ()) (in ServletModule ) <servletkey> serve ( \"/1/foo\" ). with ( MyServlet . class ) (in ServletModule ) <servletinstance> serve ( \"/1/foo\" ). with ( new MyServlet ()) (in ServletModule ) instance bing ( Smth . class ). toInstance ( obj ) providerinstance bind ( Smth . class ). toProvider ( obj ) linkedkey bind ( Smth . class ). to ( Other . class ) ( Other may be already declared with separate binding) providerkey bind ( Smth . class ). toProvider ( DmthProv . class ) untargeted bind ( Smth . class ) providermethod Module method annotated with @Provides exposed expose ( PrivateService . class ) (service expose in PrivateModule ) Warning Multibindings extension bindings are showed as raw bindings. There are no special support to aggregate them (maybe will be added later). MultibindingsModule ( r . v . d . g . d . r . g . support ) \u251c\u2500\u2500 linkedkey [ @Prototype ] @Element Plugin ( multibinding ) at ru . vyarus . dropwizard . guice . debug . renderer . guice . support . MultibindingsModule . configure ( MultibindingsModule . java : 17 ) \u251c\u2500\u2500 instance [ @Singleton ] @Element Plugin ( multibinding ) at ru . vyarus . dropwizard . guice . debug . renderer . guice . support . MultibindingsModule . configure ( MultibindingsModule . java : 18 ) for Multibinder . newSetBinder ( binder (), Plugin . class ). addBinding (). to ( MyPlugin . class )","title":"Binding types"},{"location":"guide/diagnostic/guice-report/#overrides","text":"Report explicitly marks overridden bindings (by overriding modules). For example, in the report above, module binding \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:37) *OVERRIDDEN is overridden by \u251c\u2500\u2500 linkedkey [@Prototype] BindService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:16) *OVERRIDE Important Report lines are long so you'll have to scroll report blocks to the right to see markers.","title":"Overrides"},{"location":"guide/diagnostic/guice-report/#aop","text":"Report shows all beans affected with aop: \u251c\u2500\u2500 untargetted [@Singleton] AopedService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:36) *AOP Tip Use AOP report to see what exact handlers were applied and with what order.","title":"Aop"},{"location":"guide/diagnostic/guice-report/#private-modules","text":"For private guice modules report will show all internal bindings: INFO [2019-10-13 09:21:21,080] ru.vyarus.dropwizard.guice.debug.GuiceBindingsDiagnostic: Guice bindings = 4 MODULES with 4 bindings \u2502 \u2514\u2500\u2500 OuterModule (r.v.d.g.d.r.g.s.privt) \u2502 \u2514\u2500\u2500 InnerModule (r.v.d.g.d.r.g.s.privt) *PRIVATE \u251c\u2500\u2500 untargetted [@Prototype] InnerService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:14) \u251c\u2500\u2500 untargetted [@Prototype] OuterService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:15) *EXPOSED \u251c\u2500\u2500 exposed [@Prototype] OuterService at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:17) \u2502 \u2514\u2500\u2500 Inner2Module (r.v.d.g.d.r.g.s.privt) \u251c\u2500\u2500 untargetted [@Prototype] InnerService2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.Inner2Module.configure(Inner2Module.java:14) \u2502 \u2514\u2500\u2500 Inner3Module (r.v.d.g.d.r.g.s.privt) *PRIVATE \u2514\u2500\u2500 untargetted [@Prototype] OutServ at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.Inner3Module.configure(Inner3Module.java:13) *EXPOSED where public class OuterModule extends AbstractModule { @Override protected void configure () { install ( new InnerModule ()); } } public class InnerModule extends PrivateModule { @Override protected void configure () { install ( new Inner2Module ()); bind ( InnerService . class ); bind ( OuterService . class ); expose ( OuterService . class ); } } public class Inner2Module extends AbstractModule { @Override protected void configure () { install ( new Inner3Module ()); bind ( InnerService2 . class ); } } public class Inner3Module extends PrivateModule { @Override protected void configure () { bind ( OutServ . class ); expose ( OutServ . class ); } } Warning Exposed service from inner private module expose(OutServ.class); is not shown in report! It is hidden intentionally to clarify which bindings are visible by application (only exposed bindings after the top-most private module).","title":"Private modules"},{"location":"guide/diagnostic/guice-report/#removed-bindings","text":"For recognized extensions and transitive modules guicey can apply disable rules: so when you disable extension ( .disableExtensions ) or guice module ( .disableModules ) it will physically remove relative bindings. All removed are indicated on report. For example: INFO [2019-10-13 09:26:59,502] ru.vyarus.dropwizard.guice.debug.GuiceBindingsDiagnostic: Guice bindings = 2 MODULES with 2 bindings \u2502 \u2514\u2500\u2500 TransitiveModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 untargetted [@Prototype] Res1 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:15) *EXTENSION \u251c\u2500\u2500 untargetted [@Prototype] Res2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:16) *EXTENSION, REMOVED \u2514\u2500\u2500 Inner (r.v.d.g.d.r.g.s.TransitiveModule) *REMOVED where: public class TransitiveModule extends AbstractModule { @Override protected void configure () { bind ( Res1 . class ); bind ( Res2 . class ); install ( new Inner ()); } public static class Inner extends AbstractModule { @Override protected void configure () { ... } } } GuiceBundle . builder () . modules ( new TransitiveModule ()) . disableExtensions ( TransitiveModule . Res2 ) . disableModules ( TransitiveModule . Inner ) . printGuiceBindings () . build ()","title":"Removed bindings"},{"location":"guide/diagnostic/guice-report/#report-customization","text":"Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, guice bindings report without library bindings is configured like this: listen ( new GuiceBindingsDiagnostic ( new GuiceConfig () . hideGuiceBindings () . hideGuiceyBindings ()) Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation. For examples of direct renderer usage see events implementation: InjectorPhaseEvent.ReportRenderer","title":"Report customization"},{"location":"guide/diagnostic/installers-report/","text":"Installers report \u00b6 Installers report is intended to show what extensions could be used and share some light on how installers work. Activation: GuiceBundle . builder () ... . printAvailableInstallers () . build ()); Example output: INFO [2019-10-11 06:09:06,085] ru.vyarus.dropwizard.guice.debug.ConfigurationDiagnostic: Available installers report ---------------------------------------------------------------------------[CONFIGURATION] INSTALLERS in processing order = OBJECT, ORDER lifecycle (r.v.d.g.m.i.f.LifeCycleInstaller) OBJECT, ORDER managed (r.v.d.g.m.i.feature.ManagedInstaller) OBJECT jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) JERSEY, BIND, OPTIONS jerseyprovider (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) TYPE, JERSEY, BIND, OPTIONS resource (r.v.d.g.m.i.f.j.ResourceInstaller) BIND eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) OBJECT healthcheck (r.v.d.g.m.i.f.h.HealthCheckInstaller) OBJECT task (r.v.d.g.m.i.feature.TaskInstaller) BIND plugin (r.v.d.g.m.i.f.plugin.PluginInstaller) OBJECT, OPTIONS, ORDER webservlet (r.v.d.g.m.i.f.w.WebServletInstaller) OBJECT, ORDER webfilter (r.v.d.g.m.i.f.web.WebFilterInstaller) OBJECT, OPTIONS, ORDER weblistener (r.v.d.g.m.i.f.w.l.WebListenerInstaller) ---------------------------------------------------------------------------[CONFIGURATION TREE] APPLICATION \u2502 \u2514\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u251c\u2500\u2500 installer LifeCycleInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer ManagedInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer JerseyProviderInstaller (r.v.d.g.m.i.f.j.provider) \u251c\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer EagerSingletonInstaller (r.v.d.g.m.i.f.eager) \u251c\u2500\u2500 installer HealthCheckInstaller (r.v.d.g.m.i.f.health) \u251c\u2500\u2500 installer TaskInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer PluginInstaller (r.v.d.g.m.i.f.plugin) \u2502 \u2514\u2500\u2500 WebInstallersBundle (r.v.d.g.m.installer) \u251c\u2500\u2500 installer WebFilterInstaller (r.v.d.g.m.i.f.web) \u251c\u2500\u2500 installer WebServletInstaller (r.v.d.g.m.i.f.web) \u2514\u2500\u2500 installer WebListenerInstaller (r.v.d.g.m.i.f.w.listener) Note This is actually re-configured configuration report . But, in contrast to configuration report, it shows all installers ( even not used ). Also, it indicated used installer features. For example, looking at OBJECT, ORDER managed (r.v.d.g.m.i.feature.ManagedInstaller) You could see that managed installer (responsible for Managed objects installation) use objects for installation (obtains extension instance from guice and registers it). Also it supports ordering (so extensions could use @Order annotation). By looking at @EagerSingleton installer: BIND eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) You can see that it only applies guice binding and nothing more. Installer features \u00b6 Feature Description OBJECT Installer use object instances for extensions registration (obtain instance from guice context) TYPE Installer use extension class for extension registration. Usually it's jersey installers which has to register extension in jersey context JERSEY Installer installs jersey features (in time of jersey start and not after injector creation as \"pure\" installers) BIND Installer perform manual guice binding. For such installers, automatic untargeted binding for extension is not created (assuming installer require some custom binding). Such installers also verify manual guice bindings, when they are recognized as extension binding. OPTIONS Installer requires access for options. Most likely it means it supports additional configuration options (but it cold just read core options value). ORDER Installer supports extensions ordering. Use @Order annotation to declare order.","title":"Installers"},{"location":"guide/diagnostic/installers-report/#installers-report","text":"Installers report is intended to show what extensions could be used and share some light on how installers work. Activation: GuiceBundle . builder () ... . printAvailableInstallers () . build ()); Example output: INFO [2019-10-11 06:09:06,085] ru.vyarus.dropwizard.guice.debug.ConfigurationDiagnostic: Available installers report ---------------------------------------------------------------------------[CONFIGURATION] INSTALLERS in processing order = OBJECT, ORDER lifecycle (r.v.d.g.m.i.f.LifeCycleInstaller) OBJECT, ORDER managed (r.v.d.g.m.i.feature.ManagedInstaller) OBJECT jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) JERSEY, BIND, OPTIONS jerseyprovider (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) TYPE, JERSEY, BIND, OPTIONS resource (r.v.d.g.m.i.f.j.ResourceInstaller) BIND eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) OBJECT healthcheck (r.v.d.g.m.i.f.h.HealthCheckInstaller) OBJECT task (r.v.d.g.m.i.feature.TaskInstaller) BIND plugin (r.v.d.g.m.i.f.plugin.PluginInstaller) OBJECT, OPTIONS, ORDER webservlet (r.v.d.g.m.i.f.w.WebServletInstaller) OBJECT, ORDER webfilter (r.v.d.g.m.i.f.web.WebFilterInstaller) OBJECT, OPTIONS, ORDER weblistener (r.v.d.g.m.i.f.w.l.WebListenerInstaller) ---------------------------------------------------------------------------[CONFIGURATION TREE] APPLICATION \u2502 \u2514\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u251c\u2500\u2500 installer LifeCycleInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer ManagedInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer JerseyProviderInstaller (r.v.d.g.m.i.f.j.provider) \u251c\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer EagerSingletonInstaller (r.v.d.g.m.i.f.eager) \u251c\u2500\u2500 installer HealthCheckInstaller (r.v.d.g.m.i.f.health) \u251c\u2500\u2500 installer TaskInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer PluginInstaller (r.v.d.g.m.i.f.plugin) \u2502 \u2514\u2500\u2500 WebInstallersBundle (r.v.d.g.m.installer) \u251c\u2500\u2500 installer WebFilterInstaller (r.v.d.g.m.i.f.web) \u251c\u2500\u2500 installer WebServletInstaller (r.v.d.g.m.i.f.web) \u2514\u2500\u2500 installer WebListenerInstaller (r.v.d.g.m.i.f.w.listener) Note This is actually re-configured configuration report . But, in contrast to configuration report, it shows all installers ( even not used ). Also, it indicated used installer features. For example, looking at OBJECT, ORDER managed (r.v.d.g.m.i.feature.ManagedInstaller) You could see that managed installer (responsible for Managed objects installation) use objects for installation (obtains extension instance from guice and registers it). Also it supports ordering (so extensions could use @Order annotation). By looking at @EagerSingleton installer: BIND eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) You can see that it only applies guice binding and nothing more.","title":"Installers report"},{"location":"guide/diagnostic/installers-report/#installer-features","text":"Feature Description OBJECT Installer use object instances for extensions registration (obtain instance from guice context) TYPE Installer use extension class for extension registration. Usually it's jersey installers which has to register extension in jersey context JERSEY Installer installs jersey features (in time of jersey start and not after injector creation as \"pure\" installers) BIND Installer perform manual guice binding. For such installers, automatic untargeted binding for extension is not created (assuming installer require some custom binding). Such installers also verify manual guice bindings, when they are recognized as extension binding. OPTIONS Installer requires access for options. Most likely it means it supports additional configuration options (but it cold just read core options value). ORDER Installer supports extensions ordering. Use @Order annotation to declare order.","title":"Installer features"},{"location":"guide/diagnostic/jersey-report/","text":"Jersey config report \u00b6 Report shows all registered jersey extensions, including registered by dropwizard and all manual registrations. GuiceBundle . builder () ... . printJerseyConfig () . build () Example report: INFO [2019-10-28 06:16:44,068] ru.vyarus.dropwizard.guice.debug.JerseyConfigDiagnostic: Jersey configuration = Exception mappers Throwable ExceptionMapperBinder$1 (io.dropwizard.setup) EofException EarlyEofExceptionMapper (i.d.jersey.errors) EmptyOptionalException EmptyOptionalExceptionMapper (i.d.jersey.optional) IOException GuiceExceptionMapper (r.v.d.g.c.h.support) IOException HKExceptionMapper (r.v.d.g.c.h.s.hk) *jersey managed IllegalStateException IllegalStateExceptionMapper (i.d.jersey.errors) JerseyViolationException JerseyViolationExceptionMapper (i.d.j.validation) JsonProcessingException JsonProcessingExceptionMapper (i.d.jersey.jackson) ValidationException ValidationExceptionMapper (o.g.j.s.v.internal) Param converters AbstractParamConverterProvider (i.d.jersey.params) FuzzyEnumParamConverterProvider (i.d.j.validation) GuiceParamConverterProvider (r.v.d.g.c.h.support) HKParamConverterProvider (r.v.d.g.c.h.s.hk) *jersey managed RootElementProvider (o.g.j.j.i.JaxbStringReaderProvider) OptionalDoubleParamConverterProvider (i.d.jersey.optional) OptionalIntParamConverterProvider (i.d.jersey.optional) OptionalLongParamConverterProvider (i.d.jersey.optional) OptionalParamConverterProvider (i.d.jersey.guava) OptionalParamConverterProvider (i.d.jersey.optional) AggregatedProvider (o.g.j.i.i.ParamConverters) Context resolvers Context GuiceContextResolver (r.v.d.g.c.h.support) Context HKContextResolver (r.v.d.g.c.h.s.hk) *jersey managed Message body readers Object BasicTypesMessageProvider (o.g.j.m.internal) [text/plain] byte[] ByteArrayProvider (o.g.j.m.internal) [application/octet-stream, */*] DataSource DataSourceProvider (o.g.j.m.internal) [application/octet-stream, */*] Document DocumentProvider (o.g.j.jaxb.internal) [application/xml, text/xml, */*] File FileProvider (o.g.j.m.internal) [application/octet-stream, */*] MultivaluedMap<String, String> FormMultivaluedMapProvider (o.g.j.m.internal) [application/x-www-form-urlencoded] Form FormProvider (o.g.j.m.internal) [application/x-www-form-urlencoded, */*] Type GuiceMessageBodyReader (r.v.d.g.c.h.support) Type HKMessageBodyReader (r.v.d.g.c.h.s.hk) *jersey managed InputStream InputStreamProvider (o.g.j.m.internal) [application/octet-stream, */*] Object JacksonJsonProvider (c.f.j.jaxrs.json) [*/*] Object JacksonMessageBodyProvider (i.d.jersey.jackson) [*/*] Reader ReaderProvider (o.g.j.m.internal) [text/plain, */*] RenderedImage RenderedImageProvider (o.g.j.m.internal) [image/*, application/octet-stream] StreamSource StreamSourceReader (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] SAXSource SaxSourceReader (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] DOMSource DomSourceReader (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] String StringMessageProvider (o.g.j.m.internal) [text/plain, */*] T[], Collection<T> App (o.g.j.j.i.XmlCollectionJaxbProvider) [application/xml] T[], Collection<T> Text (o.g.j.j.i.XmlCollectionJaxbProvider) [text/xml] T[], Collection<T> General (o.g.j.j.i.XmlCollectionJaxbProvider) [*/*] JAXBElement<Object> App (o.g.j.j.i.XmlJaxbElementProvider) [application/xml] JAXBElement<Object> Text (o.g.j.j.i.XmlJaxbElementProvider) [text/xml] JAXBElement<Object> General (o.g.j.j.i.XmlJaxbElementProvider) [*/*,*/*+xml] Object App (o.g.j.j.i.XmlRootElementJaxbProvider) [application/xml] Object Text (o.g.j.j.i.XmlRootElementJaxbProvider) [text/xml] Object General (o.g.j.j.i.XmlRootElementJaxbProvider) [*/*] Object App (o.g.j.j.i.XmlRootObjectJaxbProvider) [application/xml] Object Text (o.g.j.j.i.XmlRootObjectJaxbProvider) [text/xml] Object General (o.g.j.j.i.XmlRootObjectJaxbProvider) [*/*] Message body writers Object BasicTypesMessageProvider (o.g.j.m.internal) [text/plain] byte[] ByteArrayProvider (o.g.j.m.internal) [application/octet-stream, */*] ChunkedOutput<Object> ChunkedResponseWriter (o.g.jersey.server) DataSource DataSourceProvider (o.g.j.m.internal) [application/octet-stream, */*] Document DocumentProvider (o.g.j.jaxb.internal) [application/xml, text/xml, */*] File FileProvider (o.g.j.m.internal) [application/octet-stream, */*] MultivaluedMap<String, String> FormMultivaluedMapProvider (o.g.j.m.internal) [application/x-www-form-urlencoded] Form FormProvider (o.g.j.m.internal) [application/x-www-form-urlencoded, */*] Type GuiceMessageBodyWriter (r.v.d.g.c.h.support) Type HKMessageBodyWriter (r.v.d.g.c.h.s.hk) *jersey managed InputStream InputStreamProvider (o.g.j.m.internal) [application/octet-stream, */*] Object JacksonJsonProvider (c.f.j.jaxrs.json) [*/*] Object JacksonMessageBodyProvider (i.d.jersey.jackson) [*/*] OptionalDouble OptionalDoubleMessageBodyWriter (i.d.jersey.optional) [*/*] OptionalInt OptionalIntMessageBodyWriter (i.d.jersey.optional) [*/*] OptionalLong OptionalLongMessageBodyWriter (i.d.jersey.optional) [*/*] Optional<Object> OptionalMessageBodyWriter (i.d.jersey.guava) [*/*] Optional<Object> OptionalMessageBodyWriter (i.d.jersey.optional) [*/*] Reader ReaderProvider (o.g.j.m.internal) [text/plain, */*] RenderedImage RenderedImageProvider (o.g.j.m.internal) [image/*] Source SourceWriter (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] StreamingOutput StreamingOutputProvider (o.g.j.m.internal) [application/octet-stream, */*] String StringMessageProvider (o.g.j.m.internal) [text/plain, */*] Object ValidationErrorMessageBodyWriter (o.g.j.s.v.internal) T[], Collection<T> App (o.g.j.j.i.XmlCollectionJaxbProvider) [application/xml] T[], Collection<T> Text (o.g.j.j.i.XmlCollectionJaxbProvider) [text/xml] T[], Collection<T> General (o.g.j.j.i.XmlCollectionJaxbProvider) [*/*] JAXBElement<Object> App (o.g.j.j.i.XmlJaxbElementProvider) [application/xml] JAXBElement<Object> Text (o.g.j.j.i.XmlJaxbElementProvider) [text/xml] JAXBElement<Object> General (o.g.j.j.i.XmlJaxbElementProvider) [*/*,*/*+xml] Object App (o.g.j.j.i.XmlRootElementJaxbProvider) [application/xml] Object Text (o.g.j.j.i.XmlRootElementJaxbProvider) [text/xml] Object General (o.g.j.j.i.XmlRootElementJaxbProvider) [*/*] Reader interceptors MappableExceptionWrapperInterceptor (o.g.j.s.internal) GuiceReaderInterceptor (r.v.d.g.c.h.support) HKReaderInterceptor (r.v.d.g.c.h.s.hk) *jersey managed Writer interceptors MappableExceptionWrapperInterceptor (o.g.j.s.internal) JsonWithPaddingInterceptor (o.g.j.s.internal) GuiceWriterInterceptor (r.v.d.g.c.h.support) HKWriterInterceptor (r.v.d.g.c.h.s.hk) *jersey managed Container request filters GuiceContainerRequestFilter (r.v.d.g.c.h.support) HKContainerRequestFilter (r.v.d.g.c.h.s.hk) *jersey managed Container response filters GuiceContainerResponseFilter (r.v.d.g.c.h.support) HKContainerResponseFilter (r.v.d.g.c.h.s.hk) *jersey managed Dynamic features CacheControlledResponseFeature (i.d.jersey.caching) GuiceDynamicFeature (r.v.d.g.c.h.support) HKDynamicFeature (r.v.d.g.c.h.s.hk) *jersey managed Param value providers AsyncResponseValueParamProvider (o.g.j.s.i.inject) BeanParamValueParamProvider (o.g.j.s.i.inject) CookieParamValueParamProvider (o.g.j.s.i.inject) DelegatedInjectionValueParamProvider (o.g.j.s.i.inject) EntityParamValueParamProvider (o.g.j.s.i.inject) FormParamValueParamProvider (o.g.j.s.i.inject) GuiceValueParamProvider (r.v.d.g.c.h.support) HKValueParamProvider (r.v.d.g.c.h.s.hk) *jersey managed HeaderParamValueParamProvider (o.g.j.s.i.inject) MatrixParamValueParamProvider (o.g.j.s.i.inject) PathParamValueParamProvider (o.g.j.s.i.inject) QueryParamValueParamProvider (o.g.j.s.i.inject) SessionFactoryProvider (i.d.jersey.sessions) WebTargetValueParamProvider (o.g.j.s.i.inject) Injection resolvers @Context ContextInjectionResolverImpl (o.g.j.inject.hk2) @Ann GuiceInjectionResolver (r.v.d.g.c.h.support) @Ann HKInjectionResolver (r.v.d.g.c.h.s.hk) *jersey managed @Suspended ParamInjectionResolver (o.g.j.s.i.inject) using AsyncResponseValueParamProvider @CookieParam ParamInjectionResolver (o.g.j.s.i.inject) using CookieParamValueParamProvider @FormParam ParamInjectionResolver (o.g.j.s.i.inject) using FormParamValueParamProvider @HeaderParam ParamInjectionResolver (o.g.j.s.i.inject) using HeaderParamValueParamProvider @MatrixParam ParamInjectionResolver (o.g.j.s.i.inject) using MatrixParamValueParamProvider @PathParam ParamInjectionResolver (o.g.j.s.i.inject) using PathParamValueParamProvider @QueryParam ParamInjectionResolver (o.g.j.s.i.inject) using QueryParamValueParamProvider @Uri ParamInjectionResolver (o.g.j.s.i.inject) using WebTargetValueParamProvider @BeanParam ParamInjectionResolver (o.g.j.s.i.inject) using BeanParamValueParamProvider Warning Items order does not represent actual priority order! Items in each section are sorted according to @Priority annotation and then by name, but @Custom qualification priority is ignored (and so user extensions and default one may be shown in incorrect order). Report sorting applied only for consistency (always show the same order) - it's a trade off. Common markers \u00b6 Markers are shown at the end of extension line. The following markers are common for all extension types. Filter \u00b6 Jersey extension scope may be reduced with @NameBinding annotation. Custom annotation may be created (declared as @NameBinding ): @NameBinding @Target ( ElementType . TYPE ) @Retention ( RetentionPolicy . RUNTIME ) public @interface FilterAnn {} Now if extension will be annotated with it: @Provider @FilterAnn public class ExMapper implements ExceptionMapper < IOException > {} Will be applied only to resources, annotated with @FilterAnn . Report will identify scoped extensions with marker: IOException ExMapper (r.v.d.g.d.r.j.FilterMarkerRenderTest) *only @FilterAnn Lazy \u00b6 Extensions annotated with @LazyBinding are identified with marker: IOException ExMapper (r.v.d.g.d.r.j.LazyRenderTest) *lazy Jersey managed \u00b6 Extensions, managed by HK2 are also identified with marker: @Ann HKInjectionResolver (r.v.d.g.c.h.s.hk) *jersey managed Exception mappers \u00b6 Extended exception mappers (these mappers may decide if they accept exception handling): @Provider public class ExtMapper implements ExtendedExceptionMapper < IOException > { @Override public boolean isMappable ( IOException exception ) { return false ; } @Override public Response toResponse ( IOException exception ) { return null ; } } Are identified in report: OException ExtMapper (r.v.d.g.d.r.j.ExtendedExceptionMapperRenderTest) *extended Report customization \u00b6 Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, to show only exception mappers: listen ( new JerseyConfigDiagnostic ( new JerseyConfig () . showExceptionMappers ())) Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation.","title":"Jersey"},{"location":"guide/diagnostic/jersey-report/#jersey-config-report","text":"Report shows all registered jersey extensions, including registered by dropwizard and all manual registrations. GuiceBundle . builder () ... . printJerseyConfig () . build () Example report: INFO [2019-10-28 06:16:44,068] ru.vyarus.dropwizard.guice.debug.JerseyConfigDiagnostic: Jersey configuration = Exception mappers Throwable ExceptionMapperBinder$1 (io.dropwizard.setup) EofException EarlyEofExceptionMapper (i.d.jersey.errors) EmptyOptionalException EmptyOptionalExceptionMapper (i.d.jersey.optional) IOException GuiceExceptionMapper (r.v.d.g.c.h.support) IOException HKExceptionMapper (r.v.d.g.c.h.s.hk) *jersey managed IllegalStateException IllegalStateExceptionMapper (i.d.jersey.errors) JerseyViolationException JerseyViolationExceptionMapper (i.d.j.validation) JsonProcessingException JsonProcessingExceptionMapper (i.d.jersey.jackson) ValidationException ValidationExceptionMapper (o.g.j.s.v.internal) Param converters AbstractParamConverterProvider (i.d.jersey.params) FuzzyEnumParamConverterProvider (i.d.j.validation) GuiceParamConverterProvider (r.v.d.g.c.h.support) HKParamConverterProvider (r.v.d.g.c.h.s.hk) *jersey managed RootElementProvider (o.g.j.j.i.JaxbStringReaderProvider) OptionalDoubleParamConverterProvider (i.d.jersey.optional) OptionalIntParamConverterProvider (i.d.jersey.optional) OptionalLongParamConverterProvider (i.d.jersey.optional) OptionalParamConverterProvider (i.d.jersey.guava) OptionalParamConverterProvider (i.d.jersey.optional) AggregatedProvider (o.g.j.i.i.ParamConverters) Context resolvers Context GuiceContextResolver (r.v.d.g.c.h.support) Context HKContextResolver (r.v.d.g.c.h.s.hk) *jersey managed Message body readers Object BasicTypesMessageProvider (o.g.j.m.internal) [text/plain] byte[] ByteArrayProvider (o.g.j.m.internal) [application/octet-stream, */*] DataSource DataSourceProvider (o.g.j.m.internal) [application/octet-stream, */*] Document DocumentProvider (o.g.j.jaxb.internal) [application/xml, text/xml, */*] File FileProvider (o.g.j.m.internal) [application/octet-stream, */*] MultivaluedMap<String, String> FormMultivaluedMapProvider (o.g.j.m.internal) [application/x-www-form-urlencoded] Form FormProvider (o.g.j.m.internal) [application/x-www-form-urlencoded, */*] Type GuiceMessageBodyReader (r.v.d.g.c.h.support) Type HKMessageBodyReader (r.v.d.g.c.h.s.hk) *jersey managed InputStream InputStreamProvider (o.g.j.m.internal) [application/octet-stream, */*] Object JacksonJsonProvider (c.f.j.jaxrs.json) [*/*] Object JacksonMessageBodyProvider (i.d.jersey.jackson) [*/*] Reader ReaderProvider (o.g.j.m.internal) [text/plain, */*] RenderedImage RenderedImageProvider (o.g.j.m.internal) [image/*, application/octet-stream] StreamSource StreamSourceReader (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] SAXSource SaxSourceReader (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] DOMSource DomSourceReader (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] String StringMessageProvider (o.g.j.m.internal) [text/plain, */*] T[], Collection<T> App (o.g.j.j.i.XmlCollectionJaxbProvider) [application/xml] T[], Collection<T> Text (o.g.j.j.i.XmlCollectionJaxbProvider) [text/xml] T[], Collection<T> General (o.g.j.j.i.XmlCollectionJaxbProvider) [*/*] JAXBElement<Object> App (o.g.j.j.i.XmlJaxbElementProvider) [application/xml] JAXBElement<Object> Text (o.g.j.j.i.XmlJaxbElementProvider) [text/xml] JAXBElement<Object> General (o.g.j.j.i.XmlJaxbElementProvider) [*/*,*/*+xml] Object App (o.g.j.j.i.XmlRootElementJaxbProvider) [application/xml] Object Text (o.g.j.j.i.XmlRootElementJaxbProvider) [text/xml] Object General (o.g.j.j.i.XmlRootElementJaxbProvider) [*/*] Object App (o.g.j.j.i.XmlRootObjectJaxbProvider) [application/xml] Object Text (o.g.j.j.i.XmlRootObjectJaxbProvider) [text/xml] Object General (o.g.j.j.i.XmlRootObjectJaxbProvider) [*/*] Message body writers Object BasicTypesMessageProvider (o.g.j.m.internal) [text/plain] byte[] ByteArrayProvider (o.g.j.m.internal) [application/octet-stream, */*] ChunkedOutput<Object> ChunkedResponseWriter (o.g.jersey.server) DataSource DataSourceProvider (o.g.j.m.internal) [application/octet-stream, */*] Document DocumentProvider (o.g.j.jaxb.internal) [application/xml, text/xml, */*] File FileProvider (o.g.j.m.internal) [application/octet-stream, */*] MultivaluedMap<String, String> FormMultivaluedMapProvider (o.g.j.m.internal) [application/x-www-form-urlencoded] Form FormProvider (o.g.j.m.internal) [application/x-www-form-urlencoded, */*] Type GuiceMessageBodyWriter (r.v.d.g.c.h.support) Type HKMessageBodyWriter (r.v.d.g.c.h.s.hk) *jersey managed InputStream InputStreamProvider (o.g.j.m.internal) [application/octet-stream, */*] Object JacksonJsonProvider (c.f.j.jaxrs.json) [*/*] Object JacksonMessageBodyProvider (i.d.jersey.jackson) [*/*] OptionalDouble OptionalDoubleMessageBodyWriter (i.d.jersey.optional) [*/*] OptionalInt OptionalIntMessageBodyWriter (i.d.jersey.optional) [*/*] OptionalLong OptionalLongMessageBodyWriter (i.d.jersey.optional) [*/*] Optional<Object> OptionalMessageBodyWriter (i.d.jersey.guava) [*/*] Optional<Object> OptionalMessageBodyWriter (i.d.jersey.optional) [*/*] Reader ReaderProvider (o.g.j.m.internal) [text/plain, */*] RenderedImage RenderedImageProvider (o.g.j.m.internal) [image/*] Source SourceWriter (o.g.j.m.i.SourceProvider) [application/xml, text/xml, */*] StreamingOutput StreamingOutputProvider (o.g.j.m.internal) [application/octet-stream, */*] String StringMessageProvider (o.g.j.m.internal) [text/plain, */*] Object ValidationErrorMessageBodyWriter (o.g.j.s.v.internal) T[], Collection<T> App (o.g.j.j.i.XmlCollectionJaxbProvider) [application/xml] T[], Collection<T> Text (o.g.j.j.i.XmlCollectionJaxbProvider) [text/xml] T[], Collection<T> General (o.g.j.j.i.XmlCollectionJaxbProvider) [*/*] JAXBElement<Object> App (o.g.j.j.i.XmlJaxbElementProvider) [application/xml] JAXBElement<Object> Text (o.g.j.j.i.XmlJaxbElementProvider) [text/xml] JAXBElement<Object> General (o.g.j.j.i.XmlJaxbElementProvider) [*/*,*/*+xml] Object App (o.g.j.j.i.XmlRootElementJaxbProvider) [application/xml] Object Text (o.g.j.j.i.XmlRootElementJaxbProvider) [text/xml] Object General (o.g.j.j.i.XmlRootElementJaxbProvider) [*/*] Reader interceptors MappableExceptionWrapperInterceptor (o.g.j.s.internal) GuiceReaderInterceptor (r.v.d.g.c.h.support) HKReaderInterceptor (r.v.d.g.c.h.s.hk) *jersey managed Writer interceptors MappableExceptionWrapperInterceptor (o.g.j.s.internal) JsonWithPaddingInterceptor (o.g.j.s.internal) GuiceWriterInterceptor (r.v.d.g.c.h.support) HKWriterInterceptor (r.v.d.g.c.h.s.hk) *jersey managed Container request filters GuiceContainerRequestFilter (r.v.d.g.c.h.support) HKContainerRequestFilter (r.v.d.g.c.h.s.hk) *jersey managed Container response filters GuiceContainerResponseFilter (r.v.d.g.c.h.support) HKContainerResponseFilter (r.v.d.g.c.h.s.hk) *jersey managed Dynamic features CacheControlledResponseFeature (i.d.jersey.caching) GuiceDynamicFeature (r.v.d.g.c.h.support) HKDynamicFeature (r.v.d.g.c.h.s.hk) *jersey managed Param value providers AsyncResponseValueParamProvider (o.g.j.s.i.inject) BeanParamValueParamProvider (o.g.j.s.i.inject) CookieParamValueParamProvider (o.g.j.s.i.inject) DelegatedInjectionValueParamProvider (o.g.j.s.i.inject) EntityParamValueParamProvider (o.g.j.s.i.inject) FormParamValueParamProvider (o.g.j.s.i.inject) GuiceValueParamProvider (r.v.d.g.c.h.support) HKValueParamProvider (r.v.d.g.c.h.s.hk) *jersey managed HeaderParamValueParamProvider (o.g.j.s.i.inject) MatrixParamValueParamProvider (o.g.j.s.i.inject) PathParamValueParamProvider (o.g.j.s.i.inject) QueryParamValueParamProvider (o.g.j.s.i.inject) SessionFactoryProvider (i.d.jersey.sessions) WebTargetValueParamProvider (o.g.j.s.i.inject) Injection resolvers @Context ContextInjectionResolverImpl (o.g.j.inject.hk2) @Ann GuiceInjectionResolver (r.v.d.g.c.h.support) @Ann HKInjectionResolver (r.v.d.g.c.h.s.hk) *jersey managed @Suspended ParamInjectionResolver (o.g.j.s.i.inject) using AsyncResponseValueParamProvider @CookieParam ParamInjectionResolver (o.g.j.s.i.inject) using CookieParamValueParamProvider @FormParam ParamInjectionResolver (o.g.j.s.i.inject) using FormParamValueParamProvider @HeaderParam ParamInjectionResolver (o.g.j.s.i.inject) using HeaderParamValueParamProvider @MatrixParam ParamInjectionResolver (o.g.j.s.i.inject) using MatrixParamValueParamProvider @PathParam ParamInjectionResolver (o.g.j.s.i.inject) using PathParamValueParamProvider @QueryParam ParamInjectionResolver (o.g.j.s.i.inject) using QueryParamValueParamProvider @Uri ParamInjectionResolver (o.g.j.s.i.inject) using WebTargetValueParamProvider @BeanParam ParamInjectionResolver (o.g.j.s.i.inject) using BeanParamValueParamProvider Warning Items order does not represent actual priority order! Items in each section are sorted according to @Priority annotation and then by name, but @Custom qualification priority is ignored (and so user extensions and default one may be shown in incorrect order). Report sorting applied only for consistency (always show the same order) - it's a trade off.","title":"Jersey config report"},{"location":"guide/diagnostic/jersey-report/#common-markers","text":"Markers are shown at the end of extension line. The following markers are common for all extension types.","title":"Common markers"},{"location":"guide/diagnostic/jersey-report/#filter","text":"Jersey extension scope may be reduced with @NameBinding annotation. Custom annotation may be created (declared as @NameBinding ): @NameBinding @Target ( ElementType . TYPE ) @Retention ( RetentionPolicy . RUNTIME ) public @interface FilterAnn {} Now if extension will be annotated with it: @Provider @FilterAnn public class ExMapper implements ExceptionMapper < IOException > {} Will be applied only to resources, annotated with @FilterAnn . Report will identify scoped extensions with marker: IOException ExMapper (r.v.d.g.d.r.j.FilterMarkerRenderTest) *only @FilterAnn","title":"Filter"},{"location":"guide/diagnostic/jersey-report/#lazy","text":"Extensions annotated with @LazyBinding are identified with marker: IOException ExMapper (r.v.d.g.d.r.j.LazyRenderTest) *lazy","title":"Lazy"},{"location":"guide/diagnostic/jersey-report/#jersey-managed","text":"Extensions, managed by HK2 are also identified with marker: @Ann HKInjectionResolver (r.v.d.g.c.h.s.hk) *jersey managed","title":"Jersey managed"},{"location":"guide/diagnostic/jersey-report/#exception-mappers","text":"Extended exception mappers (these mappers may decide if they accept exception handling): @Provider public class ExtMapper implements ExtendedExceptionMapper < IOException > { @Override public boolean isMappable ( IOException exception ) { return false ; } @Override public Response toResponse ( IOException exception ) { return null ; } } Are identified in report: OException ExtMapper (r.v.d.g.d.r.j.ExtendedExceptionMapperRenderTest) *extended","title":"Exception mappers"},{"location":"guide/diagnostic/jersey-report/#report-customization","text":"Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, to show only exception mappers: listen ( new JerseyConfigDiagnostic ( new JerseyConfig () . showExceptionMappers ())) Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation.","title":"Report customization"},{"location":"guide/diagnostic/lifecycle-report/","text":"Lifecycle report \u00b6 In contrast to other reports, this report prints many small messages: 1 message on each meaningful guicey lifecycle points. This lets you: See how configuration goes (and so on each stage problem appear) Separate your logs (making entire startup operations order more obvious) Indicate time since application startup making obvious how much time application spent on each phase. GuiceBundle . builder () ... . printLifecyclePhases () // or printLifecyclePhasesDetailes() to see all confgiruation objects used on logged stage . build () Example output: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.013 ]____________________________________________________/ 1 hooks processed \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.121 ]____________________________________________________/ Initialized 3 (-1) GuiceyBundles \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.136 ]____________________________________________________/ 2 commands installed \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.151 ]____________________________________________________/ 11 (-1) installers initialized \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.158 ]____________________________________________________/ 14 classpath extensions detected \\____ INFO [2019-10-13 08:33:33,925] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: / INFO [2019-10-13 08:33:33,926] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: / \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.869 ]____________________________________________________/ Started 3 GuiceyBundles \\____ ... Important Lifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events. Anyway, these logs intended to be used for problems resolution and so console only output should not be a problem. Note (-1) in some events in report means disabled items and actual displayed count did not count disabled items. You can see all disabled items on detailed output . Detailed output \u00b6 Detailed report ( . printLifecyclePhasesDetailed () ) shows all configuration objects used at current stage. Example detailed output: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.013 ]____________________________________________________/ 1 hooks processed \\____ hooks = GuiceyTestHook (r.v.d.g.AbstractTest) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.118 ]____________________________________________________/ Initialized 3 (-1) GuiceyBundles \\____ bundles = GuiceRestrictedConfigBundle (r.v.d.g.support.util) CoreInstallersBundle (r.v.d.g.m.installer) WebInstallersBundle (r.v.d.g.m.installer) disabled = HK2DebugBundle (r.v.d.g.m.j.debug) ignored duplicate instances = HK2DebugBundle (r.v.d.g.m.j.debug) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.131 ]____________________________________________________/ 2 commands installed \\____ commands = DummyCommand (r.v.d.g.s.feature) NonInjactableCommand (r.v.d.g.s.feature) ... Timer \u00b6 Each log contains time marker: __[ 00:00:00.131 ]___ Timer starts on GuiceBundle creation (it is physically impossible to start it earlier). Note that timer also measure shutdown time (starting from initial shutdown start event): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.000 ]____________________________________________________/ Stopping Jetty... \\____ INFO [2019-10-13 08:36:02,882] org.eclipse.jetty.server.AbstractConnector: Stopped application@36cc9385{HTTP/1.1,[http/1.1]}{0.0.0.0:8080} INFO [2019-10-13 08:36:02,883] org.eclipse.jetty.server.AbstractConnector: Stopped admin@cf518cf{HTTP/1.1,[http/1.1]}{0.0.0.0:8081} INFO [2019-10-13 08:36:02,886] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@5a484ce1{Admin context,/,null,UNAVAILABLE} \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.000 ]____________________________________________________/ Jersey app destroyed \\____ INFO [2019-10-13 08:36:02,892] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@3cc30dee{Application context,/,null,UNAVAILABLE} \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.000 ]____________________________________________________/ Jetty stopped \\____ This may help you to spot slow shutdown logic.","title":"Lifecycle"},{"location":"guide/diagnostic/lifecycle-report/#lifecycle-report","text":"In contrast to other reports, this report prints many small messages: 1 message on each meaningful guicey lifecycle points. This lets you: See how configuration goes (and so on each stage problem appear) Separate your logs (making entire startup operations order more obvious) Indicate time since application startup making obvious how much time application spent on each phase. GuiceBundle . builder () ... . printLifecyclePhases () // or printLifecyclePhasesDetailes() to see all confgiruation objects used on logged stage . build () Example output: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.013 ]____________________________________________________/ 1 hooks processed \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.121 ]____________________________________________________/ Initialized 3 (-1) GuiceyBundles \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.136 ]____________________________________________________/ 2 commands installed \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.151 ]____________________________________________________/ 11 (-1) installers initialized \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.158 ]____________________________________________________/ 14 classpath extensions detected \\____ INFO [2019-10-13 08:33:33,925] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: / INFO [2019-10-13 08:33:33,926] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: / \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.869 ]____________________________________________________/ Started 3 GuiceyBundles \\____ ... Important Lifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events. Anyway, these logs intended to be used for problems resolution and so console only output should not be a problem. Note (-1) in some events in report means disabled items and actual displayed count did not count disabled items. You can see all disabled items on detailed output .","title":"Lifecycle report"},{"location":"guide/diagnostic/lifecycle-report/#detailed-output","text":"Detailed report ( . printLifecyclePhasesDetailed () ) shows all configuration objects used at current stage. Example detailed output: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.013 ]____________________________________________________/ 1 hooks processed \\____ hooks = GuiceyTestHook (r.v.d.g.AbstractTest) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.118 ]____________________________________________________/ Initialized 3 (-1) GuiceyBundles \\____ bundles = GuiceRestrictedConfigBundle (r.v.d.g.support.util) CoreInstallersBundle (r.v.d.g.m.installer) WebInstallersBundle (r.v.d.g.m.installer) disabled = HK2DebugBundle (r.v.d.g.m.j.debug) ignored duplicate instances = HK2DebugBundle (r.v.d.g.m.j.debug) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.131 ]____________________________________________________/ 2 commands installed \\____ commands = DummyCommand (r.v.d.g.s.feature) NonInjactableCommand (r.v.d.g.s.feature) ...","title":"Detailed output"},{"location":"guide/diagnostic/lifecycle-report/#timer","text":"Each log contains time marker: __[ 00:00:00.131 ]___ Timer starts on GuiceBundle creation (it is physically impossible to start it earlier). Note that timer also measure shutdown time (starting from initial shutdown start event): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.000 ]____________________________________________________/ Stopping Jetty... \\____ INFO [2019-10-13 08:36:02,882] org.eclipse.jetty.server.AbstractConnector: Stopped application@36cc9385{HTTP/1.1,[http/1.1]}{0.0.0.0:8080} INFO [2019-10-13 08:36:02,883] org.eclipse.jetty.server.AbstractConnector: Stopped admin@cf518cf{HTTP/1.1,[http/1.1]}{0.0.0.0:8081} INFO [2019-10-13 08:36:02,886] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@5a484ce1{Admin context,/,null,UNAVAILABLE} \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.000 ]____________________________________________________/ Jersey app destroyed \\____ INFO [2019-10-13 08:36:02,892] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@3cc30dee{Application context,/,null,UNAVAILABLE} \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.000 ]____________________________________________________/ Jetty stopped \\____ This may help you to spot slow shutdown logic.","title":"Timer"},{"location":"guide/diagnostic/web-report/","text":"Web mappings report \u00b6 Report shows all registered servlets and filters (including declared in guice ServletModule ). GuiceBundle . builder () ... . printWebMappings () . build () Example report: INFO [2019-10-24 07:48:32,601] ru.vyarus.dropwizard.guice.debug.WebMappingsDiagnostic: Web mappings: MAIN / \u251c\u2500\u2500 filter /custom/* CustomMappingFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [ERROR] .custommapping \u251c\u2500\u2500 filter /async/* async AsyncFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .async \u251c\u2500\u2500 filter /both/* BothFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .both \u251c\u2500\u2500 filter /1/* MainFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .main \u251c\u2500\u2500 filter /2/* --\"-- \u2502 \u251c\u2500\u2500 filter /* async GuiceFilter (c.g.inject.servlet) [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/* GServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/abc?/ regex GRegexServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u2514\u2500\u2500 guiceservlet /2/foo instance of GServletInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 filter /* async AllowedMethodsFilter (i.d.jersey.filter) [REQUEST] io.dropwizard.jersey.filter.AllowedMethodsFilter-5d51e129 \u251c\u2500\u2500 filter /* async ThreadNameFilter (i.d.servlets) [REQUEST] io.dropwizard.servlets.ThreadNameFilter-21c815e4 \u2502 \u251c\u2500\u2500 servlet /foo MainServlet (r.v.d.g.d.r.w.s.UserServletsBundle) target \u2502 \u2514\u2500\u2500 filter TargetServletFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .targetservlet \u2502 \u251c\u2500\u2500 servlet /bar --\"-- \u251c\u2500\u2500 servlet /both BothServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .both \u251c\u2500\u2500 servlet /async async AsyncServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .async \u251c\u2500\u2500 servlet /* async JerseyServletContainer (i.d.jersey.setup) io.dropwizard.jersey.setup.JerseyServletContainer-cf518cf \u2514\u2500\u2500 servlet / async Default404Servlet (o.e.j.s.ServletHandler) org.eclipse.jetty.servlet.ServletHandler$Default404Servlet-5a6fa56e ADMIN / \u251c\u2500\u2500 filter /both/* BothFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .both \u251c\u2500\u2500 filter /1/* AdminFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .admin \u251c\u2500\u2500 filter /2/* --\"-- \u2502 \u251c\u2500\u2500 filter /* async AdminGuiceFilter (r.v.d.g.m.i.internal) [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/* GServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/abc?/ regex GRegexServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u2514\u2500\u2500 guiceservlet /2/foo instance of GServletInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 filter /* async AllowedMethodsFilter (i.d.jersey.filter) [REQUEST] io.dropwizard.jersey.filter.AllowedMethodsFilter-5c080ef3 \u251c\u2500\u2500 servlet /tasks/* async TaskServlet (i.d.servlets.tasks) tasks \u251c\u2500\u2500 servlet /fooadmin AdminServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .admin \u251c\u2500\u2500 servlet /baradmin --\"-- \u251c\u2500\u2500 servlet /both BothServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .both \u251c\u2500\u2500 servlet /* async AdminServlet (c.c.metrics.servlets) com.codahale.metrics.servlets.AdminServlet-24e83d19 \u2514\u2500\u2500 servlet / async Default404Servlet (o.e.j.s.ServletHandler) org.eclipse.jetty.servlet.ServletHandler$Default404Servlet-1200458e Report shows both main and admin contexts. Note Filter and servlet names are shown list at each line because they are often autogenerated and hardly readable. Still name is required if you will need to map filter to exact servlet (or to disable/stop exact servlet) For both filters and servlets async filters and servlets are explicitly marked with async . Filters dispatch types are shown at the end of filter line: \u251c\u2500\u2500 filter /custom/* CustomMappingFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [ERROR] .custommapping \u251c\u2500\u2500 filter /async/* async AsyncFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .async If filter is applied by servlet name then it would be rendered below target servlet: \u251c\u2500\u2500 servlet /foo MainServlet (r.v.d.g.d.r.w.s.UserServletsBundle) target \u2502 \u2514\u2500\u2500 filter TargetServletFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .targetservlet Warning Filters, applied by servlet name are not shown at all if target servlets are not registered. If filter or servlet is applied with multiple target urls then each pattern will start on new line and only on first line complete information will be shown (idem --\"-- string will be used to identify same filter): \u251c\u2500\u2500 filter /1/* MainFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .main \u251c\u2500\u2500 filter /2/* --\"-- Guice \u00b6 Guice servlets and filters (declared in ServletModule s) are shown below guice GuiceFilter (guice filter actually intercept requests and then manually redirect to matching guice bean): \u251c\u2500\u2500 filter /* async GuiceFilter (c.g.inject.servlet) [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule Attention Guice servlets and filters are shown in both admin and main contexts, because GuiceFilter is applied on both contexts and so all urls will work in both contexts. Note that regex registrations are explicitly marked with reges filterRegex ( \"/1/abc?/.*\" ). through ( GRegexFilter . class ) State \u00b6 Report also indicate all stopped and disabled items (report below executed under lightweight guicey test, when jetty is not started): MAIN / \u251c\u2500\u2500 filter /custom/* CustomMappingFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [ERROR] .custommapping \u251c\u2500\u2500 filter /async/* async AsyncFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .async \u251c\u2500\u2500 filter /both/* BothFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .both \u251c\u2500\u2500 filter /1/* MainFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .main \u251c\u2500\u2500 filter /2/* --\"-- \u2502 \u251c\u2500\u2500 filter /* async GuiceFilter (c.g.inject.servlet) STOPPED [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/* GServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/abc?/ regex GRegexServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u2514\u2500\u2500 guiceservlet /2/foo instance of GServletInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 servlet /foo MainServlet (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED target \u2502 \u2514\u2500\u2500 filter TargetServletFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .targetservlet \u2502 \u251c\u2500\u2500 servlet /bar --\"-- \u251c\u2500\u2500 servlet /both BothServlet (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED .both \u2514\u2500\u2500 servlet /async async AsyncServlet (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED .async Here MainServlet is disabled (and stopped) and BothServlet is just stopped. Tip Servlet could be disabled like this: environment . getApplicationContext (). getServletHandler () . getServlet ( \"target\" ). setEnabled ( false ) Report customization \u00b6 Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, same report by for main context only: listen ( new WebMappingsDiagnostic ( new MappingsConfig () . showMainContext () . showDropwizardMappings () . showGuiceMappings ())) Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation.","title":"Web"},{"location":"guide/diagnostic/web-report/#web-mappings-report","text":"Report shows all registered servlets and filters (including declared in guice ServletModule ). GuiceBundle . builder () ... . printWebMappings () . build () Example report: INFO [2019-10-24 07:48:32,601] ru.vyarus.dropwizard.guice.debug.WebMappingsDiagnostic: Web mappings: MAIN / \u251c\u2500\u2500 filter /custom/* CustomMappingFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [ERROR] .custommapping \u251c\u2500\u2500 filter /async/* async AsyncFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .async \u251c\u2500\u2500 filter /both/* BothFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .both \u251c\u2500\u2500 filter /1/* MainFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .main \u251c\u2500\u2500 filter /2/* --\"-- \u2502 \u251c\u2500\u2500 filter /* async GuiceFilter (c.g.inject.servlet) [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/* GServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/abc?/ regex GRegexServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u2514\u2500\u2500 guiceservlet /2/foo instance of GServletInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 filter /* async AllowedMethodsFilter (i.d.jersey.filter) [REQUEST] io.dropwizard.jersey.filter.AllowedMethodsFilter-5d51e129 \u251c\u2500\u2500 filter /* async ThreadNameFilter (i.d.servlets) [REQUEST] io.dropwizard.servlets.ThreadNameFilter-21c815e4 \u2502 \u251c\u2500\u2500 servlet /foo MainServlet (r.v.d.g.d.r.w.s.UserServletsBundle) target \u2502 \u2514\u2500\u2500 filter TargetServletFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .targetservlet \u2502 \u251c\u2500\u2500 servlet /bar --\"-- \u251c\u2500\u2500 servlet /both BothServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .both \u251c\u2500\u2500 servlet /async async AsyncServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .async \u251c\u2500\u2500 servlet /* async JerseyServletContainer (i.d.jersey.setup) io.dropwizard.jersey.setup.JerseyServletContainer-cf518cf \u2514\u2500\u2500 servlet / async Default404Servlet (o.e.j.s.ServletHandler) org.eclipse.jetty.servlet.ServletHandler$Default404Servlet-5a6fa56e ADMIN / \u251c\u2500\u2500 filter /both/* BothFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .both \u251c\u2500\u2500 filter /1/* AdminFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .admin \u251c\u2500\u2500 filter /2/* --\"-- \u2502 \u251c\u2500\u2500 filter /* async AdminGuiceFilter (r.v.d.g.m.i.internal) [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/* GServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/abc?/ regex GRegexServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u2514\u2500\u2500 guiceservlet /2/foo instance of GServletInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 filter /* async AllowedMethodsFilter (i.d.jersey.filter) [REQUEST] io.dropwizard.jersey.filter.AllowedMethodsFilter-5c080ef3 \u251c\u2500\u2500 servlet /tasks/* async TaskServlet (i.d.servlets.tasks) tasks \u251c\u2500\u2500 servlet /fooadmin AdminServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .admin \u251c\u2500\u2500 servlet /baradmin --\"-- \u251c\u2500\u2500 servlet /both BothServlet (r.v.d.g.d.r.w.s.UserServletsBundle) .both \u251c\u2500\u2500 servlet /* async AdminServlet (c.c.metrics.servlets) com.codahale.metrics.servlets.AdminServlet-24e83d19 \u2514\u2500\u2500 servlet / async Default404Servlet (o.e.j.s.ServletHandler) org.eclipse.jetty.servlet.ServletHandler$Default404Servlet-1200458e Report shows both main and admin contexts. Note Filter and servlet names are shown list at each line because they are often autogenerated and hardly readable. Still name is required if you will need to map filter to exact servlet (or to disable/stop exact servlet) For both filters and servlets async filters and servlets are explicitly marked with async . Filters dispatch types are shown at the end of filter line: \u251c\u2500\u2500 filter /custom/* CustomMappingFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [ERROR] .custommapping \u251c\u2500\u2500 filter /async/* async AsyncFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .async If filter is applied by servlet name then it would be rendered below target servlet: \u251c\u2500\u2500 servlet /foo MainServlet (r.v.d.g.d.r.w.s.UserServletsBundle) target \u2502 \u2514\u2500\u2500 filter TargetServletFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .targetservlet Warning Filters, applied by servlet name are not shown at all if target servlets are not registered. If filter or servlet is applied with multiple target urls then each pattern will start on new line and only on first line complete information will be shown (idem --\"-- string will be used to identify same filter): \u251c\u2500\u2500 filter /1/* MainFilter (r.v.d.g.d.r.w.s.UserServletsBundle) [REQUEST] .main \u251c\u2500\u2500 filter /2/* --\"--","title":"Web mappings report"},{"location":"guide/diagnostic/web-report/#guice","text":"Guice servlets and filters (declared in ServletModule s) are shown below guice GuiceFilter (guice filter actually intercept requests and then manually redirect to matching guice bean): \u251c\u2500\u2500 filter /* async GuiceFilter (c.g.inject.servlet) [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule Attention Guice servlets and filters are shown in both admin and main contexts, because GuiceFilter is applied on both contexts and so all urls will work in both contexts. Note that regex registrations are explicitly marked with reges filterRegex ( \"/1/abc?/.*\" ). through ( GRegexFilter . class )","title":"Guice"},{"location":"guide/diagnostic/web-report/#state","text":"Report also indicate all stopped and disabled items (report below executed under lightweight guicey test, when jetty is not started): MAIN / \u251c\u2500\u2500 filter /custom/* CustomMappingFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [ERROR] .custommapping \u251c\u2500\u2500 filter /async/* async AsyncFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .async \u251c\u2500\u2500 filter /both/* BothFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .both \u251c\u2500\u2500 filter /1/* MainFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .main \u251c\u2500\u2500 filter /2/* --\"-- \u2502 \u251c\u2500\u2500 filter /* async GuiceFilter (c.g.inject.servlet) STOPPED [REQUEST] Guice Filter \u2502 \u251c\u2500\u2500 guicefilter /1/* GFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/abc?/.* regex GRegexFilter r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guicefilter /1/foo instance of GFilterInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/* GServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 guiceservlet /2/abc?/ regex GRegexServlet r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u2514\u2500\u2500 guiceservlet /2/foo instance of GServletInstance r.v.d.g.d.r.w.support.GuiceWebModule \u2502 \u251c\u2500\u2500 servlet /foo MainServlet (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED target \u2502 \u2514\u2500\u2500 filter TargetServletFilter (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED [REQUEST] .targetservlet \u2502 \u251c\u2500\u2500 servlet /bar --\"-- \u251c\u2500\u2500 servlet /both BothServlet (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED .both \u2514\u2500\u2500 servlet /async async AsyncServlet (r.v.d.g.d.r.w.s.UserServletsBundle) STOPPED .async Here MainServlet is disabled (and stopped) and BothServlet is just stopped. Tip Servlet could be disabled like this: environment . getApplicationContext (). getServletHandler () . getServlet ( \"target\" ). setEnabled ( false )","title":"State"},{"location":"guide/diagnostic/web-report/#report-customization","text":"Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, same report by for main context only: listen ( new WebMappingsDiagnostic ( new MappingsConfig () . showMainContext () . showDropwizardMappings () . showGuiceMappings ())) Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation.","title":"Report customization"},{"location":"guide/diagnostic/yaml-values-report/","text":"Yaml values report \u00b6 Prints all available direct yaml values : GuiceBundle . builder () ... . printConfigurationBindings () // or printCustomConfigurationBindings() to avoid dropwizard bindings . build () Note Even if custom binding report selected ( printCustomConfigurationBindings() ), guicey will always bind all bindings, including dropwizard Configuration class. Custom config report could just shows less for simplicity. Will print: INFO [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = ComplexGenericCase (visible paths) \u2502 \u251c\u2500\u2500 sub: ComplexGenericCase.Sub<String> \u2502 \u2514\u2500\u2500 smth: String = null \u2502 \u251c\u2500\u2500 logging: DefaultLoggingFactory \u2502 \u251c\u2500\u2500 level: String = \"INFO\" \u2502 \u251c\u2500\u2500 loggers: RegularImmutableMap<String, JsonNode> = {} \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<ILoggingEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] \u2502 \u251c\u2500\u2500 metrics: MetricsFactory \u2502 \u251c\u2500\u2500 frequency: Duration = 1 minute \u2502 \u2514\u2500\u2500 reporters: RegularImmutableList<ReporterFactory> = [] \u2502 \u2514\u2500\u2500 server: DefaultServerFactory \u251c\u2500\u2500 maxThreads: Integer = 1024 \u251c\u2500\u2500 minThreads: Integer = 8 \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024 \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute \u251c\u2500\u2500 nofileSoftLimit: Integer = null \u251c\u2500\u2500 nofileHardLimit: Integer = null \u251c\u2500\u2500 gid: Integer = null \u251c\u2500\u2500 uid: Integer = null \u251c\u2500\u2500 user: String = null \u251c\u2500\u2500 group: String = null \u251c\u2500\u2500 umask: String = null \u251c\u2500\u2500 startsAsRoot: Boolean = null \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds \u251c\u2500\u2500 allowedMethods: HashSet<String> = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true \u251c\u2500\u2500 applicationConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] \u251c\u2500\u2500 adminConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@227a47] \u251c\u2500\u2500 adminMaxThreads: Integer = 64 \u251c\u2500\u2500 adminMinThreads: Integer = 1 \u251c\u2500\u2500 applicationContextPath: String = \"/\" \u251c\u2500\u2500 adminContextPath: String = \"/\" \u2502 \u251c\u2500\u2500 serverPush: ServerPushFilterFactory \u2502 \u251c\u2500\u2500 enabled: Boolean = false \u2502 \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds \u2502 \u251c\u2500\u2500 maxAssociations: Integer = 16 \u2502 \u251c\u2500\u2500 refererHosts: List<String> = null \u2502 \u2514\u2500\u2500 refererPorts: List<Integer> = null \u2502 \u251c\u2500\u2500 rootPath: Optional<String> = Optional.empty \u2502 \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<IAccessEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] \u2502 \u2514\u2500\u2500 gzip: GzipHandlerFactory \u251c\u2500\u2500 enabled: Boolean = true \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet<String> = [] \u251c\u2500\u2500 compressedMimeTypes: Set<String> = null \u251c\u2500\u2500 includedMethods: Set<String> = null \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1 \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true \u2514\u2500\u2500 syncFlush: Boolean = false Configuration object bindings: @Config ComplexGenericCase @Config Configuration Unique sub configuration objects bindings: ComplexGenericCase.sub @Config ComplexGenericCase.Sub<String> = null Configuration.logging @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} Configuration.metrics @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} Configuration.server @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} Configuration.server.gzip @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 Configuration.server.requestLog @Config RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 Configuration.server.serverPush @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 Configuration paths bindings: ComplexGenericCase: @Config(\"sub\") ComplexGenericCase.Sub<String> = null @Config(\"sub.smth\") String = null Configuration: @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} @Config(\"logging.appenders\") List<AppenderFactory<ILoggingEvent>> (with actual type SingletonImmutableList<AppenderFactory<ILoggingEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] @Config(\"logging.level\") String = \"INFO\" @Config(\"logging.loggers\") Map<String, JsonNode> (with actual type RegularImmutableMap<String, JsonNode>) = {} @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} @Config(\"metrics.frequency\") Duration = 1 minute @Config(\"metrics.reporters\") List<ReporterFactory> (with actual type RegularImmutableList<ReporterFactory>) = [] @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} @Config(\"server.adminConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@227a47] @Config(\"server.adminContextPath\") String = \"/\" @Config(\"server.adminMaxThreads\") Integer = 64 @Config(\"server.adminMinThreads\") Integer = 1 @Config(\"server.allowedMethods\") Set<String> (with actual type HashSet<String>) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] @Config(\"server.applicationConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] @Config(\"server.applicationContextPath\") String = \"/\" @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false @Config(\"server.enableThreadNameFilter\") Boolean = true @Config(\"server.gid\") Integer = null @Config(\"server.group\") String = null @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes @Config(\"server.gzip.compressedMimeTypes\") Set<String> = null @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1 @Config(\"server.gzip.enabled\") Boolean = true @Config(\"server.gzip.excludedUserAgentPatterns\") Set<String> (with actual type HashSet<String>) = [] @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true @Config(\"server.gzip.includedMethods\") Set<String> = null @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes @Config(\"server.gzip.syncFlush\") Boolean = false @Config(\"server.idleThreadTimeout\") Duration = 1 minute @Config(\"server.maxQueuedRequests\") Integer = 1024 @Config(\"server.maxThreads\") Integer = 1024 @Config(\"server.minThreads\") Integer = 8 @Config(\"server.nofileHardLimit\") Integer = null @Config(\"server.nofileSoftLimit\") Integer = null @Config(\"server.registerDefaultExceptionMappers\") Boolean = true @Config(\"server.requestLog\") RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 @Config(\"server.requestLog.appenders\") List<AppenderFactory<IAccessEvent>> (with actual type SingletonImmutableList<AppenderFactory<IAccessEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] @Config(\"server.rootPath\") Optional<String> = Optional.empty @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds @Config(\"server.serverPush.enabled\") Boolean = false @Config(\"server.serverPush.maxAssociations\") Integer = 16 @Config(\"server.serverPush.refererHosts\") List<String> = null @Config(\"server.serverPush.refererPorts\") List<Integer> = null @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds @Config(\"server.startsAsRoot\") Boolean = null @Config(\"server.uid\") Integer = null @Config(\"server.umask\") String = null @Config(\"server.user\") String = null Here you can see: All visible configuration values (as tree). Types and interfaces for configuration object Unique sub configuration objects Values bound to guice context Also, if manual qualification is used, all annotated properties would also be shown: Qualified bindings: @Named(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[], reportOnStop=false} (metrics) @CustomQualifier SubObj = ru.vyarus.dropwizard.guice.yaml.qualifier.QualifierSampleTest$SubObj@19e0dffe (obj1) @Named(\"sub-prop\") Set<String> = (aggregated values) String = \"2\" (obj1.prop2) String = \"3\" (obj1.prop3) @Named(\"custom\") String = \"1\" (prop1) Guice \u00b6 Report is mostly intended to be used to see available guice bindings and that's why @Config annotation is shown almost everywhere. For example, @Config(\"server.serverPush.enabled\") Boolean = false means that the following injection will work: @Inject @Config ( \"server.serverPush.enabled\" ) Boolean pushEnabled ; And it will be set to \"false\". Tip Report is printed before guice injector creation to let you review all available bindings when injector creation fails due to incorrect configuration value binding. The same for unique objects: Configuration.logging @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} Means available injection: @Inject @Config LoggingFactory logginFactory ; Note Declaration type is always used ( LoggingFactory ) even when runtype type is known ( (with actual type DefaultLoggingFactory) ). This is important to keep bindings consistent (otherwise they would always change, depending on actual config value). Direct values access \u00b6 But report is also handful for direct values access (through ConfigurationTree object ). For example, accessing value by path: tree . valueByPath ( \"logging.level\" ) == INFO Or unique object access: tree . valueByUniqueDeclaredType ( MetricsFactory . class ) == < factory instance > Report customization \u00b6 Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, custom bindings report is configured like this: listen ( new YamlBindingsDiagnostic ( new BindingsConfig () . showConfigurationTree () . showNullValues () . showCustomConfigOnly ())); Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation. For examples of direct renderer usage see events implementation: RunPhaseEvent.renderConfigurationBindings()","title":"Yaml values"},{"location":"guide/diagnostic/yaml-values-report/#yaml-values-report","text":"Prints all available direct yaml values : GuiceBundle . builder () ... . printConfigurationBindings () // or printCustomConfigurationBindings() to avoid dropwizard bindings . build () Note Even if custom binding report selected ( printCustomConfigurationBindings() ), guicey will always bind all bindings, including dropwizard Configuration class. Custom config report could just shows less for simplicity. Will print: INFO [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = ComplexGenericCase (visible paths) \u2502 \u251c\u2500\u2500 sub: ComplexGenericCase.Sub<String> \u2502 \u2514\u2500\u2500 smth: String = null \u2502 \u251c\u2500\u2500 logging: DefaultLoggingFactory \u2502 \u251c\u2500\u2500 level: String = \"INFO\" \u2502 \u251c\u2500\u2500 loggers: RegularImmutableMap<String, JsonNode> = {} \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<ILoggingEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] \u2502 \u251c\u2500\u2500 metrics: MetricsFactory \u2502 \u251c\u2500\u2500 frequency: Duration = 1 minute \u2502 \u2514\u2500\u2500 reporters: RegularImmutableList<ReporterFactory> = [] \u2502 \u2514\u2500\u2500 server: DefaultServerFactory \u251c\u2500\u2500 maxThreads: Integer = 1024 \u251c\u2500\u2500 minThreads: Integer = 8 \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024 \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute \u251c\u2500\u2500 nofileSoftLimit: Integer = null \u251c\u2500\u2500 nofileHardLimit: Integer = null \u251c\u2500\u2500 gid: Integer = null \u251c\u2500\u2500 uid: Integer = null \u251c\u2500\u2500 user: String = null \u251c\u2500\u2500 group: String = null \u251c\u2500\u2500 umask: String = null \u251c\u2500\u2500 startsAsRoot: Boolean = null \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds \u251c\u2500\u2500 allowedMethods: HashSet<String> = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true \u251c\u2500\u2500 applicationConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] \u251c\u2500\u2500 adminConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@227a47] \u251c\u2500\u2500 adminMaxThreads: Integer = 64 \u251c\u2500\u2500 adminMinThreads: Integer = 1 \u251c\u2500\u2500 applicationContextPath: String = \"/\" \u251c\u2500\u2500 adminContextPath: String = \"/\" \u2502 \u251c\u2500\u2500 serverPush: ServerPushFilterFactory \u2502 \u251c\u2500\u2500 enabled: Boolean = false \u2502 \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds \u2502 \u251c\u2500\u2500 maxAssociations: Integer = 16 \u2502 \u251c\u2500\u2500 refererHosts: List<String> = null \u2502 \u2514\u2500\u2500 refererPorts: List<Integer> = null \u2502 \u251c\u2500\u2500 rootPath: Optional<String> = Optional.empty \u2502 \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<IAccessEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] \u2502 \u2514\u2500\u2500 gzip: GzipHandlerFactory \u251c\u2500\u2500 enabled: Boolean = true \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet<String> = [] \u251c\u2500\u2500 compressedMimeTypes: Set<String> = null \u251c\u2500\u2500 includedMethods: Set<String> = null \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1 \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true \u2514\u2500\u2500 syncFlush: Boolean = false Configuration object bindings: @Config ComplexGenericCase @Config Configuration Unique sub configuration objects bindings: ComplexGenericCase.sub @Config ComplexGenericCase.Sub<String> = null Configuration.logging @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} Configuration.metrics @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} Configuration.server @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} Configuration.server.gzip @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 Configuration.server.requestLog @Config RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 Configuration.server.serverPush @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 Configuration paths bindings: ComplexGenericCase: @Config(\"sub\") ComplexGenericCase.Sub<String> = null @Config(\"sub.smth\") String = null Configuration: @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} @Config(\"logging.appenders\") List<AppenderFactory<ILoggingEvent>> (with actual type SingletonImmutableList<AppenderFactory<ILoggingEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] @Config(\"logging.level\") String = \"INFO\" @Config(\"logging.loggers\") Map<String, JsonNode> (with actual type RegularImmutableMap<String, JsonNode>) = {} @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} @Config(\"metrics.frequency\") Duration = 1 minute @Config(\"metrics.reporters\") List<ReporterFactory> (with actual type RegularImmutableList<ReporterFactory>) = [] @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} @Config(\"server.adminConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@227a47] @Config(\"server.adminContextPath\") String = \"/\" @Config(\"server.adminMaxThreads\") Integer = 64 @Config(\"server.adminMinThreads\") Integer = 1 @Config(\"server.allowedMethods\") Set<String> (with actual type HashSet<String>) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] @Config(\"server.applicationConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] @Config(\"server.applicationContextPath\") String = \"/\" @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false @Config(\"server.enableThreadNameFilter\") Boolean = true @Config(\"server.gid\") Integer = null @Config(\"server.group\") String = null @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes @Config(\"server.gzip.compressedMimeTypes\") Set<String> = null @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1 @Config(\"server.gzip.enabled\") Boolean = true @Config(\"server.gzip.excludedUserAgentPatterns\") Set<String> (with actual type HashSet<String>) = [] @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true @Config(\"server.gzip.includedMethods\") Set<String> = null @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes @Config(\"server.gzip.syncFlush\") Boolean = false @Config(\"server.idleThreadTimeout\") Duration = 1 minute @Config(\"server.maxQueuedRequests\") Integer = 1024 @Config(\"server.maxThreads\") Integer = 1024 @Config(\"server.minThreads\") Integer = 8 @Config(\"server.nofileHardLimit\") Integer = null @Config(\"server.nofileSoftLimit\") Integer = null @Config(\"server.registerDefaultExceptionMappers\") Boolean = true @Config(\"server.requestLog\") RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 @Config(\"server.requestLog.appenders\") List<AppenderFactory<IAccessEvent>> (with actual type SingletonImmutableList<AppenderFactory<IAccessEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] @Config(\"server.rootPath\") Optional<String> = Optional.empty @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds @Config(\"server.serverPush.enabled\") Boolean = false @Config(\"server.serverPush.maxAssociations\") Integer = 16 @Config(\"server.serverPush.refererHosts\") List<String> = null @Config(\"server.serverPush.refererPorts\") List<Integer> = null @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds @Config(\"server.startsAsRoot\") Boolean = null @Config(\"server.uid\") Integer = null @Config(\"server.umask\") String = null @Config(\"server.user\") String = null Here you can see: All visible configuration values (as tree). Types and interfaces for configuration object Unique sub configuration objects Values bound to guice context Also, if manual qualification is used, all annotated properties would also be shown: Qualified bindings: @Named(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[], reportOnStop=false} (metrics) @CustomQualifier SubObj = ru.vyarus.dropwizard.guice.yaml.qualifier.QualifierSampleTest$SubObj@19e0dffe (obj1) @Named(\"sub-prop\") Set<String> = (aggregated values) String = \"2\" (obj1.prop2) String = \"3\" (obj1.prop3) @Named(\"custom\") String = \"1\" (prop1)","title":"Yaml values report"},{"location":"guide/diagnostic/yaml-values-report/#guice","text":"Report is mostly intended to be used to see available guice bindings and that's why @Config annotation is shown almost everywhere. For example, @Config(\"server.serverPush.enabled\") Boolean = false means that the following injection will work: @Inject @Config ( \"server.serverPush.enabled\" ) Boolean pushEnabled ; And it will be set to \"false\". Tip Report is printed before guice injector creation to let you review all available bindings when injector creation fails due to incorrect configuration value binding. The same for unique objects: Configuration.logging @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} Means available injection: @Inject @Config LoggingFactory logginFactory ; Note Declaration type is always used ( LoggingFactory ) even when runtype type is known ( (with actual type DefaultLoggingFactory) ). This is important to keep bindings consistent (otherwise they would always change, depending on actual config value).","title":"Guice"},{"location":"guide/diagnostic/yaml-values-report/#direct-values-access","text":"But report is also handful for direct values access (through ConfigurationTree object ). For example, accessing value by path: tree . valueByPath ( \"logging.level\" ) == INFO Or unique object access: tree . valueByUniqueDeclaredType ( MetricsFactory . class ) == < factory instance >","title":"Direct values access"},{"location":"guide/diagnostic/yaml-values-report/#report-customization","text":"Report is implemented as guicey event listener and provide additional customization options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration. For example, custom bindings report is configured like this: listen ( new YamlBindingsDiagnostic ( new BindingsConfig () . showConfigurationTree () . showNullValues () . showCustomConfigOnly ())); Report rendering logic may also be used directly as report provide separate renderer object implementing ReportRenderer . Renderer not bound to guice context and assume direct instantiation. For examples of direct renderer usage see events implementation: RunPhaseEvent.renderConfigurationBindings()","title":"Report customization"},{"location":"guide/guice/bindings/","text":"Bindings \u00b6 Guicey always installs GuiceBootstrapModule which registers the following bindings: Dropwizard objects: io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Detailed configuration bindings (by root classes, interfaces, yaml path or unique subtype) Jersey objects (including request scoped ) Guicey special objects All installed extensions Tip All registered bindings could be seen with guice report . Configuration \u00b6 Configuration bound to guice as: io.dropwizard.Configuration Your configuration class ( MyConfiguration extends Configuration ) All classes between them For example, if MyConfiguration extends MyAbstractConfiguration extends Configuration Then MyAbstractConfiguration will be also bound and the following injection will work: @Inject MyAbstractConfiguration conf Note Configuration object bindings could be declared with or without qualifier @Config . So @Inject @Config MyAbstractConfiguration conf will also work. It is suggested to always use qualifier (to get in common with direct value bindings), but it's up to you. If root configuration classes implement interfaces then configuration could be bound by interface. This may be used to support common Has<Something> configuration interfaces convention used to recognize your extension configuration in configuration object. public interface HasFeatureX { FeatureXConfig getFetureXConfig (); } public class MyConfiguration extends Configuration implements HasFeatureXConfig {...} public class MyBean { @Inject @Config HasFeatureX conf ; ... } Interface binding will ignore interfaces in java.* or groovy.* packages (to avoid unnecessary bindings). Tip Consider using direct sub configuration object binding instead of marker interface if object uniqueness is guaranteed in user configuration. Yaml config introspection \u00b6 Guicey performs Configuration object introspection to provide access for configured yaml values by path or through sub-objects. Warning Additional configuration objects are not bound when yaml introspection is disabled Raw introspection result could be injected directly (for reporting or analysis): @Inject ConfigurationTree tree ; Tip All available configuration bindings could be seen with .printConfigurationBindings() report (use .printAllConfigurationBindings() to see also core dropwizard configuration values). This report is executed before injector creation so use it in cases when injector fail to inject configration value to validate binsinds correctness. Unique objects \u00b6 Unique sub-object (sub configuration classes appeared once) could be injected directly. For example, the following config contains two (custom) unique sub objects: public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; @JsonProperty DbConfig db ; } Which could be injected directly: @Inject @Config AuthConfig auth ; @Inject @Config DbConfig db ; Tip This is very useful for re-usable modules, which are not aware of your configuration object structure, but require only one sub configuration object: public class MyConfig extends Configuration { @JsonProperty FeatureXConfig featureX ; } Somewhere in module service: public class FeatureXService { @Inject @Config FeatureXConfig featureX ; } Value by path \u00b6 All visible configuration paths values can be directly bound: public class MyConfig extends Configuration { SubConf sub ; } public class SubConf { String smth ; List < String > values ; } @Inject @Config ( \"sub\" ) SubConf sub ; @Inject @Config ( \"sub.smth\" ) String smth ; @Inject @Config ( \"sub.values\" ) List < String > values ; Note Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations). The only exception is conditional mapping like dropwizard server when available paths could change, depending on configuration (what configuration type will be used) Note Generified types are bound only with generics (with all available type information). If you have SubConf<T> sub in config, then it will be bound with correct generic SubConfig<String> (suppose generic T is declared as String). Value type, declared in configuration class is used for binding, but there are two exceptions. First, if declared type is declared as collection ( Set , List , Map ) implementation then binding will use base collection interface: ArrayList < String > value @Inject @Config ( \"value\" ) List < String > vlaue ; Second, if, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence: @Config(\"path\") Object val - when value is null @Config(\"path\") ValueType val - actual value type, when value is not null It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard server ). Tip If provided value bindings are not enough for your case, you can declare your own value bindings: Get introspcetion result object ( ConfigurationTree ) in guice module and bind values the way you need it: public class MyConfigBindingsModule extends DropwizardAwareModule { @Override public void configure () { bind ( String . class ). annotatedWith ( Names . named ( \"db.url\" ), configuration ( \"db.url)); } } Environment binding \u00b6 Dropwizard io.dropwizard.setup.Environment is bound to guice context. It is mostly useful to perform additional configurations in guice bean for features not covered with installers. For example: public class MyBean { @Inject public MyBean ( Environment environment ) { environment . lifecycle (). addServerLifecycleListener ( new ServerLifecycleListener { public void serverStarted ( Server server ) { callSomeMethod (); } }) } } It's not the best example, but it illustrates usage (and such things usually helps to quick-test something). See also authentication configuration example . Jersey specific bindings \u00b6 Jersey bindings are not immediately available, because HK2 context starts after guice, so use Provider to inject these bindings. These bindings available after HK2 context start: javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.AsyncContext Tip Read about jersey bindings implementation in lifecycle section . Request and response \u00b6 By default, GuiceFilter is enabled on both contexts (admin and main). So you can inject request and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions). If you disable guice filter with .noGuiceFilter() then guicey will bridge objects from HK2 context: javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse This means you can still inject them, but request and response will only be available under resource calls (the only part managed by jersey). Example usage: @Inject Provider < HttpServletRequest > requestProvider ; Note Pay attention, that in guice-managed resources @Context field bindings must be replaced with providers . Options \u00b6 ru.vyarus.dropwizard.guice.module.context.option.Options binding provides access to guicey options : @Inject Options options ; Example usage: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" ) Guicey configuration \u00b6 ru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo binding provides access to guicey configuration details : @Inject GuiceyConfigurationInfo info Extension bindings \u00b6 Summary Normally, you don't need to know about extension bindings because they are mostly useless for application, but this section is important in case of problems. In order to support guice binder().requireExplicitBindings() option guicey binds all extensions with untargeted binding: binder().bind(YourExtension.class) . But there are three exceptions: Installers with custom binding logic (like a plugins installer ) If extension was detected from binding (obviously binding already exists) If extension is annotated with @LazyBinding As injector is created in Stage.PRODUCTION , all singleton extensions will be instantiated in time of injector startup (injector stage could be changed in main bundle ).","title":"Bindings"},{"location":"guide/guice/bindings/#bindings","text":"Guicey always installs GuiceBootstrapModule which registers the following bindings: Dropwizard objects: io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Detailed configuration bindings (by root classes, interfaces, yaml path or unique subtype) Jersey objects (including request scoped ) Guicey special objects All installed extensions Tip All registered bindings could be seen with guice report .","title":"Bindings"},{"location":"guide/guice/bindings/#configuration","text":"Configuration bound to guice as: io.dropwizard.Configuration Your configuration class ( MyConfiguration extends Configuration ) All classes between them For example, if MyConfiguration extends MyAbstractConfiguration extends Configuration Then MyAbstractConfiguration will be also bound and the following injection will work: @Inject MyAbstractConfiguration conf Note Configuration object bindings could be declared with or without qualifier @Config . So @Inject @Config MyAbstractConfiguration conf will also work. It is suggested to always use qualifier (to get in common with direct value bindings), but it's up to you. If root configuration classes implement interfaces then configuration could be bound by interface. This may be used to support common Has<Something> configuration interfaces convention used to recognize your extension configuration in configuration object. public interface HasFeatureX { FeatureXConfig getFetureXConfig (); } public class MyConfiguration extends Configuration implements HasFeatureXConfig {...} public class MyBean { @Inject @Config HasFeatureX conf ; ... } Interface binding will ignore interfaces in java.* or groovy.* packages (to avoid unnecessary bindings). Tip Consider using direct sub configuration object binding instead of marker interface if object uniqueness is guaranteed in user configuration.","title":"Configuration"},{"location":"guide/guice/bindings/#yaml-config-introspection","text":"Guicey performs Configuration object introspection to provide access for configured yaml values by path or through sub-objects. Warning Additional configuration objects are not bound when yaml introspection is disabled Raw introspection result could be injected directly (for reporting or analysis): @Inject ConfigurationTree tree ; Tip All available configuration bindings could be seen with .printConfigurationBindings() report (use .printAllConfigurationBindings() to see also core dropwizard configuration values). This report is executed before injector creation so use it in cases when injector fail to inject configration value to validate binsinds correctness.","title":"Yaml config introspection"},{"location":"guide/guice/bindings/#unique-objects","text":"Unique sub-object (sub configuration classes appeared once) could be injected directly. For example, the following config contains two (custom) unique sub objects: public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; @JsonProperty DbConfig db ; } Which could be injected directly: @Inject @Config AuthConfig auth ; @Inject @Config DbConfig db ; Tip This is very useful for re-usable modules, which are not aware of your configuration object structure, but require only one sub configuration object: public class MyConfig extends Configuration { @JsonProperty FeatureXConfig featureX ; } Somewhere in module service: public class FeatureXService { @Inject @Config FeatureXConfig featureX ; }","title":"Unique objects"},{"location":"guide/guice/bindings/#value-by-path","text":"All visible configuration paths values can be directly bound: public class MyConfig extends Configuration { SubConf sub ; } public class SubConf { String smth ; List < String > values ; } @Inject @Config ( \"sub\" ) SubConf sub ; @Inject @Config ( \"sub.smth\" ) String smth ; @Inject @Config ( \"sub.values\" ) List < String > values ; Note Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations). The only exception is conditional mapping like dropwizard server when available paths could change, depending on configuration (what configuration type will be used) Note Generified types are bound only with generics (with all available type information). If you have SubConf<T> sub in config, then it will be bound with correct generic SubConfig<String> (suppose generic T is declared as String). Value type, declared in configuration class is used for binding, but there are two exceptions. First, if declared type is declared as collection ( Set , List , Map ) implementation then binding will use base collection interface: ArrayList < String > value @Inject @Config ( \"value\" ) List < String > vlaue ; Second, if, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence: @Config(\"path\") Object val - when value is null @Config(\"path\") ValueType val - actual value type, when value is not null It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard server ). Tip If provided value bindings are not enough for your case, you can declare your own value bindings: Get introspcetion result object ( ConfigurationTree ) in guice module and bind values the way you need it: public class MyConfigBindingsModule extends DropwizardAwareModule { @Override public void configure () { bind ( String . class ). annotatedWith ( Names . named ( \"db.url\" ), configuration ( \"db.url)); } }","title":"Value by path"},{"location":"guide/guice/bindings/#environment-binding","text":"Dropwizard io.dropwizard.setup.Environment is bound to guice context. It is mostly useful to perform additional configurations in guice bean for features not covered with installers. For example: public class MyBean { @Inject public MyBean ( Environment environment ) { environment . lifecycle (). addServerLifecycleListener ( new ServerLifecycleListener { public void serverStarted ( Server server ) { callSomeMethod (); } }) } } It's not the best example, but it illustrates usage (and such things usually helps to quick-test something). See also authentication configuration example .","title":"Environment binding"},{"location":"guide/guice/bindings/#jersey-specific-bindings","text":"Jersey bindings are not immediately available, because HK2 context starts after guice, so use Provider to inject these bindings. These bindings available after HK2 context start: javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.AsyncContext Tip Read about jersey bindings implementation in lifecycle section .","title":"Jersey specific bindings"},{"location":"guide/guice/bindings/#request-and-response","text":"By default, GuiceFilter is enabled on both contexts (admin and main). So you can inject request and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions). If you disable guice filter with .noGuiceFilter() then guicey will bridge objects from HK2 context: javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse This means you can still inject them, but request and response will only be available under resource calls (the only part managed by jersey). Example usage: @Inject Provider < HttpServletRequest > requestProvider ; Note Pay attention, that in guice-managed resources @Context field bindings must be replaced with providers .","title":"Request and response"},{"location":"guide/guice/bindings/#options","text":"ru.vyarus.dropwizard.guice.module.context.option.Options binding provides access to guicey options : @Inject Options options ; Example usage: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" )","title":"Options"},{"location":"guide/guice/bindings/#guicey-configuration","text":"ru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo binding provides access to guicey configuration details : @Inject GuiceyConfigurationInfo info","title":"Guicey configuration"},{"location":"guide/guice/bindings/#extension-bindings","text":"Summary Normally, you don't need to know about extension bindings because they are mostly useless for application, but this section is important in case of problems. In order to support guice binder().requireExplicitBindings() option guicey binds all extensions with untargeted binding: binder().bind(YourExtension.class) . But there are three exceptions: Installers with custom binding logic (like a plugins installer ) If extension was detected from binding (obviously binding already exists) If extension is annotated with @LazyBinding As injector is created in Stage.PRODUCTION , all singleton extensions will be instantiated in time of injector startup (injector stage could be changed in main bundle ).","title":"Extension bindings"},{"location":"guide/guice/injector/","text":"Injector instance \u00b6 Restrictive options \u00b6 Guicey is compatible with the following guice restrictive options: public class MyModule extends AbstractModule { @Override protected void configure () { binder (). disableCircularProxies (); binder (). requireExactBindingAnnotations (); binder (). requireExplicitBindings (); } } Access injector \u00b6 In some cases it may be important to get injector instance outside of guice context. Warning Injector is created on dropwizard run phase. Attempt to obtain injector before it will lead to exception. Injector instance could be resolved with: GuiceBundle # getInjector () method on instance (exception thrown if not yet started) InjectorLookup . getInjector ( app ). get () static call using application instance (lookup returns Optional for null safety). If you need lazy injector reference, you can use InjectorProvider class ( Provider < Injector > ): Provider < Injector > provider = new InjectorProvider ( app ); // somewhere after run phase Injector injector = provider . get (); Bean instance may be obtained with getInstance shortcut: public class MyApplication extends Application < Configuration > { @Override public void run ( TestConfiguration configuration , Environment environment ) throws Exception { InjectorLookup . getInstance ( this , SomeService . class ). get (). doSomething (); } } Injector could also be referenced by Environment object: InjectorLookup . getInstance ( environment , SomeService . class ). get (). doSomething (); Tip Most likely, requirement for injector instance means integration with some third party library. Consider writing custom installer in such cases (it will eliminate need for injector instance). Inside guice context you can simply inject Injector instance: @Inject Injector injector ; Injector stage \u00b6 By default injector is created at PRODICTION stage, which means that all registered singletons are instantiated in time of injector creation. You can change stage at main bundle : GuiceBundle . builder () ... . build ( Stage . DEVELOPMENT ) Injector factory \u00b6 You can control guice injector creation through ru.vyarus.dropwizard.guice.injector.InjectorFactory . Default implementation is very simple: public class DefaultInjectorFactory implements InjectorFactory { @Override public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return Guice . createInjector ( stage , modules ); } } Injector creation customization may be required by some 3 rd party library. For example, netflix governator owns injector creation ( see example ). Custom injector factory could be registered in guice bundle builder: bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new CustomInjectorFactory ()) ...","title":"Injector"},{"location":"guide/guice/injector/#injector-instance","text":"","title":"Injector instance"},{"location":"guide/guice/injector/#restrictive-options","text":"Guicey is compatible with the following guice restrictive options: public class MyModule extends AbstractModule { @Override protected void configure () { binder (). disableCircularProxies (); binder (). requireExactBindingAnnotations (); binder (). requireExplicitBindings (); } }","title":"Restrictive options"},{"location":"guide/guice/injector/#access-injector","text":"In some cases it may be important to get injector instance outside of guice context. Warning Injector is created on dropwizard run phase. Attempt to obtain injector before it will lead to exception. Injector instance could be resolved with: GuiceBundle # getInjector () method on instance (exception thrown if not yet started) InjectorLookup . getInjector ( app ). get () static call using application instance (lookup returns Optional for null safety). If you need lazy injector reference, you can use InjectorProvider class ( Provider < Injector > ): Provider < Injector > provider = new InjectorProvider ( app ); // somewhere after run phase Injector injector = provider . get (); Bean instance may be obtained with getInstance shortcut: public class MyApplication extends Application < Configuration > { @Override public void run ( TestConfiguration configuration , Environment environment ) throws Exception { InjectorLookup . getInstance ( this , SomeService . class ). get (). doSomething (); } } Injector could also be referenced by Environment object: InjectorLookup . getInstance ( environment , SomeService . class ). get (). doSomething (); Tip Most likely, requirement for injector instance means integration with some third party library. Consider writing custom installer in such cases (it will eliminate need for injector instance). Inside guice context you can simply inject Injector instance: @Inject Injector injector ;","title":"Access injector"},{"location":"guide/guice/injector/#injector-stage","text":"By default injector is created at PRODICTION stage, which means that all registered singletons are instantiated in time of injector creation. You can change stage at main bundle : GuiceBundle . builder () ... . build ( Stage . DEVELOPMENT )","title":"Injector stage"},{"location":"guide/guice/injector/#injector-factory","text":"You can control guice injector creation through ru.vyarus.dropwizard.guice.injector.InjectorFactory . Default implementation is very simple: public class DefaultInjectorFactory implements InjectorFactory { @Override public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return Guice . createInjector ( stage , modules ); } } Injector creation customization may be required by some 3 rd party library. For example, netflix governator owns injector creation ( see example ). Custom injector factory could be registered in guice bundle builder: bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new CustomInjectorFactory ()) ...","title":"Injector factory"},{"location":"guide/guice/module-analysis/","text":"Modules analysis \u00b6 Before injector start, guicey parse registered modules with guice SPI in order to: Recognize extensions from bindings Remove disabled extensions bindings Remove bindings of disabled modules Tip Use guice report to see all available bindings Warning Only direct modules ( .modules() ) are analyzed! Overriding modules ( .modulesOverride() ) are ignored (intentionally). Then all not removed bindings are composed to special module (even when no bindings removed, this avoid duplicate modules parsing on injector creation). That means that injector factory receive not user registered modules, but synthetic (with pre-parsed bindings) module instead. Note The most time-consuming operation in analysis is modules parsing, which is actually performed in any case during guice injector creation. You can see this on statistics report : if you switch off analysis injector time will grow. Extensions recognition \u00b6 Guicey can recognize extensions in guice bindings (from configured guice modules). For example, public class MyModule extends AbstractModule { public void configure () { // right parts just for example bind ( MyResource . class ). to ( MyResourceImpl . class ); bind ( MyManaged . class ). toProvider ( MyManagedProvider . class ); } } Guicey will detect MyResource as jersey resource and MyManaged as managed extension. Tip Extensions annotated with @InvisibleForScanner are not recognized, like in classpath scanner . But note that annotated extensions should not be registered manually ! Because it will lead to default extension binding registration by guicey, which will most likely conflict with existing binding (as a workaround @LazyBinding annotation may be used). Alternatively, you can simply qualify bean and it would not be recognized as extension. This is completely equivalent to GuiceBundle . builder () . extensions ( MyResource . class , MyManaged . class ) Note Internally, the same installers are used for extensions recognition and installation. The only difference is that guicey would not create default bindings for such extensions (because bindings already exists). Restrictions \u00b6 Only direct bindings ( bind(..) ) and linked keys ( bind(..).to(..) ) are checked. Instances are not analyzed ( bind(Something.class).toInstance(new Extension()) ) because extensions supposed to be guice-managed (not strictly required, but will allow to avoid aop-related problems). But, still it is possible to declare not guice managed extension with instance mapping to extension class or provider. Generified ( bind(new TypeLiteral<MyResource<String>(){}) ) and qualified ( bind(MyResource.class).annotatedWith(Qualify.class) ) bindings are ignored (simply because it's not obvious what to do with them). Overriding modules are not checked as they supposed to be used for quick fixes and test mocking. Will be recognized // untargetted binding bind ( Extension . class ) // left side of the link bind ( Extension . class ). to ( Something . class ) // right side of the link bind ( Something . class ). to ( Extension . class ) // left side of instance or provider mapping bind ( Extension . class ). toInstance ( new Extension ()) bind ( Extension . class ). toProvider ( SomeProvider . class ) Will NOT be recognized // instances not analysed bind ( Something . class ). toInstance ( new Extension ()) // extension-recignizable type must be strictly declared bind ( Something . class ). toProvider ( ExtensionProvider . class ) // generified declaration bind ( new TypeLiteral < Extension < Somthing > (){}) // qualified declaration bind ( Extension . class ). annotatedWith ( Qualify . class ) Side note Qualified and generified cases are not supported because they imply that multiple instances of one class may be declared. This rise problems with direct manual declaration: for example, if user declare .extensions(Extension.class) and in module we have bind(Extension.class).annotatedWith(Qualify.class) how can we be sure if its the same declaration or not? Current implementation will not revognize qualified extension and automatically create direct binding ( bind(Extension.class) ). For sure someone will face generified or qualified extensions case, but it would be simplier to workaraund it in exact case, rather then trying to handle all posible cases in general, making everything more complex. Disabled extensions \u00b6 In order to disable extension , recognized from binding, guicey will simply remove this binding. If extension was a part of longer links chain then entire chain would be removed too! For example, bind ( One . class ). to ( Two . class ) bind ( Two . class ). to ( Extension . class ) When Extension disabled One-->Two link is also removed. Motivation: First of all, this avoid error cases when remaining chain part contains only abstract types (e.g. only interfaces remains) Removes possible incosistencies as long chains may appear due to some class overrides and so removing only top (overriding) class will just to \"before override\" state. Removed chains are visible on guice report . Transitive modules \u00b6 During bindings analysis guicey can see binding modules hierarchy (module A install module B which register binding C). Using this guicey can remove all bindings relative to exact module class - the result is the same as if such module was never registered. This is transitive modules disable implementation. Disabling analysis \u00b6 To completely switch off analysis use option: . option ( GuiceyOptions . AnalyzeModules , false ) Warning When analysis is disabled, extensions recognition and transitive modules disables will not work anymore! With disabled analysis injector factory will receive user provided modules directly (instead of pre-parsed synthetic module). Important Enabled analysis completely prevent situations when default binding, created by guciey, conflict with manual binding existing in module. In such case startup will fail. Before modules analysis it was only possible to solve such issue with @LazyBinding annotation. Reporting \u00b6 You can see analysis information under diagnostic report : ... \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms \u2502 \u251c\u2500\u2500 7 modules autowired \u2502 \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms \u2502 \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings ... \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms \u2502 \u251c\u2500\u2500 4 extensions installed \u2502 \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding ... \u251c\u2500\u2500 GUICE BINDINGS \u2502 \u2502 \u2502 \u2514\u2500\u2500 ModuleWithExtensions (r.v.d.g.d.s.module) \u2502 \u2514\u2500\u2500 extension ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) ... Here you can see that 5 user modules were analyzed out ot 7 overall modules. 2 avoided modules are GuiceBootstrapModule and some overriding module. Modules contains 8 elements : this includes not only bindings, but also type listeners, aop handlers, etc (all declarations). 1 extensions detected from 3 acceptable bindings - only 3 bindings were acceptable for analysis (not generified and not qualified bindings) and 1 extension was recognized. Recognition could also be seen under EXTENSIONS section: declared as: 2 manual, 1 scan, 1 binding (note that numbers show detections, but single extension may be detected in multiple sources). And, finally, configuration tree shows extension binding module . But it's always top-most registered module (binding could be actually declared in some transitive module)! Removed bindings \u00b6 If any bindings were removed, this would be also shown in report: ... \u251c\u2500\u2500 [11%] MODULES processed in 37.54 ms \u2502 \u251c\u2500\u2500 2 modules autowired \u2502 \u251c\u2500\u2500 4 elements found in 1 user modules in 32.43 ms \u2502 \u251c\u2500\u2500 2 extensions detected from 2 acceptable bindings \u2502 \u251c\u2500\u2500 3 elements removed \u2502 \u2514\u2500\u2500 1 inner modules removed (types) ... (removed links are also counted) Guice bindings report shows exact removed items: 2 MODULES with 2 bindings \u2502 \u2514\u2500\u2500 TransitiveModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 untargetted [@Prototype] Res1 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:15) *EXTENSION \u251c\u2500\u2500 untargetted [@Prototype] Res2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:16) *EXTENSION, REMOVED \u2514\u2500\u2500 Inner (r.v.d.g.d.r.g.s.TransitiveModule) *REMOVED Here entire module Inner and Res2 extension binding removed. Removed chains are shown as: BINDING CHAINS \u2514\u2500\u2500 Base --[linked]--> Ext --[linked]--> ExtImpl *CHAIN REMOVED","title":"Modules analysis"},{"location":"guide/guice/module-analysis/#modules-analysis","text":"Before injector start, guicey parse registered modules with guice SPI in order to: Recognize extensions from bindings Remove disabled extensions bindings Remove bindings of disabled modules Tip Use guice report to see all available bindings Warning Only direct modules ( .modules() ) are analyzed! Overriding modules ( .modulesOverride() ) are ignored (intentionally). Then all not removed bindings are composed to special module (even when no bindings removed, this avoid duplicate modules parsing on injector creation). That means that injector factory receive not user registered modules, but synthetic (with pre-parsed bindings) module instead. Note The most time-consuming operation in analysis is modules parsing, which is actually performed in any case during guice injector creation. You can see this on statistics report : if you switch off analysis injector time will grow.","title":"Modules analysis"},{"location":"guide/guice/module-analysis/#extensions-recognition","text":"Guicey can recognize extensions in guice bindings (from configured guice modules). For example, public class MyModule extends AbstractModule { public void configure () { // right parts just for example bind ( MyResource . class ). to ( MyResourceImpl . class ); bind ( MyManaged . class ). toProvider ( MyManagedProvider . class ); } } Guicey will detect MyResource as jersey resource and MyManaged as managed extension. Tip Extensions annotated with @InvisibleForScanner are not recognized, like in classpath scanner . But note that annotated extensions should not be registered manually ! Because it will lead to default extension binding registration by guicey, which will most likely conflict with existing binding (as a workaround @LazyBinding annotation may be used). Alternatively, you can simply qualify bean and it would not be recognized as extension. This is completely equivalent to GuiceBundle . builder () . extensions ( MyResource . class , MyManaged . class ) Note Internally, the same installers are used for extensions recognition and installation. The only difference is that guicey would not create default bindings for such extensions (because bindings already exists).","title":"Extensions recognition"},{"location":"guide/guice/module-analysis/#restrictions","text":"Only direct bindings ( bind(..) ) and linked keys ( bind(..).to(..) ) are checked. Instances are not analyzed ( bind(Something.class).toInstance(new Extension()) ) because extensions supposed to be guice-managed (not strictly required, but will allow to avoid aop-related problems). But, still it is possible to declare not guice managed extension with instance mapping to extension class or provider. Generified ( bind(new TypeLiteral<MyResource<String>(){}) ) and qualified ( bind(MyResource.class).annotatedWith(Qualify.class) ) bindings are ignored (simply because it's not obvious what to do with them). Overriding modules are not checked as they supposed to be used for quick fixes and test mocking. Will be recognized // untargetted binding bind ( Extension . class ) // left side of the link bind ( Extension . class ). to ( Something . class ) // right side of the link bind ( Something . class ). to ( Extension . class ) // left side of instance or provider mapping bind ( Extension . class ). toInstance ( new Extension ()) bind ( Extension . class ). toProvider ( SomeProvider . class ) Will NOT be recognized // instances not analysed bind ( Something . class ). toInstance ( new Extension ()) // extension-recignizable type must be strictly declared bind ( Something . class ). toProvider ( ExtensionProvider . class ) // generified declaration bind ( new TypeLiteral < Extension < Somthing > (){}) // qualified declaration bind ( Extension . class ). annotatedWith ( Qualify . class ) Side note Qualified and generified cases are not supported because they imply that multiple instances of one class may be declared. This rise problems with direct manual declaration: for example, if user declare .extensions(Extension.class) and in module we have bind(Extension.class).annotatedWith(Qualify.class) how can we be sure if its the same declaration or not? Current implementation will not revognize qualified extension and automatically create direct binding ( bind(Extension.class) ). For sure someone will face generified or qualified extensions case, but it would be simplier to workaraund it in exact case, rather then trying to handle all posible cases in general, making everything more complex.","title":"Restrictions"},{"location":"guide/guice/module-analysis/#disabled-extensions","text":"In order to disable extension , recognized from binding, guicey will simply remove this binding. If extension was a part of longer links chain then entire chain would be removed too! For example, bind ( One . class ). to ( Two . class ) bind ( Two . class ). to ( Extension . class ) When Extension disabled One-->Two link is also removed. Motivation: First of all, this avoid error cases when remaining chain part contains only abstract types (e.g. only interfaces remains) Removes possible incosistencies as long chains may appear due to some class overrides and so removing only top (overriding) class will just to \"before override\" state. Removed chains are visible on guice report .","title":"Disabled extensions"},{"location":"guide/guice/module-analysis/#transitive-modules","text":"During bindings analysis guicey can see binding modules hierarchy (module A install module B which register binding C). Using this guicey can remove all bindings relative to exact module class - the result is the same as if such module was never registered. This is transitive modules disable implementation.","title":"Transitive modules"},{"location":"guide/guice/module-analysis/#disabling-analysis","text":"To completely switch off analysis use option: . option ( GuiceyOptions . AnalyzeModules , false ) Warning When analysis is disabled, extensions recognition and transitive modules disables will not work anymore! With disabled analysis injector factory will receive user provided modules directly (instead of pre-parsed synthetic module). Important Enabled analysis completely prevent situations when default binding, created by guciey, conflict with manual binding existing in module. In such case startup will fail. Before modules analysis it was only possible to solve such issue with @LazyBinding annotation.","title":"Disabling analysis"},{"location":"guide/guice/module-analysis/#reporting","text":"You can see analysis information under diagnostic report : ... \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms \u2502 \u251c\u2500\u2500 7 modules autowired \u2502 \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms \u2502 \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings ... \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms \u2502 \u251c\u2500\u2500 4 extensions installed \u2502 \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding ... \u251c\u2500\u2500 GUICE BINDINGS \u2502 \u2502 \u2502 \u2514\u2500\u2500 ModuleWithExtensions (r.v.d.g.d.s.module) \u2502 \u2514\u2500\u2500 extension ModuleFeature (r.v.d.g.d.s.m.ModuleWithExtensions) ... Here you can see that 5 user modules were analyzed out ot 7 overall modules. 2 avoided modules are GuiceBootstrapModule and some overriding module. Modules contains 8 elements : this includes not only bindings, but also type listeners, aop handlers, etc (all declarations). 1 extensions detected from 3 acceptable bindings - only 3 bindings were acceptable for analysis (not generified and not qualified bindings) and 1 extension was recognized. Recognition could also be seen under EXTENSIONS section: declared as: 2 manual, 1 scan, 1 binding (note that numbers show detections, but single extension may be detected in multiple sources). And, finally, configuration tree shows extension binding module . But it's always top-most registered module (binding could be actually declared in some transitive module)!","title":"Reporting"},{"location":"guide/guice/module-analysis/#removed-bindings","text":"If any bindings were removed, this would be also shown in report: ... \u251c\u2500\u2500 [11%] MODULES processed in 37.54 ms \u2502 \u251c\u2500\u2500 2 modules autowired \u2502 \u251c\u2500\u2500 4 elements found in 1 user modules in 32.43 ms \u2502 \u251c\u2500\u2500 2 extensions detected from 2 acceptable bindings \u2502 \u251c\u2500\u2500 3 elements removed \u2502 \u2514\u2500\u2500 1 inner modules removed (types) ... (removed links are also counted) Guice bindings report shows exact removed items: 2 MODULES with 2 bindings \u2502 \u2514\u2500\u2500 TransitiveModule (r.v.d.g.d.r.g.support) \u251c\u2500\u2500 untargetted [@Prototype] Res1 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:15) *EXTENSION \u251c\u2500\u2500 untargetted [@Prototype] Res2 at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:16) *EXTENSION, REMOVED \u2514\u2500\u2500 Inner (r.v.d.g.d.r.g.s.TransitiveModule) *REMOVED Here entire module Inner and Res2 extension binding removed. Removed chains are shown as: BINDING CHAINS \u2514\u2500\u2500 Base --[linked]--> Ext --[linked]--> ExtImpl *CHAIN REMOVED","title":"Removed bindings"},{"location":"guide/guice/module-autowiring/","text":"Module autowiring \u00b6 Because guice modules are registered in dropwizard init section only Bootstrap instance is available. Often Environment and Configuration objects are also required. Autowiring interfaces \u00b6 Guicey can automatically inject environment objects into your module if it implements any of (or all of them): BootstrapAwareModule - access bootstrap instance EnvironmentAwareModule - access environment instance ConfigurationAwareModule - access configuration instance ConfigurationTreeAwareModule - access to configuration values by path OptionsAwareModule - access guicey options Reference object will be set to module just before injector creation, so you can use it inside your module logic ( configuration method). Warning Module autowiring will only work for modules directly set to modules() (of main bundle or any guicey bundle). public class MyModule implements EnvironmentAwareModule { private Environemnt environment ; @Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @Override protected void configure () { // use environment here } } Autowiring base class \u00b6 To avoid manually implementing interfaces (avoid boilerplate) you can use DropwizardAwareModule as base class which already implements all autowiring interfaces: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { bootstrap () // Bootstrap instance environment () // Environment instance configuration () // MyConfiguration instance appPackage () // application class package configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) annotatedConfiguration ( ann ) // annotaed configuration value by instance annotatedConfiguration ( Class ) // annotaed configuration value by annotation type options () // access guicey options sharedState ( Class ) // shared sctate access } } Options \u00b6 Options could be used in guice module to access guicey configurations: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { // empty when guicey servlet support is dasabled if ( options . < EnumSet > get ( GuiceyOptions . GuiceFilterRegistration ). isEmtpy ()) { // do nothing } else { // register servlet module } } } Or it could be some custom options usage. Tip If you are going to register module inside guicey bundle, you can simply resolve option value inside guicey bundle and pass it to module directly. Configuration access \u00b6 Tip If you are going to register module inside guicey bundle, you can simply resolve configuration object inside guicey bundle and pass it to module directly (bundle has absolutely the same configuration access methods) Unique feature config \u00b6 When working with re-usable modules, it could be handy to rely on unique configuration object: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { XFeatureConfig conf = configuration ( XFeatureConfig . class ); ... } } Note that this module doesn't known exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt ) it will be different unique config. Access by path \u00b6 When you are not sure that configuration is unique, you can rely on exact path definition: public class XFeatureModule extends DropwizardAwareModule < Configuration > { private String path ; public XFeatureModule ( String path ) { this . path = path ; } @Override protected void configure () { XFeatureConfig conf = configuration ( path ); ... } } Path is declared by module user, who knows required configuration location: GuiceBundle . builder () . modules ( new XFeatureModule ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... } Multiple configs \u00b6 In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { List < XFeatureConfig > confs = configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } It wil return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses too. So if there are XFeatureConfigExt declared somewhere it will also be returned. Custom configuration analysis \u00b6 In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = configurationTree (). findAllRootPathsFrom ( MyConfig . class ); List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, module search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ). See introspected configuration structure description Shared state \u00b6 Special shortcuts provided to simplify access to shared state (if required). public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { SharedConfigObject config = sharedStateOrFail ( SomeBundle . class , \"Bundle %s is not registered\" , SomeBundle . class . getSimpleName ()); } } Shared state supposed to be declared in bundles and if required state is not available in time of injector creation then required bundle was not registered for sure. Be careful with shared state as it is intended to be used only in rare cases when really complex integrations required.","title":"Module autowiring"},{"location":"guide/guice/module-autowiring/#module-autowiring","text":"Because guice modules are registered in dropwizard init section only Bootstrap instance is available. Often Environment and Configuration objects are also required.","title":"Module autowiring"},{"location":"guide/guice/module-autowiring/#autowiring-interfaces","text":"Guicey can automatically inject environment objects into your module if it implements any of (or all of them): BootstrapAwareModule - access bootstrap instance EnvironmentAwareModule - access environment instance ConfigurationAwareModule - access configuration instance ConfigurationTreeAwareModule - access to configuration values by path OptionsAwareModule - access guicey options Reference object will be set to module just before injector creation, so you can use it inside your module logic ( configuration method). Warning Module autowiring will only work for modules directly set to modules() (of main bundle or any guicey bundle). public class MyModule implements EnvironmentAwareModule { private Environemnt environment ; @Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @Override protected void configure () { // use environment here } }","title":"Autowiring interfaces"},{"location":"guide/guice/module-autowiring/#autowiring-base-class","text":"To avoid manually implementing interfaces (avoid boilerplate) you can use DropwizardAwareModule as base class which already implements all autowiring interfaces: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { bootstrap () // Bootstrap instance environment () // Environment instance configuration () // MyConfiguration instance appPackage () // application class package configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) annotatedConfiguration ( ann ) // annotaed configuration value by instance annotatedConfiguration ( Class ) // annotaed configuration value by annotation type options () // access guicey options sharedState ( Class ) // shared sctate access } }","title":"Autowiring base class"},{"location":"guide/guice/module-autowiring/#options","text":"Options could be used in guice module to access guicey configurations: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { // empty when guicey servlet support is dasabled if ( options . < EnumSet > get ( GuiceyOptions . GuiceFilterRegistration ). isEmtpy ()) { // do nothing } else { // register servlet module } } } Or it could be some custom options usage. Tip If you are going to register module inside guicey bundle, you can simply resolve option value inside guicey bundle and pass it to module directly.","title":"Options"},{"location":"guide/guice/module-autowiring/#configuration-access","text":"Tip If you are going to register module inside guicey bundle, you can simply resolve configuration object inside guicey bundle and pass it to module directly (bundle has absolutely the same configuration access methods)","title":"Configuration access"},{"location":"guide/guice/module-autowiring/#unique-feature-config","text":"When working with re-usable modules, it could be handy to rely on unique configuration object: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { XFeatureConfig conf = configuration ( XFeatureConfig . class ); ... } } Note that this module doesn't known exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt ) it will be different unique config.","title":"Unique feature config"},{"location":"guide/guice/module-autowiring/#access-by-path","text":"When you are not sure that configuration is unique, you can rely on exact path definition: public class XFeatureModule extends DropwizardAwareModule < Configuration > { private String path ; public XFeatureModule ( String path ) { this . path = path ; } @Override protected void configure () { XFeatureConfig conf = configuration ( path ); ... } } Path is declared by module user, who knows required configuration location: GuiceBundle . builder () . modules ( new XFeatureModule ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... }","title":"Access by path"},{"location":"guide/guice/module-autowiring/#multiple-configs","text":"In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { List < XFeatureConfig > confs = configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } It wil return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses too. So if there are XFeatureConfigExt declared somewhere it will also be returned.","title":"Multiple configs"},{"location":"guide/guice/module-autowiring/#custom-configuration-analysis","text":"In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = configurationTree (). findAllRootPathsFrom ( MyConfig . class ); List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, module search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ). See introspected configuration structure description","title":"Custom configuration analysis"},{"location":"guide/guice/module-autowiring/#shared-state","text":"Special shortcuts provided to simplify access to shared state (if required). public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { SharedConfigObject config = sharedStateOrFail ( SomeBundle . class , \"Bundle %s is not registered\" , SomeBundle . class . getSimpleName ()); } } Shared state supposed to be declared in bundles and if required state is not available in time of injector creation then required bundle was not registered for sure. Be careful with shared state as it is intended to be used only in rare cases when really complex integrations required.","title":"Shared state"},{"location":"guide/guice/override/","text":"Override guice bindings \u00b6 Guice natively support bindings override with Modules.override() api. This is mostly useful in tests, when some bindings could be overridden with mocks. But it could also be used in real application in order to \"workaround\" some 3 rd party module behaviour. Guicey provides special support for overridings registration. You need 2 modules: one with original binding and another with binding override. For example, suppose you want to replace ServiceX binding from: public class MyModule extends AbstractModule { @Override protected void configure () { bind ( ServiceX . class ). to ( ServiceXImpl . class ); } } Generally have few options: If it implements an interface, implement your own service and bind as bind ( ServiceX . class ). to ( MyServiceXImpl . class ) If service is a class, you can modify its behaviour with extended class bind ( ServiceX . class ). to ( MyServiceXExt . class ) Or you can simply register some mock instance bind ( ServiceX . class ). toInstance ( myMockInstance ) Here assume that ServiceX is interface, so simply register different implementation: public class MyOverridingModule extends AbstractModule { @Override protected void configure () { bind ( ServiceX . class ). to ( CustomServiceXImpl . class ); } } Now register overriding: GuiceBundle . builder () . modules ( new MyModule ()) . modulesOverride ( new MyOverridingModule ()) . build () And everywhere in code @Inject ServiceX service ; will receive CustomServiceXImpl (instead of ServiceXImpl ) Tip Sometimes it may be simpler to disable existing module and register new module with modified bindings instead of overrides (for example with a hooks ) Note Overriding module could contain additional bindings - they would be also available in the resulted injector. (binding from overriding module either overrides existing binding or simply added as new binding)","title":"Override bindings"},{"location":"guide/guice/override/#override-guice-bindings","text":"Guice natively support bindings override with Modules.override() api. This is mostly useful in tests, when some bindings could be overridden with mocks. But it could also be used in real application in order to \"workaround\" some 3 rd party module behaviour. Guicey provides special support for overridings registration. You need 2 modules: one with original binding and another with binding override. For example, suppose you want to replace ServiceX binding from: public class MyModule extends AbstractModule { @Override protected void configure () { bind ( ServiceX . class ). to ( ServiceXImpl . class ); } } Generally have few options: If it implements an interface, implement your own service and bind as bind ( ServiceX . class ). to ( MyServiceXImpl . class ) If service is a class, you can modify its behaviour with extended class bind ( ServiceX . class ). to ( MyServiceXExt . class ) Or you can simply register some mock instance bind ( ServiceX . class ). toInstance ( myMockInstance ) Here assume that ServiceX is interface, so simply register different implementation: public class MyOverridingModule extends AbstractModule { @Override protected void configure () { bind ( ServiceX . class ). to ( CustomServiceXImpl . class ); } } Now register overriding: GuiceBundle . builder () . modules ( new MyModule ()) . modulesOverride ( new MyOverridingModule ()) . build () And everywhere in code @Inject ServiceX service ; will receive CustomServiceXImpl (instead of ServiceXImpl ) Tip Sometimes it may be simpler to disable existing module and register new module with modified bindings instead of overrides (for example with a hooks ) Note Overriding module could contain additional bindings - they would be also available in the resulted injector. (binding from overriding module either overrides existing binding or simply added as new binding)","title":"Override guice bindings"},{"location":"guide/guice/scopes/","text":"Scopes \u00b6 Reminder By default, all guice beans are created in prototype scope . Guicey only force singleton scope for jersey extensions ( resources and extensions )) Available scopes: @Singleton - single instance per context @RequestScoped - object per request (if guice filter support is not disabled ) @Prototype - prototype scope annotation (useful to override forced singleton scope for jersey services) Session scope ( @SessionScoped ) is usually useless, because sessions are not enabled by default in dropwizard (but it is possible to enable them). Tip Scopes of registered beans could be checked in guice report Prototype \u00b6 Normally, prototype scope (new instance on each new injection) is the default - no need to explicitly specify it. The only possible usage is overriding default forced singleton scope for jersey extensions. For example, resource declared like this: @Path ( \"/my\" ) public class MyResource {} Will be singleton. Prototype scope must be explicitly declared (if required): @Path ( \"/my\" ) @Prototype public class MyResource {} Note @Prototype scope annotation support is registered by guicey Singleton \u00b6 Both com.google.inject.Singleton and javax.inject.Singleton annotations could be used. Tip Prefer declaring @Singleton scope on all beans, except cases when different scope is required. Request \u00b6 By default, GuiceFilter is registered for both application and admin contexts. And so request (and session) scopes will be available in both contexts. @RequestScoped public class MyRequestScopedBean { ... } In order to access request scoped beans in other beans you'll need to use provider: Provider < MyRequestScopedBean > myBeanProvider ; Some jersey objects are already bound in request scope Context request and response objects are also available through request scope: Provider < HttpServletRequest > requestProvider Provider < HttpServletResponse > responseProvider Request scope transition \u00b6 This is guice feature, it is just mentioned here. Guice could access request scoped bindings only in current thread. If you need to access request scoped binding in different thread, you need to transfer request scope into that thread: @Singleton public class RequestBean { // provider will not work in other thread because of request scope @Inject Provider < UriInfo > uri ; public void doSomethingInRequestScope () { // jersey object must be resolved inside hk request scope (to store it in guice request scope) // so guice could see its instance later in another thread uri . get (); // wrap logic that require request scope Callable < String > action = ServletScopes . transferRequest (() -> { // access request scoped binding in different thread return uri . get (). getQueryParameters (). getFirst ( \"q\" ); }); CompletableFuture . runAsync (() -> { try { // execute action in different thread action . call (); } catch ( Exception e ) { e . printStackTrace (); } }); } } Warning Pay attention that for jersey scope objects provider must be called first in the current thread ! Guice would be able to propagate to another thread only objects already present in guice request scope. Without it, provider.get() , called under different thread would be delegated to jersey, which is not aware of this thread and so fail to provide its request scope object. Such additional call is not required for pure guice-managed request scope objects. Request scope simulation \u00b6 Sometimes, request scoped beans may need to be used somewhere without request (for example, inside scheduled job). Of course, this is not correct situation, and the best way is to re-design services, but not always possible. As a workaround, request scope could be simulated: @Inject Provider < RScopedService > service ; ... final RequestScoper scope = ServletScopes . scopeRequest ( Collections . emptyMap ()); try ( final RequestScoper . CloseableScope ignored = scope . open ()) { // work with request-scoped bean service . get (). doSomething (); } Eager singleton \u00b6 By default, guicey create injector in PRODUCTION stage, so all registered singletons will be instantiated immediately. But if you rely on guice JIT (instantiation by injection) it may defer bean creation (until it will be requested first time). To always start beans (even in DEVELOPMENT stage) guice provide eager singleton option: bind(MyService.class).asEagerSingleton() . For cases when you don't want to manually declare bean, but require it to start with guice context you can either implement Managed or mark bean as @EagerSingleton (the latter will simply bind annotated bean as guice eager singleton instead of you).","title":"Scopes"},{"location":"guide/guice/scopes/#scopes","text":"Reminder By default, all guice beans are created in prototype scope . Guicey only force singleton scope for jersey extensions ( resources and extensions )) Available scopes: @Singleton - single instance per context @RequestScoped - object per request (if guice filter support is not disabled ) @Prototype - prototype scope annotation (useful to override forced singleton scope for jersey services) Session scope ( @SessionScoped ) is usually useless, because sessions are not enabled by default in dropwizard (but it is possible to enable them). Tip Scopes of registered beans could be checked in guice report","title":"Scopes"},{"location":"guide/guice/scopes/#prototype","text":"Normally, prototype scope (new instance on each new injection) is the default - no need to explicitly specify it. The only possible usage is overriding default forced singleton scope for jersey extensions. For example, resource declared like this: @Path ( \"/my\" ) public class MyResource {} Will be singleton. Prototype scope must be explicitly declared (if required): @Path ( \"/my\" ) @Prototype public class MyResource {} Note @Prototype scope annotation support is registered by guicey","title":"Prototype"},{"location":"guide/guice/scopes/#singleton","text":"Both com.google.inject.Singleton and javax.inject.Singleton annotations could be used. Tip Prefer declaring @Singleton scope on all beans, except cases when different scope is required.","title":"Singleton"},{"location":"guide/guice/scopes/#request","text":"By default, GuiceFilter is registered for both application and admin contexts. And so request (and session) scopes will be available in both contexts. @RequestScoped public class MyRequestScopedBean { ... } In order to access request scoped beans in other beans you'll need to use provider: Provider < MyRequestScopedBean > myBeanProvider ; Some jersey objects are already bound in request scope Context request and response objects are also available through request scope: Provider < HttpServletRequest > requestProvider Provider < HttpServletResponse > responseProvider","title":"Request"},{"location":"guide/guice/scopes/#request-scope-transition","text":"This is guice feature, it is just mentioned here. Guice could access request scoped bindings only in current thread. If you need to access request scoped binding in different thread, you need to transfer request scope into that thread: @Singleton public class RequestBean { // provider will not work in other thread because of request scope @Inject Provider < UriInfo > uri ; public void doSomethingInRequestScope () { // jersey object must be resolved inside hk request scope (to store it in guice request scope) // so guice could see its instance later in another thread uri . get (); // wrap logic that require request scope Callable < String > action = ServletScopes . transferRequest (() -> { // access request scoped binding in different thread return uri . get (). getQueryParameters (). getFirst ( \"q\" ); }); CompletableFuture . runAsync (() -> { try { // execute action in different thread action . call (); } catch ( Exception e ) { e . printStackTrace (); } }); } } Warning Pay attention that for jersey scope objects provider must be called first in the current thread ! Guice would be able to propagate to another thread only objects already present in guice request scope. Without it, provider.get() , called under different thread would be delegated to jersey, which is not aware of this thread and so fail to provide its request scope object. Such additional call is not required for pure guice-managed request scope objects.","title":"Request scope transition"},{"location":"guide/guice/scopes/#request-scope-simulation","text":"Sometimes, request scoped beans may need to be used somewhere without request (for example, inside scheduled job). Of course, this is not correct situation, and the best way is to re-design services, but not always possible. As a workaround, request scope could be simulated: @Inject Provider < RScopedService > service ; ... final RequestScoper scope = ServletScopes . scopeRequest ( Collections . emptyMap ()); try ( final RequestScoper . CloseableScope ignored = scope . open ()) { // work with request-scoped bean service . get (). doSomething (); }","title":"Request scope simulation"},{"location":"guide/guice/scopes/#eager-singleton","text":"By default, guicey create injector in PRODUCTION stage, so all registered singletons will be instantiated immediately. But if you rely on guice JIT (instantiation by injection) it may defer bean creation (until it will be requested first time). To always start beans (even in DEVELOPMENT stage) guice provide eager singleton option: bind(MyService.class).asEagerSingleton() . For cases when you don't want to manually declare bean, but require it to start with guice context you can either implement Managed or mark bean as @EagerSingleton (the latter will simply bind annotated bean as guice eager singleton instead of you).","title":"Eager singleton"},{"location":"guide/guice/servletmodule/","text":"ServletModule \u00b6 By default, GuiceFilter is registered for both application and admin contexts: ServletModule can be used for filters and servlets declaration Request (and session) scope is available in both contexts Note Actually, the same GuiceFilter instance is used for both contexts. This way request scope works properly on both contexts, and registrations through ServeletModule are available both context. See web mappings report . Example of servlet and filter registration through guice module: public class WebModule extends ServletModule { @Override protected void configureServlets () { filter ( \"/*\" ). through ( MyFilter . class ); serve ( \"/myservlet\" ). with ( MyServlet . class ); } } GuiceBundle . builder () . modules ( new WebModule ()) . build () Warning Rest context is mapped to root by default. To change it use configuration file: server : rootPath : '/rest/*' Note With guice you can map servlets and filters using regexps Tip It may be more handy to use web extensions instead of direct registrations. For example, it is the only way to bind servlets in admin context. Limitations \u00b6 By default, GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types use option: . option ( GuiceyOptions . GuiceFilterRegistration , EnumSet . of ( REQUEST , FORWARD )) Warning Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register GuiceFilter for ASYNC type). Use web installers for such cases. Warning GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and there may be problems combining servlets from ServletModule and filters in main scope. Disable ServletModule support \u00b6 Danger Option is deprecated because request scope will become mandatory for the next guicey version (due to HK2 remove). If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support: GuiceBundle . builder () . noGuiceFilter () It will: Avoid registration of GuiceFilter in both contexts Remove request and session guice scopes support (because no ServletModule registered) Prevent installation of any ServletModule (error will be thrown indicating duplicate binding) HttpServletRequest and HttpServletResponse still may be injected in resources with Provider (but it will not be possible to use such injections in servlets, filters or any other place) Disabling saves about ~50ms of startup time.","title":"ServletModule"},{"location":"guide/guice/servletmodule/#servletmodule","text":"By default, GuiceFilter is registered for both application and admin contexts: ServletModule can be used for filters and servlets declaration Request (and session) scope is available in both contexts Note Actually, the same GuiceFilter instance is used for both contexts. This way request scope works properly on both contexts, and registrations through ServeletModule are available both context. See web mappings report . Example of servlet and filter registration through guice module: public class WebModule extends ServletModule { @Override protected void configureServlets () { filter ( \"/*\" ). through ( MyFilter . class ); serve ( \"/myservlet\" ). with ( MyServlet . class ); } } GuiceBundle . builder () . modules ( new WebModule ()) . build () Warning Rest context is mapped to root by default. To change it use configuration file: server : rootPath : '/rest/*' Note With guice you can map servlets and filters using regexps Tip It may be more handy to use web extensions instead of direct registrations. For example, it is the only way to bind servlets in admin context.","title":"ServletModule"},{"location":"guide/guice/servletmodule/#limitations","text":"By default, GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types use option: . option ( GuiceyOptions . GuiceFilterRegistration , EnumSet . of ( REQUEST , FORWARD )) Warning Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register GuiceFilter for ASYNC type). Use web installers for such cases. Warning GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and there may be problems combining servlets from ServletModule and filters in main scope.","title":"Limitations"},{"location":"guide/guice/servletmodule/#disable-servletmodule-support","text":"Danger Option is deprecated because request scope will become mandatory for the next guicey version (due to HK2 remove). If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support: GuiceBundle . builder () . noGuiceFilter () It will: Avoid registration of GuiceFilter in both contexts Remove request and session guice scopes support (because no ServletModule registered) Prevent installation of any ServletModule (error will be thrown indicating duplicate binding) HttpServletRequest and HttpServletResponse still may be injected in resources with Provider (but it will not be possible to use such injections in servlets, filters or any other place) Disabling saves about ~50ms of startup time.","title":"Disable ServletModule support"},{"location":"guide/test/general/","text":"General test tools \u00b6 Test framework-agnostic tools. Useful when: There are no extensions for your test framework Assertions must be performed after test app shutdown (or before startup) Commands testing Test utils: TestSupport - root utilities class, providing easy access to other helpers DropwizardTestSupport - dropwizard native support for full integration tests GuiceyTestSupport - guice context-only integration tests (without starting web part) CommandTestSupport - general commands tests ClientSupport - web client helper (useful for calling application urls) Important TestSupport assumed to be used as a universal shortcut: everything could be created/executed through it so just type TestSupport. and look available methods - no need to remember other classes . Application run \u00b6 Application could be started in 2 ways: Core - create only guice injector (without starting web services) - ideal for business logic testing (pretty fast) Web - full application start to test web endpoints (and complete flows) The second case is handled by DropwizardTestSupport and the first one by GuiceyTestSupport object (which is an extension for DropwizardTestSupport ). There is a generic builder to simplify work with these objects (provides all possible options for configuring these objects): RunResult result = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) // run lightweight application (without web services) . runCore () Tip RunResult contains both DropwizardTestSupport used for execution and Injector instance. In other words, everything required for performing assertions. or with action: Object serviceValue = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) // run full application . runWeb ( injector -> { return injector . getInstance ( FooService . class ). getSomething (); }) Note Builder methods are almost equal to junit 5 extension builder Important All run methods declared as throws Exception . This was done to bypass original exceptions instead of wrapping them inside runtime exceptions. This should not be a problem: just add throws Exception into test method signature Configuration \u00b6 Configuration could be applied in a different ways: // with override values only TestSupport . build ( App . class ) . configOverride ( \"foo: 12\" ) // file with overrides TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/config.yml\" ) . configOverride ( \"foo: 12\" ) // direct config object MyConfig config = new MyConfig (); TestSupport . build ( App . class ) . config ( config ) Also, configuration source provider could be modified: TestSupport . build ( App . class ) . config ( \"path/in/classpath/config.yml\" ) . configSourceProvider ( new ResourceConfigurationSourceProvider ()) There are also configuration shortcuts: TestSupport . build ( App . class ) . randomPorts () . restMapping ( \"api\" ) To randomize used application ports (overrides config file values) and apply a different rest mapping path. When config overrides are used, they are always stored as system properties. This could be a problem for parallel tests execution. To overcome this, test-unique prefixes could be used: TestSupport . build ( App . class ) . configOverride ( \"foo\" , \"1\" ) . propertyPrefix ( \"something\" ) Junit 5 extensions use test class (and sometimes method) name to generate unique prefixes. Lifecycle listeners \u00b6 Builder also support listeners registration in order to simulate setup/cleanup lifecycle methods, common for test frameworks: TestSupport . build ( App . class ) . listen ( new TestSupportBuilder . TestListener <> () { public void setup ( final DropwizardTestSupport < C > support ) throws Exception { // do before test } ... }) . runCore (); All listener methods are default so only required methods could be overridden. Warning Builder could be used for support objects creation ( buildCore() , buildWeb() ) - in this case listeners could not be used (only builder runner could properly process listeners). Shortcuts \u00b6 For simple cases, there are many builder shortcuts in TestSupport class. Support object construction: DropTestSupport support = TestSupport . webApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); GuiceyTestSupport support = TestSupport . coreApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); Run: RunResult result = TestSupport . runWebApp ( App . class ); RunResult result = TestSupport . runWebApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); Object value = TestSupport . runWebApp ( App . class , injector - > { return injector . getInstance ( Service . class ). getSmth (); }); Object value = TestSupport . runWebApp ( App . class , \"path/to/config.yml\" , injector - > { return injector . getInstance ( Service . class ). getSmth (); }, \"prop: 1\" , \"prop2: 2\" ); // ... and same methods for \"coreApp\" All these methods are builder shortcuts (suitable for simple cases). I will use the builder call below, but it is equivalent to these shortcut methods (they just appeared before builder and were preserved for compatibility). Tip Context DropwizardTestSupport and ClientSupport objects could be statically referenced inside callback: TestSupport . runWebApp ( App . class , injector - > { DropwizardTestSupport support = TestSupport . getContext (); ClientSupport client = TestSupport . getContextClient (); return null ; }); Asserting execution \u00b6 To assert configuration or any guicey bean it would be enough to use run without callback: RunResult < CfgType > result = TestSupport . build ( App . class ). runCore (); // direct configuratio instance Assertions . assertEquals ( 12 , result . getConfiguration (). getProp1 ()); // any guice bean Assertions . assertEquals ( 12 , result . getBean ( Configuration . class ). getProp1 ()); Assertions . assertNotNull ( result . getEnvironment ()); Assertions . assertNotNull ( result . getApplication ()); Web-related assertions could be done inside callback: SomeRsponseObject res = TestSupport . build ( App . class ). runWeb ( injecor -> { ClientSupport client = TestSupport . getContextClient () return client . get ( \"some\" , SomeRsponseObject . class ); }); Assertions . assertEquals ( \"something\" , res . getField1 ()) Or multiple assertions could be done directly inside callback. Raw test support objects \u00b6 It may be required to use DropwizardTestSuppor objects directly: for example, when before() and after() calls must be performed in different methods (some test framework integration). Objects could be created with builder: GuiceyTestSupport core = TestSupport . build ( App . class ) . buildCore (); DropwizardTestSupport web = TestSupport . build ( App . class ) . buildWeb (); Note GuiceyTestSupport extends DropwizardTestSupport , so in both cases DropwizardTestSupport could be used as type. There are also shortcut methods: DropwizardTestSupport supportCore = TestSupport . coreApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); DropwizardTestSupport supportWeb = TestSupport . webApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); Support object usage: support . before () // test support . after () This is equivalent to: TestSupport . run ( support , injector -> { // test }); Other helper methods for support object (executed while the support object is active): TestSupport.getInjector(support) - obtain application injector TestSupport.getBean(support, Key/Class) - get guice bean TestSupport.injectBeans(support, target) - inject annotated object fields TestSupport.webClient(support) - construct ClientSupport object Support object provides references for dropwizard objects: support . getEnvironment (); support . getConfiguration (); support . getApplication (); Complete example using junit: public class RawTest { static DropwizardTestSupport support ; @Inject MyService service ; @BeforeAll public static void setup () { support = TestSupport . coreApp ( App . class ); // support = TestSupport.webApp(App.class); // start app support . before (); } @BeforeEach public void before () { // inject services in test TestSupport . injectBeans ( support , this ); } @AfterAll public static void cleanup () { if ( support != null ) { support . after (); } } @Test public void test () { Assertions . assertEquals ( \"10\" , service . computeValue ()); } } Note support.before() would automatically call after() in case of startup error Client \u00b6 ClientSupport is a JerseyClient aware of dropwizard configuration, so you can easily call admin/main/rest urls. Creation: ClientSupport client = TestSupport . webClient ( support ); where support is DropwizardTestSupport or GuiceyTestSupport (in later case it could be used only as generic client for calling external urls). Example usage: // GET {rest path}/some client . targetRest ( \"some\" ). request (). buildGet (). invoke () // GET {main context path}/servlet client . targetMain ( \"servlet\" ). request (). buildGet (). invoke () // GET {admin context path}/adminServlet client . targetAdmin ( \"adminServlet\" ). request (). buildGet (). invoke () // General external url call client . target ( \"https://google.com\" ). request (). buildGet (). invoke () Tip All methods above accepts any number of strings which would be automatically combined into correct path: client . targetRest ( \"some\" , \"other/\" , \"/part\" ) would be correctly combined as \"/some/other/part/\" As you can see, test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct. Response res = client . targetRest ( \"some\" ). request (). buildGet (). invoke () Assertions . assertEquals ( 200 , res . getStatus ()) Assertions . assertEquals ( \"response text\" , res . readEntity ( String )) Also, if you want to use other client, client object can simply provide required info: client . getPort () // app port (8080) client . getAdminPort () // app admin port (8081) client . basePathRoot () // root server path (http://localhost:8080/) client . basePathMain () // main context path (http://localhost:8080/) client . basePathAdmin () // admin context path (http://localhost:8081/) client . basePathRest () // rest context path (http://localhost:8080/) Simple REST methods \u00b6 The client also contains simplified GET/POST/PUT/DELETE methods for path, relative to server root (everything after port): @Test public void testWeb ( ClientSupport client ) { // get with result Result res = client . get ( \"rest/sample\" , Result . class ); // post without result (void) client . post ( \"rest/action\" , new PostObject (), null ); // post with result Result res = client . post ( \"rest/action\" , new PostObject (), Result . class ); } All methods: Methods accept paths relative to server root. In the example above: \"http://localhost:8080/rest/sample\" Could return mapped response. For void calls, use null instead of the result type. In this case, only 200 and 204 (no content) responses would be considered successful POST and PUT also accept (body) object to send. But methods does not allow multipart execution. Tip These methods could be used as examples for jersey client usage. Customization \u00b6 JerseyClient used in ClientSupport could be customized now using TestClientFactory implementation. Simple factory example: public class SimpleTestClientFactory implements TestClientFactory { @Override public JerseyClient create ( final DropwizardTestSupport <?> support ) { return new JerseyClientBuilder () . register ( new JacksonFeature ( support . getEnvironment (). getObjectMapper ())) . property ( ClientProperties . CONNECT_TIMEOUT , 1000 ) . property ( ClientProperties . READ_TIMEOUT , 5000 ) . property ( HttpUrlConnectorProvider . SET_METHOD_WORKAROUND , true ) . build (); } } Tip See DefaultTestClientFactory implementation (it's a bit more complex) Custom factory could be specified directly in test annotation (junit 5, spock 2): @TestDropwizardApp ( value = MyApp . class , clientFactory = CustomTestClientFactory . class ) All other builders also support client factory as an optional parameter. Default client \u00b6 JerseyClient used inside ClientSupport is created by DefaultTestClientFactory . Default implementation: Enables multipart feature if dropwizard-forms is in classpath (so the client could be used for sending multipart data). Enables request and response logging to simplify writing (and debugging) tests. By default, all request and response messages are written directly into console to guarantee client actions visibility (logging might not be configured in tests). Example output: [Client action]---------------------------------------------{ 1 * Sending client request on thread main 1 > GET http://localhost:8080/sample/get }---------------------------------------------------------- [Client action]---------------------------------------------{ 1 * Client response received on thread main 1 < 200 1 < Content-Length: 13 1 < Content-Type: application/json 1 < Date: Mon, 27 Nov 2023 10:00:40 GMT 1 < Vary: Accept-Encoding {\"foo\":\"get\"} }---------------------------------------------------------- Console output might be disabled with a system proprty: // shortcut sets DefaultTestClientFactory.USE_LOGGER property DefaultTestClientFactory . disableConsoleLog () With it, everything would be logged into ClientSupport logger (java.util) under INFO (most likely, would be invisible in the most logger configurations, but could be enabled). To reset property (and get logs back into console) use: DefaultTestClientFactory . enableConsoleLog () Note Static methods added not directly into ClientSupport because this is the default client factory feature. You might use a completely different factory. Capture console output \u00b6 There is now a utility to capture console output: String out = TestSupport . captureOutput (() -> { // run application inside TestSupport . runWebApp ( App . class , injector -> { ClientSupport client = TestSupport . getContextClient (); // call application api endpoint client . get ( \"sample/get\" , null ); return null ; }); }); // uses assert4j, test that client was called (just an example) Assertions . assertThat ( out ) . contains ( \"[Client action]---------------------------------------------{\" ); Returned output contains both System.out and System.err - same as it would be seen in console. All output is also printed into console to simplify visual validation Warning Such tests could not be run in parallel (due to system io overrides) Test commands \u00b6 CommandTestSupport object is a commands test utility equivalent to DropwizardTestSupport . It uses dropwizard Cli for arguments recognition and command selection. The main difference with DropwizardTestSupport is that command execution is a short-lived process and all assertions are possible only after the execution. That's why command runner would include in the result all possible dropwizard objects, created during execution (because it would be impossible to reference them after execution). New builder (almost the same as application execution builder) simplify commands execution: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); This runner could be used to run any command type (simple, configured, environment). The type of command would define what objects would be present ofter the command execution (for example, Injector would be available only for EnvironmentCommand ). Important Such run never fails with an exception: any appeared exception would be stored inside the response: Assertions . assertFalse ( result . isSuccessful ()); Assertions . assertEquals ( \"Error message\" , result . getException (). getMessage ()); IO \u00b6 Runner use System.in/err/out replacement. All output is intercepted and could be asserted: Assertions . assertTrue ( result . getOutput (). contains ( \"some text\" )) result.getOutput() contains both out and err streams together (the same way as user would see it in console). Error output is also available separately with result.getErrorOutput() . Note All output is always printed to console, so you could always see it after test execution (without additional actions) Commands requiring user input could also be tested (with mocked input): CommandResult result = TestSupport . buildCommandRunner ( App . class ) . consoleInputs ( \"1\" , \"two\" , \"something else\" ) . run ( \"quiz\" ) At least, the required number of answers must be provided (otherwise error would be thrown, indicating not enough inputs) Warning Due to IO overrides, command tests could not run in parallel. For junit 5, such tests could be annotated with @Isolated (to prevent execution in parallel with other tests) Configuration \u00b6 Configuration options are the same as in run builder. For example: // override only TestSupport . buildCommandRunner ( App . class ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // file with overrides TestSupport . buildCommandRunner ( App . class ) . config ( \"src/test/resources/path/to/config.yml\" ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // direct config object MyConfig config = new MyConfig (); TestSupport . buildCommandRunner ( App . class ) . config ( config ) . run ( \"cfg\" ); Note Config file should not be specified in command itself - builder would add it, if required. But still, it would not be a mistake to use config file directly in command: TestSupport . buildCommandRunner ( App . class ) // note .config(\"...\") was not used (otherwise two files would appear)! . run ( \"cfg\" , \"path/to/config.yml\" ); Using builder for config file configuration assumed to be a preferred way. Listener \u00b6 There is a simple listener support (like in application run builder) for setup-cleanup actions: TestSupport . buildCommandRunner ( App . class ) . listen ( new CommandRunBuilder . CommandListener <> () { public void setup ( String [] args ) { ... } public void cleanup ( CommandResult < TestConfiguration > result ) { ... } }) . run ( \"cmd\" ) Test application startup fail \u00b6 Command runner could also be used for application startup fail tests: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"server\" ) or with the shortcut: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Note In case of application successful start, special check would immediately stop it by throwing exception (resulting object would contain it), so such test would never freeze. No additional mocks or extensions required because running like this would not cause System.exist(1) call, performed in Application class (see Application.onFatalError ).","title":"General support"},{"location":"guide/test/general/#general-test-tools","text":"Test framework-agnostic tools. Useful when: There are no extensions for your test framework Assertions must be performed after test app shutdown (or before startup) Commands testing Test utils: TestSupport - root utilities class, providing easy access to other helpers DropwizardTestSupport - dropwizard native support for full integration tests GuiceyTestSupport - guice context-only integration tests (without starting web part) CommandTestSupport - general commands tests ClientSupport - web client helper (useful for calling application urls) Important TestSupport assumed to be used as a universal shortcut: everything could be created/executed through it so just type TestSupport. and look available methods - no need to remember other classes .","title":"General test tools"},{"location":"guide/test/general/#application-run","text":"Application could be started in 2 ways: Core - create only guice injector (without starting web services) - ideal for business logic testing (pretty fast) Web - full application start to test web endpoints (and complete flows) The second case is handled by DropwizardTestSupport and the first one by GuiceyTestSupport object (which is an extension for DropwizardTestSupport ). There is a generic builder to simplify work with these objects (provides all possible options for configuring these objects): RunResult result = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) // run lightweight application (without web services) . runCore () Tip RunResult contains both DropwizardTestSupport used for execution and Injector instance. In other words, everything required for performing assertions. or with action: Object serviceValue = TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/test/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . hooks ( new MyHook ()) // run full application . runWeb ( injector -> { return injector . getInstance ( FooService . class ). getSomething (); }) Note Builder methods are almost equal to junit 5 extension builder Important All run methods declared as throws Exception . This was done to bypass original exceptions instead of wrapping them inside runtime exceptions. This should not be a problem: just add throws Exception into test method signature","title":"Application run"},{"location":"guide/test/general/#configuration","text":"Configuration could be applied in a different ways: // with override values only TestSupport . build ( App . class ) . configOverride ( \"foo: 12\" ) // file with overrides TestSupport . build ( App . class ) . config ( \"src/test/resources/path/to/config.yml\" ) . configOverride ( \"foo: 12\" ) // direct config object MyConfig config = new MyConfig (); TestSupport . build ( App . class ) . config ( config ) Also, configuration source provider could be modified: TestSupport . build ( App . class ) . config ( \"path/in/classpath/config.yml\" ) . configSourceProvider ( new ResourceConfigurationSourceProvider ()) There are also configuration shortcuts: TestSupport . build ( App . class ) . randomPorts () . restMapping ( \"api\" ) To randomize used application ports (overrides config file values) and apply a different rest mapping path. When config overrides are used, they are always stored as system properties. This could be a problem for parallel tests execution. To overcome this, test-unique prefixes could be used: TestSupport . build ( App . class ) . configOverride ( \"foo\" , \"1\" ) . propertyPrefix ( \"something\" ) Junit 5 extensions use test class (and sometimes method) name to generate unique prefixes.","title":"Configuration"},{"location":"guide/test/general/#lifecycle-listeners","text":"Builder also support listeners registration in order to simulate setup/cleanup lifecycle methods, common for test frameworks: TestSupport . build ( App . class ) . listen ( new TestSupportBuilder . TestListener <> () { public void setup ( final DropwizardTestSupport < C > support ) throws Exception { // do before test } ... }) . runCore (); All listener methods are default so only required methods could be overridden. Warning Builder could be used for support objects creation ( buildCore() , buildWeb() ) - in this case listeners could not be used (only builder runner could properly process listeners).","title":"Lifecycle listeners"},{"location":"guide/test/general/#shortcuts","text":"For simple cases, there are many builder shortcuts in TestSupport class. Support object construction: DropTestSupport support = TestSupport . webApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); GuiceyTestSupport support = TestSupport . coreApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); Run: RunResult result = TestSupport . runWebApp ( App . class ); RunResult result = TestSupport . runWebApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); Object value = TestSupport . runWebApp ( App . class , injector - > { return injector . getInstance ( Service . class ). getSmth (); }); Object value = TestSupport . runWebApp ( App . class , \"path/to/config.yml\" , injector - > { return injector . getInstance ( Service . class ). getSmth (); }, \"prop: 1\" , \"prop2: 2\" ); // ... and same methods for \"coreApp\" All these methods are builder shortcuts (suitable for simple cases). I will use the builder call below, but it is equivalent to these shortcut methods (they just appeared before builder and were preserved for compatibility). Tip Context DropwizardTestSupport and ClientSupport objects could be statically referenced inside callback: TestSupport . runWebApp ( App . class , injector - > { DropwizardTestSupport support = TestSupport . getContext (); ClientSupport client = TestSupport . getContextClient (); return null ; });","title":"Shortcuts"},{"location":"guide/test/general/#asserting-execution","text":"To assert configuration or any guicey bean it would be enough to use run without callback: RunResult < CfgType > result = TestSupport . build ( App . class ). runCore (); // direct configuratio instance Assertions . assertEquals ( 12 , result . getConfiguration (). getProp1 ()); // any guice bean Assertions . assertEquals ( 12 , result . getBean ( Configuration . class ). getProp1 ()); Assertions . assertNotNull ( result . getEnvironment ()); Assertions . assertNotNull ( result . getApplication ()); Web-related assertions could be done inside callback: SomeRsponseObject res = TestSupport . build ( App . class ). runWeb ( injecor -> { ClientSupport client = TestSupport . getContextClient () return client . get ( \"some\" , SomeRsponseObject . class ); }); Assertions . assertEquals ( \"something\" , res . getField1 ()) Or multiple assertions could be done directly inside callback.","title":"Asserting execution"},{"location":"guide/test/general/#raw-test-support-objects","text":"It may be required to use DropwizardTestSuppor objects directly: for example, when before() and after() calls must be performed in different methods (some test framework integration). Objects could be created with builder: GuiceyTestSupport core = TestSupport . build ( App . class ) . buildCore (); DropwizardTestSupport web = TestSupport . build ( App . class ) . buildWeb (); Note GuiceyTestSupport extends DropwizardTestSupport , so in both cases DropwizardTestSupport could be used as type. There are also shortcut methods: DropwizardTestSupport supportCore = TestSupport . coreApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); DropwizardTestSupport supportWeb = TestSupport . webApp ( App . class , \"path/to/config.yml\" , \"prop: 1\" , \"prop2: 2\" ); Support object usage: support . before () // test support . after () This is equivalent to: TestSupport . run ( support , injector -> { // test }); Other helper methods for support object (executed while the support object is active): TestSupport.getInjector(support) - obtain application injector TestSupport.getBean(support, Key/Class) - get guice bean TestSupport.injectBeans(support, target) - inject annotated object fields TestSupport.webClient(support) - construct ClientSupport object Support object provides references for dropwizard objects: support . getEnvironment (); support . getConfiguration (); support . getApplication (); Complete example using junit: public class RawTest { static DropwizardTestSupport support ; @Inject MyService service ; @BeforeAll public static void setup () { support = TestSupport . coreApp ( App . class ); // support = TestSupport.webApp(App.class); // start app support . before (); } @BeforeEach public void before () { // inject services in test TestSupport . injectBeans ( support , this ); } @AfterAll public static void cleanup () { if ( support != null ) { support . after (); } } @Test public void test () { Assertions . assertEquals ( \"10\" , service . computeValue ()); } } Note support.before() would automatically call after() in case of startup error","title":"Raw test support objects"},{"location":"guide/test/general/#client","text":"ClientSupport is a JerseyClient aware of dropwizard configuration, so you can easily call admin/main/rest urls. Creation: ClientSupport client = TestSupport . webClient ( support ); where support is DropwizardTestSupport or GuiceyTestSupport (in later case it could be used only as generic client for calling external urls). Example usage: // GET {rest path}/some client . targetRest ( \"some\" ). request (). buildGet (). invoke () // GET {main context path}/servlet client . targetMain ( \"servlet\" ). request (). buildGet (). invoke () // GET {admin context path}/adminServlet client . targetAdmin ( \"adminServlet\" ). request (). buildGet (). invoke () // General external url call client . target ( \"https://google.com\" ). request (). buildGet (). invoke () Tip All methods above accepts any number of strings which would be automatically combined into correct path: client . targetRest ( \"some\" , \"other/\" , \"/part\" ) would be correctly combined as \"/some/other/part/\" As you can see, test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct. Response res = client . targetRest ( \"some\" ). request (). buildGet (). invoke () Assertions . assertEquals ( 200 , res . getStatus ()) Assertions . assertEquals ( \"response text\" , res . readEntity ( String )) Also, if you want to use other client, client object can simply provide required info: client . getPort () // app port (8080) client . getAdminPort () // app admin port (8081) client . basePathRoot () // root server path (http://localhost:8080/) client . basePathMain () // main context path (http://localhost:8080/) client . basePathAdmin () // admin context path (http://localhost:8081/) client . basePathRest () // rest context path (http://localhost:8080/)","title":"Client"},{"location":"guide/test/general/#simple-rest-methods","text":"The client also contains simplified GET/POST/PUT/DELETE methods for path, relative to server root (everything after port): @Test public void testWeb ( ClientSupport client ) { // get with result Result res = client . get ( \"rest/sample\" , Result . class ); // post without result (void) client . post ( \"rest/action\" , new PostObject (), null ); // post with result Result res = client . post ( \"rest/action\" , new PostObject (), Result . class ); } All methods: Methods accept paths relative to server root. In the example above: \"http://localhost:8080/rest/sample\" Could return mapped response. For void calls, use null instead of the result type. In this case, only 200 and 204 (no content) responses would be considered successful POST and PUT also accept (body) object to send. But methods does not allow multipart execution. Tip These methods could be used as examples for jersey client usage.","title":"Simple REST methods"},{"location":"guide/test/general/#customization","text":"JerseyClient used in ClientSupport could be customized now using TestClientFactory implementation. Simple factory example: public class SimpleTestClientFactory implements TestClientFactory { @Override public JerseyClient create ( final DropwizardTestSupport <?> support ) { return new JerseyClientBuilder () . register ( new JacksonFeature ( support . getEnvironment (). getObjectMapper ())) . property ( ClientProperties . CONNECT_TIMEOUT , 1000 ) . property ( ClientProperties . READ_TIMEOUT , 5000 ) . property ( HttpUrlConnectorProvider . SET_METHOD_WORKAROUND , true ) . build (); } } Tip See DefaultTestClientFactory implementation (it's a bit more complex) Custom factory could be specified directly in test annotation (junit 5, spock 2): @TestDropwizardApp ( value = MyApp . class , clientFactory = CustomTestClientFactory . class ) All other builders also support client factory as an optional parameter.","title":"Customization"},{"location":"guide/test/general/#default-client","text":"JerseyClient used inside ClientSupport is created by DefaultTestClientFactory . Default implementation: Enables multipart feature if dropwizard-forms is in classpath (so the client could be used for sending multipart data). Enables request and response logging to simplify writing (and debugging) tests. By default, all request and response messages are written directly into console to guarantee client actions visibility (logging might not be configured in tests). Example output: [Client action]---------------------------------------------{ 1 * Sending client request on thread main 1 > GET http://localhost:8080/sample/get }---------------------------------------------------------- [Client action]---------------------------------------------{ 1 * Client response received on thread main 1 < 200 1 < Content-Length: 13 1 < Content-Type: application/json 1 < Date: Mon, 27 Nov 2023 10:00:40 GMT 1 < Vary: Accept-Encoding {\"foo\":\"get\"} }---------------------------------------------------------- Console output might be disabled with a system proprty: // shortcut sets DefaultTestClientFactory.USE_LOGGER property DefaultTestClientFactory . disableConsoleLog () With it, everything would be logged into ClientSupport logger (java.util) under INFO (most likely, would be invisible in the most logger configurations, but could be enabled). To reset property (and get logs back into console) use: DefaultTestClientFactory . enableConsoleLog () Note Static methods added not directly into ClientSupport because this is the default client factory feature. You might use a completely different factory.","title":"Default client"},{"location":"guide/test/general/#capture-console-output","text":"There is now a utility to capture console output: String out = TestSupport . captureOutput (() -> { // run application inside TestSupport . runWebApp ( App . class , injector -> { ClientSupport client = TestSupport . getContextClient (); // call application api endpoint client . get ( \"sample/get\" , null ); return null ; }); }); // uses assert4j, test that client was called (just an example) Assertions . assertThat ( out ) . contains ( \"[Client action]---------------------------------------------{\" ); Returned output contains both System.out and System.err - same as it would be seen in console. All output is also printed into console to simplify visual validation Warning Such tests could not be run in parallel (due to system io overrides)","title":"Capture console output"},{"location":"guide/test/general/#test-commands","text":"CommandTestSupport object is a commands test utility equivalent to DropwizardTestSupport . It uses dropwizard Cli for arguments recognition and command selection. The main difference with DropwizardTestSupport is that command execution is a short-lived process and all assertions are possible only after the execution. That's why command runner would include in the result all possible dropwizard objects, created during execution (because it would be impossible to reference them after execution). New builder (almost the same as application execution builder) simplify commands execution: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); This runner could be used to run any command type (simple, configured, environment). The type of command would define what objects would be present ofter the command execution (for example, Injector would be available only for EnvironmentCommand ). Important Such run never fails with an exception: any appeared exception would be stored inside the response: Assertions . assertFalse ( result . isSuccessful ()); Assertions . assertEquals ( \"Error message\" , result . getException (). getMessage ());","title":"Test commands"},{"location":"guide/test/general/#io","text":"Runner use System.in/err/out replacement. All output is intercepted and could be asserted: Assertions . assertTrue ( result . getOutput (). contains ( \"some text\" )) result.getOutput() contains both out and err streams together (the same way as user would see it in console). Error output is also available separately with result.getErrorOutput() . Note All output is always printed to console, so you could always see it after test execution (without additional actions) Commands requiring user input could also be tested (with mocked input): CommandResult result = TestSupport . buildCommandRunner ( App . class ) . consoleInputs ( \"1\" , \"two\" , \"something else\" ) . run ( \"quiz\" ) At least, the required number of answers must be provided (otherwise error would be thrown, indicating not enough inputs) Warning Due to IO overrides, command tests could not run in parallel. For junit 5, such tests could be annotated with @Isolated (to prevent execution in parallel with other tests)","title":"IO"},{"location":"guide/test/general/#configuration_1","text":"Configuration options are the same as in run builder. For example: // override only TestSupport . buildCommandRunner ( App . class ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // file with overrides TestSupport . buildCommandRunner ( App . class ) . config ( \"src/test/resources/path/to/config.yml\" ) . configOverride ( \"foo: 12\" ) . run ( \"cfg\" ); // direct config object MyConfig config = new MyConfig (); TestSupport . buildCommandRunner ( App . class ) . config ( config ) . run ( \"cfg\" ); Note Config file should not be specified in command itself - builder would add it, if required. But still, it would not be a mistake to use config file directly in command: TestSupport . buildCommandRunner ( App . class ) // note .config(\"...\") was not used (otherwise two files would appear)! . run ( \"cfg\" , \"path/to/config.yml\" ); Using builder for config file configuration assumed to be a preferred way.","title":"Configuration"},{"location":"guide/test/general/#listener","text":"There is a simple listener support (like in application run builder) for setup-cleanup actions: TestSupport . buildCommandRunner ( App . class ) . listen ( new CommandRunBuilder . CommandListener <> () { public void setup ( String [] args ) { ... } public void cleanup ( CommandResult < TestConfiguration > result ) { ... } }) . run ( \"cmd\" )","title":"Listener"},{"location":"guide/test/general/#test-application-startup-fail","text":"Command runner could also be used for application startup fail tests: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"server\" ) or with the shortcut: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Note In case of application successful start, special check would immediately stop it by throwing exception (resulting object would contain it), so such test would never freeze. No additional mocks or extensions required because running like this would not cause System.exist(1) call, performed in Application class (see Application.onFatalError ).","title":"Test application startup fail"},{"location":"guide/test/junit4/","text":"Junit 4 \u00b6 Warning Since guicey 5.5 junit 4 support was extracted from guicey to external module : Package remains the same to simplify migration (only additional dependency would be required) Deprecation marks removed from rules to reduce warnings. DEPRECATED because dropwizard deprecated its junit4 rules. Consider migration to JUnit 5 Setup \u00b6 Required dependencies (assuming BOM used for versions management): testImplementation 'ru.vyarus.guicey:guicey-test-junit4' With Junit 5 \u00b6 OR you can use it with junit 5 vintage engine: testImplementation 'ru.vyarus.guicey:guicey-test-junit4' testImplementation 'org.junit.jupiter:junit-jupiter-api' testRuntimeOnly 'org.junit.jupiter:junit-jupiter' testRuntimeOnly 'org.junit.vintage:junit-vintage-engine' This way all existing junit 4 tests would work and new tests could use junit 5 extensions. Rules \u00b6 Provided rules: GuiceyAppRule - lightweight integration tests (guice only) GuiceyHooksRule - test-specific application modifications StartupErrorRule - helper for testing failed application startup Testing core logic \u00b6 For integration testing of guice specific logic you can use GuiceyAppRule . It works almost like DropwizardAppRule , but doesn't start jetty (and so jersey and guice web modules will not be initialized). Managed and lifecycle objects supported. public class MyTest { @Rule GuiceyAppRule < MyConfiguration > RULE = new GuiceyAppRule <> ( MyApplication . class , \"path/to/configuration.yaml\" ); public void testSomething () { RULE . getBean ( MyService . class ). doSomething (); ... } } As with dropwizard rule, configuration is optional new GuiceyAppRule <> ( MyApplication . class , null ) Testing web logic \u00b6 For web component tests (servlets, filters, resources) use DropwizardAppRule . To access guice beans use injector lookup: InjectorLookup . getInstance ( RULE . getApplication (), MyService . class ). get (); Customizing guicey configuration \u00b6 Guicey provides a way to modify its configuration in tests. You can apply configuration hook using rule: // there may be exact class instead of lambda new GuiceyHooksRule (( builder ) -> builder . modules (...)) To use it with DropwizardAppRule or GuiceyAppRule you will have to apply explicit order: static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( new GuiceyHooksRule (( builder ) -> builder . modules (...))) . around ( RULE ); Attention RuleChain is required because rules execution order is not guaranteed and configuration rule must obviously be executed before application rule. If you need to declare configurations common for all tests then declare rule instance in base test class and use it in chain (at each test): public class BaseTest { // IMPORTANT no @ClassRule annotation here! static GuiceyHooksRule BASE = new GuiceyHooksRule (( builder ) -> builder . modules (...)) } public class SomeTest extends BaseTest { static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( BASE ) // optional test-specific staff . around ( new GuiceyHooksRule (( builder ) -> builder . modules (...)) . around ( RULE ); } Warning Don't use configuration rule with spock because it will not work. Use special spock extension instead. Access guice beans \u00b6 When using DropwizardAppRule the only way to obtain guice managed beans is through: InjectorLookup . getInjector ( RULE . getApplication ()). getBean ( MyService . class ); Also, the following trick may be used to inject test fields: public class MyTest { @ClassRule static DropwizardAppRule < TestConfiguration > RULE = ... @Inject MyService service ; @Inject MyOtherService otherService ; @Before public void setUp () { InjectorLookup . get ( RULE . getApplication ()). get (). injectMemebers ( this ) } } Testing startup errors \u00b6 If exception occur on startup dropwizard will call System . exit ( 1 ) instead of throwing exception (as it was before 1.1.0). System exit could be intercepted with system rules . Note If you are going to move to junit 5 soon then better use system stubs library. It is a successor of system rules and provides both junit 4 and 5 extensions. Special rule provided to simplify work with system rules: StartupErrorRule . It's a combination of exit and out/err outputs interception rules. public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } This test will pass only if application will throw exception during startup. In junit it is impossible to apply checks after exit statement, so such checks must be registered as a special callback: public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (( out , err ) -> { Assert . assertTrue ( out . contains ( \"some log line\" )); Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } Note that err will contain full exception stack trace and so you can check exception type too by using contains statement like above. Check callback(s) may be added after rule creation: @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () throws Exception { RULE . checkAfterExit (( out , err ) -> { Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); ... } Multiple check callbacks may be registered (even if the first one was registered in rule's create call). Rule works a bit differently with spock 1 . Migrating to JUnit 5 \u00b6 Instead of GuiceyAppRule use @TestGuiceyApp extension. Instead of DropwizardAppRule use @TestDropwizardApp extension. GuiceyHooksRule can be substituted with hooks declaration in extensions or as test fields Instead of StartupErrorRule use system-stubs - the successor of system rules In essence: Use annotations instead of rules (and forget about RuleChain difficulties) Test fields injection will work out of the box, so no need for additional hacks JUnit 5 propose parameter injection , which may be not common at first, but it's actually very handy Also, there is a pre-configured http client suitable for calling test application urls (or any other general url).","title":"Junit 4"},{"location":"guide/test/junit4/#junit-4","text":"Warning Since guicey 5.5 junit 4 support was extracted from guicey to external module : Package remains the same to simplify migration (only additional dependency would be required) Deprecation marks removed from rules to reduce warnings. DEPRECATED because dropwizard deprecated its junit4 rules. Consider migration to JUnit 5","title":"Junit 4"},{"location":"guide/test/junit4/#setup","text":"Required dependencies (assuming BOM used for versions management): testImplementation 'ru.vyarus.guicey:guicey-test-junit4'","title":"Setup"},{"location":"guide/test/junit4/#with-junit-5","text":"OR you can use it with junit 5 vintage engine: testImplementation 'ru.vyarus.guicey:guicey-test-junit4' testImplementation 'org.junit.jupiter:junit-jupiter-api' testRuntimeOnly 'org.junit.jupiter:junit-jupiter' testRuntimeOnly 'org.junit.vintage:junit-vintage-engine' This way all existing junit 4 tests would work and new tests could use junit 5 extensions.","title":"With Junit 5"},{"location":"guide/test/junit4/#rules","text":"Provided rules: GuiceyAppRule - lightweight integration tests (guice only) GuiceyHooksRule - test-specific application modifications StartupErrorRule - helper for testing failed application startup","title":"Rules"},{"location":"guide/test/junit4/#testing-core-logic","text":"For integration testing of guice specific logic you can use GuiceyAppRule . It works almost like DropwizardAppRule , but doesn't start jetty (and so jersey and guice web modules will not be initialized). Managed and lifecycle objects supported. public class MyTest { @Rule GuiceyAppRule < MyConfiguration > RULE = new GuiceyAppRule <> ( MyApplication . class , \"path/to/configuration.yaml\" ); public void testSomething () { RULE . getBean ( MyService . class ). doSomething (); ... } } As with dropwizard rule, configuration is optional new GuiceyAppRule <> ( MyApplication . class , null )","title":"Testing core logic"},{"location":"guide/test/junit4/#testing-web-logic","text":"For web component tests (servlets, filters, resources) use DropwizardAppRule . To access guice beans use injector lookup: InjectorLookup . getInstance ( RULE . getApplication (), MyService . class ). get ();","title":"Testing web logic"},{"location":"guide/test/junit4/#customizing-guicey-configuration","text":"Guicey provides a way to modify its configuration in tests. You can apply configuration hook using rule: // there may be exact class instead of lambda new GuiceyHooksRule (( builder ) -> builder . modules (...)) To use it with DropwizardAppRule or GuiceyAppRule you will have to apply explicit order: static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( new GuiceyHooksRule (( builder ) -> builder . modules (...))) . around ( RULE ); Attention RuleChain is required because rules execution order is not guaranteed and configuration rule must obviously be executed before application rule. If you need to declare configurations common for all tests then declare rule instance in base test class and use it in chain (at each test): public class BaseTest { // IMPORTANT no @ClassRule annotation here! static GuiceyHooksRule BASE = new GuiceyHooksRule (( builder ) -> builder . modules (...)) } public class SomeTest extends BaseTest { static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( BASE ) // optional test-specific staff . around ( new GuiceyHooksRule (( builder ) -> builder . modules (...)) . around ( RULE ); } Warning Don't use configuration rule with spock because it will not work. Use special spock extension instead.","title":"Customizing guicey configuration"},{"location":"guide/test/junit4/#access-guice-beans","text":"When using DropwizardAppRule the only way to obtain guice managed beans is through: InjectorLookup . getInjector ( RULE . getApplication ()). getBean ( MyService . class ); Also, the following trick may be used to inject test fields: public class MyTest { @ClassRule static DropwizardAppRule < TestConfiguration > RULE = ... @Inject MyService service ; @Inject MyOtherService otherService ; @Before public void setUp () { InjectorLookup . get ( RULE . getApplication ()). get (). injectMemebers ( this ) } }","title":"Access guice beans"},{"location":"guide/test/junit4/#testing-startup-errors","text":"If exception occur on startup dropwizard will call System . exit ( 1 ) instead of throwing exception (as it was before 1.1.0). System exit could be intercepted with system rules . Note If you are going to move to junit 5 soon then better use system stubs library. It is a successor of system rules and provides both junit 4 and 5 extensions. Special rule provided to simplify work with system rules: StartupErrorRule . It's a combination of exit and out/err outputs interception rules. public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } This test will pass only if application will throw exception during startup. In junit it is impossible to apply checks after exit statement, so such checks must be registered as a special callback: public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (( out , err ) -> { Assert . assertTrue ( out . contains ( \"some log line\" )); Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } Note that err will contain full exception stack trace and so you can check exception type too by using contains statement like above. Check callback(s) may be added after rule creation: @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () throws Exception { RULE . checkAfterExit (( out , err ) -> { Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); ... } Multiple check callbacks may be registered (even if the first one was registered in rule's create call). Rule works a bit differently with spock 1 .","title":"Testing startup errors"},{"location":"guide/test/junit4/#migrating-to-junit-5","text":"Instead of GuiceyAppRule use @TestGuiceyApp extension. Instead of DropwizardAppRule use @TestDropwizardApp extension. GuiceyHooksRule can be substituted with hooks declaration in extensions or as test fields Instead of StartupErrorRule use system-stubs - the successor of system rules In essence: Use annotations instead of rules (and forget about RuleChain difficulties) Test fields injection will work out of the box, so no need for additional hacks JUnit 5 propose parameter injection , which may be not common at first, but it's actually very handy Also, there is a pre-configured http client suitable for calling test application urls (or any other general url).","title":"Migrating to JUnit 5"},{"location":"guide/test/junit5/","text":"JUnit 5 \u00b6 Migration from JUnit 4 Junit 5 user guide Setup \u00b6 You will need the following dependencies (assuming BOM used for versions management): testImplementation 'io.dropwizard:dropwizard-testing' testImplementation 'org.junit.jupiter:junit-jupiter-api' testRuntimeOnly 'org.junit.jupiter:junit-jupiter' Tip If you already have junit4 or spock tests, you can activate vintage engine so all tests could work together with junit 5: testRuntimeOnly 'org.junit.vintage:junit-vintage-engine' Note In gradle you need to explicitly activate junit 5 support with test { useJUnitPlatform () ... } Warning Junit 5 annotations are different from junit4, so if you have both junit 5 and junit 4 make sure correct classes (annotations) used for junit 5 tests: import org.junit.jupiter.api.Assertions ; import org.junit.jupiter.api.Test ; Dropwizard extensions compatibility \u00b6 Guicey extensions could be used together with dropwizard extensions . This may be required only in edge cases when multiple applications startup is required. For example: // run app (injector only) @TestGuiceyApp ( App . class ) // activate dropwizard extensions @ExtendWith ( DropwizardExtensionsSupport . class ) public class ClientSupportGuiceyTest { // Use dropwizard extension to start a separate server // It might be the same application or different // (application instances would be different in any case) static DropwizardAppExtension app = new DropwizardAppExtension ( App . class ); @Test void testLimitedClient ( ClientSupport client ) { Assertions . assertEquals ( 200 , client . target ( \"http://localhost:8080/dummy/\" ) . request (). buildGet (). invoke (). getStatus ()); } } Info There is a difference in extensions implementation. Dropwizard extensions work as: junit extension @ExtendWith(DropwizardExtensionsSupport.class) looks for fields implementing DropwizardExtension (like DropwizardAppExtension ) and start/stop them according to test lifecycle. Guicey extensions implemented as separate junit extensions (and only hook fields are manually searched). Also, guciey extensions implement junit parameters injection (for test and lifecycle methods). Extensions \u00b6 @TestGuiceyApp - for lightweight tests (without starting web part, only guice context) @TestDropwizardApp - for complete integration tests For most tests @TestGuiceyApp assumed to be used as it only starts guice injector (which is much faster than complete application startup). Such tests are ideal for testing business logic (services). @TestDropwizardApp (full integration test) used only to check web endpoints and full workflow (assuming all business logic was already tested with lightweight tests) Both extensions allow using injections directly in test fields. Extensions could be used under junit parallel execution (no side effects). Alternative declaration might be used for deferred configuration or starting application for each test method . Pre-configured http client might be used for calling test application endpoints (or external). Test environment might be prepared with setup objects and application might be re-configured with hooks Testing core logic \u00b6 @TestGuiceyApp runs all guice logic without starting jetty (so resources, servlets and filters will not be available). Managed objects will still be handled correctly. @TestGuiceyApp ( MyApplication . class ) public class AutoScanModeTest { @Inject MyService service ; @Test public void testMyService () { Assertions . assertEquals ( \"hello\" , service . getSmth ()); } Also, injections work as method parameters: @TestGuiceyApp ( MyApplication . class ) public class AutoScanModeTest { public void testMyService ( MyService service ) { Assertions . assertEquals ( \"hello\" , service . getSmth ()); } Application started before all tests in annotated class and stopped after them. Testing web logic \u00b6 @TestDropwizardApp is useful for complete integration testing (when web part is required): @TestDropwizardApp ( MyApplication . class ) class WebModuleTest { @Inject MyService service @Test public void checkWebBindings ( ClientSupport client ) { Assertions . assertEquals ( \"Sample filter and service called\" , client . targetMain ( \"servlet\" ). request (). buildGet (). invoke (). readEntity ( String . class )); Assertions . assertTrur ( service . isCalled ()); Random ports \u00b6 In order to start application on random port you can use configuration shortcut: @TestDropwizardApp ( value = MyApplication . class , randomPorts = true ) Note Random ports setting override exact ports in configuration: @TestDropwizardApp ( value = MyApplication , config = 'path/to/my/config.yml' , randomPorts = true ) Also, random ports support both server types (default and simple) Real ports could be resolved with ClientSupport object. Rest mapping \u00b6 Normally, rest mapping configured with server.rootMapping=/something/* configuration, but if you don't use custom configuration class, but still want to re-map rest, shortcut could be used: @TestDropwizardApp ( value = MyApplication . class , restMapping = \"something\" ) In contrast to config declaration, attribute value may not start with '/' and end with '/*' - it would be appended automatically. This option is only intended to simplify cases when custom configuration file is not yet used in tests (usually early PoC phase). It allows you to map servlet into application root in test (because rest is no more resides in root). When used with existing configuration file, this parameter will override file definition. Guice injections \u00b6 Any guice bean could be injected directly into the test field: @Inject SomeBean bean This will work even for not declared (in guice modules) beans (JIT injection will occur). To better understand injection scopes look the following test: // one application instance started for all test methods @TestGuiceyApp ( AutoScanApplication . class ) @TestMethodOrder ( MethodOrderer . OrderAnnotation . class ) public class InjectionScopeTest { // new instance injected on each test @Inject TestBean bean ; // the same context used for all tests (in class), so the same bean instance inserted before each test @Inject TestSingletonBean singletonBean ; @Test @Order ( 1 ) public void testInjection () { bean . value = 5 ; singletonBean . value = 15 ; Assertions . assertEquals ( 5 , bean . value ); Assertions . assertEquals ( 15 , singletonBean . value ); } @Test @Order ( 2 ) public void testSharedState () { Assertions . assertEquals ( 0 , bean . value ); Assertions . assertEquals ( 15 , singletonBean . value ); } // bean is in prototype scope public static class TestBean { int value ; } @Singleton public static class TestSingletonBean { int value ; } } Note Guice AOP will not work on test methods (because test instances are not created by guice). Parameter injection \u00b6 Any declared guice bean may be injected as test method parameter: @Test public void testSomthing ( DummyBean bean ) (where DummyBean is manually declared in some module or requested as a dependency (JIT-instantiated) during injector creation). For unknown beans injection (not declared and not used during startup) special annotation must be used: @Test public void testSomthing ( @Jit TestBean bean ) Info Additional annotation required because you may use other junit extensions providing their own parameters, which guicey extension should not try to handle. That's why not annotated parameters verified with existing injector bindings. Qualified and generified injections will also work: @Test public void testSomthing ( @Named ( \"qual\" ) SomeBean bean , TestBean < String > generifiedBean , Provider < OtherBean > provider ) Also, there are special objects available as parameters: Application or exact application class ( MyApplication ) ObjectMapper ClientSupport application web client helper DropwizardTestSupport test support object used internally Note Parameter injection will work on test methods as well as lifecyle methods (beforeAll, afterEach etc.) Example: @TestDropwizardApp ( AutoScanApplication . class ) public class ParametersInjectionDwTest { public ParametersInjectionDwTest ( Environment env , DummyService service ) { Preconditions . checkNotNull ( env ); Preconditions . checkNotNull ( service ); } @BeforeAll static void before ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @BeforeEach void setUp ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @AfterEach void tearDown ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @AfterAll static void after ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @Test void checkAllPossibleParams ( Application app , AutoScanApplication app2 , Configuration conf , TestConfiguration conf2 , Environment env , ObjectMapper mapper , Injector injector , ClientSupport client , DropwizardTestSupport support , DummyService service , @Jit JitService jit ) { assertNotNull ( app ); assertNotNull ( app2 ); assertNotNull ( conf ); assertNotNull ( conf2 ); assertNotNull ( env ); assertNotNull ( mapper ); assertNotNull ( injector ); assertNotNull ( client ); assertNotNull ( support ); assertNotNull ( service ); assertNotNull ( jit ); assertEquals ( client . getPort (), 8080 ); assertEquals ( client . getAdminPort (), 8081 ); } public static class JitService { private final DummyService service ; @Inject public JitService ( DummyService service ) { this . service = service ; } } } Tip DropwizardTestSupport and ClientSupport objects are also available with a static calls (in the same thread): DropwizardTestSupport support = TestSupport . getContext (); ClientSupport client = TestSupport . getContextClient (); Client \u00b6 Both extensions prepare special jersey client instance which could be used for web calls. It is mostly useful for complete web tests to call rest services and servlets. @Test void checkRandomPorts ( ClientSupport client ) { Assertions . assertNotEquals ( 8080 , client . getPort ()); Assertions . assertNotEquals ( 8081 , client . getAdminPort ()); } Client object provides: Access to JerseyClient object (for raw calls) Shortcuts for querying main, admin or rest contexts (it will count the current configuration automatically) Shortcuts for base main, admin or rest contexts base urls (and application ports) Example usages: // GET {rest path}/some client . targetRest ( \"some\" ). request (). buildGet (). invoke () // GET {main context path}/servlet client . targetMain ( \"servlet\" ). request (). buildGet (). invoke () // GET {admin context path}/adminServlet client . targetAdmin ( \"adminServlet\" ). request (). buildGet (). invoke () Tip All methods above accepts any number of strings which would be automatically combined into correct path: client . targetRest ( \"some\" , \"other/\" , \"/part\" ) would be correctly combined as \"/some/other/part/\" As you can see test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct. Response res = client . targetRest ( \"some\" ). request (). buildGet (). invoke () Assertions . assertEquals ( 200 , res . getStatus ()) Assertions . assertEquals ( \"response text\" , res . readEntity ( String )) Also, if you want to use other client, client object can simply provide required info: client . getPort () // app port (8080) client . getAdminPort () // app admin port (8081) client . basePathMain () // main context path (http://localhost:8080/) client . basePathAdmin () // admin context path (http://localhost:8081/) client . basePathRest () // rest context path (http://localhost:8080/) Raw client usage: // call completely external url client . target ( \"http://somedomain:8080/dummy/\" ). request (). buildGet (). invoke () Warning Client object could be injected with both dropwizard and guicey extensions, but in case of guicey extension, only raw client could be used (because web part not started all other methods will throw NPE) Client factory \u00b6 Internal JerseyClient creation could be customized with TestClientFactory implementation. Default implementation ( DefaultTestClientFactory ) applies timeouts and auto-registers multipart support if dropwizard-forms module is available in classpath. Custom implementation could be specified directly in the test annotation: @TestDropwizardApp ( value = MyApp . class , clientFactory = CustomTestClientFactory . class ) Configuration \u00b6 For both extensions you can configure application with external configuration file: @TestGuiceyApp ( value = MyApplication . class , config = \"path/to/my/config.yml\" public class ConfigOverrideTest { Or just declare required values: @TestGuiceyApp ( value = MyApplication . class , configOverride = { \"foo: 2\" , \"bar: 12\" }) public class ConfigOverrideTest { (note that overriding declaration follows yaml format \"key: value\") Or use both at once (here overrides will override file values): @TestGuiceyApp ( value = MyApplication . class , config = ' path / to / my / config . yml ' , configOverride = { \"foo: 2\" , \"bar: 12\" }) class ConfigOverrideTest { Deferred configuration \u00b6 If you need to configure value, supplied by some other extension, or value may be resolved only after test start, then static overrides declaration is not an option. In this case use alternative extensions declaration which provides additional config override methods: @RegisterExtension @Order ( 1 ) static FooExtension ext = new FooExtension (); @RegisterExtension @Order ( 2 ) static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( AutoScanApplication . class ) . config ( \"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\" ) . configOverrides ( \"foo: 1\" ) . configOverride ( \"bar\" , () -> ext . getValue ()) . configOverrides ( new ConfigOverrideValue ( \"baa\" , () -> \"44\" )) . create (); In most cases configOverride(\"bar\", () -> ext.getValue()) would be enough to configure a supplier instead of static value. In more complex cases, you can use custom implementations of ConfigOverride . Guicey have to accept only ConfigOverride objects implementing custom ru.vyarus.dropwizard.guice.test.util.ConfigurablePrefix interface. In order to support parallel tests guicey generates unique config prefix for each test (because all overrides eventually stored to system properties) and so it needs a way to set this prefix into custom ConfigOverride objects. Configuration from 3 rd party extensions \u00b6 If you have junit extension (e.g. which starts db for test) and you need to apply configuration overrides from that extension, then you should simply store required values inside junit storage: public class ConfigExtension implements BeforeAllCallback { @Override public void beforeAll ( ExtensionContext context ) throws Exception { // do something and then store value context . getStore ( ExtensionContext . Namespace . GLOBAL ). put ( \"ext1\" , 10 ); } } And map overrides directly from store using configOverrideByExtension method: @ExtendWith ( ConfigExtension . class ) public class SampleTest { @RegisterExtension static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( App . class ) . configOverrideByExtension ( ExtensionContext . Namespace . GLOBAL , \"ext1\" ) . create (); } Here, value applied by extension under key ext1 would be applied to configuration ext1 path. If you need to use different configuration key: . configOverrideByExtension ( ExtensionContext . Namespace . GLOBAL , \"ext1\" , \"key\" ) Tip You can use setup objects instead of custom junit extensions for test environment setup Test environment setup \u00b6 It is often required to prepare test environment before starting dropwizard application. Normally, such cases require writing custom junit extensions. In order to simplify environment setup, guicey provides TestEnviromentSetup interface. Setup objects are called before application startup and could directly apply (through parameter) configuration overrides and hooks. For example, suppose you need to set up a database before test: public class TestDbSetup implements TestEnvironmentSetup { @Override public Object setup ( TestExtension extension ) { // pseudo code Db db = DbFactory . startTestDb (); // register required configuration extension . configOverride ( \"database.url\" , () -> db . getUrl ()) . configOverride ( \"database.user\" , () -> db . getUser ()) . configOverride ( \"database.password\" , () -> db . getPassword ); // assuming object implements Closable return db ; } } It is not required to return anything, only if something needs to be closed after application shutdown: objects other than Closable ( AutoClosable ) or org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource simply ignored. This approach (only one method) simplifies interface usage with lambdas. Setup object might be declared in extension annotation: @TestGuiceyApp ( value = App . class , setup = TestDbSetup . class ) Or in manual registration: @RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ) // as class . setup ( TestDbSetup . class ) // or as instance . setup ( new TestDbSetup ()) Or with lambda: . setup ( ext -> { Db db = new Db (); ext . configOverride ( \"db.url\" , () -> db . getUrl ()) return db ; }) Setup fields \u00b6 Alternatively, setup objects might be declared simply in test fields: @EnableSetup static TestEnvironmentSetup db = ext -> { Db db = new Db (); ext . configOverride ( \"db.url\" , () -> db . getUrl ()) return db ; }; or @EnableSetup static TestDbSetup db = new TestDbSetup () This could be extremely useful if you need to unify setup logic for multiple tests, but use different extension declarations in test. In this case simply move field declaration into base test class: public abstract class BaseTest { @EnableSetup static TestDbSetup db = new TestDbSetup (); } Note To avoid confusion with guicey hooks: setup object required to prepare test environment before test (and apply required configurations) whereas hooks is a general mechanism for application customization (not only in tests). Setup objects are executed before application startup (before DropwizardTestSupport object creation) and hooks are executed by started application. Application test modification \u00b6 You can use hooks to customize application . In both extensions annotation hooks could be declared with attribute: @TestDropwizardApp ( value = MyApplication . class , hooks = MyHook . class ) or @TestGuiceyApp ( value = MyApplication . class , hooks = MyHook . class ) Where MyHook is: public class MyHook implements GuiceyConfigurationHook {} Hook fields \u00b6 Alternatively, you can declare hook directly in test field: @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . modules ( new DebugModule ()); Any number of fields could be declared. The same way hook could be declared in base test class: public abstract class BaseTest { // hook in base class @EnableHook static GuiceyConfigurationHook BASE_HOOK = builder -> builder . modules ( new DebugModule ()); } @TestGuiceyApp ( value = App . class , hooks = SomeOtherHook . class ) public class SomeTest extends BaseTest { // Another hook @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . modules ( new DebugModule2 ()); } All 3 hooks will work. Extension configuration unification \u00b6 It is a common need to run multiple tests with the same test application configuration (same config overrides, same hooks etc.). Do not configure it in each test, instead move extension configuration into base test class: @TestGuiceyApp (...) public abstract class AbstractTest { // here might be helper methods } And now all test classes should simply extend it: public class Test1 extends AbstractTest { @Inject MyService service ; @Test public void testSomething () { ... } } If you use manual extension configuration (through field), just replace annotation in base class with manual declaration - approach would still work. Reuse application between tests \u00b6 In some cases it is preferable to start application just once and use for all tests (e.g. due to long startup or time-consuming environment preparation). In order to use the same application instance, extension declaration must be performed in base test class and reuseApplication flag must be enabled: @TestGuiceyApp ( value = Application . class , reuseApplication = true ) public abstract class BaseTest {} or public abstract class BaseTest { @RegisterExtension static TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ) . reuseApplication () . create (); } The same will work for dropwizard extension ( @TestDropwizardApp and TestDropwizardAppExtension ). Important Application instance re-use is not enabled by default for backwards compatibility (for cases when base class declaration already used). There might be multiple base test classes declaring reusable applications: different global applications would be started for each declaration (allowing you to group tests requiring different applications) Global application would be closed after all tests execution (with test engine shutdown). In essence, reusable application \"stick\" to declaration in base class, so all tests, extending base class \"inherit\" the same declaration and so the same application (when reuse enabled). Tip Reusable applications may be used together with tests, not extending base class and using guicey extensions. Such tests would simply start a new application instance. Just be sure to avoid port clashes when using reusable dropwizard apps (by using randomPorts option). @EnableSetup and @EnableHook fields are also supported for reusable applications. But declare all such fields on base class level (or below) because otherwise only fields declared on first started test would be used. Warning would be printed if such fields used (or ignored because reusable app was already started by different test). Parallel execution \u00b6 Junit parallel tests execution could be activated with properties file junit-platform.properties located at test resources root: junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent Note In order to avoid config overriding collisions (because all overrides eventually stored to system properties) guicey generates unique property prefixes in each test. To avoid port collisions in dropwizard tests use randomPorts option . Alternative declaration \u00b6 Both extensions could be declared in fields: @RegisterExtension static TestDropwizardAppExtension app = TestDropwizardAppExtension . forApp ( AutoScanApplication . class ) . config ( \"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . randomPorts () . hooks ( Hook . class ) . hooks ( builder -> builder . disableExtensions ( DummyManaged . class )) . create (); The only difference with annotations is that you can declare hooks and setup objects as lambdas directly (still hooks in static fields will also work). @RegisterExtension static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( AutoScanApplication . class ) ... This alternative declaration is intended to be used in cases when guicey extensions need to be aligned with other 3 rd party extensions: in junit you can order extensions declared with annotations (by annotation order) and extensions declared with @RegisterExtension (by declaration order). But there is no way to order extension registered with @RegisterExtension before annotation extension. So if you have 3 rd party extension which needs to be executed BEFORE guicey extensions, you can use field declaration. Note Junit 5 intentionally shuffle @RegisterExtension extensions order, but you can always order them with @Order annotation. Start application by test method \u00b6 When you declare extensions with annotations or with @RegisterExtension in static fields, application would be started before all test methods and shut down after last test method. If you want to start application for each test method then declare extension in non-static field: RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ). create () // injection would be re-newed for each test method @Inject Bean bean ; @Test public void test1 () { Assertions . assertEquals ( 0 , bean . value ); // changing value to show that bean was reset between tests bean . value = 10 } @Test public void test2 () { Assertions . assertEquals ( 0 , bean . value ); bean . value = 10 } Also, @EnableHook and @EnableSetup fields might also be not static (but static fields would also work) in this case: @RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ). create () @EnableSetup MySetup setup = new MySetup () Debug \u00b6 Debug option could be activated on extensions in order to print registered setup objects and hooks (registered in test): Guicey test extensions (Test2.): Setup objects = HookObjectsLogTest$Test2$$Lambda$349/1644231115 (r.v.d.g.t.j.hook) @EnableSetup field Test2.setup Test hooks = HookObjectsLogTest$Base$$Lambda$341/1127224355 (r.v.d.g.t.j.hook) @EnableHook field Base.base1 Ext1 (r.v.d.g.t.j.h.HookObjectsLogTest) @RegisterExtension class HookObjectsLogTest$Test2$$Lambda$345/484589713 (r.v.d.g.t.j.hook) @RegisterExtension instance Ext3 (r.v.d.g.t.j.h.HookObjectsLogTest) HookObjectsLogTest$Test2$$Lambda$349/1644231115 class HookObjectsLogTest$Test2$$Lambda$369/1911152052 (r.v.d.g.t.j.hook) HookObjectsLogTest$Test2$$Lambda$349/1644231115 instance HookObjectsLogTest$Test2$$Lambda$350/537066525 (r.v.d.g.t.j.hook) @EnableHook field Test2.ext1 which prints registered objects in the execution order and with registration source in the right. And applied configuration overrides: Applied configuration overrides (Test1.): foo = 1 Important Configuration overrides printed after application startup because they are extracted from system properties (to guarantee exact used value), which is possible to analyze only after DropwizardTestSupport#before() call. Note Configuration prefix for system properties is shown in brackets: (Test1.) . It simplifies investigation in case of concurrent tests. Debug could be activated by annotation: @TestGuiceyApp ( value = App . class , debug = true ) By builder: @RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App ) . debug () . create () By setup object: @EnableSetup static TestEnvironmentSetup db = ext -> { ext . debug (); }; And using system property: -Dguicey.extensions.debug=true There is also a shortcut for enabling system property: TestSupport . debugExtensions () Junit nested classes \u00b6 Junit natively supports nested tests . Guicey extensions affects all nested tests below declaration (nesting level is not limited): @TestGuiceyApp ( AutoScanApplication . class ) public class NestedPropagationTest { @Inject Environment environment ; @Test void checkInjection () { Assertions . assertNotNull ( environment ); } @Nested class Inner { @Inject Environment env ; // intentionally different name @Test void checkInjection () { Assertions . assertNotNull ( env ); } } } Note Nested tests will use exactly the same guice context as root test (application started only once). Extension declared on nested test will affect all sub-tests: public class NestedTreeTest { @TestGuiceyApp ( AutoScanApplication . class ) @Nested class Level1 { @Inject Environment environment ; @Test void checkExtensionApplied () { Assertions . assertNotNull ( environment ); } @Nested class Level2 { @Inject Environment env ; @Test void checkExtensionApplied () { Assertions . assertNotNull ( env ); } @Nested class Level3 { @Inject Environment envr ; @Test void checkExtensionApplied () { Assertions . assertNotNull ( envr ); } } } } @Nested class NotAffected { @Inject Environment environment ; @Test void extensionNotApplied () { Assertions . assertNull ( environment ); } } } This way nested tests allows you to use different extension configurations in one (root) class. Note that extension declaration with @RegisterExtension on the root class field would also be applied to nested tests. Even declaration in non-static field (start application for each method) would also work. Use interfaces to share tests \u00b6 This is just a tip on how to execute same test method in different environments. public class ClientSupportDwTest { interface ClientCallTest { // test to apply for multiple environments @Test default void callClient ( ClientSupport client ) { Assertions . assertEquals ( \"main\" , client . targetMain ( \"servlet\" ) . request (). buildGet (). invoke (). readEntity ( String . class )); } } @TestDropwizardApp ( App . class ) @Nested class DefaultConfig implements ClientCallTest { @Test void testClient ( ClientSupport client ) { Assertions . assertEquals ( \"http://localhost:8080/\" , client . basePathMain ()); } } @TestDropwizardApp ( value = App . class , configOverride = { \"server.applicationContextPath: /app\" , \"server.adminContextPath: /admin\" , }, restMapping = \"api\" ) @Nested class ChangedDefaultConfig implements ClientCallTest { @Test void testClient ( ClientSupport client ) { Assertions . assertEquals ( \"http://localhost:8080/app/\" , client . basePathMain ()); } } } Here test declared in ClientCallTest interface will be called for each nested test (one declaration - two executions in different environments). Meta annotation \u00b6 You can prepare meta annotation (possibly combining multiple 3 rd party extensions): @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . TYPE ) @TestDropwizardApp ( AutoScanApplication . class ) public @interface MyApp { } @MyApp public class MetaAnnotationDwTest { @Test void checkAnnotationRecognized ( Application app ) { Assertions . assertNotNull ( app ); } } OR you can simply use base test class and configure annotation there: @TestDropwizardApp ( AutoScanApplication . class ) public class BaseTest {} public class ActualTest extends BaseTest {} Testing commands \u00b6 Warning Commands execution overrides System IO and so can't run in parallel with other tests! Use @Isolated on such tests to prevent parallel execution with other tests Command execution is usually a short-lived action, so it is not possible to write an extension for it. Command could be tested only with generic utility: @Test public class testCommand () { CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"cmd\" , \"-p\" , \"param\" ); Assertions . assertTrue ( result . isSuccessful ()); } Run command arguments are the same as real command arguments (the same Cli used for commands parsing). You can only omit configuration path and use builder instead: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . config ( \"path/to/config.yml\" ) . configOverride ( \"prop: 1\" ) . run ( \"cmd\" , \"-p\" , \"param\" ); Important Command execution never throws an exception - any appeared exception would be inside resulted object. Output is intercepted and could be used for assertions: Assertions . assertTrue ( result . getOutput (). contains ( \"some text\" )) All special objects (like configuration, environment etc), created during command execution are all stored inside the result object (this is the only way to access them). Commands requiring user input are also supported: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . consoleInputs ( \"1\" , \"two\" , \"something else\" ) . run ( \"quiz\" ) This could be used to test any command (simple, configuration or environment), but injector would be created only for environment command. Testing startup error \u00b6 Warning Commands execution overrides System IO and so can't run in parallel with other tests! Use @Isolated on such tests to prevent parallel execution with other tests Tests for application startup fail often required to check some startup conditions. The problem is that it's not enough to simply run the application with \"bad\" configuration file because on error application calls System.exit(1) (see Application.onFatalError ) Instead, you can use command run utility: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Note Test framework-agnostic utilities provides simple utilities to run application (core or web). Could be useful when testing several applications interaction. Environment variables \u00b6 Warning Such modifications are not suitable for parallel tests execution! Use @Isolated on such tests to prevent parallel execution with other tests To modify environment variables for test use system stubs library testImplementation 'uk.org.webcompere:system-stubs-jupiter:2.0.3' @ExtendWith ( SystemStubsExtension . class ) public class MyTest { @SystemStub EnvironmentVariables ENV ; @SystemStub SystemOut out ; @SystemStub SystemProperties propsReset ; @BeforeAll public void setup () { ENV . set ( \"VAR\" , \"1\" ); System . setProperty ( \"foo\" , \"bar\" ); // OR propsReset.set(\"foo\", \"bar\") - both works the same } @Test public void test () { // here goes some test that requires custom environment and system property values // validating output Assertions . assertTrue ( out . getTest (). contains ( \"some log message\" )); } } Pay attention that there is no need for cleanup: system properties and environment variables would be re-set automatically! 3 rd party extensions integration \u00b6 It is extremely simple in JUnit 5 to write extensions . If you do your own extension, you can easily integrate with guicey or dropwizard extensions: there are special static methods allowing you to obtain main test objects: GuiceyExtensionsSupport.lookupSupport(extensionContext) -> Optional<DropwizardTestSupport> GuiceyExtensionsSupport.lookupInjector(extensionContext) -> Optional<Injector> GuiceyExtensionsSupport.lookupClient(extensionContext) -> Optional<ClientSupport> For example: public class MyExtension implements BeforeEachCallback { @Override public void beforeEach ( ExtensionContext context ) throws Exception { Injector injector = GuiceyExtensionsSupport . lookupInjector ( context ). get (); ... } } (guicey holds test state in junit test-specific storages and that's why test context is required) Warning There is no way in junit to order extensions, so you will have to make sure that your extension will be declared after guicey extension ( @TestGuiceyApp or @TestDropwizardApp ). There is intentionally no direct api for applying configuration overrides from 3 rd party extensions because it would be not obvious. Instead, you should always declare overridden value in extension declaration. Either use instance getter: @RegisterExtension static MyExtension ext = new MyExtension () @RegisterExtension static TestGuiceyAppExtension dw = TestGuiceyAppExtension . forApp ( App . class ) . configOverride ( \"some.key\" , () -> ext . getValue ()) . create () Or store value inside junit store and then reference it: @RegisterExtension static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( App . class ) . configOverrideByExtension ( ExtensionContext . Namespace . GLOBAL , \"ext1\" ) . create ();","title":"Junit 5"},{"location":"guide/test/junit5/#junit-5","text":"Migration from JUnit 4 Junit 5 user guide","title":"JUnit 5"},{"location":"guide/test/junit5/#setup","text":"You will need the following dependencies (assuming BOM used for versions management): testImplementation 'io.dropwizard:dropwizard-testing' testImplementation 'org.junit.jupiter:junit-jupiter-api' testRuntimeOnly 'org.junit.jupiter:junit-jupiter' Tip If you already have junit4 or spock tests, you can activate vintage engine so all tests could work together with junit 5: testRuntimeOnly 'org.junit.vintage:junit-vintage-engine' Note In gradle you need to explicitly activate junit 5 support with test { useJUnitPlatform () ... } Warning Junit 5 annotations are different from junit4, so if you have both junit 5 and junit 4 make sure correct classes (annotations) used for junit 5 tests: import org.junit.jupiter.api.Assertions ; import org.junit.jupiter.api.Test ;","title":"Setup"},{"location":"guide/test/junit5/#dropwizard-extensions-compatibility","text":"Guicey extensions could be used together with dropwizard extensions . This may be required only in edge cases when multiple applications startup is required. For example: // run app (injector only) @TestGuiceyApp ( App . class ) // activate dropwizard extensions @ExtendWith ( DropwizardExtensionsSupport . class ) public class ClientSupportGuiceyTest { // Use dropwizard extension to start a separate server // It might be the same application or different // (application instances would be different in any case) static DropwizardAppExtension app = new DropwizardAppExtension ( App . class ); @Test void testLimitedClient ( ClientSupport client ) { Assertions . assertEquals ( 200 , client . target ( \"http://localhost:8080/dummy/\" ) . request (). buildGet (). invoke (). getStatus ()); } } Info There is a difference in extensions implementation. Dropwizard extensions work as: junit extension @ExtendWith(DropwizardExtensionsSupport.class) looks for fields implementing DropwizardExtension (like DropwizardAppExtension ) and start/stop them according to test lifecycle. Guicey extensions implemented as separate junit extensions (and only hook fields are manually searched). Also, guciey extensions implement junit parameters injection (for test and lifecycle methods).","title":"Dropwizard extensions compatibility"},{"location":"guide/test/junit5/#extensions","text":"@TestGuiceyApp - for lightweight tests (without starting web part, only guice context) @TestDropwizardApp - for complete integration tests For most tests @TestGuiceyApp assumed to be used as it only starts guice injector (which is much faster than complete application startup). Such tests are ideal for testing business logic (services). @TestDropwizardApp (full integration test) used only to check web endpoints and full workflow (assuming all business logic was already tested with lightweight tests) Both extensions allow using injections directly in test fields. Extensions could be used under junit parallel execution (no side effects). Alternative declaration might be used for deferred configuration or starting application for each test method . Pre-configured http client might be used for calling test application endpoints (or external). Test environment might be prepared with setup objects and application might be re-configured with hooks","title":"Extensions"},{"location":"guide/test/junit5/#testing-core-logic","text":"@TestGuiceyApp runs all guice logic without starting jetty (so resources, servlets and filters will not be available). Managed objects will still be handled correctly. @TestGuiceyApp ( MyApplication . class ) public class AutoScanModeTest { @Inject MyService service ; @Test public void testMyService () { Assertions . assertEquals ( \"hello\" , service . getSmth ()); } Also, injections work as method parameters: @TestGuiceyApp ( MyApplication . class ) public class AutoScanModeTest { public void testMyService ( MyService service ) { Assertions . assertEquals ( \"hello\" , service . getSmth ()); } Application started before all tests in annotated class and stopped after them.","title":"Testing core logic"},{"location":"guide/test/junit5/#testing-web-logic","text":"@TestDropwizardApp is useful for complete integration testing (when web part is required): @TestDropwizardApp ( MyApplication . class ) class WebModuleTest { @Inject MyService service @Test public void checkWebBindings ( ClientSupport client ) { Assertions . assertEquals ( \"Sample filter and service called\" , client . targetMain ( \"servlet\" ). request (). buildGet (). invoke (). readEntity ( String . class )); Assertions . assertTrur ( service . isCalled ());","title":"Testing web logic"},{"location":"guide/test/junit5/#random-ports","text":"In order to start application on random port you can use configuration shortcut: @TestDropwizardApp ( value = MyApplication . class , randomPorts = true ) Note Random ports setting override exact ports in configuration: @TestDropwizardApp ( value = MyApplication , config = 'path/to/my/config.yml' , randomPorts = true ) Also, random ports support both server types (default and simple) Real ports could be resolved with ClientSupport object.","title":"Random ports"},{"location":"guide/test/junit5/#rest-mapping","text":"Normally, rest mapping configured with server.rootMapping=/something/* configuration, but if you don't use custom configuration class, but still want to re-map rest, shortcut could be used: @TestDropwizardApp ( value = MyApplication . class , restMapping = \"something\" ) In contrast to config declaration, attribute value may not start with '/' and end with '/*' - it would be appended automatically. This option is only intended to simplify cases when custom configuration file is not yet used in tests (usually early PoC phase). It allows you to map servlet into application root in test (because rest is no more resides in root). When used with existing configuration file, this parameter will override file definition.","title":"Rest mapping"},{"location":"guide/test/junit5/#guice-injections","text":"Any guice bean could be injected directly into the test field: @Inject SomeBean bean This will work even for not declared (in guice modules) beans (JIT injection will occur). To better understand injection scopes look the following test: // one application instance started for all test methods @TestGuiceyApp ( AutoScanApplication . class ) @TestMethodOrder ( MethodOrderer . OrderAnnotation . class ) public class InjectionScopeTest { // new instance injected on each test @Inject TestBean bean ; // the same context used for all tests (in class), so the same bean instance inserted before each test @Inject TestSingletonBean singletonBean ; @Test @Order ( 1 ) public void testInjection () { bean . value = 5 ; singletonBean . value = 15 ; Assertions . assertEquals ( 5 , bean . value ); Assertions . assertEquals ( 15 , singletonBean . value ); } @Test @Order ( 2 ) public void testSharedState () { Assertions . assertEquals ( 0 , bean . value ); Assertions . assertEquals ( 15 , singletonBean . value ); } // bean is in prototype scope public static class TestBean { int value ; } @Singleton public static class TestSingletonBean { int value ; } } Note Guice AOP will not work on test methods (because test instances are not created by guice).","title":"Guice injections"},{"location":"guide/test/junit5/#parameter-injection","text":"Any declared guice bean may be injected as test method parameter: @Test public void testSomthing ( DummyBean bean ) (where DummyBean is manually declared in some module or requested as a dependency (JIT-instantiated) during injector creation). For unknown beans injection (not declared and not used during startup) special annotation must be used: @Test public void testSomthing ( @Jit TestBean bean ) Info Additional annotation required because you may use other junit extensions providing their own parameters, which guicey extension should not try to handle. That's why not annotated parameters verified with existing injector bindings. Qualified and generified injections will also work: @Test public void testSomthing ( @Named ( \"qual\" ) SomeBean bean , TestBean < String > generifiedBean , Provider < OtherBean > provider ) Also, there are special objects available as parameters: Application or exact application class ( MyApplication ) ObjectMapper ClientSupport application web client helper DropwizardTestSupport test support object used internally Note Parameter injection will work on test methods as well as lifecyle methods (beforeAll, afterEach etc.) Example: @TestDropwizardApp ( AutoScanApplication . class ) public class ParametersInjectionDwTest { public ParametersInjectionDwTest ( Environment env , DummyService service ) { Preconditions . checkNotNull ( env ); Preconditions . checkNotNull ( service ); } @BeforeAll static void before ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @BeforeEach void setUp ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @AfterEach void tearDown ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @AfterAll static void after ( Application app , DummyService service ) { Preconditions . checkNotNull ( app ); Preconditions . checkNotNull ( service ); } @Test void checkAllPossibleParams ( Application app , AutoScanApplication app2 , Configuration conf , TestConfiguration conf2 , Environment env , ObjectMapper mapper , Injector injector , ClientSupport client , DropwizardTestSupport support , DummyService service , @Jit JitService jit ) { assertNotNull ( app ); assertNotNull ( app2 ); assertNotNull ( conf ); assertNotNull ( conf2 ); assertNotNull ( env ); assertNotNull ( mapper ); assertNotNull ( injector ); assertNotNull ( client ); assertNotNull ( support ); assertNotNull ( service ); assertNotNull ( jit ); assertEquals ( client . getPort (), 8080 ); assertEquals ( client . getAdminPort (), 8081 ); } public static class JitService { private final DummyService service ; @Inject public JitService ( DummyService service ) { this . service = service ; } } } Tip DropwizardTestSupport and ClientSupport objects are also available with a static calls (in the same thread): DropwizardTestSupport support = TestSupport . getContext (); ClientSupport client = TestSupport . getContextClient ();","title":"Parameter injection"},{"location":"guide/test/junit5/#client","text":"Both extensions prepare special jersey client instance which could be used for web calls. It is mostly useful for complete web tests to call rest services and servlets. @Test void checkRandomPorts ( ClientSupport client ) { Assertions . assertNotEquals ( 8080 , client . getPort ()); Assertions . assertNotEquals ( 8081 , client . getAdminPort ()); } Client object provides: Access to JerseyClient object (for raw calls) Shortcuts for querying main, admin or rest contexts (it will count the current configuration automatically) Shortcuts for base main, admin or rest contexts base urls (and application ports) Example usages: // GET {rest path}/some client . targetRest ( \"some\" ). request (). buildGet (). invoke () // GET {main context path}/servlet client . targetMain ( \"servlet\" ). request (). buildGet (). invoke () // GET {admin context path}/adminServlet client . targetAdmin ( \"adminServlet\" ). request (). buildGet (). invoke () Tip All methods above accepts any number of strings which would be automatically combined into correct path: client . targetRest ( \"some\" , \"other/\" , \"/part\" ) would be correctly combined as \"/some/other/part/\" As you can see test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct. Response res = client . targetRest ( \"some\" ). request (). buildGet (). invoke () Assertions . assertEquals ( 200 , res . getStatus ()) Assertions . assertEquals ( \"response text\" , res . readEntity ( String )) Also, if you want to use other client, client object can simply provide required info: client . getPort () // app port (8080) client . getAdminPort () // app admin port (8081) client . basePathMain () // main context path (http://localhost:8080/) client . basePathAdmin () // admin context path (http://localhost:8081/) client . basePathRest () // rest context path (http://localhost:8080/) Raw client usage: // call completely external url client . target ( \"http://somedomain:8080/dummy/\" ). request (). buildGet (). invoke () Warning Client object could be injected with both dropwizard and guicey extensions, but in case of guicey extension, only raw client could be used (because web part not started all other methods will throw NPE)","title":"Client"},{"location":"guide/test/junit5/#client-factory","text":"Internal JerseyClient creation could be customized with TestClientFactory implementation. Default implementation ( DefaultTestClientFactory ) applies timeouts and auto-registers multipart support if dropwizard-forms module is available in classpath. Custom implementation could be specified directly in the test annotation: @TestDropwizardApp ( value = MyApp . class , clientFactory = CustomTestClientFactory . class )","title":"Client factory"},{"location":"guide/test/junit5/#configuration","text":"For both extensions you can configure application with external configuration file: @TestGuiceyApp ( value = MyApplication . class , config = \"path/to/my/config.yml\" public class ConfigOverrideTest { Or just declare required values: @TestGuiceyApp ( value = MyApplication . class , configOverride = { \"foo: 2\" , \"bar: 12\" }) public class ConfigOverrideTest { (note that overriding declaration follows yaml format \"key: value\") Or use both at once (here overrides will override file values): @TestGuiceyApp ( value = MyApplication . class , config = ' path / to / my / config . yml ' , configOverride = { \"foo: 2\" , \"bar: 12\" }) class ConfigOverrideTest {","title":"Configuration"},{"location":"guide/test/junit5/#deferred-configuration","text":"If you need to configure value, supplied by some other extension, or value may be resolved only after test start, then static overrides declaration is not an option. In this case use alternative extensions declaration which provides additional config override methods: @RegisterExtension @Order ( 1 ) static FooExtension ext = new FooExtension (); @RegisterExtension @Order ( 2 ) static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( AutoScanApplication . class ) . config ( \"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\" ) . configOverrides ( \"foo: 1\" ) . configOverride ( \"bar\" , () -> ext . getValue ()) . configOverrides ( new ConfigOverrideValue ( \"baa\" , () -> \"44\" )) . create (); In most cases configOverride(\"bar\", () -> ext.getValue()) would be enough to configure a supplier instead of static value. In more complex cases, you can use custom implementations of ConfigOverride . Guicey have to accept only ConfigOverride objects implementing custom ru.vyarus.dropwizard.guice.test.util.ConfigurablePrefix interface. In order to support parallel tests guicey generates unique config prefix for each test (because all overrides eventually stored to system properties) and so it needs a way to set this prefix into custom ConfigOverride objects.","title":"Deferred configuration"},{"location":"guide/test/junit5/#configuration-from-3rd-party-extensions","text":"If you have junit extension (e.g. which starts db for test) and you need to apply configuration overrides from that extension, then you should simply store required values inside junit storage: public class ConfigExtension implements BeforeAllCallback { @Override public void beforeAll ( ExtensionContext context ) throws Exception { // do something and then store value context . getStore ( ExtensionContext . Namespace . GLOBAL ). put ( \"ext1\" , 10 ); } } And map overrides directly from store using configOverrideByExtension method: @ExtendWith ( ConfigExtension . class ) public class SampleTest { @RegisterExtension static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( App . class ) . configOverrideByExtension ( ExtensionContext . Namespace . GLOBAL , \"ext1\" ) . create (); } Here, value applied by extension under key ext1 would be applied to configuration ext1 path. If you need to use different configuration key: . configOverrideByExtension ( ExtensionContext . Namespace . GLOBAL , \"ext1\" , \"key\" ) Tip You can use setup objects instead of custom junit extensions for test environment setup","title":"Configuration from 3rd party extensions"},{"location":"guide/test/junit5/#test-environment-setup","text":"It is often required to prepare test environment before starting dropwizard application. Normally, such cases require writing custom junit extensions. In order to simplify environment setup, guicey provides TestEnviromentSetup interface. Setup objects are called before application startup and could directly apply (through parameter) configuration overrides and hooks. For example, suppose you need to set up a database before test: public class TestDbSetup implements TestEnvironmentSetup { @Override public Object setup ( TestExtension extension ) { // pseudo code Db db = DbFactory . startTestDb (); // register required configuration extension . configOverride ( \"database.url\" , () -> db . getUrl ()) . configOverride ( \"database.user\" , () -> db . getUser ()) . configOverride ( \"database.password\" , () -> db . getPassword ); // assuming object implements Closable return db ; } } It is not required to return anything, only if something needs to be closed after application shutdown: objects other than Closable ( AutoClosable ) or org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource simply ignored. This approach (only one method) simplifies interface usage with lambdas. Setup object might be declared in extension annotation: @TestGuiceyApp ( value = App . class , setup = TestDbSetup . class ) Or in manual registration: @RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ) // as class . setup ( TestDbSetup . class ) // or as instance . setup ( new TestDbSetup ()) Or with lambda: . setup ( ext -> { Db db = new Db (); ext . configOverride ( \"db.url\" , () -> db . getUrl ()) return db ; })","title":"Test environment setup"},{"location":"guide/test/junit5/#setup-fields","text":"Alternatively, setup objects might be declared simply in test fields: @EnableSetup static TestEnvironmentSetup db = ext -> { Db db = new Db (); ext . configOverride ( \"db.url\" , () -> db . getUrl ()) return db ; }; or @EnableSetup static TestDbSetup db = new TestDbSetup () This could be extremely useful if you need to unify setup logic for multiple tests, but use different extension declarations in test. In this case simply move field declaration into base test class: public abstract class BaseTest { @EnableSetup static TestDbSetup db = new TestDbSetup (); } Note To avoid confusion with guicey hooks: setup object required to prepare test environment before test (and apply required configurations) whereas hooks is a general mechanism for application customization (not only in tests). Setup objects are executed before application startup (before DropwizardTestSupport object creation) and hooks are executed by started application.","title":"Setup fields"},{"location":"guide/test/junit5/#application-test-modification","text":"You can use hooks to customize application . In both extensions annotation hooks could be declared with attribute: @TestDropwizardApp ( value = MyApplication . class , hooks = MyHook . class ) or @TestGuiceyApp ( value = MyApplication . class , hooks = MyHook . class ) Where MyHook is: public class MyHook implements GuiceyConfigurationHook {}","title":"Application test modification"},{"location":"guide/test/junit5/#hook-fields","text":"Alternatively, you can declare hook directly in test field: @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . modules ( new DebugModule ()); Any number of fields could be declared. The same way hook could be declared in base test class: public abstract class BaseTest { // hook in base class @EnableHook static GuiceyConfigurationHook BASE_HOOK = builder -> builder . modules ( new DebugModule ()); } @TestGuiceyApp ( value = App . class , hooks = SomeOtherHook . class ) public class SomeTest extends BaseTest { // Another hook @EnableHook static GuiceyConfigurationHook HOOK = builder -> builder . modules ( new DebugModule2 ()); } All 3 hooks will work.","title":"Hook fields"},{"location":"guide/test/junit5/#extension-configuration-unification","text":"It is a common need to run multiple tests with the same test application configuration (same config overrides, same hooks etc.). Do not configure it in each test, instead move extension configuration into base test class: @TestGuiceyApp (...) public abstract class AbstractTest { // here might be helper methods } And now all test classes should simply extend it: public class Test1 extends AbstractTest { @Inject MyService service ; @Test public void testSomething () { ... } } If you use manual extension configuration (through field), just replace annotation in base class with manual declaration - approach would still work.","title":"Extension configuration unification"},{"location":"guide/test/junit5/#reuse-application-between-tests","text":"In some cases it is preferable to start application just once and use for all tests (e.g. due to long startup or time-consuming environment preparation). In order to use the same application instance, extension declaration must be performed in base test class and reuseApplication flag must be enabled: @TestGuiceyApp ( value = Application . class , reuseApplication = true ) public abstract class BaseTest {} or public abstract class BaseTest { @RegisterExtension static TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ) . reuseApplication () . create (); } The same will work for dropwizard extension ( @TestDropwizardApp and TestDropwizardAppExtension ). Important Application instance re-use is not enabled by default for backwards compatibility (for cases when base class declaration already used). There might be multiple base test classes declaring reusable applications: different global applications would be started for each declaration (allowing you to group tests requiring different applications) Global application would be closed after all tests execution (with test engine shutdown). In essence, reusable application \"stick\" to declaration in base class, so all tests, extending base class \"inherit\" the same declaration and so the same application (when reuse enabled). Tip Reusable applications may be used together with tests, not extending base class and using guicey extensions. Such tests would simply start a new application instance. Just be sure to avoid port clashes when using reusable dropwizard apps (by using randomPorts option). @EnableSetup and @EnableHook fields are also supported for reusable applications. But declare all such fields on base class level (or below) because otherwise only fields declared on first started test would be used. Warning would be printed if such fields used (or ignored because reusable app was already started by different test).","title":"Reuse application between tests"},{"location":"guide/test/junit5/#parallel-execution","text":"Junit parallel tests execution could be activated with properties file junit-platform.properties located at test resources root: junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent Note In order to avoid config overriding collisions (because all overrides eventually stored to system properties) guicey generates unique property prefixes in each test. To avoid port collisions in dropwizard tests use randomPorts option .","title":"Parallel execution"},{"location":"guide/test/junit5/#alternative-declaration","text":"Both extensions could be declared in fields: @RegisterExtension static TestDropwizardAppExtension app = TestDropwizardAppExtension . forApp ( AutoScanApplication . class ) . config ( \"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . randomPorts () . hooks ( Hook . class ) . hooks ( builder -> builder . disableExtensions ( DummyManaged . class )) . create (); The only difference with annotations is that you can declare hooks and setup objects as lambdas directly (still hooks in static fields will also work). @RegisterExtension static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( AutoScanApplication . class ) ... This alternative declaration is intended to be used in cases when guicey extensions need to be aligned with other 3 rd party extensions: in junit you can order extensions declared with annotations (by annotation order) and extensions declared with @RegisterExtension (by declaration order). But there is no way to order extension registered with @RegisterExtension before annotation extension. So if you have 3 rd party extension which needs to be executed BEFORE guicey extensions, you can use field declaration. Note Junit 5 intentionally shuffle @RegisterExtension extensions order, but you can always order them with @Order annotation.","title":"Alternative declaration"},{"location":"guide/test/junit5/#start-application-by-test-method","text":"When you declare extensions with annotations or with @RegisterExtension in static fields, application would be started before all test methods and shut down after last test method. If you want to start application for each test method then declare extension in non-static field: RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ). create () // injection would be re-newed for each test method @Inject Bean bean ; @Test public void test1 () { Assertions . assertEquals ( 0 , bean . value ); // changing value to show that bean was reset between tests bean . value = 10 } @Test public void test2 () { Assertions . assertEquals ( 0 , bean . value ); bean . value = 10 } Also, @EnableHook and @EnableSetup fields might also be not static (but static fields would also work) in this case: @RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App . class ). create () @EnableSetup MySetup setup = new MySetup ()","title":"Start application by test method"},{"location":"guide/test/junit5/#debug","text":"Debug option could be activated on extensions in order to print registered setup objects and hooks (registered in test): Guicey test extensions (Test2.): Setup objects = HookObjectsLogTest$Test2$$Lambda$349/1644231115 (r.v.d.g.t.j.hook) @EnableSetup field Test2.setup Test hooks = HookObjectsLogTest$Base$$Lambda$341/1127224355 (r.v.d.g.t.j.hook) @EnableHook field Base.base1 Ext1 (r.v.d.g.t.j.h.HookObjectsLogTest) @RegisterExtension class HookObjectsLogTest$Test2$$Lambda$345/484589713 (r.v.d.g.t.j.hook) @RegisterExtension instance Ext3 (r.v.d.g.t.j.h.HookObjectsLogTest) HookObjectsLogTest$Test2$$Lambda$349/1644231115 class HookObjectsLogTest$Test2$$Lambda$369/1911152052 (r.v.d.g.t.j.hook) HookObjectsLogTest$Test2$$Lambda$349/1644231115 instance HookObjectsLogTest$Test2$$Lambda$350/537066525 (r.v.d.g.t.j.hook) @EnableHook field Test2.ext1 which prints registered objects in the execution order and with registration source in the right. And applied configuration overrides: Applied configuration overrides (Test1.): foo = 1 Important Configuration overrides printed after application startup because they are extracted from system properties (to guarantee exact used value), which is possible to analyze only after DropwizardTestSupport#before() call. Note Configuration prefix for system properties is shown in brackets: (Test1.) . It simplifies investigation in case of concurrent tests. Debug could be activated by annotation: @TestGuiceyApp ( value = App . class , debug = true ) By builder: @RegisterExtension TestGuiceyAppExtension ext = TestGuiceyAppExtension . forApp ( App ) . debug () . create () By setup object: @EnableSetup static TestEnvironmentSetup db = ext -> { ext . debug (); }; And using system property: -Dguicey.extensions.debug=true There is also a shortcut for enabling system property: TestSupport . debugExtensions ()","title":"Debug"},{"location":"guide/test/junit5/#junit-nested-classes","text":"Junit natively supports nested tests . Guicey extensions affects all nested tests below declaration (nesting level is not limited): @TestGuiceyApp ( AutoScanApplication . class ) public class NestedPropagationTest { @Inject Environment environment ; @Test void checkInjection () { Assertions . assertNotNull ( environment ); } @Nested class Inner { @Inject Environment env ; // intentionally different name @Test void checkInjection () { Assertions . assertNotNull ( env ); } } } Note Nested tests will use exactly the same guice context as root test (application started only once). Extension declared on nested test will affect all sub-tests: public class NestedTreeTest { @TestGuiceyApp ( AutoScanApplication . class ) @Nested class Level1 { @Inject Environment environment ; @Test void checkExtensionApplied () { Assertions . assertNotNull ( environment ); } @Nested class Level2 { @Inject Environment env ; @Test void checkExtensionApplied () { Assertions . assertNotNull ( env ); } @Nested class Level3 { @Inject Environment envr ; @Test void checkExtensionApplied () { Assertions . assertNotNull ( envr ); } } } } @Nested class NotAffected { @Inject Environment environment ; @Test void extensionNotApplied () { Assertions . assertNull ( environment ); } } } This way nested tests allows you to use different extension configurations in one (root) class. Note that extension declaration with @RegisterExtension on the root class field would also be applied to nested tests. Even declaration in non-static field (start application for each method) would also work.","title":"Junit nested classes"},{"location":"guide/test/junit5/#use-interfaces-to-share-tests","text":"This is just a tip on how to execute same test method in different environments. public class ClientSupportDwTest { interface ClientCallTest { // test to apply for multiple environments @Test default void callClient ( ClientSupport client ) { Assertions . assertEquals ( \"main\" , client . targetMain ( \"servlet\" ) . request (). buildGet (). invoke (). readEntity ( String . class )); } } @TestDropwizardApp ( App . class ) @Nested class DefaultConfig implements ClientCallTest { @Test void testClient ( ClientSupport client ) { Assertions . assertEquals ( \"http://localhost:8080/\" , client . basePathMain ()); } } @TestDropwizardApp ( value = App . class , configOverride = { \"server.applicationContextPath: /app\" , \"server.adminContextPath: /admin\" , }, restMapping = \"api\" ) @Nested class ChangedDefaultConfig implements ClientCallTest { @Test void testClient ( ClientSupport client ) { Assertions . assertEquals ( \"http://localhost:8080/app/\" , client . basePathMain ()); } } } Here test declared in ClientCallTest interface will be called for each nested test (one declaration - two executions in different environments).","title":"Use interfaces to share tests"},{"location":"guide/test/junit5/#meta-annotation","text":"You can prepare meta annotation (possibly combining multiple 3 rd party extensions): @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . TYPE ) @TestDropwizardApp ( AutoScanApplication . class ) public @interface MyApp { } @MyApp public class MetaAnnotationDwTest { @Test void checkAnnotationRecognized ( Application app ) { Assertions . assertNotNull ( app ); } } OR you can simply use base test class and configure annotation there: @TestDropwizardApp ( AutoScanApplication . class ) public class BaseTest {} public class ActualTest extends BaseTest {}","title":"Meta annotation"},{"location":"guide/test/junit5/#testing-commands","text":"Warning Commands execution overrides System IO and so can't run in parallel with other tests! Use @Isolated on such tests to prevent parallel execution with other tests Command execution is usually a short-lived action, so it is not possible to write an extension for it. Command could be tested only with generic utility: @Test public class testCommand () { CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"cmd\" , \"-p\" , \"param\" ); Assertions . assertTrue ( result . isSuccessful ()); } Run command arguments are the same as real command arguments (the same Cli used for commands parsing). You can only omit configuration path and use builder instead: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . config ( \"path/to/config.yml\" ) . configOverride ( \"prop: 1\" ) . run ( \"cmd\" , \"-p\" , \"param\" ); Important Command execution never throws an exception - any appeared exception would be inside resulted object. Output is intercepted and could be used for assertions: Assertions . assertTrue ( result . getOutput (). contains ( \"some text\" )) All special objects (like configuration, environment etc), created during command execution are all stored inside the result object (this is the only way to access them). Commands requiring user input are also supported: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . consoleInputs ( \"1\" , \"two\" , \"something else\" ) . run ( \"quiz\" ) This could be used to test any command (simple, configuration or environment), but injector would be created only for environment command.","title":"Testing commands"},{"location":"guide/test/junit5/#testing-startup-error","text":"Warning Commands execution overrides System IO and so can't run in parallel with other tests! Use @Isolated on such tests to prevent parallel execution with other tests Tests for application startup fail often required to check some startup conditions. The problem is that it's not enough to simply run the application with \"bad\" configuration file because on error application calls System.exit(1) (see Application.onFatalError ) Instead, you can use command run utility: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp () Note Test framework-agnostic utilities provides simple utilities to run application (core or web). Could be useful when testing several applications interaction.","title":"Testing startup error"},{"location":"guide/test/junit5/#environment-variables","text":"Warning Such modifications are not suitable for parallel tests execution! Use @Isolated on such tests to prevent parallel execution with other tests To modify environment variables for test use system stubs library testImplementation 'uk.org.webcompere:system-stubs-jupiter:2.0.3' @ExtendWith ( SystemStubsExtension . class ) public class MyTest { @SystemStub EnvironmentVariables ENV ; @SystemStub SystemOut out ; @SystemStub SystemProperties propsReset ; @BeforeAll public void setup () { ENV . set ( \"VAR\" , \"1\" ); System . setProperty ( \"foo\" , \"bar\" ); // OR propsReset.set(\"foo\", \"bar\") - both works the same } @Test public void test () { // here goes some test that requires custom environment and system property values // validating output Assertions . assertTrue ( out . getTest (). contains ( \"some log message\" )); } } Pay attention that there is no need for cleanup: system properties and environment variables would be re-set automatically!","title":"Environment variables"},{"location":"guide/test/junit5/#3rd-party-extensions-integration","text":"It is extremely simple in JUnit 5 to write extensions . If you do your own extension, you can easily integrate with guicey or dropwizard extensions: there are special static methods allowing you to obtain main test objects: GuiceyExtensionsSupport.lookupSupport(extensionContext) -> Optional<DropwizardTestSupport> GuiceyExtensionsSupport.lookupInjector(extensionContext) -> Optional<Injector> GuiceyExtensionsSupport.lookupClient(extensionContext) -> Optional<ClientSupport> For example: public class MyExtension implements BeforeEachCallback { @Override public void beforeEach ( ExtensionContext context ) throws Exception { Injector injector = GuiceyExtensionsSupport . lookupInjector ( context ). get (); ... } } (guicey holds test state in junit test-specific storages and that's why test context is required) Warning There is no way in junit to order extensions, so you will have to make sure that your extension will be declared after guicey extension ( @TestGuiceyApp or @TestDropwizardApp ). There is intentionally no direct api for applying configuration overrides from 3 rd party extensions because it would be not obvious. Instead, you should always declare overridden value in extension declaration. Either use instance getter: @RegisterExtension static MyExtension ext = new MyExtension () @RegisterExtension static TestGuiceyAppExtension dw = TestGuiceyAppExtension . forApp ( App . class ) . configOverride ( \"some.key\" , () -> ext . getValue ()) . create () Or store value inside junit store and then reference it: @RegisterExtension static TestGuiceyAppExtension app = TestGuiceyAppExtension . forApp ( App . class ) . configOverrideByExtension ( ExtensionContext . Namespace . GLOBAL , \"ext1\" ) . create ();","title":"3rd party extensions integration"},{"location":"guide/test/overview/","text":"Testing \u00b6 Guicey provides test extensions for: Spock 2 JUnit 5 Framework-agnostic utilities Deprecated: Spock 1 JUnit 4 Almost all extensions implemented with DropwizardTestSupport . History There is no special Spock 2 extensions, instead junit 5 extensions must be used directly. You get the best of both worlds - use junit extensions (and so can always easily migrate to pure junit) and have spock (and groovy) expressiveness. Currently, spock 1 and junit 4 extensions considered deprecated becuase they use deprecated dropwizard rule . Tip Test framework-agnostic utilities are useful with junit 5 or spock extensions in cases when assertions required after application shutdown or to test application startup errors. Additionally, guicey provides several mechanisms at its core for application customization in tests (see below). Test concepts \u00b6 Core dropwziard testing support proposes atomic testing approach (separate testing of each element). With DI (guice) we have to move towards integration testing because: It is now harder to mock classes \"manually\" (because of DI \"black box\") We have a core (guice injector, without web services), starting much faster than complete application. The following kinds of tests should be used: Unit tests for atomic parts (usually, utility classes) Core integration tests: lightweight application start to test core services (business logic) Web integration tests: full application startup to test web endpoints (full workflow to check transport layer) Custom command tests (also kind of \"integration\", but depends on command) Application startup fail test (done with command runner) to check self-checks Setup objects \u00b6 Junit 5 extensions provide support for setup objects : a simple way to prepare test environment and apply context configuration (e.g. start test database). Spock 2 test could also use setup objects. Configuration hooks \u00b6 Guicey provides hooks mechanism to be able to modify application configuration in tests. Using hooks you can disable installers, extensions, guicey bundles or override guice bindings. It may also be useful to register additional extensions (e.g. to validate some internal behaviour). Example hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . disableModules ( FeatureXModule . class ) . disable ( inPackage ( \"com.foo.feature\" )) . modulesOverride ( new MockDaoModule ()) . option ( Myoptions . DebugOption , true ); } } Note You can modify options in hook and so could enable some custom debug/monitoring options specifically for test. There are special spock and junit extensions for hooks registrations. Disables \u00b6 You can use hooks to disable all not needed features in test: installers extensions guice modules guicey bundles dropwizard bundles This way you can isolate (as much as possible) some feature for testing. The most helpful should be bundles disable (if you use bundles for features grouping) and guice modules. Use predicate disabling . Note It is supposed that disabling will be used instead of mocking - you simply remove what you don't need and register replacements, if required. Guice bindings override \u00b6 It is quite common requirement to override bindings for testing. For example, you may want to mock database access. Guicey could use guice Modules.override() to help you override required bindings. To use it prepare module only with changed bindings (bindings that must override existing). For example, you want to replace ServiceX. You have few options: If it implements interface, implement your own service and bind as bind(ServiceContract.class).to(MyServiceXImpl.class) If service is a class, you can modify its behaviour with extended class bind(ServiceX.class).to(MyServiceXExt.class) Or you can simply register some mock instance bind(ServiceX.class).toInstance(myMockInstance) public class MyOverridingModule extends AbstractModule { protected configure () { bind ( ServiceX . class ). to ( MyServiceXExt . class ); } } And register overriding module in hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . modulesOverride ( new MyOverridingModule ()); } } Debug bundles \u00b6 You can also use special guicey bundles, which modify application behavior. Bundles could contain additional listeners or services to gather additional metrics during tests or validate behavior. For example, guicey tests use bundle to enable restricted guice options like disableCircularProxies . Bundles are also able to: disable installers, extensions, guice modules override guice bindings You can also use lookup mechanism to load bundles in tests. For example, system properties lookup . Overriding overridden beans \u00b6 Guicey provides direct support for overriding guice bindings , so in most cases you don't need to do anything. But, if you use this to override application bindings need to override such bindings in test (again), then you may use provided custom injector factory : Register factory in guice bundle: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) After that you can register overriding bindings (which will override even modules registered in modulesOverride ) with: BindingsOverrideInjectorFactory . override ( new MyOverridingModule ()) Important It is assumed that overriding modules registration and application initialization will be at the same thread ( ThreadLocal used for holding registered modules to allow parallel tests usage). For example, suppose we have some service CustomerService and it's implementation CustomerServiceImpl , defined in some 3 rd party module. For some reason we need to override this binding in the application: public class OverridingModule extends AbstractModule { @Override protected void configure () { bind ( CustomerService . class ). to ( CustomCustomerServiceImpl . class ); } } If we need to override this binding in test (again): (Simplified) registration looks like this: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) . modules ( new ThirdPatyModule ()) // override binding for application needs . modulesOverride ( new OverridingModule ()) ... . build () // register overriding somewhere BindingsOverrideInjectorFactory . override ( new TestOverridingModule ()) Tip Configuration hook may be used for static call (as a good integration point) After test startup, application will use customer service binding from TestOverridingModule. Test commands \u00b6 Dropwizard commands could be tested with commands test support For example: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); There are no special junit 5 or spock 2 extensions for command tests because general run methods are already the best way. Test application startup fail \u00b6 To verify application self-check mechanisms (make sure application would fail with incomplete configuration, or whatever other reason) use commands runner . For example: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp ()","title":"Overview"},{"location":"guide/test/overview/#testing","text":"Guicey provides test extensions for: Spock 2 JUnit 5 Framework-agnostic utilities Deprecated: Spock 1 JUnit 4 Almost all extensions implemented with DropwizardTestSupport . History There is no special Spock 2 extensions, instead junit 5 extensions must be used directly. You get the best of both worlds - use junit extensions (and so can always easily migrate to pure junit) and have spock (and groovy) expressiveness. Currently, spock 1 and junit 4 extensions considered deprecated becuase they use deprecated dropwizard rule . Tip Test framework-agnostic utilities are useful with junit 5 or spock extensions in cases when assertions required after application shutdown or to test application startup errors. Additionally, guicey provides several mechanisms at its core for application customization in tests (see below).","title":"Testing"},{"location":"guide/test/overview/#test-concepts","text":"Core dropwziard testing support proposes atomic testing approach (separate testing of each element). With DI (guice) we have to move towards integration testing because: It is now harder to mock classes \"manually\" (because of DI \"black box\") We have a core (guice injector, without web services), starting much faster than complete application. The following kinds of tests should be used: Unit tests for atomic parts (usually, utility classes) Core integration tests: lightweight application start to test core services (business logic) Web integration tests: full application startup to test web endpoints (full workflow to check transport layer) Custom command tests (also kind of \"integration\", but depends on command) Application startup fail test (done with command runner) to check self-checks","title":"Test concepts"},{"location":"guide/test/overview/#setup-objects","text":"Junit 5 extensions provide support for setup objects : a simple way to prepare test environment and apply context configuration (e.g. start test database). Spock 2 test could also use setup objects.","title":"Setup objects"},{"location":"guide/test/overview/#configuration-hooks","text":"Guicey provides hooks mechanism to be able to modify application configuration in tests. Using hooks you can disable installers, extensions, guicey bundles or override guice bindings. It may also be useful to register additional extensions (e.g. to validate some internal behaviour). Example hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . disableModules ( FeatureXModule . class ) . disable ( inPackage ( \"com.foo.feature\" )) . modulesOverride ( new MockDaoModule ()) . option ( Myoptions . DebugOption , true ); } } Note You can modify options in hook and so could enable some custom debug/monitoring options specifically for test. There are special spock and junit extensions for hooks registrations.","title":"Configuration hooks"},{"location":"guide/test/overview/#disables","text":"You can use hooks to disable all not needed features in test: installers extensions guice modules guicey bundles dropwizard bundles This way you can isolate (as much as possible) some feature for testing. The most helpful should be bundles disable (if you use bundles for features grouping) and guice modules. Use predicate disabling . Note It is supposed that disabling will be used instead of mocking - you simply remove what you don't need and register replacements, if required.","title":"Disables"},{"location":"guide/test/overview/#guice-bindings-override","text":"It is quite common requirement to override bindings for testing. For example, you may want to mock database access. Guicey could use guice Modules.override() to help you override required bindings. To use it prepare module only with changed bindings (bindings that must override existing). For example, you want to replace ServiceX. You have few options: If it implements interface, implement your own service and bind as bind(ServiceContract.class).to(MyServiceXImpl.class) If service is a class, you can modify its behaviour with extended class bind(ServiceX.class).to(MyServiceXExt.class) Or you can simply register some mock instance bind(ServiceX.class).toInstance(myMockInstance) public class MyOverridingModule extends AbstractModule { protected configure () { bind ( ServiceX . class ). to ( MyServiceXExt . class ); } } And register overriding module in hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . modulesOverride ( new MyOverridingModule ()); } }","title":"Guice bindings override"},{"location":"guide/test/overview/#debug-bundles","text":"You can also use special guicey bundles, which modify application behavior. Bundles could contain additional listeners or services to gather additional metrics during tests or validate behavior. For example, guicey tests use bundle to enable restricted guice options like disableCircularProxies . Bundles are also able to: disable installers, extensions, guice modules override guice bindings You can also use lookup mechanism to load bundles in tests. For example, system properties lookup .","title":"Debug bundles"},{"location":"guide/test/overview/#overriding-overridden-beans","text":"Guicey provides direct support for overriding guice bindings , so in most cases you don't need to do anything. But, if you use this to override application bindings need to override such bindings in test (again), then you may use provided custom injector factory : Register factory in guice bundle: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) After that you can register overriding bindings (which will override even modules registered in modulesOverride ) with: BindingsOverrideInjectorFactory . override ( new MyOverridingModule ()) Important It is assumed that overriding modules registration and application initialization will be at the same thread ( ThreadLocal used for holding registered modules to allow parallel tests usage). For example, suppose we have some service CustomerService and it's implementation CustomerServiceImpl , defined in some 3 rd party module. For some reason we need to override this binding in the application: public class OverridingModule extends AbstractModule { @Override protected void configure () { bind ( CustomerService . class ). to ( CustomCustomerServiceImpl . class ); } } If we need to override this binding in test (again): (Simplified) registration looks like this: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) . modules ( new ThirdPatyModule ()) // override binding for application needs . modulesOverride ( new OverridingModule ()) ... . build () // register overriding somewhere BindingsOverrideInjectorFactory . override ( new TestOverridingModule ()) Tip Configuration hook may be used for static call (as a good integration point) After test startup, application will use customer service binding from TestOverridingModule.","title":"Overriding overridden beans"},{"location":"guide/test/overview/#test-commands","text":"Dropwizard commands could be tested with commands test support For example: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . run ( \"simple\" , \"-u\" , \"user\" ) Assertions . assertTrue ( result . isSuccessful ()); There are no special junit 5 or spock 2 extensions for command tests because general run methods are already the best way.","title":"Test commands"},{"location":"guide/test/overview/#test-application-startup-fail","text":"To verify application self-check mechanisms (make sure application would fail with incomplete configuration, or whatever other reason) use commands runner . For example: CommandResult result = TestSupport . buildCommandRunner ( App . class ) . runApp ()","title":"Test application startup fail"},{"location":"guide/test/spock/","text":"Spock 1 \u00b6 Spock framework allows you to write much clearer tests (comparing to junit) thanks to groovy language. Warning Since guicey 5.5 spock 1 support was extracted from guicey to external module . Package remains the same to simplify migration (only additional dependency would be required) This was required because spock 1 does not work on JDK 16 and above. DEPRECATED because Implementation relies on deprecated junit 4 rules. Consider migration to spock 2 (junit 5) Setup \u00b6 You will need the following dependencies (assuming BOM used for versions management): testImplementation 'ru.vyarus.guicey:guicey-test-spock' With Junit 5 \u00b6 OR you can use it with junit 5 vintage engine: testImplementation 'ru.vyarus.guicey:guicey-test-spock' testImplementation 'org.junit.jupiter:junit-jupiter-api' testRuntimeOnly 'org.junit.jupiter:junit-jupiter' testRuntimeOnly 'org.junit.vintage:junit-vintage-engine' This way you can write both spock (groovy) and junit 5 (java or groovy) tests. Extensions \u00b6 Provided extensions: @UseGuiceyApp - for lightweight tests (without starting web part, only guice context) @UseDropwizardApp - for complete integration tests Both extensions allow using injections directly in specifications (like spock-guice). @UseGuiceyHooks extension could be used to apply configuration hook common for all tests. But, it is deprecated in favor of native hooks support in main extensions. Testing core logic \u00b6 @UseGuiceyApp runs all guice logic without starting jetty (so resources, servlets and filters will not be available). Managed objects will still be handled correctly. @UseGuiceyApp ( MyApplication ) class AutoScanModeTest extends Specification { @Inject MyService service def \"My service test\" { when: 'calling service' def res = service . getSmth () then: 'correct result returned' res == 'hello' } Application started before all tests in annotated class and stopped after them. Testing web logic \u00b6 @UseDropwizardApp is useful for complete integration testing (when web part is required): @UseDropwizardApp ( MyApplication ) class WebModuleTest extends Specification { @Inject MyService service def \"Check web bindings\" () { when: \"calling filter\" def res = new URL ( \"http://localhost:8080/dummyFilter\" ). getText () then: \"filter active\" res == 'Sample filter and service called' service . isCalled () Random ports \u00b6 In order to start application on random port you can use configuration shortcut: @UseDropwizardApp ( value = MyApplication , randomPorts = true ) Note Random ports will be applied even if configuration with exact ports provided: @UseDropwizardApp ( value = MyApplication , config = 'path/to/my/config.yml' , randomPorts = true ) Also, random ports support both server types (default and simple) Real ports could be resolved with ClientSupport object. Rest mapping \u00b6 Normally, rest mapping configured with server.rootMapping=/something/* configuration, but if you don't use custom configuration class, but still want to re-map rest, shortcut could be used: @UseDropwizardApp ( value = MyApplication , restMapping = \"something\" ) In contrast to config declaration, attribute value may not start with '/' and end with '/*' - it would be appended automatically. This option is only intended to simplify cases when custom configuration file is not yet used in tests (usually early PoC phase). It allows you to map servlet into application root in test (because rest is no more resides in root). When used with existing configuration file, this parameter will override file definition. Guice injections \u00b6 Any guice bean may be injected directly into test field: @Inject SomeBean bean This may be even bean not declared in guice modules (JIT injection will occur). To better understand injection scopes look the following test: @UseGuiceyApp ( AutoScanApplication ) class InjectionTest extends Specification { // instance remain the same between tests @Shared @Inject TestBean sharedBean // new instance injected on each test @Inject TestBean bean // the same context used for all tests (in class), so the same bean instance inserted before each test @Inject TestSingletonBean singletonBean def \"Check injection types\" () { when: \"changing state of injected beans\" sharedBean . value = 10 bean . value = 5 singletonBean . value = 15 then: \"instances are different\" sharedBean . value == 10 bean . value == 5 singletonBean . value == 15 } def \"Check shared state\" () { expect: \"shared bean instance is the same, whereas other one re-injected\" sharedBean . value == 10 bean . value == 0 singletonBean . value == 15 // the same instance was set before second test } // bean is in prototype scope static class TestBean { int value } @Singleton static class TestSingletonBean { int value } } Note Guice AOP will not work on test methods (because test instances not created by guice). Client \u00b6 Both extensions prepare special jersey client instance which could be used for web calls. It is mostly useful for complete web tests to call rest services and servlets. @InjectClient ClientSupport client It will also work in static fields or @Shared fields. Client object provides: Access to JerseyClient object (for raw calls) Shortcuts for querying main, admin or rest contexts (it will count the current configuration automatically) Shortcuts for base main, admin or rest contexts base urls (and application ports) Example usages: // GET {rest path}/some client . targetRest ( \"some\" ). request (). buildGet (). invoke () // GET {main context path}/servlet client . targetMain ( \"servlet\" ). request (). buildGet (). invoke () // GET {admin context path}/adminServlet client . targetAdmin ( \"adminServlet\" ). request (). buildGet (). invoke () Tip All methods above accepts any number of strings which would be automatically combined into correct path: client . targetRest ( \"some\" , \"other/\" , \"/part\" ) would be correctly combined as \"/some/other/part/\" As you can see test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct. when: \"calling rest service\" def res = client . targetRest ( \"some\" ). request (). buildGet (). invoke () then: \"response is correct\" res . status == 200 res . readEntity ( String ) == \"response text\" Also, if you want to use other client, client object can simply provide required info: client . getPort () // app port (8080) client . getAdminPort () // app admin port (8081) client . basePathMain () // main context path (http://localhost:8080/) client . basePathAdmin () // admin context path (http://localhost:8081/) client . basePathRest () // rest context path (http://localhost:8080/) Raw client usage: // call completely external url client . target ( \"http://somedomain:8080/dummy/\" ). request (). buildGet (). invoke () Warning Client object could be injected with both dropwizard and guicey extensions, but in case of guicey extension, only raw client could be used (because web part not started all other methods will throw NPE) Configuration \u00b6 For both extensions you can configure application with external configuration file: @UseGuiceyApp ( value = MyApplication , config = 'path/to/my/config.yml' class ConfigOverrideTest extends Specification { Or just declare required values: @UseGuiceyApp ( value = MyApplication , configOverride = [ @ConfigOverride ( key = \"foo\" , value = \"2\" ), @ConfigOverride ( key = \"bar\" , value = \"12\" ) ]) class ConfigOverrideTest extends Specification { Or use both at once (here overrides will override file values): @UseGuiceyApp ( value = MyApplication , config = 'path/to/my/config.yml' , configOverride = [ @ConfigOverride ( key = \"foo\" , value = \"2\" ), @ConfigOverride ( key = \"bar\" , value = \"12\" ) ]) class ConfigOverrideTest extends Specification { Application test modification \u00b6 You can use hooks to customize application . In both extensions annotation hooks could be declared with attribute: @UseDropwizardApp ( value = MyApplication , hooks = MyHook ) or @UseGuiceyApp ( value = MyApplication , hooks = MyHook ) Where MyHook is: class MyHook implements GuiceyConfigurationHook {} Hook fields \u00b6 Alternatively, you can declare hook directly in test static field: @EnableHook static GuiceyConfigurationHook HOOK = { it . modules ( new DebugModule ()) } Any number of fields could be declared. The same way hook could be declared in base test class: class BaseTest extends Specification { // hook in base class @EnableHook static GuiceyConfigurationHook BASE_HOOK = { it . modules ( new DebugModule ()) } } @UseGuiceyApp ( value = App , hooks = SomeOtherHook ) class SomeTest extends BaseTest { // Another hook @EnableHook static GuiceyConfigurationHook HOOK = { it . modules ( new DebugModule2 ()) } } All 3 hooks will work. Hooks extension \u00b6 Warning This extension is deprecated in favour of field hooks declarations. @UseGuiceyHooks ( MyBaseHook ) class BaseTest extends Specification { } @UseGuiceyApp ( App ) class SomeTest extends BaseTest {} Note You can still use test specific hooks together with declared base hook (to apply some more test-specific configuration). Warning Only one @UseGuiceyHooks declaration may be used in test hierarchy: for example, you can't declare it in base class and then another one on extended class - base for a group of tests. This is spock limitation (only one extension will actually work) but should not be an issue for most cases. Extension configuration unification \u00b6 It is a common need to run multiple tests with the same test application configuration (same config overrides, same hooks etc.). Do not configure it in each test, instead move extension configuration into base test class: @UsetGuiceyApp (...) abstract class AbstractTest extends Specification { // here might be helper methods } And now all test classes should simply extend it: class Test1 extends AbstractTest { @Inject MyService service def \"Check something\" () { ... } } Dropwizard startup error \u00b6 StartupErrorRule may be used to intercept dropwizard System . exit ( 1 ) call. But it will work different then for junit: then section is always called with exception ( CheckExitCalled ). Also, then section may be used for assertion after exit calls and so there is no need to add custom assertion callbacks (required by junit tests). class ErrorTest extends Specification { @Rule StartupErrorRule RULE = StartupErrorRule . create () def \"Check startup error\" () { when: \"starting app with error\" new MyErrApp (). main ([ 'server' ]) then: \"startup failed\" thrown ( RULE . indicatorExceptionType ) RULE . output . contains ( 'stating application' ) RULE . error . contains ( 'some error occur' ) Spock lifecycle hooks \u00b6 class MyTest extends Specification { @ClassRule @Shared JunitRule sharedRule = new JunitRule () @Rule JunitRule2 rule = new JunitRule2 () def setupSpec () { } def setup () { } def \"Test method body\" () { setup: } } Class rules are applied once per test class (same as setupSpec ). Rules are applied per test method (same as setup ). Setup order: Class rule Setup spec method Rule Setup method Test method's setup section Migration to Spock 2 \u00b6 There is no special extensions for Spock 2, instead junit 5 integrations must be used with it, using special library Current spock extensions are almost equivalent to junit5 extensions (in features and behaviour): Instead of @UseGuiceyApp use @TestGuiceyApp Instead of @UseDropwizardApp use @TestDropwizardApp Hooks can be specified with hooks declaration in extensions or as test fields Instead of StartupErrorRule use system-stubs - the successor of system rules Client \u00b6 For ClientSupport object, INSTEAD of @Inject ClientSupport client use parameter injection (possibly in fixture methods too): def \"Check something\" ( ClientSupport client ) {} Config overrides \u00b6 Junit extension does not require an annotation for each override, so INSTEAD of: @UseDropwizardApp ( value = App , configOverride = [ @ConfigOverride ( key = \"server.rootPath\" , value = \"/rest/*\" ), @ConfigOverride ( key = \"server.applicationContextPath\" , value = \"/prefix\" ), @ConfigOverride ( key = \"server.adminContextPath\" , value = \"/admin\" ) Use: @TestDropwizardApp ( value = App , restMapping = \"/rest/*\" , configOverride = [ \"server.applicationContextPath: /prefix\" , \"server.adminContextPath: /admin\" ]) Note that server.rootPath could be configured with restMapping annotation property. Alternative declaration \u00b6 You may also use alternative declaration : class MyTest extends Specification { @RegisterExtension static TestDropwizardAppExtension app = TestDropwizardAppExtension . forApp ( App ) . config ( \"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . randomPorts () . hooks ( Hook ) . hooks ( builder -> builder . disableExtensions ( DummyManaged )) . create () } This is an alternative to previous rules declaration in fields. It is useful when you need dynamic hook (as lambda) or configuration overrides require some other extensions. Note that config override may be registered with Supplier : . configOverride ( \"key\" , () -> { Somewhere . getValue ()}) Warning Don't use @Shared fields instead of static - it wouldn't work! Also non-static field declaration is not supported by junit extension.","title":"Spock 1"},{"location":"guide/test/spock/#spock-1","text":"Spock framework allows you to write much clearer tests (comparing to junit) thanks to groovy language. Warning Since guicey 5.5 spock 1 support was extracted from guicey to external module . Package remains the same to simplify migration (only additional dependency would be required) This was required because spock 1 does not work on JDK 16 and above. DEPRECATED because Implementation relies on deprecated junit 4 rules. Consider migration to spock 2 (junit 5)","title":"Spock 1"},{"location":"guide/test/spock/#setup","text":"You will need the following dependencies (assuming BOM used for versions management): testImplementation 'ru.vyarus.guicey:guicey-test-spock'","title":"Setup"},{"location":"guide/test/spock/#with-junit-5","text":"OR you can use it with junit 5 vintage engine: testImplementation 'ru.vyarus.guicey:guicey-test-spock' testImplementation 'org.junit.jupiter:junit-jupiter-api' testRuntimeOnly 'org.junit.jupiter:junit-jupiter' testRuntimeOnly 'org.junit.vintage:junit-vintage-engine' This way you can write both spock (groovy) and junit 5 (java or groovy) tests.","title":"With Junit 5"},{"location":"guide/test/spock/#extensions","text":"Provided extensions: @UseGuiceyApp - for lightweight tests (without starting web part, only guice context) @UseDropwizardApp - for complete integration tests Both extensions allow using injections directly in specifications (like spock-guice). @UseGuiceyHooks extension could be used to apply configuration hook common for all tests. But, it is deprecated in favor of native hooks support in main extensions.","title":"Extensions"},{"location":"guide/test/spock/#testing-core-logic","text":"@UseGuiceyApp runs all guice logic without starting jetty (so resources, servlets and filters will not be available). Managed objects will still be handled correctly. @UseGuiceyApp ( MyApplication ) class AutoScanModeTest extends Specification { @Inject MyService service def \"My service test\" { when: 'calling service' def res = service . getSmth () then: 'correct result returned' res == 'hello' } Application started before all tests in annotated class and stopped after them.","title":"Testing core logic"},{"location":"guide/test/spock/#testing-web-logic","text":"@UseDropwizardApp is useful for complete integration testing (when web part is required): @UseDropwizardApp ( MyApplication ) class WebModuleTest extends Specification { @Inject MyService service def \"Check web bindings\" () { when: \"calling filter\" def res = new URL ( \"http://localhost:8080/dummyFilter\" ). getText () then: \"filter active\" res == 'Sample filter and service called' service . isCalled ()","title":"Testing web logic"},{"location":"guide/test/spock/#random-ports","text":"In order to start application on random port you can use configuration shortcut: @UseDropwizardApp ( value = MyApplication , randomPorts = true ) Note Random ports will be applied even if configuration with exact ports provided: @UseDropwizardApp ( value = MyApplication , config = 'path/to/my/config.yml' , randomPorts = true ) Also, random ports support both server types (default and simple) Real ports could be resolved with ClientSupport object.","title":"Random ports"},{"location":"guide/test/spock/#rest-mapping","text":"Normally, rest mapping configured with server.rootMapping=/something/* configuration, but if you don't use custom configuration class, but still want to re-map rest, shortcut could be used: @UseDropwizardApp ( value = MyApplication , restMapping = \"something\" ) In contrast to config declaration, attribute value may not start with '/' and end with '/*' - it would be appended automatically. This option is only intended to simplify cases when custom configuration file is not yet used in tests (usually early PoC phase). It allows you to map servlet into application root in test (because rest is no more resides in root). When used with existing configuration file, this parameter will override file definition.","title":"Rest mapping"},{"location":"guide/test/spock/#guice-injections","text":"Any guice bean may be injected directly into test field: @Inject SomeBean bean This may be even bean not declared in guice modules (JIT injection will occur). To better understand injection scopes look the following test: @UseGuiceyApp ( AutoScanApplication ) class InjectionTest extends Specification { // instance remain the same between tests @Shared @Inject TestBean sharedBean // new instance injected on each test @Inject TestBean bean // the same context used for all tests (in class), so the same bean instance inserted before each test @Inject TestSingletonBean singletonBean def \"Check injection types\" () { when: \"changing state of injected beans\" sharedBean . value = 10 bean . value = 5 singletonBean . value = 15 then: \"instances are different\" sharedBean . value == 10 bean . value == 5 singletonBean . value == 15 } def \"Check shared state\" () { expect: \"shared bean instance is the same, whereas other one re-injected\" sharedBean . value == 10 bean . value == 0 singletonBean . value == 15 // the same instance was set before second test } // bean is in prototype scope static class TestBean { int value } @Singleton static class TestSingletonBean { int value } } Note Guice AOP will not work on test methods (because test instances not created by guice).","title":"Guice injections"},{"location":"guide/test/spock/#client","text":"Both extensions prepare special jersey client instance which could be used for web calls. It is mostly useful for complete web tests to call rest services and servlets. @InjectClient ClientSupport client It will also work in static fields or @Shared fields. Client object provides: Access to JerseyClient object (for raw calls) Shortcuts for querying main, admin or rest contexts (it will count the current configuration automatically) Shortcuts for base main, admin or rest contexts base urls (and application ports) Example usages: // GET {rest path}/some client . targetRest ( \"some\" ). request (). buildGet (). invoke () // GET {main context path}/servlet client . targetMain ( \"servlet\" ). request (). buildGet (). invoke () // GET {admin context path}/adminServlet client . targetAdmin ( \"adminServlet\" ). request (). buildGet (). invoke () Tip All methods above accepts any number of strings which would be automatically combined into correct path: client . targetRest ( \"some\" , \"other/\" , \"/part\" ) would be correctly combined as \"/some/other/part/\" As you can see test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct. when: \"calling rest service\" def res = client . targetRest ( \"some\" ). request (). buildGet (). invoke () then: \"response is correct\" res . status == 200 res . readEntity ( String ) == \"response text\" Also, if you want to use other client, client object can simply provide required info: client . getPort () // app port (8080) client . getAdminPort () // app admin port (8081) client . basePathMain () // main context path (http://localhost:8080/) client . basePathAdmin () // admin context path (http://localhost:8081/) client . basePathRest () // rest context path (http://localhost:8080/) Raw client usage: // call completely external url client . target ( \"http://somedomain:8080/dummy/\" ). request (). buildGet (). invoke () Warning Client object could be injected with both dropwizard and guicey extensions, but in case of guicey extension, only raw client could be used (because web part not started all other methods will throw NPE)","title":"Client"},{"location":"guide/test/spock/#configuration","text":"For both extensions you can configure application with external configuration file: @UseGuiceyApp ( value = MyApplication , config = 'path/to/my/config.yml' class ConfigOverrideTest extends Specification { Or just declare required values: @UseGuiceyApp ( value = MyApplication , configOverride = [ @ConfigOverride ( key = \"foo\" , value = \"2\" ), @ConfigOverride ( key = \"bar\" , value = \"12\" ) ]) class ConfigOverrideTest extends Specification { Or use both at once (here overrides will override file values): @UseGuiceyApp ( value = MyApplication , config = 'path/to/my/config.yml' , configOverride = [ @ConfigOverride ( key = \"foo\" , value = \"2\" ), @ConfigOverride ( key = \"bar\" , value = \"12\" ) ]) class ConfigOverrideTest extends Specification {","title":"Configuration"},{"location":"guide/test/spock/#application-test-modification","text":"You can use hooks to customize application . In both extensions annotation hooks could be declared with attribute: @UseDropwizardApp ( value = MyApplication , hooks = MyHook ) or @UseGuiceyApp ( value = MyApplication , hooks = MyHook ) Where MyHook is: class MyHook implements GuiceyConfigurationHook {}","title":"Application test modification"},{"location":"guide/test/spock/#hook-fields","text":"Alternatively, you can declare hook directly in test static field: @EnableHook static GuiceyConfigurationHook HOOK = { it . modules ( new DebugModule ()) } Any number of fields could be declared. The same way hook could be declared in base test class: class BaseTest extends Specification { // hook in base class @EnableHook static GuiceyConfigurationHook BASE_HOOK = { it . modules ( new DebugModule ()) } } @UseGuiceyApp ( value = App , hooks = SomeOtherHook ) class SomeTest extends BaseTest { // Another hook @EnableHook static GuiceyConfigurationHook HOOK = { it . modules ( new DebugModule2 ()) } } All 3 hooks will work.","title":"Hook fields"},{"location":"guide/test/spock/#hooks-extension","text":"Warning This extension is deprecated in favour of field hooks declarations. @UseGuiceyHooks ( MyBaseHook ) class BaseTest extends Specification { } @UseGuiceyApp ( App ) class SomeTest extends BaseTest {} Note You can still use test specific hooks together with declared base hook (to apply some more test-specific configuration). Warning Only one @UseGuiceyHooks declaration may be used in test hierarchy: for example, you can't declare it in base class and then another one on extended class - base for a group of tests. This is spock limitation (only one extension will actually work) but should not be an issue for most cases.","title":"Hooks extension"},{"location":"guide/test/spock/#extension-configuration-unification","text":"It is a common need to run multiple tests with the same test application configuration (same config overrides, same hooks etc.). Do not configure it in each test, instead move extension configuration into base test class: @UsetGuiceyApp (...) abstract class AbstractTest extends Specification { // here might be helper methods } And now all test classes should simply extend it: class Test1 extends AbstractTest { @Inject MyService service def \"Check something\" () { ... } }","title":"Extension configuration unification"},{"location":"guide/test/spock/#dropwizard-startup-error","text":"StartupErrorRule may be used to intercept dropwizard System . exit ( 1 ) call. But it will work different then for junit: then section is always called with exception ( CheckExitCalled ). Also, then section may be used for assertion after exit calls and so there is no need to add custom assertion callbacks (required by junit tests). class ErrorTest extends Specification { @Rule StartupErrorRule RULE = StartupErrorRule . create () def \"Check startup error\" () { when: \"starting app with error\" new MyErrApp (). main ([ 'server' ]) then: \"startup failed\" thrown ( RULE . indicatorExceptionType ) RULE . output . contains ( 'stating application' ) RULE . error . contains ( 'some error occur' )","title":"Dropwizard startup error"},{"location":"guide/test/spock/#spock-lifecycle-hooks","text":"class MyTest extends Specification { @ClassRule @Shared JunitRule sharedRule = new JunitRule () @Rule JunitRule2 rule = new JunitRule2 () def setupSpec () { } def setup () { } def \"Test method body\" () { setup: } } Class rules are applied once per test class (same as setupSpec ). Rules are applied per test method (same as setup ). Setup order: Class rule Setup spec method Rule Setup method Test method's setup section","title":"Spock lifecycle hooks"},{"location":"guide/test/spock/#migration-to-spock-2","text":"There is no special extensions for Spock 2, instead junit 5 integrations must be used with it, using special library Current spock extensions are almost equivalent to junit5 extensions (in features and behaviour): Instead of @UseGuiceyApp use @TestGuiceyApp Instead of @UseDropwizardApp use @TestDropwizardApp Hooks can be specified with hooks declaration in extensions or as test fields Instead of StartupErrorRule use system-stubs - the successor of system rules","title":"Migration to Spock 2"},{"location":"guide/test/spock/#client_1","text":"For ClientSupport object, INSTEAD of @Inject ClientSupport client use parameter injection (possibly in fixture methods too): def \"Check something\" ( ClientSupport client ) {}","title":"Client"},{"location":"guide/test/spock/#config-overrides","text":"Junit extension does not require an annotation for each override, so INSTEAD of: @UseDropwizardApp ( value = App , configOverride = [ @ConfigOverride ( key = \"server.rootPath\" , value = \"/rest/*\" ), @ConfigOverride ( key = \"server.applicationContextPath\" , value = \"/prefix\" ), @ConfigOverride ( key = \"server.adminContextPath\" , value = \"/admin\" ) Use: @TestDropwizardApp ( value = App , restMapping = \"/rest/*\" , configOverride = [ \"server.applicationContextPath: /prefix\" , \"server.adminContextPath: /admin\" ]) Note that server.rootPath could be configured with restMapping annotation property.","title":"Config overrides"},{"location":"guide/test/spock/#alternative-declaration","text":"You may also use alternative declaration : class MyTest extends Specification { @RegisterExtension static TestDropwizardAppExtension app = TestDropwizardAppExtension . forApp ( App ) . config ( \"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\" ) . configOverrides ( \"foo: 2\" , \"bar: 12\" ) . randomPorts () . hooks ( Hook ) . hooks ( builder -> builder . disableExtensions ( DummyManaged )) . create () } This is an alternative to previous rules declaration in fields. It is useful when you need dynamic hook (as lambda) or configuration overrides require some other extensions. Note that config override may be registered with Supplier : . configOverride ( \"key\" , () -> { Somewhere . getValue ()}) Warning Don't use @Shared fields instead of static - it wouldn't work! Also non-static field declaration is not supported by junit extension.","title":"Alternative declaration"},{"location":"guide/test/spock2/","text":"Spock 2 \u00b6 Migration from spock 1 There are no special extensions for Spock 2 (like it was for spock 1), instead I did an extra integration library , so you can use existing Junit 5 extensions with spock. Note You are not limited to guicey junit 5 extensions, you can use ( almost ) any junit 5 extensions. And you can use any other spock extensions together with junit extensions. Setup \u00b6 You will need the following dependencies (assuming BOM used for versions management): testImplementation 'ru.vyarus:spock-junit5' testImplementation 'org.spockframework:spock-core:2.3-groovy-3.0' testImplementation 'io.dropwizard:dropwizard-testing' testImplementation 'org.junit.jupiter:junit-jupiter-api' Note In gradle you need to explicitly activate junit 5 support with test { useJUnitPlatform () ... } Usage \u00b6 See junit 5 extensions docs for usage details (it's all used the same). Warning Junit 5 extensions would not work with @Shared spock fields! You can still use such fields directly, but don't expect junit 5 extensions to be able to work with such fields (they can't \"see\" it). Here is a simple example: @TestDropwizardApp ( App ) class MyTest extends Specification { @Inject MyService service def \"Check something\" ( ClientSupport client ) { when: \"calling rest endpoint\" def res = client . targetRest ( \"foo/bar\" ). request () . buildGet (). invoke (). readEntity ( String ) then: \"result correct\" res == \"something\" and: \"service called\" service . isCalled () } } Tip Note that parameter injection will also work in test and fixture (setup/cleanup) methods Overall, you get best of both worlds: same extensions as in junit 5 (and ability to use all other junit extensions) and spock expressiveness for writing tests. Testing commands \u00b6 Warning Commands execution overrides System IO and so can't run in parallel with other tests! Use @Isolated on such tests to prevent parallel execution with other tests Command execution is usually a short-lived action, so it is not possible to write an extension for it. Command could be tested only with generic utility: def \"Test command execution\" () { when : \"executing command\" CommandResult result = TestSupport . buildCommandRunner ( App ) . run ( \"cmd\" , \"-p\" , \"param\" ) then : \"success\" result . successful } Read more details in junit 5 guide Note The same utility could be used to test application startup fails Special cases \u00b6 Junit 5 doc describes system stubs library usage. It is completely valid for spock, I'll just show a few examples here on how to: Modify (and reset) environment variables Modify (and reset) system properties Validate system output (e.g. testing logs) Intercepting system exit @ExtendWith ( SystemStubsExtension ) class StartupErrorTest extends Specification { @SystemStub SystemExit exit @SystemStub SystemErr err def \"Check app crash\" () { when: \"starting app\" exit . execute (() -> { new App (). run ([ 'server' ] as String []) }); then: \"error\" exit . exitCode == 1 err . text . contains ( \"Error message text\" ) } } @ExtendWith ( SystemStubsExtension ) class EnvironmentChangeTest extends Specification { @SystemStub EnvironmentVariables ENV @SystemStub SystemOut out @SystemStub SystemProperties propsReset def \"Check variables mapping\" () { setup: ENV . set ( \"VAR\" , \"1\" ) System . setProperty ( \"foo\" , \"bar\" ) // OR propsReset.set(\"foo\", \"bar\") - both works the same when: // something requiring custom env or property values then: // validate system output (e.g. logs correctness) out . text . contains ( \"Some message assumed to be logged\" ) Note Use test framework-agnostic utilities to run application with configuration or to run application without web part (for faster test).","title":"Spock 2"},{"location":"guide/test/spock2/#spock-2","text":"Migration from spock 1 There are no special extensions for Spock 2 (like it was for spock 1), instead I did an extra integration library , so you can use existing Junit 5 extensions with spock. Note You are not limited to guicey junit 5 extensions, you can use ( almost ) any junit 5 extensions. And you can use any other spock extensions together with junit extensions.","title":"Spock 2"},{"location":"guide/test/spock2/#setup","text":"You will need the following dependencies (assuming BOM used for versions management): testImplementation 'ru.vyarus:spock-junit5' testImplementation 'org.spockframework:spock-core:2.3-groovy-3.0' testImplementation 'io.dropwizard:dropwizard-testing' testImplementation 'org.junit.jupiter:junit-jupiter-api' Note In gradle you need to explicitly activate junit 5 support with test { useJUnitPlatform () ... }","title":"Setup"},{"location":"guide/test/spock2/#usage","text":"See junit 5 extensions docs for usage details (it's all used the same). Warning Junit 5 extensions would not work with @Shared spock fields! You can still use such fields directly, but don't expect junit 5 extensions to be able to work with such fields (they can't \"see\" it). Here is a simple example: @TestDropwizardApp ( App ) class MyTest extends Specification { @Inject MyService service def \"Check something\" ( ClientSupport client ) { when: \"calling rest endpoint\" def res = client . targetRest ( \"foo/bar\" ). request () . buildGet (). invoke (). readEntity ( String ) then: \"result correct\" res == \"something\" and: \"service called\" service . isCalled () } } Tip Note that parameter injection will also work in test and fixture (setup/cleanup) methods Overall, you get best of both worlds: same extensions as in junit 5 (and ability to use all other junit extensions) and spock expressiveness for writing tests.","title":"Usage"},{"location":"guide/test/spock2/#testing-commands","text":"Warning Commands execution overrides System IO and so can't run in parallel with other tests! Use @Isolated on such tests to prevent parallel execution with other tests Command execution is usually a short-lived action, so it is not possible to write an extension for it. Command could be tested only with generic utility: def \"Test command execution\" () { when : \"executing command\" CommandResult result = TestSupport . buildCommandRunner ( App ) . run ( \"cmd\" , \"-p\" , \"param\" ) then : \"success\" result . successful } Read more details in junit 5 guide Note The same utility could be used to test application startup fails","title":"Testing commands"},{"location":"guide/test/spock2/#special-cases","text":"Junit 5 doc describes system stubs library usage. It is completely valid for spock, I'll just show a few examples here on how to: Modify (and reset) environment variables Modify (and reset) system properties Validate system output (e.g. testing logs) Intercepting system exit @ExtendWith ( SystemStubsExtension ) class StartupErrorTest extends Specification { @SystemStub SystemExit exit @SystemStub SystemErr err def \"Check app crash\" () { when: \"starting app\" exit . execute (() -> { new App (). run ([ 'server' ] as String []) }); then: \"error\" exit . exitCode == 1 err . text . contains ( \"Error message text\" ) } } @ExtendWith ( SystemStubsExtension ) class EnvironmentChangeTest extends Specification { @SystemStub EnvironmentVariables ENV @SystemStub SystemOut out @SystemStub SystemProperties propsReset def \"Check variables mapping\" () { setup: ENV . set ( \"VAR\" , \"1\" ) System . setProperty ( \"foo\" , \"bar\" ) // OR propsReset.set(\"foo\", \"bar\") - both works the same when: // something requiring custom env or property values then: // validate system output (e.g. logs correctness) out . text . contains ( \"Some message assumed to be logged\" ) Note Use test framework-agnostic utilities to run application with configuration or to run application without web part (for faster test).","title":"Special cases"},{"location":"installers/eager/","text":"Eager singleton installer \u00b6 CoreInstallersBundle / EagerSingletonInstaller Recognition \u00b6 Detects classes annotated with @EagerSingleton annotation and registers them in guice injector. It is equivalent of eager singleton registration bind ( type ). asEagerSingleton () . Useful in cases when you have a bean which is not injected by other beans (so guice can't register it through aot). Normally, you would have to manually register such bean in module. Most likely, such bean will contain initialization logic. Ideal for cases not directly covered by installers. For example: @EagerSingleton public class MyListener implements LifeCycle . Listener { @Inject public MyListener ( Environment environment ) { environment . lifecicle . addListener ( this ); } } Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener. May be used in conjunction with @PostConstruct annotations (e.g. using ext-annotations ): installer finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should be used for quick prototyping only.","title":"Eager singleton"},{"location":"installers/eager/#eager-singleton-installer","text":"CoreInstallersBundle / EagerSingletonInstaller","title":"Eager singleton installer"},{"location":"installers/eager/#recognition","text":"Detects classes annotated with @EagerSingleton annotation and registers them in guice injector. It is equivalent of eager singleton registration bind ( type ). asEagerSingleton () . Useful in cases when you have a bean which is not injected by other beans (so guice can't register it through aot). Normally, you would have to manually register such bean in module. Most likely, such bean will contain initialization logic. Ideal for cases not directly covered by installers. For example: @EagerSingleton public class MyListener implements LifeCycle . Listener { @Inject public MyListener ( Environment environment ) { environment . lifecicle . addListener ( this ); } } Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener. May be used in conjunction with @PostConstruct annotations (e.g. using ext-annotations ): installer finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should be used for quick prototyping only.","title":"Recognition"},{"location":"installers/filter/","text":"Web filter installer \u00b6 WebInstallersBundle / WebFilterInstaller Register new filter in main or admin contexts. Recognition \u00b6 Detects classes annotated with @javax.servlet.annotation.WebFilter annotation and register them in dropwizard environment. @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Only the following annotation properties are supported: filterName , urlPatterns (or value ), servletNames , dispatcherTypes , initParams , asyncSupported . Warning Url patterns and servlet names can't be used at the same time. Filter name is not required. If name not provided, then it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off. For example, for class \"MyCoolFilter\" generated name will be \".mycool\". Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } There is a difference between using filter installer and registering filters with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata). Async \u00b6 Example of async filter definition: @WebFilter ( urlPatterns = \"/asyncfilter\" , asyncSupported = true ) public class AsyncFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { final AsyncContext context = request . startAsync (); context . start (() -> { context . getResponse (). writer . write ( \"done!\" ); context . complete (); }); } @Override public void destroy () { } } Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters. Admin context \u00b6 By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... }","title":"Web filter"},{"location":"installers/filter/#web-filter-installer","text":"WebInstallersBundle / WebFilterInstaller Register new filter in main or admin contexts.","title":"Web filter installer"},{"location":"installers/filter/#recognition","text":"Detects classes annotated with @javax.servlet.annotation.WebFilter annotation and register them in dropwizard environment. @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Only the following annotation properties are supported: filterName , urlPatterns (or value ), servletNames , dispatcherTypes , initParams , asyncSupported . Warning Url patterns and servlet names can't be used at the same time. Filter name is not required. If name not provided, then it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off. For example, for class \"MyCoolFilter\" generated name will be \".mycool\". Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } There is a difference between using filter installer and registering filters with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).","title":"Recognition"},{"location":"installers/filter/#async","text":"Example of async filter definition: @WebFilter ( urlPatterns = \"/asyncfilter\" , asyncSupported = true ) public class AsyncFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { final AsyncContext context = request . startAsync (); context . start (() -> { context . getResponse (). writer . write ( \"done!\" ); context . complete (); }); } @Override public void destroy () { } } Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters.","title":"Async"},{"location":"installers/filter/#admin-context","text":"By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... }","title":"Admin context"},{"location":"installers/healthcheck/","text":"Health check installer \u00b6 CoreInstallersBundle / HealthCheckInstaller Installs dropwizard health check . Recognition \u00b6 Detects classes extending guicey NamedHealthCheck and register their instances in environment. Custom base class is required, because default HealthCheck did not provide check name, which is required for registration. public class MyHealthCheck extends NamedHealthCheck { @Inject private MyService service ; @Override protected Result check () throws Exception { if ( service . isOk ()) { return Result . healthy (); } else { return Result . unhealthy ( \"Service is not ok\" ); } } @Override public String getName () { return \"my-service\" ; } }","title":"Health check"},{"location":"installers/healthcheck/#health-check-installer","text":"CoreInstallersBundle / HealthCheckInstaller Installs dropwizard health check .","title":"Health check installer"},{"location":"installers/healthcheck/#recognition","text":"Detects classes extending guicey NamedHealthCheck and register their instances in environment. Custom base class is required, because default HealthCheck did not provide check name, which is required for registration. public class MyHealthCheck extends NamedHealthCheck { @Inject private MyService service ; @Override protected Result check () throws Exception { if ( service . isOk ()) { return Result . healthy (); } else { return Result . unhealthy ( \"Service is not ok\" ); } } @Override public String getName () { return \"my-service\" ; } }","title":"Recognition"},{"location":"installers/jersey-ext/","text":"Jersey extension installer \u00b6 CoreInstallersBundle / JerseyProviderInstaller Installs various jersey extensions, usually annotated with jersey @Provider annotation and installed via environment . jersey (). register () : Supplier, ExceptionMapper, ValueParamProvider, InjectionResolver, ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener, ModelProcessor Recognition \u00b6 Detects known jersey extension classes and classes annotated with jersey @javax.ws.rs.ext.Provider annotation and register their instances in jersey. Extensions registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Before guicey 5.7.0 it was required to annotate all extensions with @Provide , but now it is not required - extension would be recognized by implemented interface. But, if you prefer legacy behaviour then it could be reverted with: . option ( InstallersOptions . JerseyExtensionsRecognizedByType , false ) Special @Prototype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used). Due to specifics of HK2 integration , you may need to use: @JerseyManaged to delegate bean creation to HK2 @LazyBinding to delay bean creation to time when all dependencies will be available javax.inject.Provider as universal workaround (to wrap not immediately available dependency). Or you can enable HK2 management for jersey extensions by default . Note that this will affect resources too and guice aop will not work on jersey extensions. Priority \u00b6 By default, all registered providers are qualified with @org.glassfish.jersey.internal.inject.Custom to prioritize them (be able to override dropwizard defaults). This mimics the default behaviour of manual registration with environment . jersey (). register (...) . For example, when you register your own ExceptionMapper<Throwable> it would be used instead of default dropwizard one (due to prioritized qualification). For more details see org.glassfish.jersey.internal.inject.Providers#getAllServiceHolders( org.glassfish.jersey.internal.inject.InjectionManager, java.lang.Class) which is used by jersey for providers loading. Tip Previously (<= 5.2.0) guicey were not qualifying providers and qualification may (unlikely, but can!) introduce behaviour changes on guicey upgrade (due to prioritized custom providers). In this case, auto qualification may be disabled with . option ( InstallerOptions . PrioritizeJerseyExtensions , false ) to revert to legacy guicey behaviour. @Custom may be used directly in this case on some providers for prioritization. @Priority annotation may be used for ordering providers. Value should be > 0 (but may be negative, just a convention). For example, 1000 is prioritized before 2000. See javax.ws.rs.Priorities for default priority constants. Note @Priority may work differently on @Custom qualified providers (all user providers by default) and unqualified (e.g. registered through hk module, like dropwizard defaults). Right now, qualified providers sorted ascending while unqualified sorted descending (due to different selection implementations, see getAllServiceHolders reference above). Probably a jersey bug. Supplier \u00b6 Warning Supplier is used now by hk2 as a replacement to its own Factory interface. If you were using AbstractContainerRequestValueFactory then use just Supplier<T> instead. Any class implementing java . util . function . Supplier (or extending abstract class implementing it). public class MySupplier implements Supplier < MyModel > { @Override public MyModel get () { ... } } Suppliers in essence are very like guice (or javax.inject ) providers ( Provider ). Warning Previously, factories were used as auth objects providers. Now Function<ContainerRequest, ?> must be used instead: @Provider class AuthFactory implements Function < ContainerRequest , User > { @Override public User apply ( ContainerRequest containerRequest ) { return new User (); } } ExceptionMapper \u00b6 Any class implementing javax . ws . rs . ext . ExceptionMapper (or extending abstract class implementing it). Useful for error handling customization . public class DummyExceptionMapper implements ExceptionMapper < RuntimeException > { private final Logger logger = LoggerFactory . getLogger ( DummyExceptionMapper . class ); @Override public Response toResponse ( RuntimeException e ) { logger . debug ( \"Problem while executing\" , e ); return Response . status ( Response . Status . BAD_REQUEST ) . type ( MediaType . TEXT_PLAIN ) . entity ( e . getMessage ()) . build (); } } Tip You can also use ExtendedExceptionMapper as more flexible alternative. See example usage in dropwizard-views . Tip Default exception dropwizard mappers (registered in io.dropwizard.setup.ExceptionMapperBinder ) could be overridden (see priority section ) or completely disabled with server.registerDefaultExceptionMappers option. ValueParamProvider \u00b6 Any class implementing org . glassfish . jersey . server . spi . internal . ValueParamProvider (or extending abstract class implementing it). public class AuthFactoryProvider extends AbstractValueParamProvider { private final AuthFactory authFactory ; @Inject public AuthFactoryProvider ( final javax . inject . Provider < MultivaluedParameterExtractorProvider > extractorProvider , final AuthFactory factory ) { super ( extractorProvider , Parameter . Source . UNKNOWN ); this . authFactory = factory ; } @Override protected Function < ContainerRequest , User > createValueProvider ( Parameter parameter ) { final Auth auth = parameter . getAnnotation ( Auth . class ); return auth != null ? authFactory : null ; } } InjectionResolver \u00b6 Any class implementing org . glassfish . hk2 . api . InjectionResolver (or extending abstract class implementing it). class MyObjInjectionResolver implements InjectionResolver < MyObjAnn > { @Override public Object resolve ( Injectee injectee ) { return new MyObj (); } @Override public Class < MyObjAnn > getAnnotation () { return MyObjAnn . class ; } @Override public boolean isConstructorParameterIndicator () { return false ; } @Override public boolean isMethodParameterIndicator () { return true ; } } ParamConverterProvider \u00b6 Any class implementing javax . ws . rs . ext . ParamConverterProvider (or extending abstract class implementing it). public class FooParamConverter implements ParamConverterProvider { @Override public < T > ParamConverter < T > getConverter ( Class < T > rawType , Type genericType , Annotation [] annotations ) { if ( Foo . class . isAssignableFrom ( rawType )) { return ( ParamConverter < T > ) new FooConverter (); } return null ; } private static class FooConverter implements ParamConverter < Foo > { @Override public Foo fromString ( String value ) { return new Foo ( value ); } @Override public String toString ( Foo value ) { return value . value ; } } } ContextResolver \u00b6 Any class implementing javax . ws . rs . ext . ContextResolver (or extending abstract class implementing it). public class MyContextResolver implements ContextResolver < Context > { @Override public Context getContext ( Class type ) { return new Context (); } public static class Context {} } MessageBodyReader \u00b6 Any class implementing javax . ws . rs . ext . MessageBodyReader (or extending abstract class implementing it). Useful for custom representations . public class TypeMessageBodyReader implements MessageBodyReader < Type > { @Override public boolean isReadable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public Type readFrom ( Class < Type > type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , String > httpHeaders , InputStream entityStream ) throws IOException , WebApplicationException { return null ; } public static class Type {} } MessageBodyWriter \u00b6 Any class implementing javax . ws . rs . ext . MessageBodyWriter (or extending abstract class implementing it). Useful for custom representations . public class TypeMessageBodyWriter implements MessageBodyWriter < Type > { @Override public boolean isWriteable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public long getSize ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return 0 ; } @Override public void writeTo ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , Object > httpHeaders , OutputStream entityStream ) throws IOException , WebApplicationException { } public static class Type {} } ReaderInterceptor \u00b6 Any class implementing javax . ws . rs . ext . ReaderInterceptor (or extending abstract class implementing it). public class MyReaderInterceptor implements ReaderInterceptor { @Override public Object aroundReadFrom ( ReaderInterceptorContext context ) throws IOException , WebApplicationException { return null ; } } WriterInterceptor \u00b6 Any class implementing javax . ws . rs . ext . WriterInterceptor (or extending abstract class implementing it). public class MyWriterInterceptor implements WriterInterceptor { @Override void aroundWriteTo ( WriterInterceptorContext context ) throws IOException , WebApplicationException { } } ContainerRequestFilter \u00b6 Any class implementing javax . ws . rs . container . ContainerRequestFilter (or extending abstract class implementing it). Useful for request modifications . public class MyContainerRequestFilter implements ContainerRequestFilter { @Override public void filter ( ContainerRequestContext requestContext ) throws IOException { } } ContainerResponseFilter \u00b6 Any class implementing javax . ws . rs . container . ContainerResponseFilter (or extending abstract class implementing it). Useful for response modifications . public class MyContainerResponseFilter implements ContainerResponseFilter { @Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { } } DynamicFeature \u00b6 Any class implementing javax . ws . rs . container . DynamicFeature (or extending abstract class implementing it). Useful for conditional activation of filters . public class MyDynamicFeature implements DynamicFeature { @Override public void configure ( ResourceInfo resourceInfo , FeatureContext context ) { } } ApplicationEventListener \u00b6 Any class implementing org . glassfish . jersey . server . monitoring . ApplicationEventListener (or extending abstract class implementing it). public class MyApplicationEventListener implements ApplicationEventListener { @Override public void onEvent ( ApplicationEvent event ) { } @Override public RequestEventListener onRequest ( RequestEvent requestEvent ) { return null ; } } ModelProcessor \u00b6 Any class implementing org . glassfish . jersey . server . model . ModelProcessor (or extending abstract class implementing it). public class MyModelProcessor implements ModelProcessor { @Override public ResourceModel processResourceModel ( ResourceModel resourceModel , Configuration configuration ) { return resourceModel ; } @Override public ResourceModel processSubResource ( ResourceModel subResourceModel , Configuration configuration ) { return subResourceModel ; } }","title":"Jersey extension"},{"location":"installers/jersey-ext/#jersey-extension-installer","text":"CoreInstallersBundle / JerseyProviderInstaller Installs various jersey extensions, usually annotated with jersey @Provider annotation and installed via environment . jersey (). register () : Supplier, ExceptionMapper, ValueParamProvider, InjectionResolver, ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener, ModelProcessor","title":"Jersey extension installer"},{"location":"installers/jersey-ext/#recognition","text":"Detects known jersey extension classes and classes annotated with jersey @javax.ws.rs.ext.Provider annotation and register their instances in jersey. Extensions registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Before guicey 5.7.0 it was required to annotate all extensions with @Provide , but now it is not required - extension would be recognized by implemented interface. But, if you prefer legacy behaviour then it could be reverted with: . option ( InstallersOptions . JerseyExtensionsRecognizedByType , false ) Special @Prototype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used). Due to specifics of HK2 integration , you may need to use: @JerseyManaged to delegate bean creation to HK2 @LazyBinding to delay bean creation to time when all dependencies will be available javax.inject.Provider as universal workaround (to wrap not immediately available dependency). Or you can enable HK2 management for jersey extensions by default . Note that this will affect resources too and guice aop will not work on jersey extensions.","title":"Recognition"},{"location":"installers/jersey-ext/#priority","text":"By default, all registered providers are qualified with @org.glassfish.jersey.internal.inject.Custom to prioritize them (be able to override dropwizard defaults). This mimics the default behaviour of manual registration with environment . jersey (). register (...) . For example, when you register your own ExceptionMapper<Throwable> it would be used instead of default dropwizard one (due to prioritized qualification). For more details see org.glassfish.jersey.internal.inject.Providers#getAllServiceHolders( org.glassfish.jersey.internal.inject.InjectionManager, java.lang.Class) which is used by jersey for providers loading. Tip Previously (<= 5.2.0) guicey were not qualifying providers and qualification may (unlikely, but can!) introduce behaviour changes on guicey upgrade (due to prioritized custom providers). In this case, auto qualification may be disabled with . option ( InstallerOptions . PrioritizeJerseyExtensions , false ) to revert to legacy guicey behaviour. @Custom may be used directly in this case on some providers for prioritization. @Priority annotation may be used for ordering providers. Value should be > 0 (but may be negative, just a convention). For example, 1000 is prioritized before 2000. See javax.ws.rs.Priorities for default priority constants. Note @Priority may work differently on @Custom qualified providers (all user providers by default) and unqualified (e.g. registered through hk module, like dropwizard defaults). Right now, qualified providers sorted ascending while unqualified sorted descending (due to different selection implementations, see getAllServiceHolders reference above). Probably a jersey bug.","title":"Priority"},{"location":"installers/jersey-ext/#supplier","text":"Warning Supplier is used now by hk2 as a replacement to its own Factory interface. If you were using AbstractContainerRequestValueFactory then use just Supplier<T> instead. Any class implementing java . util . function . Supplier (or extending abstract class implementing it). public class MySupplier implements Supplier < MyModel > { @Override public MyModel get () { ... } } Suppliers in essence are very like guice (or javax.inject ) providers ( Provider ). Warning Previously, factories were used as auth objects providers. Now Function<ContainerRequest, ?> must be used instead: @Provider class AuthFactory implements Function < ContainerRequest , User > { @Override public User apply ( ContainerRequest containerRequest ) { return new User (); } }","title":"Supplier"},{"location":"installers/jersey-ext/#exceptionmapper","text":"Any class implementing javax . ws . rs . ext . ExceptionMapper (or extending abstract class implementing it). Useful for error handling customization . public class DummyExceptionMapper implements ExceptionMapper < RuntimeException > { private final Logger logger = LoggerFactory . getLogger ( DummyExceptionMapper . class ); @Override public Response toResponse ( RuntimeException e ) { logger . debug ( \"Problem while executing\" , e ); return Response . status ( Response . Status . BAD_REQUEST ) . type ( MediaType . TEXT_PLAIN ) . entity ( e . getMessage ()) . build (); } } Tip You can also use ExtendedExceptionMapper as more flexible alternative. See example usage in dropwizard-views . Tip Default exception dropwizard mappers (registered in io.dropwizard.setup.ExceptionMapperBinder ) could be overridden (see priority section ) or completely disabled with server.registerDefaultExceptionMappers option.","title":"ExceptionMapper"},{"location":"installers/jersey-ext/#valueparamprovider","text":"Any class implementing org . glassfish . jersey . server . spi . internal . ValueParamProvider (or extending abstract class implementing it). public class AuthFactoryProvider extends AbstractValueParamProvider { private final AuthFactory authFactory ; @Inject public AuthFactoryProvider ( final javax . inject . Provider < MultivaluedParameterExtractorProvider > extractorProvider , final AuthFactory factory ) { super ( extractorProvider , Parameter . Source . UNKNOWN ); this . authFactory = factory ; } @Override protected Function < ContainerRequest , User > createValueProvider ( Parameter parameter ) { final Auth auth = parameter . getAnnotation ( Auth . class ); return auth != null ? authFactory : null ; } }","title":"ValueParamProvider"},{"location":"installers/jersey-ext/#injectionresolver","text":"Any class implementing org . glassfish . hk2 . api . InjectionResolver (or extending abstract class implementing it). class MyObjInjectionResolver implements InjectionResolver < MyObjAnn > { @Override public Object resolve ( Injectee injectee ) { return new MyObj (); } @Override public Class < MyObjAnn > getAnnotation () { return MyObjAnn . class ; } @Override public boolean isConstructorParameterIndicator () { return false ; } @Override public boolean isMethodParameterIndicator () { return true ; } }","title":"InjectionResolver"},{"location":"installers/jersey-ext/#paramconverterprovider","text":"Any class implementing javax . ws . rs . ext . ParamConverterProvider (or extending abstract class implementing it). public class FooParamConverter implements ParamConverterProvider { @Override public < T > ParamConverter < T > getConverter ( Class < T > rawType , Type genericType , Annotation [] annotations ) { if ( Foo . class . isAssignableFrom ( rawType )) { return ( ParamConverter < T > ) new FooConverter (); } return null ; } private static class FooConverter implements ParamConverter < Foo > { @Override public Foo fromString ( String value ) { return new Foo ( value ); } @Override public String toString ( Foo value ) { return value . value ; } } }","title":"ParamConverterProvider"},{"location":"installers/jersey-ext/#contextresolver","text":"Any class implementing javax . ws . rs . ext . ContextResolver (or extending abstract class implementing it). public class MyContextResolver implements ContextResolver < Context > { @Override public Context getContext ( Class type ) { return new Context (); } public static class Context {} }","title":"ContextResolver"},{"location":"installers/jersey-ext/#messagebodyreader","text":"Any class implementing javax . ws . rs . ext . MessageBodyReader (or extending abstract class implementing it). Useful for custom representations . public class TypeMessageBodyReader implements MessageBodyReader < Type > { @Override public boolean isReadable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public Type readFrom ( Class < Type > type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , String > httpHeaders , InputStream entityStream ) throws IOException , WebApplicationException { return null ; } public static class Type {} }","title":"MessageBodyReader"},{"location":"installers/jersey-ext/#messagebodywriter","text":"Any class implementing javax . ws . rs . ext . MessageBodyWriter (or extending abstract class implementing it). Useful for custom representations . public class TypeMessageBodyWriter implements MessageBodyWriter < Type > { @Override public boolean isWriteable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public long getSize ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return 0 ; } @Override public void writeTo ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , Object > httpHeaders , OutputStream entityStream ) throws IOException , WebApplicationException { } public static class Type {} }","title":"MessageBodyWriter"},{"location":"installers/jersey-ext/#readerinterceptor","text":"Any class implementing javax . ws . rs . ext . ReaderInterceptor (or extending abstract class implementing it). public class MyReaderInterceptor implements ReaderInterceptor { @Override public Object aroundReadFrom ( ReaderInterceptorContext context ) throws IOException , WebApplicationException { return null ; } }","title":"ReaderInterceptor"},{"location":"installers/jersey-ext/#writerinterceptor","text":"Any class implementing javax . ws . rs . ext . WriterInterceptor (or extending abstract class implementing it). public class MyWriterInterceptor implements WriterInterceptor { @Override void aroundWriteTo ( WriterInterceptorContext context ) throws IOException , WebApplicationException { } }","title":"WriterInterceptor"},{"location":"installers/jersey-ext/#containerrequestfilter","text":"Any class implementing javax . ws . rs . container . ContainerRequestFilter (or extending abstract class implementing it). Useful for request modifications . public class MyContainerRequestFilter implements ContainerRequestFilter { @Override public void filter ( ContainerRequestContext requestContext ) throws IOException { } }","title":"ContainerRequestFilter"},{"location":"installers/jersey-ext/#containerresponsefilter","text":"Any class implementing javax . ws . rs . container . ContainerResponseFilter (or extending abstract class implementing it). Useful for response modifications . public class MyContainerResponseFilter implements ContainerResponseFilter { @Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { } }","title":"ContainerResponseFilter"},{"location":"installers/jersey-ext/#dynamicfeature","text":"Any class implementing javax . ws . rs . container . DynamicFeature (or extending abstract class implementing it). Useful for conditional activation of filters . public class MyDynamicFeature implements DynamicFeature { @Override public void configure ( ResourceInfo resourceInfo , FeatureContext context ) { } }","title":"DynamicFeature"},{"location":"installers/jersey-ext/#applicationeventlistener","text":"Any class implementing org . glassfish . jersey . server . monitoring . ApplicationEventListener (or extending abstract class implementing it). public class MyApplicationEventListener implements ApplicationEventListener { @Override public void onEvent ( ApplicationEvent event ) { } @Override public RequestEventListener onRequest ( RequestEvent requestEvent ) { return null ; } }","title":"ApplicationEventListener"},{"location":"installers/jersey-ext/#modelprocessor","text":"Any class implementing org . glassfish . jersey . server . model . ModelProcessor (or extending abstract class implementing it). public class MyModelProcessor implements ModelProcessor { @Override public ResourceModel processResourceModel ( ResourceModel resourceModel , Configuration configuration ) { return resourceModel ; } @Override public ResourceModel processSubResource ( ResourceModel subResourceModel , Configuration configuration ) { return subResourceModel ; } }","title":"ModelProcessor"},{"location":"installers/jersey-feature/","text":"Jersey feature installer \u00b6 CoreInstallersBundle / JerseyFeatureInstaller Recognition \u00b6 Detects classes implementing javax . ws . rs . core . Feature and register their instances in jersey. It may be useful to configure jersey inside guice components: public class MyClass { ... public static class ConfigurationFeature implements Feature { @Override public boolean configure ( FeatureContext context ) { context . register ( RolesAllowedDynamicFeature . class ); context . register ( new AuthValueFactoryProvider . Binder ( User . class )); return true ; } } } Inner classes are also recognized by classpath scan. But often the same could be achieved by injecting Environment instance. @Singleton public class MyClass { @Inject public MyClass ( Environment environment ) { environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } }","title":"Jersey feature"},{"location":"installers/jersey-feature/#jersey-feature-installer","text":"CoreInstallersBundle / JerseyFeatureInstaller","title":"Jersey feature installer"},{"location":"installers/jersey-feature/#recognition","text":"Detects classes implementing javax . ws . rs . core . Feature and register their instances in jersey. It may be useful to configure jersey inside guice components: public class MyClass { ... public static class ConfigurationFeature implements Feature { @Override public boolean configure ( FeatureContext context ) { context . register ( RolesAllowedDynamicFeature . class ); context . register ( new AuthValueFactoryProvider . Binder ( User . class )); return true ; } } } Inner classes are also recognized by classpath scan. But often the same could be achieved by injecting Environment instance. @Singleton public class MyClass { @Inject public MyClass ( Environment environment ) { environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } }","title":"Recognition"},{"location":"installers/lifecycle/","text":"Lifecycle installer \u00b6 CoreInstallersBundle / LifeCycleInstaller Installs jetty LifeCycle implementations. Recognition \u00b6 Detects classes implementing jetty LifeCycle interface and register their instances in environment. public class MyCycle implements LifeCycle { ... } In most cases it's better to use managed object instead of implementing lifecycle. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyCycle implements LifeCycle","title":"Lifecycle"},{"location":"installers/lifecycle/#lifecycle-installer","text":"CoreInstallersBundle / LifeCycleInstaller Installs jetty LifeCycle implementations.","title":"Lifecycle installer"},{"location":"installers/lifecycle/#recognition","text":"Detects classes implementing jetty LifeCycle interface and register their instances in environment. public class MyCycle implements LifeCycle { ... } In most cases it's better to use managed object instead of implementing lifecycle. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyCycle implements LifeCycle","title":"Recognition"},{"location":"installers/listener/","text":"Web listener installer \u00b6 WebInstallersBundle / WebListenerInstaller Register new web listener in main or admin contexts. Recognition \u00b6 Detects classes annotated with @javax.servlet.annotation.WebListener annotation and register them in dropwizard environment. @WebListener public class MyListener implements ServletContextListener , ServletRequestListener {...} Listener could implement multiple listener interfaces and all types will be registered. Supported listeners (the same as declared in annotation): javax.servlet.ServletContextListener javax.servlet.ServletContextAttributeListener javax.servlet.ServletRequestListener javax.servlet.ServletRequestAttributeListener javax.servlet.http.HttpSessionListener javax.servlet.http.HttpSessionAttributeListener javax.servlet.http.HttpSessionIdListener By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support then warning will be logged (and servlet listeners will actually not be registered). Error is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work). If you want to throw exception in such case, use special option: bundle . option ( InstallersOptions . DenySessionListenersWithoutSession , true ) Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebListener public class MyListener implements ServletContextListener {...} Admin context \u00b6 By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebListener public class MyListener implements ServletContextListener {...} Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebListener public class MyListener implements ServletContextListener {...}","title":"Web listener"},{"location":"installers/listener/#web-listener-installer","text":"WebInstallersBundle / WebListenerInstaller Register new web listener in main or admin contexts.","title":"Web listener installer"},{"location":"installers/listener/#recognition","text":"Detects classes annotated with @javax.servlet.annotation.WebListener annotation and register them in dropwizard environment. @WebListener public class MyListener implements ServletContextListener , ServletRequestListener {...} Listener could implement multiple listener interfaces and all types will be registered. Supported listeners (the same as declared in annotation): javax.servlet.ServletContextListener javax.servlet.ServletContextAttributeListener javax.servlet.ServletRequestListener javax.servlet.ServletRequestAttributeListener javax.servlet.http.HttpSessionListener javax.servlet.http.HttpSessionAttributeListener javax.servlet.http.HttpSessionIdListener By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support then warning will be logged (and servlet listeners will actually not be registered). Error is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work). If you want to throw exception in such case, use special option: bundle . option ( InstallersOptions . DenySessionListenersWithoutSession , true ) Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebListener public class MyListener implements ServletContextListener {...}","title":"Recognition"},{"location":"installers/listener/#admin-context","text":"By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebListener public class MyListener implements ServletContextListener {...} Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebListener public class MyListener implements ServletContextListener {...}","title":"Admin context"},{"location":"installers/managed/","text":"Managed installer \u00b6 CoreInstallersBundle / ManagedInstaller Installs dropwizard managed objects . Recognition \u00b6 Detects classes implementing dropwizard Managed and register their instances in environment. public class MyService implements Managed { @Override public void start () throws Exception { ... } @Override public void stop () throws Exception { ... } } It is perfect for implementing guice service lifecycle . Tip Alternatively you can use @PostConstruct and @PreDestroy annotations inside guice beans with lifecycle-annotations extension module. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyService implements Managed","title":"Managed"},{"location":"installers/managed/#managed-installer","text":"CoreInstallersBundle / ManagedInstaller Installs dropwizard managed objects .","title":"Managed installer"},{"location":"installers/managed/#recognition","text":"Detects classes implementing dropwizard Managed and register their instances in environment. public class MyService implements Managed { @Override public void start () throws Exception { ... } @Override public void stop () throws Exception { ... } } It is perfect for implementing guice service lifecycle . Tip Alternatively you can use @PostConstruct and @PreDestroy annotations inside guice beans with lifecycle-annotations extension module. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyService implements Managed","title":"Recognition"},{"location":"installers/plugin/","text":"Plugin installer \u00b6 CoreInstallersBundle / PluginInstaller Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case). Recognition \u00b6 Detects classes annotated with guicey @Plugin annotation and bind them into set or map using guice multibindings mechanism. Suppose you have plugin interface public interface PluginInterface . Annotate plugin implementations with @Plugin : @Plugin ( PluginInterface . class ) public class PluginImpl1 implements PluginInterface Now all implementations could be autowired as @Inject Set < PluginInterface > plugins ; Warning At least one implementation must be provided because otherwise guicey will not be able to register Set binding and guice startup will fail. If no plugins situation is possible, then you will have to manually register empty (default) plugins binding: public class MyModule extends AbstractModule { @Override protected configure () { Multibinder . newSetBinder ( binder (), PluginInterface . class ); } } Guicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting. Named plugins \u00b6 Sometimes it's required to have named plugin mapping: to bind, Map instead of simple set. For example, when you have multiple authorization providers and each provider implementation must be registered with name. Most likely, you would use enum for keys: public enum PluginKey { FIRST , SECOND } Custom plugin annotation needs to be defined to use new keys: @Plugin ( PluginInterface . class ) @Target ( ElementType . TYPE ) @Retention ( RetentionPolicy . RUNTIME ) public @interface MyPlugin { PluginKey value (); } Note Annotation itself is annotated with @Plugin , defining target plugin interface. Guicey will detect your custom annotation usage by analyzing its annotations. Annotating plugin implementation: @MyPlugin ( PluginKey . FIRST ) public class PluginImpl1 implements PluginInterface All plugins could be referenced as map: @Inject Map < PluginKey , PluginInterface > plugins ; Note It's not required to use enum as key. Any type could be set in your custom annotation. For example, string key could be used: public @interface MyPlugin { String value (); } @MyPlugin ( \"first\" ) public class PluginImpl1 implements PluginInterface @Inject Map < String , PluginInterface > plugins ; Warning As with simple plugin bindings, at least one plugin must be registered so guice could create map binding. Otherwise, you need to manually declare empty (default) plugins map binding: MapBinder . newMapBinder ( binder , keyType , pluginType );","title":"Plugin"},{"location":"installers/plugin/#plugin-installer","text":"CoreInstallersBundle / PluginInstaller Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).","title":"Plugin installer"},{"location":"installers/plugin/#recognition","text":"Detects classes annotated with guicey @Plugin annotation and bind them into set or map using guice multibindings mechanism. Suppose you have plugin interface public interface PluginInterface . Annotate plugin implementations with @Plugin : @Plugin ( PluginInterface . class ) public class PluginImpl1 implements PluginInterface Now all implementations could be autowired as @Inject Set < PluginInterface > plugins ; Warning At least one implementation must be provided because otherwise guicey will not be able to register Set binding and guice startup will fail. If no plugins situation is possible, then you will have to manually register empty (default) plugins binding: public class MyModule extends AbstractModule { @Override protected configure () { Multibinder . newSetBinder ( binder (), PluginInterface . class ); } } Guicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting.","title":"Recognition"},{"location":"installers/plugin/#named-plugins","text":"Sometimes it's required to have named plugin mapping: to bind, Map instead of simple set. For example, when you have multiple authorization providers and each provider implementation must be registered with name. Most likely, you would use enum for keys: public enum PluginKey { FIRST , SECOND } Custom plugin annotation needs to be defined to use new keys: @Plugin ( PluginInterface . class ) @Target ( ElementType . TYPE ) @Retention ( RetentionPolicy . RUNTIME ) public @interface MyPlugin { PluginKey value (); } Note Annotation itself is annotated with @Plugin , defining target plugin interface. Guicey will detect your custom annotation usage by analyzing its annotations. Annotating plugin implementation: @MyPlugin ( PluginKey . FIRST ) public class PluginImpl1 implements PluginInterface All plugins could be referenced as map: @Inject Map < PluginKey , PluginInterface > plugins ; Note It's not required to use enum as key. Any type could be set in your custom annotation. For example, string key could be used: public @interface MyPlugin { String value (); } @MyPlugin ( \"first\" ) public class PluginImpl1 implements PluginInterface @Inject Map < String , PluginInterface > plugins ; Warning As with simple plugin bindings, at least one plugin must be registered so guice could create map binding. Otherwise, you need to manually declare empty (default) plugins map binding: MapBinder . newMapBinder ( binder , keyType , pluginType );","title":"Named plugins"},{"location":"installers/resource/","text":"Resource installer \u00b6 CoreInstallersBundle / ResourceInstaller Installs rest resources . Recognition \u00b6 Detects classes annotated with jax-rs @Path annotation and register them as rest resources. Guice will manage resource creation, so you may think of it as usual guice bean. @Path ( \"/res\" ) @Produces ( ' application / json ' ) class SampleResource { @Inject private MyService service ; @GET @Path ( \"/sample\" ) public Response sample () { return Response . ok ( service . result ()). build (); } } Resources registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Special @Prototype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used). Interface recognition \u00b6 Class will also be recognized if @Path annotation found on directly implemented interface. @Path ( \"/res\" ) @Produces ( ' application / json ' ) interface ResourceContract { @GET @Path ( \"/sample\" ) String sample (); } class SampleResource implements ResourceContract { @Inject private MyService service ; @Override public Response sample () { return Response . ok ( service . result ()). build (); } } Annotations on interfaces are useful for jersey client proxies Client client = ClientBuilder . newClient (); ResourceContract resource = WebResourceFactory . newResource ( ResourceContract . class , client . target ( \"http://localhost:8080/\" )); // call sample method on remote resource http://localhost:8080/res/sample String result = resource . sample (); Jersey client proxies requires extra dependency org.glassfish.jersey.ext:jersey-proxy-client Request scope bindings \u00b6 If you need request scoped objects, use Provider : class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/sample\" ) public Response sample () { HttpServletRequest request = requestProvider . get (); ... } See jersey objects, available for injection . @Context usage \u00b6 @Context annotation usage is a common point of confusion. You can't use it for class fields: this will not work public class MyResource { @Context UriInfo info ; } Use provider instead: correct way public class MyResource { @Inject Provider < UriInfo > infoProvider ; } But, you can use @Context on method parameters: public class MyResource { @GET public Response get ( @Context UriInfo info ) { ... } } Jersey managed resource \u00b6 If resource class is annotated with @JerseyManaged then jersey HK2 container will manage bean creation instead of guice. Injection of guice managed beans could still be possible via registered HK2-guice-bridge , but guice aop features will not work. Note You can manage resources with HK2 by default , but this will also affect all jersey extensions @Path ( \"/res\" ) @Produces ( ' application / json ' ) @JerseyManaged class SampleResource { ... } @Context annotation on field will work on HK2 managed bean: @Path () @JerseyManaged public class MyResource { @Context UriInfo info ; }","title":"Resource"},{"location":"installers/resource/#resource-installer","text":"CoreInstallersBundle / ResourceInstaller Installs rest resources .","title":"Resource installer"},{"location":"installers/resource/#recognition","text":"Detects classes annotated with jax-rs @Path annotation and register them as rest resources. Guice will manage resource creation, so you may think of it as usual guice bean. @Path ( \"/res\" ) @Produces ( ' application / json ' ) class SampleResource { @Inject private MyService service ; @GET @Path ( \"/sample\" ) public Response sample () { return Response . ok ( service . result ()). build (); } } Resources registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Special @Prototype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used).","title":"Recognition"},{"location":"installers/resource/#interface-recognition","text":"Class will also be recognized if @Path annotation found on directly implemented interface. @Path ( \"/res\" ) @Produces ( ' application / json ' ) interface ResourceContract { @GET @Path ( \"/sample\" ) String sample (); } class SampleResource implements ResourceContract { @Inject private MyService service ; @Override public Response sample () { return Response . ok ( service . result ()). build (); } } Annotations on interfaces are useful for jersey client proxies Client client = ClientBuilder . newClient (); ResourceContract resource = WebResourceFactory . newResource ( ResourceContract . class , client . target ( \"http://localhost:8080/\" )); // call sample method on remote resource http://localhost:8080/res/sample String result = resource . sample (); Jersey client proxies requires extra dependency org.glassfish.jersey.ext:jersey-proxy-client","title":"Interface recognition"},{"location":"installers/resource/#request-scope-bindings","text":"If you need request scoped objects, use Provider : class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/sample\" ) public Response sample () { HttpServletRequest request = requestProvider . get (); ... } See jersey objects, available for injection .","title":"Request scope bindings"},{"location":"installers/resource/#context-usage","text":"@Context annotation usage is a common point of confusion. You can't use it for class fields: this will not work public class MyResource { @Context UriInfo info ; } Use provider instead: correct way public class MyResource { @Inject Provider < UriInfo > infoProvider ; } But, you can use @Context on method parameters: public class MyResource { @GET public Response get ( @Context UriInfo info ) { ... } }","title":"@Context usage"},{"location":"installers/resource/#jersey-managed-resource","text":"If resource class is annotated with @JerseyManaged then jersey HK2 container will manage bean creation instead of guice. Injection of guice managed beans could still be possible via registered HK2-guice-bridge , but guice aop features will not work. Note You can manage resources with HK2 by default , but this will also affect all jersey extensions @Path ( \"/res\" ) @Produces ( ' application / json ' ) @JerseyManaged class SampleResource { ... } @Context annotation on field will work on HK2 managed bean: @Path () @JerseyManaged public class MyResource { @Context UriInfo info ; }","title":"Jersey managed resource"},{"location":"installers/servlet/","text":"Web servlet installer \u00b6 WebInstallersBundle / WebServletInstaller Register new servlet in main or admin contexts. Recognition \u00b6 Detects classes annotated with @javax.servlet.annotation.WebServlet annotation and register them in dropwizard environment. @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Only the following annotation properties are supported: name , urlPatterns (or value ), initParams , asyncSupported . Servlet name is not required. If name not provided, it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off. For example, for class \"MyCoolServlet\" generated name will be \".mycool\". Warning One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings. If you want to throw exception in this case, use special option: bundle . option ( InstallersOptions . DenyServletRegistrationWithClash , true ) Note that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later (and so exception will not be thrown). Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet There is a difference between using servlet installer and registering servlets with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata). Async \u00b6 Example of async servlet definition: @WebServlet ( urlPatterns = \"/async\" , asyncSupported = true ) public class AsyncServlet extends HttpServlet { @Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { final AsyncContext context = req . startAsync (); context . start (() -> { context . getResponse (). getWriter (). write ( \"done!\" ); context . complete (); }); } } Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets. Admin context \u00b6 By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Will install servlet in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... }","title":"Web servlet"},{"location":"installers/servlet/#web-servlet-installer","text":"WebInstallersBundle / WebServletInstaller Register new servlet in main or admin contexts.","title":"Web servlet installer"},{"location":"installers/servlet/#recognition","text":"Detects classes annotated with @javax.servlet.annotation.WebServlet annotation and register them in dropwizard environment. @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Only the following annotation properties are supported: name , urlPatterns (or value ), initParams , asyncSupported . Servlet name is not required. If name not provided, it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off. For example, for class \"MyCoolServlet\" generated name will be \".mycool\". Warning One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings. If you want to throw exception in this case, use special option: bundle . option ( InstallersOptions . DenyServletRegistrationWithClash , true ) Note that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later (and so exception will not be thrown). Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet There is a difference between using servlet installer and registering servlets with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).","title":"Recognition"},{"location":"installers/servlet/#async","text":"Example of async servlet definition: @WebServlet ( urlPatterns = \"/async\" , asyncSupported = true ) public class AsyncServlet extends HttpServlet { @Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { final AsyncContext context = req . startAsync (); context . start (() -> { context . getResponse (). getWriter (). write ( \"done!\" ); context . complete (); }); } } Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.","title":"Async"},{"location":"installers/servlet/#admin-context","text":"By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Will install servlet in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... }","title":"Admin context"},{"location":"installers/task/","text":"Task installer \u00b6 CoreInstallersBundle / TaskInstaller Installs dropwizard tasks . Recognition \u00b6 Detects classes extending dropwizard Task and register their instances in environment. public class MyTask extends Task { @Inject private MyService service ; public TruncateDatabaseTask () { super ( \"mytask\" ); } @Override public void execute ( ImmutableMultimap < String , String > parameters , PrintWriter output ) throws Exception { service . doSomething (); } } Task can be triggered with: http://localhost:8081/tasks/mytask","title":"Task"},{"location":"installers/task/#task-installer","text":"CoreInstallersBundle / TaskInstaller Installs dropwizard tasks .","title":"Task installer"},{"location":"installers/task/#recognition","text":"Detects classes extending dropwizard Task and register their instances in environment. public class MyTask extends Task { @Inject private MyService service ; public TruncateDatabaseTask () { super ( \"mytask\" ); } @Override public void execute ( ImmutableMultimap < String , String > parameters , PrintWriter output ) throws Exception { service . doSomething (); } } Task can be triggered with: http://localhost:8081/tasks/mytask","title":"Recognition"}]}