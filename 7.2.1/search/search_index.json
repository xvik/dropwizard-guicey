{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to dropwizard-guicey","text":"<p>Guice <code>7.0.0</code> integration for dropwizard <code>4.0.13</code>.       Compiled for <code>java 11</code>, compatible with <code>java 11 - 21</code>. </p> <p>Release Notes - History - Javadoc - Support - License </p> <p>For migration see migration guide</p>"},{"location":"#main-features","title":"Main features","text":"<ul> <li>Auto configuration from classpath scan and guice bindings.  </li> <li>Yaml config values bindings by path or unique sub objects. </li> <li>Advanced Web support</li> <li>Dropwizard style console reporting: detected (and installed) extensions are printed to console to remove uncertainty </li> <li>Test support: custom junit and spock extensions<ul> <li>Advanced test abilities to disable or override application logic</li> </ul> </li> <li>Developer friendly: <ul> <li>core integrations may be replaced (to better fit needs)</li> <li>rich api for developing custom integrations, and hooking into lifecycle) </li> <li>out of the box support for plug-n-play plugins (auto discoverable)</li> <li>diagnostic tools (reports), support for custom diagnostic tools </li> </ul> </li> </ul>"},{"location":"#sponsors","title":"Sponsors","text":"<p><sup>If guicey makes your life easier, you can support its development.</sup></p>"},{"location":"#project-structure","title":"Project structure","text":"<ul> <li>ru.vyarus:dropwizard-guicey - core     guicey module. Could be used without any extra modules</li> <li>ru.vyarus.guicey:guicey-[module name] - guicey extension      modules (use with <code>ru.vyarus.guicey:guicey-bom</code>). Modules provide additional functionality like      3<sup>rd</sup> party libraries integration. Also, serve as an example of possible extension implementations. </li> <li>Examples - various usage examples for core guicey,     extension modules and some direct integrations</li> </ul> <p>Before, guicey and extensions were released separately in different repositories - different packages were preserved after merge</p>"},{"location":"#supported-versions","title":"Supported versions","text":"<p>Due to 3 major changes in dropwizard recently, 3 guicey versions supported:</p> Dropwizard Guicey Reason 2.1.x 5.x Last java 8 compatible version 3.x 6.x Changed core dropwizard packages - old 3<sup>rd</sup> paty bundles would be incompatible 4.x 7.x Jakarta namespace migration - 3<sup>rd</sup> party guice modules might be incompatible <p>All branches use the same project structure: core guicey merged with extension modules. It greatly simplifies releases and keeps actual examples in one branch.</p> <p>Upcoming guicey changes would be ported in all 3 branches.</p>"},{"location":"#sbom","title":"SBOM","text":"<p>SBOM (cyclonedx) is published for every guicey module with <code>cyclonedx</code> classifier (same way as dropwizard) as json and xml files.</p> <p>For example: XML, JSON</p>"},{"location":"#documentation-summary","title":"Documentation Summary","text":""},{"location":"#introduction","title":"Introduction","text":"<ul> <li>Getting started guide describes installation and provides core usage examples</li> <li>Concepts overview guide introduces core guicey concepts and demonstrates differences from pure dropwizard usage</li> <li>Guice the essence of guice integration</li> <li>Testing describes integration testing techniques</li> <li>Decomposition guide on writing re-usable modules</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>User guide contains detailed feature descriptions. It is good to read, but it also functions    well as a reference if you're short on time.</li> <li>Installers describes all guicey installers. Use it as a extensions hand book.</li> <li>Modules external extension modules overview.</li> <li>Examples some usage examples. </li> </ul>"},{"location":"concepts/","title":"Concepts overview","text":"<p>Section briefly describes new concepts introduced by guicey and explains why it was done that way. For usage instruction and basic examples see getting-started section. </p>"},{"location":"concepts/#hk2","title":"HK2","text":"<p>Many people ask why not just use HK2 instead of guice as it's already provided.  Unfortunately, it's hard to use it in the same elegant way as we can use guice.  HK2 context is launched too late (after dropwizard run phase) and, for example, it is  impossible to use HK2 to instantiate dropwizard managed objects because managed  must be registered before HK2 context starts.</p> <p>Guicey use lazy factories for integration: it registers providers for HK2 objects in  guice context. Guice-managed objects (extensions) are simply registered as instances. So most of the time you don't have to know about HK2 at all.</p> <p>There are additional features allowing you to delegate some extensions management completely to HK2, but it's intended to be used in very rare cases (edge cases!).  In this case you may require to explicitly register hk2-guice bride so hk2 could  see guice beans directly. </p> <p>Danger</p> <p>Since jersey 2.26 it is possible to get rid of HK2 completely. Unfortunately, such  update requires a lot of work. Someday guicey will ONLY use guice and all current  HK2-related features will be removed. For now, all HK2-related features are softly deprecated: no deprecation annotations, just mention in javadoc.</p>"},{"location":"concepts/#lifecycle","title":"Lifecycle","text":"<p>Dropwizard declares two phases: </p> <ul> <li>initialization (<code>App.initialize</code> method) - when dropwizard app must be configured</li> <li>run (<code>App.run</code> method) - when configuration is available and extensions could be registered in environment</li> </ul> <p>Guicey follow dropwizard convention: it will configure everything (almost) on initialization phase and start injector on run phase. </p> <p>Note</p> <p>If we create injector in initialization phase then we will not have access to <code>Configuration</code> and <code>Environment</code> in guice modules, but configuration could be required, especially for 3<sup>rd</sup> party modules, which does not support lazy configuration.   </p> <p>It is preferred to register everything under the initialization phase, but not possible in many cases.    We still need to register guice modules, requiring configuration values for construction under run phase. </p> <p>In some cases, extension registration may depend on configuration value, and so  it is also allowed to register extensions in run phase (besides, extensions could be  recognized from guice bindings, registered at run phase).</p> <p>This separation of initialization and run phases makes configuration more predictable (especially important when bundles depend on initialization order).      </p>"},{"location":"concepts/#guice-module","title":"Guice module","text":"<p>In the main <code>GuiceBundle</code> guice modules registration appears under initialization phase (when neither <code>Configuration</code> nor <code>Environment</code> objects are available). If a module requires these objects  and its registration can't be moved to guicey bundle's run method, then use  marker interfaces. For example, <code>ConfigurationAwareModule</code> will lead  to configuration object set into module before injector creation.</p> <p>Tip</p> <p>If possible, use <code>DropwizardAwareModule</code> as base module class to avoid boilerplate <pre><code>public class SampleModule extends DropwizardAwareModule&lt;Configuration&gt; {\n\n    @Override\n    protected void configure() {\n        configuration() // access configuration        \n        environment() // access environment\n        bootstrap()  // access dropwizard bootstrap\n        configuratonTree() // configuration as tree of values\n        confuguration(Class) // unique sub configuration\n        configuration(String) // configuration value by yaml path\n        configurations(Class) // sub configuration objects by type (including subtypes)\n        annotatedConfiguration(ann) // annotaed configuration value by instance\n        annotatedConfiguration(Class) // annotaed configuration value by annotation type\n        options() // access guicey options\n    }\n}\n</code></pre></p> <p>Warning</p> <p>Marker interfaces work only on modules, directly registered through guicey api.</p>"},{"location":"concepts/#extensions","title":"Extensions","text":"<p>In raw dropwizard you register extensions like: </p> <pre><code>public class App extends Application&lt;Configuration&gt; {\n\n    ...\n\n    @Override\n    public void run(Configuration configuration, Environment environment) throws Exception {\n        // resource registration\n        environment.jersey().register(MyResource.class);\n        // if extension requires configuration:\n        environment.lifecycle().manage(new MyManaged(configuration.getSomething()));\n    }    \n}\n</code></pre> <p>Very easy, just need to remember where it should be registered.         </p> <p>If we want to use guice for extensions management, then all extensions must be  obtained from guice injector, but it's a boilerplate.</p> <p>Instead, guicey introduce <code>Extension-Installer</code> concept: you create extension (e.g. <code>MyResource</code>) and Installer knows how to install it. Guicey only need to know extension class.</p> <p>If you use classpath scanning, then you don't need to do anything: guicey will recognize extensions and install them.</p> <p>For example, <code>ResourceInstaller</code> will:</p> <ol> <li>recognize <code>MyResource</code> class as rest resource by <code>@Path</code> annotation</li> <li>gets instance from injector (<code>injector.getInstance(MyResource.class)</code>) and performs registration <code>environment.jersey().register(guiceManagedInstance)</code></li> </ol> <p>The same way, <code>MangedInstaller</code> recognize <code>MyManaged</code> as managed extension (by implemented interface) and  installs guice managed instance (and so all other extensions).</p> <p>Summary</p> <p>With classpath scan you don't need to do anything to install extension and in manual mode  you only need to specify extension classes. </p> <p>Tip</p> <p>Most installer implementations are very simple, so you can easily understand how it works  (all core installers are declared in core installers bundle).    </p>"},{"location":"concepts/#guice-bindings","title":"Guice bindings","text":"<p>Guicey also search extensions in registered guice modules. For example:</p> <pre><code>public class MyModule extends AbstarctModule {\n    @Override\n    protected void configure() {\n        bind(MyResource.class);    \n    }   \n}       \n\nGuiceBundle.builder()\n    .modules(new MyModule())\n    .build()\n</code></pre> <p><code>MyResource</code> will be recognized as extension and installed.</p> <p>Summary</p> <p>So overall there are 3 possible sources for extensions:</p> <ul> <li>Classpath scan (mainly used for application extensions)</li> <li>Manual declaration (used in bundles to explicitly declare extensions)</li> <li>Guice bindings</li> </ul> <p>In all cases extension is identifyed by it's class, but for extensions detected from guice bindings automatic untargetted binding is not performed.  </p>"},{"location":"concepts/#jersey-extensions","title":"Jersey extensions","text":"<p>It is important to note that jersey extensions (resources and other) are forced to be singletons (if explicit scope annotation is not set).</p> <p>This force you to always use all request scoped objects through <code>Provider</code>. But, from the other side, this avoids a jvm garbage from creating them for each request and makes everything a bit  faster (no extra DI work required for each request).</p> <p>If you think that developer comfort worth more than small performance gain, then:</p> <ul> <li>You can use explicit scope annotations to change singleton scope (<code>@RequestScoped</code>, <code>@Prototype</code>)</li> <li>Switch off forced singletons (<code>.option(InstallerOptions.ForceSingletonForJerseyExtensions, false)</code>)</li> <li>Delegate some extensions or resources management to HK2 using <code>@JerseyManaged</code></li> <li>Use HK2 by default for jersey extensions</li> </ul> <p>Warning</p> <p>Guice AOP will not work on extensions managed by HK2        </p>"},{"location":"concepts/#custom-extensions","title":"Custom extensions","text":"<p>Installers are not limited to dropwizard only features: you can use custom installers to write any 3<sup>rd</sup> party integration. The only condition is extension classes must have some unique identity (usually annotation).</p> <p>For example,  <code>EagerSingletonInstaller</code> simply binds extensions  annotated with <code>@EagerSingleton</code> with <code>bind(Ext.class).asEeagerSingleton()</code>, so we can simply annotate class and make sure it would be registered in guice context without additional configurations (thanks to classpath scan). </p> <p>Tip</p> <p>Custom installers are also discovered and registered during classpath scan.   </p> <p>Another example is <code>PluginInstaller</code> which allows you to declare plugins  (e.g. implementing some interface) and inject all of them at once (as <code>Set&lt;PluginInterface&gt;</code>).</p> <p>guicey-eventbus provides special installer to register events in guava eventBus: <code>EventBusInstaller</code> check class methods and if any method is annotated with <code>@Subscribe</code> - register extension as event bus listener.</p> <p>Not existing, but possible extension for scheduled tasks: we can create <code>@Schedule</code> annotation and write installer to automatically register such classes in scheduler framework.</p> <p>Summary</p> <p>In essence, custom installers could help you avoid many boilerplate operations.</p> <p>Warning</p> <p>Each extension could be installed only by one installer. It will be the first installer which recognize the extension in class (according to installers order).</p>"},{"location":"concepts/#core-installers-override","title":"Core installers override","text":"<p>It is also possible to replace any core installer (e.g. to change its behaviour) - you just need to disable core installer and install a replacement:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n                ...\n                .disableInstaller(ManagedInstaller.class)\n                .installers(MyCustomManagedInstaller.class)       \n                .build());\n</code></pre> <p>Tip</p> <p>You can disable all installers enabled by default with: <pre><code>.noDefaultInstallers()\n</code></pre> In this case, you will have to register some installers manually (even if it would be just a few of  guicey's own installers).</p>"},{"location":"concepts/#bundles","title":"Bundles","text":"<p>Dropwizard use bundles for re-usable logic. Bundle support both dropwizard phases (initialization and run).</p> <pre><code>public interface ConfiguredBundle&lt;T&gt; {\n    default void initialize(Bootstrap&lt;?&gt; bootstrap) {};    \n    default void run(T configuration, Environment environment) throws Exception {};\n}\n</code></pre> <p>The concept is great, but, in context of guice, dropwizard bundle did not allow us to register guice modules (and, of course, guicey installers and extensions).  So there is no way to elegantly re-use dropwizard bundles mechanism.</p> <p>Guicey introduce its own bundles:</p> <pre><code>public interface GuiceyBundle {\n    default void initialize(GuiceyBootstrap bootstrap) {}; \n    default void run(GuiceyEnvironment environment) throws Exception {};\n}\n</code></pre> <p>As you can see guicey bundles are completely equivalent to dropwizard bundles and so it is very easy to switch from dropwizard bundles into guicey bundles.</p> <p><code>GuiceyBootstrap</code> provides almost all the same methods as main <code>GuiceBundle</code>, allowing you to register installers, extensions, modules and other bundles. Also, it provides access to dropwizard Bootstrap object</p> <p><code>GuiceyEnvironment</code> allows to register only guice modules (as all configuration should appear under initialization), but provide many shortcut methods for simplify manual registrations (or delayed manual logic). Provides access to dropwizard configuration, environment and introspected configuration tree.</p> <p>Tip</p> <p>Guicey bundles assume to be used together with dropwizard bundles (because there are already  many ready-to use dropwizard bundles):  <pre><code>GuiceyBootstrap.builder()\n    .dropwizardBundles(..)\n</code></pre></p>"},{"location":"concepts/#bundles-usage-difference","title":"Bundles usage difference","text":"<p>In dropwizard, bundles are helpful not just for extracting re-usable extensions, but for separation of application logic.</p> <p>In guicey, you don't need to write registration code and with enabled classpath scan, don't need to configure much at all. This makes guicey bundles mostly usable for 3<sup>rd</sup> party integrations (or core modules extraction for large projects),  where you can't (and should not) rely on class path scan and must declare all installers and extensions manually.</p> <p>Many bundle examples could be found in extension modules.</p>"},{"location":"concepts/#bundles-lookup","title":"Bundles lookup","text":"<p>Dropwizard force you to always register bundles manually, and this is good for clarity. But, sometimes, it is desirable to apply bundles under some condition. For example, you want custom installers to be registered when 3<sup>rd</sup> party integrations jar is available or you may want to enable some bundles under integration tests only.</p> <p>Guicey provides such ability: </p> <ul> <li>add bundles appeared in classpath (with ServiceLoader, not classpath scan)</li> <li>declare extra bundles with system property (for example, could be used in tests)</li> <li>apply custom lookup implementation</li> </ul> <p>ServiceLookup based lookup is ideal for 3<sup>rd</sup> party integrations. For example, suppose you have scheduler framework integration which provides installers for custom annotation (<code>@Job</code>).  All you need to do to apply extension is to put integration jar into classpath - installers will be  implicitly registered.</p> <p>Important</p> <p>ServiceLookup requires you to prepare extra files so you prepare your bundle for using that way. It does not mean guicey loads all bundles in classpath!     </p> <p>Tip</p> <p>ServiceLoader and property based look-ups are always enabled, but you can switch them  off if required with <code>.disableBundleLookup()</code> bundle option.</p>"},{"location":"concepts/#disabling-items","title":"Disabling items","text":"<p>As you have seen in overriding installers example, you can disable installers.  But actually you can disable almost anything: installers, extensions, guice modules, guicey bundles and even dropwizard bundles.</p> <p>Mostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else).</p> <p>But, in some cases, you may want to change behaviour of 3<sup>rd</sup> party module: as an example above (with replaced installer), you can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles) installation.</p> <p>Suppose you have some 3<sup>rd</sup> party bundle:</p> <pre><code>public class XBundle implements GuiceyBundle {\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap\n            .extensions(...)\n            .modules(new XModule(), new XAddonModule());\n    }    \n}\n</code></pre> <p>And, for some reason, you don't need <code>XAddonModule</code> guice module, then you can simply disable it:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n            .bundles(new XBundle())\n            .disableModules(XAddonModule.class)\n            .build())\n</code></pre> <p>Tip</p> <p>You can even perform mass disables by predicate.  For example, disable all installations (extensions, bundles etc) from package: <pre><code>.disable(Disables.inPackage(\"some.package.here\"))\n</code></pre></p> <p>Warning</p> <p>Disabling of guice modules also affect transitive modules! For example,</p> <p><pre><code>public class MyModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        // transitive\n        install(new OtherMyModule());\n    }\n}\n\nGuiceBundle.builder()\n    .modules(new MyModule())\n    .disableModules(OtherMyModule.class)\n</code></pre> Will disable transitive module!</p> <p>Warning</p> <p>Only dropwizard bundles, registered through guicey api are visible! For such bundles, guicey will see all transitive bundles too and will be  able to disable them:</p> <p><pre><code>public class MyDwBundle implements ConfiguredBundle {\n    public void initialize(Bootstrap bootstrap) {\n        // transitive bundle\n        bootstrap.addBundle(new OtherMyDwBundle());\n    }\n}\n\nGuiceBundle.builder()\n        .dropwizardBundles(new MyDwBundle())\n        .disableDropwziardBundle(OtherMyDwBundle.class)\n</code></pre> Will prevent <code>OtherMyDwBundle</code> bundle installation.</p>"},{"location":"concepts/#de-duplication-items","title":"De-duplication items","text":"<p>Guice modules, guicey bundles and dropwizard bundles are registered by instance. That means that multiple instances of the same type could be registered, for example:</p> <pre><code>.bundles(new MyBundle(), new MyBndle())\n</code></pre> <p>Sometimes it may be desirable, but sometimes not. For example, there may be some common bundle:</p> <pre><code>public class Feature1Bundle implements GuiceyBundle {\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.bundles(new CommonBundle()); \n        ...\n    }    \n}\n\npublic class Feature2Bundle implements GuiceyBundle {\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.bundles(new CommonBundle());  \n        ...\n    }    \n}\n</code></pre> <p>And duplicate initialization of common bundle may lead to error.</p> <p>In order to detect duplicate instances guicey rely on <code>equals()</code> method. So if two instances of the same type are equal then only one of them will be used and other considered duplicate.</p> <p>So if <code>ComonBundle</code> implement <code>equals</code> everything will work as planned.</p> <p>For completely unique bundles and modules there are pre-defined base classes <code>UniqueGuiceyBundle</code> and <code>UniqueModule</code> (<code>UniqueDropwizardAwareModule</code>) accordingly. (e.g. <code>CommonBundle extends UniqueGuiceyBundle</code>)</p> <p>For cases when it is not possible to change bundle or module class, it could be  declared as unique:</p> <pre><code>GuiceBundle.builder()\n    .bundles(new Feature1Bundle(), new Feature2Bundle())\n    .uniqueItems(ComonBundle.class)\n    .build()\n</code></pre> <p>Guice modules limitation</p> <p>Transitive guice modules are not counted! That means in case of de-duplication transitive modules are not visible.              </p> <p>Note that \"common bundle\" problem for dropwizard bundles may be solved by simply  registering dropwizard bundles through guicey api.</p> <p>Dropwizard bundles</p> <p>Only dropwizard bundles, registered through guicey api are visible. So if there would be one bundle registered directly in dropwizard and  another with guicey api - guicey will not detect duplicate.</p>"},{"location":"concepts/#options","title":"Options","text":"<p>Dropwizard configuration covers most configuration cases, except development specific cases. For example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration). Other example is an ability of low level tuning for 3<sup>rd</sup> party bundles.</p> <p>Options are developer configurations: either required only for development or triggers set during development  and not intended to be changed later.</p> <ul> <li>Options are declared with enum (each enum represents options group) with value type declaration to grant safety.</li> <li>Option could be set only in main bundle (in your application class)</li> <li>You can access options anywhere: guice module, guicey bundle, and in any guice service by injecting special service</li> <li>Options report is included into diagnostic report so you can see all option values.</li> </ul> <p>For example, guicey use two option groups: <code>GuiceyOptions</code> and <code>InstallersOptions</code>. <code>GuiceyOptions</code> used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc. That means you have access to all these application configurations from anywhere in your code (for example, you can know if classpath scan is enabled or not in 3<sup>rd</sup> party bundle).</p> <p>Another good example is <code>InstallersOptions.JerseyExtensionsManagedByGuice</code> which changes the way  jersey extensions are handled: with guice or with HK2. This is developer time decision and must be selected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could know what was chosen.</p> <p>HK2 usage is highly dependent on HK2-guice-bridge presence and with option we can verify it:</p> <pre><code>Preconditions.checkState(options.get(GuiceyOptions.UseHkBridge), \n                            \"HK2 guice bridge is required!\")\n</code></pre>"},{"location":"concepts/#options-lookup","title":"Options lookup","text":"<p>You can bind option to system property in order to introduce special \"hidden\" application flag:</p> <pre><code>GuiceBuilder.builder()\n    ...\n    .options(new OptionsMapper()\n                    .prop(\"myprop\", Myoptions.SomeOption)\n                    .map())\n    .build()                \n</code></pre> <p>Now you can run application with <code>-Dmyprop=value</code> and this value will be mapped to option (accessible everywhere in the application).</p> <p>Note</p> <p>There are built-in basic value conversions from string, but in complex cases you can do manual conversion <pre><code> .prop(\"myprop\", Myoptions.SomeOption, val -&gt; convertVal(val)) \n</code></pre></p> <p>Note</p> <p>You can map options from sys properties, environment variables or strings (obtained somewhere else). You can even allow mass binding to allow external definition of any option <code>.props(\"prefix\")</code>. See options lookup doc.</p>"},{"location":"concepts/#configuration-hooks","title":"Configuration hooks","text":"<p>Guicey provides special configuration hooks mechanism which may be used to change application  configuration. It is useful for tests or to attach various diagnostic tools for compiled application.</p> <p>For example, out of the box guicey provides <code>DiagnosticHook</code>, which activates diagnostic reporting (print* methods). It may be enabled even on compiled application with a system property: </p> <pre><code>-Dguicey.hooks=diagnostic\n</code></pre> <p>The same way you can write your hooks and register them with shortcuts  (<code>GuiceBundle.builder().aliasHook(\"tool\", ToolHook.class)</code>).  </p>"},{"location":"concepts/#you-dont-need-to-remember-all-this","title":"You don't need to remember all this","text":"<p>All guicey features could be revealed from main bundle methods. So you don't  need to remember everything - just look methods.</p> <p>There is a special group of <code>print[Something]</code> methods, which are intended to help you understand internal state (and help with debugging).</p> <p>As you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan, bundles, bundles installing other bundles, many guicey modules. Also, some bundles may disable extensions, installers, guice modules (and some modules could even override bindings).</p> <p>During startup guicey tracks all performed configurations and you can even access this  information at runtime using <code>@Inject GuiceyConfigurationInfo info</code>.</p> <p>Out of the box, guicey could print all this into console, you just need to add:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n            .printDiagnosticInfo()\n            .build())\n</code></pre> <p>And other logs giving you inside look on configuration.</p>"},{"location":"concepts/#not-mentioned","title":"Not mentioned","text":"<ul> <li>Dropwizard commands support </li> <li>Integration tests support</li> <li>Lifecycle events</li> <li>Shared state </li> </ul>"},{"location":"decomposition/","title":"Decomposition","text":"<p>Guide for writing re-usable bundles</p> <p>In dropwizard there is only one decomposition element: ConfiguredBundle.</p> <p>Note</p> <p>In pure dropwizard, bundles may also  be used within a single application to separate configuration blocks (simplify logic). In guicey, this is not required as classpath scan may be used for extension registration and reduce the amount of required configuration.</p> <p>This chapter describes only re-usable logic decomposition.</p> <p>In guicey there are three decomposition elements - guicey bundles (<code>GuiceyBundle</code>), guice modules (<code>Module</code>) and dropwizard bundle (<code>ConfiguredBundle</code>). Having three options could be confusing.</p> <ul> <li>There are existing dropwizard modules - <code>ConfiguredBundle</code></li> <li>Existing guice modules (outdated list, just as an example) - <code>Module</code></li> <li>And guicey extensions - <code>GuiceyBundle</code></li> </ul> <p>All of these modules are supposed to be used together. In some cases, guicey explicitly provides wrapping  modules (e.g. the jdbi wrapper around the dropwizard module). Such wrappers provide guice related features and enhancements, impossible in vanilla dropwizard modules.</p>"},{"location":"decomposition/#guicey-bundle","title":"Guicey bundle","text":"<p>As described here, guicey introduces its own bundle because guicey provides additional configuration features. Even a simple use case may have a need to configure guice modules from a bundle.</p> <p>Prefer <code>GuiceyBundle</code> over dropwizard <code>Bundle</code> for developing re-usable modules. Of course, if module is very generic (does not depend on guice) you can use a pure dropwizard module (to publish it for wider audience), but almost all bundles rely on guicey features.</p> <p>Benefits:</p> <ul> <li>guice support (ability to register guice modules)</li> <li>options support</li> <li>use sub-configuration objects directly (important for writing generic modules)</li> <li>define custom extension types to simplify usage (e.g. like jdbi)</li> <li>automatic module loading when jar appear in classpath (e.g. like lifecycle annotations)</li> <li>shared state - advanced techniques for bundle communication (e.g. used by GSP and SPA)</li> <li>events - internal lifecycle events for fine-tuning lifecycle (again, complex cases only, for example, GSP use it to order bundles logic)</li> <li>ability to replace functionality (prevent feature x registration by disabling it and register feature y instead)</li> </ul>"},{"location":"decomposition/#dropwizard-bundle","title":"Dropwizard bundle","text":"<p>It is important to note that there is an important difference between registering a dropwizard bundle directly via the  dropwizard <code>Bootstrap</code> and registering a bundle through the guicey api - any bundle registered through the guicey api may be disabled, de-duplicated, and/or tracked for transitive bundles.</p> <p>All bundles registered through guicey api will also appear in configuration report.</p> <p>There is a difference between the order that dropwizard and guicey bundles are initialized:</p> <p>Dropwizard bundles immediately initialize a transitive bundle.</p> <pre><code>public class MyBundle implements ConfiguredBundle {\n    @Override\n    public void initialize(Bootstrap&lt;?&gt; bootstrap) {\n            bootstrap.addBundle(new MyOtherBundle());  \n\n            // line executed after MyOtherBundle init\n    }\n}\n</code></pre> <p>Guicey bundle registers a transitive bundle after current bundle, but dropwizard bundles are still immediately initialized.</p> <pre><code>public class MyBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n            bootstrap\n                .dropwizardBundles(new DwBundle())\n                .bundles(new MyOtherBundle());\n\n            // line executed before MyOtherBundle init, but after DwBundle init\n    }\n}\n</code></pre> <p>Guicey bundle de-duplication logic is further explained here. In short, registered root bundles  must be initialized in priority. This avoids situations like:</p> <pre><code>GuiceBundle.builder()\n    .bundles(new Bundle1(), new Bundle2(12))\n</code></pre> <p>If <code>Bundle2</code> is unique and <code>Bundle1</code> transitively installs <code>new Bundle2(1)</code> (e.g. with different config), then this transitive bundle would be ignored because the root bundle's init will appear first. If guicey bundles worked like dropwizard bundles, then the directly registered <code>Bundle2</code> would be ignored and remaining instance would have different configuration, introducing a major point of confusion.  </p> <p>Normally, this behaviour should not be an issue as you shouldn't rely on bundles initialization order. But this may be important with shared state.</p>"},{"location":"decomposition/#bundle-vs-module","title":"Bundle vs Module","text":"<p>When extracting functionality into re-usable module always start with a bundle. A guice module will likely be required as well.</p> <p>Logic should be separated as:</p> <ul> <li>Guice module is responsible for guice bindings and should not be aware of dropwizard. </li> <li>Bundle works with dropwizard, extracts required configuration for creating module and do other registrations.</li> </ul> <p>That's an ideal case. But, for example, if you need to apply some bindings based on configuration only  then you can do it with pure guice module, like:</p> <pre><code>public class ModuleConfig {  \n    @JsonProperty\n    private String something; \n}\n</code></pre> <p>Module knows that target application (where this re-usable module would be used) will declare this configuration inside its main configuration:</p> <pre><code>public class AppConfig extends Configuration {\n    @JsonProperty    \n    private ModuleConfig module;\n}\n</code></pre> <p>Make module aware of dropwizard stuff:</p> <pre><code>public class ModuleImpl&lt;C extends Configuration&gt; extends DropwizardAwareModule&lt;C&gt; {\n\n     @Override\n     protected void configure() {\n        // obtain sub-configuration object \n        ModuleConfig config = Preconditions.checkNotNull(configuration(ModuleConfig.class),\n                \"ModuleConfig is not found within application config. Please declare it.\");\n\n        // use it for binding    \n        bind(SomeService.class).annotatedWith(Names.named(config.getSomething())).to(SomeServiceImpl.class);                            \n     }\n}\n</code></pre> <p>Warning</p> <p>This is not the recommended way! It was shown just to demonstrate that guice module could be used without bundle. It's better to use a declarative bundle instead:</p> <pre><code>public class ModuleImpl extends AbstractBundle {\n\n     private ModuleConfig config;\n\n     public ModuleImpl(ModuleConfig config) {\n        this.config = config;\n     }        \n\n     @Override\n     protected void configure() {                    \n        bind(SomeService.class).annotatedWith(Names.named(config.getSomething())).to(SomeServiceImpl.class);                            \n     }\n}\n\npublic class ModuleBundle extends GuiceyBundle {\n    @Override   \n    public void run(GuiceyEnvironment environment) throws Exception {\n         ModuleConfig config = Preconditions.checkNotNull(environment.configuration(ModuleConfig.class),\n                    \"ModuleConfig is not found within application config. Please declare it.\");\n\n          environment.modules(new ModuleImpl(config));          \n    }\n}\n</code></pre>"},{"location":"decomposition/#bundle-tips","title":"Bundle tips","text":"<p>These tips show various techniques for developing bundles. Mostly, these tips are based on developing guicey extensions. See extensions source for examples.</p>"},{"location":"decomposition/#uniqueness","title":"Uniqueness","text":"<p>For everything that is registered \"by instance\", the de-duplication mechanism is applied.</p> <p>You can use it to provide only one instance of a bundle by <code>extends  UniqueGuiceyBundle</code>. If more sophisticated logic is required, a manual equals and hash code implementation, may be used. This could be used to de-duplicate only instances with the same constructor arguments.</p> <p>This is most applicable to guice modules as guice will not start with duplicate bindings (<code>MyModule extends UniqueModule</code>).</p>"},{"location":"decomposition/#auto-loaded-bundle","title":"Auto-loaded bundle","text":"<p>Auto-loading is based on the guicey bundles lookup feature.</p> <p>Be aware that a user may switch off bundle lookup (with <code>.disableBundleLookup()</code>) or apply custom lookup).</p>"},{"location":"decomposition/#auto-load-override","title":"Auto load override","text":"<p>If your bundle provides configuration, but you still want to load it automatically with the default configuration, then you can use bundle uniqueness:</p> <pre><code>public class AutoLoadableBundle extends UniqueGuiceyBundle { ... }\n</code></pre> <p>If this is used, only one bundle instance is allowed. If a user registers another instance of the bundle manually, the bundle found from a lookup will simply be ignored. The lifecycle annotations module uses  this technique.</p>"},{"location":"decomposition/#optional-extensions","title":"Optional extensions","text":"<p>All extensions must be registered during the initialization phase, when configuration is not yet available and so it is not possible to implement optional extension registration. </p> <p>To work around this, you can conditionally disable extensions:</p> <pre><code>public class MyFeatureBundle implements GuiceyBundle {\n\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {   \n        // always register extension\n        bootstrap.extensions(OptionalExtension.class);     \n    }   \n\n    @Override    \n    public void run(GuiceyEnvironment environment) throws Exception {\n        // disable extension based on configuration value\n        if (!environment.configuration().getSomeValue()) {\n            environment.disableExtension(OptionalExtension.class);\n        }\n    }\n}\n</code></pre>"},{"location":"decomposition/#replace-features","title":"Replace features","text":"<p>As bundle has almost complete access to configuration, it can use disables to substitute application functions.</p> <p>For example, it is known that an application uses <code>ServiceX</code> from some core module provided by the organization. Your module  requires a modified service. Your bundle may disable the core module, and install a customized module as a replacement:</p> <pre><code>public class MyFeatureBundle implements GuiceyBundle {\n\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {           \n        bootstrap\n            .disableModules(CoreModule.class)\n            .modules(new CustomizedCoreModule());     \n    }      \n}      \n</code></pre> <p>Note</p> <p>This is not the best pattern to follow. It is simpler to use binding override to override single service. This is an example for demonstration purposes.</p> <p>Bundles can't disable other bundles (because target bundle could be already processed at this point).   </p>"},{"location":"decomposition/#bundle-options","title":"Bundle options","text":"<p>Bundles can use the guicey options mechanism to access guicey option values:</p> <pre><code>public class MyBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        if (bootstrap.option(GuiceyOptions.UseHkBridge)) {\n            // show warning that bridge required\n        } \n    }\n}\n</code></pre> <p>There is also support for custom options.</p> <p>Note</p> <p>Option values are set only in main <code>GuiceBundle</code>. They are immutable, so all bundles receive the same option values.</p>"},{"location":"decomposition/#configuration-access","title":"Configuration access","text":"<p>A bundle may access direct dropwizard <code>Configuration</code>, as well as individual values thanks to yaml values introspection.</p>"},{"location":"decomposition/#qualified-properties","title":"Qualified properties","text":"<p>Configuration properties, required for injection, could be simply annotated with a qualifier annotations:</p> <pre><code>public class MyConfig extends Configuration {\n\n    @Named(\"custom\")\n    private String prop1;\n\n    @CustomQualifier\n    private SubObj obj1 = new SubObj();\n</code></pre> <p>And used directly in service:</p> <pre><code>@Singleton\npublic class MyService { \n\n    @Inject @Named(\"custom\") String prop;   \n    @Inject @CustomQualifier SubObj obj;\n}\n</code></pre> <p>Or accessed in bundle (or guice module):</p> <pre><code>public class XFeatureBundle implements GuiceyBundle {\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n        SubObj config = bootstrap.annotatedValue(CustomQualifier.class);\n        ...\n    }\n}\n</code></pre>"},{"location":"decomposition/#unique-sub-config","title":"Unique sub config","text":"<p>When creating re-usable bundle it is often required to access yaml configuration data.  Usually this is solved by some \"configuration look-ups\" like in dropwizard-views </p> <p>Guicey allows you to obtain the sub-configuration object directly:</p> <pre><code>public class XFeatureBundle implements GuiceyBundle {\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n        XFeatureConfig environment = bootstrap.configuration(XFeatureConfig.class);\n        ...\n    }\n}\n</code></pre> <p>Note that this bundle doesn't know exact type of user configuration, it just  assumes that <code>XFeatureConfig</code> is declared somewhere in configuration at any level just once. For example:</p> <pre><code>public class MyConfig extends Configuration {\n\n    @JsonProperty\n    private XFeatureConfig xfeature;\n\n    ...\n}\n</code></pre> <p>Important</p> <p>Your sub configuration object must appear only once within user configuration.</p> <p>Object uniqueness checked by exact type match, so if configuration also  contains some extending class (<code>XFeatureConfigExt extends XFeatureConfig</code>)  it will be different unique config. </p>"},{"location":"decomposition/#access-by-path","title":"Access by path","text":"<p>When you are not sure that configuration is unique, you can rely on exact path definition of required sub configuration:</p> <pre><code>public class XFeatureBundle implements GuiceyBundle {\n    private String path;\n\n    public XFeatureBundle(String path) {\n        this.path = path;\n    } \n\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n        XFeatureConfig conf = environment.configuration(path);\n        ...\n    }\n}\n</code></pre> <p>The Path may be declared by the bundle user, who knows required configuration location:</p> <pre><code>GuiceBundle.builder()\n    .bundles(new XFeatureBundle(\"sub.feature\"))\n    ...\n    .build()\n</code></pre> <p>Where </p> <pre><code>public class MyConfig extends Configuration {\n\n    @JsonProperty\n    private SubConfig sub = { // pseudo code to combine class declarations\n         @JsonProperty\n         private XFeatureConfig feature;   \n    }\n\n    ...\n}\n</code></pre>"},{"location":"decomposition/#multiple-configs","title":"Multiple configs","text":"<p>In case, when multiple config objects could be declared in user configuration, you can access all of them: </p> <pre><code>public class XFeatureBundle implements GuiceyBundle {\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n        List&lt;XFeatureConfig&gt; confs = environment.configurations(XFeatureConfig.class);\n        ...\n    }\n}\n</code></pre> <p>For configuration</p> <pre><code>public class MyConfig extends Configuration {\n\n    @JsonProperty\n    private XFeatureConfig xfeature;\n    @JsonProperty\n    private XFeatureConfig xfeature2;\n\n    ...\n}\n</code></pre> <p>This <code>configurations</code> method will return both objects: <code>[xfeature, xfeature2]</code></p> <p>Important</p> <p>In contrast to unique configurations, this method returns all subclasses as well. So if there are <code>XFeatureConfigExt extends XFeatureConfig</code> declared somewhere it will also be returned.</p>"},{"location":"decomposition/#custom-configuration-analysis","title":"Custom configuration analysis","text":"<p>In all other cases (with more complex requirements) you can use <code>ConfigurationTree</code> object which represents introspected configuration paths.  </p> <pre><code>public class XFeatureBundle implements GuiceyBundle {\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n         // get all properties of custom configuration (ignoring properties from base classes)\n        List&lt;ConfigPath&gt; paths = environment.configurationTree()\n                .findAllRootPathsFrom(MyConfig.class);\n\n        // search for not null values of marked (annotated) classes            \n        List markedTypes = paths.stream()\n            .filter(it -&gt; it.getValue() != null \n                    &amp;&amp; it.getType().getValueType().hasAnnotation(MyMarker.class))\n            .map(it -&gt; it.getValue())\n            .collect(Collectors.toList());\n        ...\n    }\n}\n</code></pre> <p>In this example, the bundle searches for properties declared directly in the <code>MyConfig</code> configuration class with non-null values and the custom marker (<code>@MyMarker</code>) class annotation.  </p> <p>See introspected configuration structure description for details.</p>"},{"location":"decomposition/#shared-state","title":"Shared state","text":"<p>Guicey maintains special shared state object useful for storing application-wide data.</p> <p>Warning</p> <p>Yes, any shared state is a \"hack\". Normally, you should avoid using it.  Guicey provides this ability to unify all such current and future hacks: so if you need to communicate between bundles - you don't need to reinvent the wheel and don't have additional problems in tests (due to leaking states).</p> <p>For example, it is used by spa bundle to share list of registered application names between all spa bundle instances and so be able to prevent duplicate name registration.</p> <p>Server pages bundle use shared state to maintain global configuration and allow application bundles communication with global views bundle. </p>"},{"location":"decomposition/#equal-communication-scenario","title":"Equal communication scenario","text":"<p>Use the following in cases when multiple (equal) bundles need to communicate, the first initialized bundle will initialize the shared state and others simply use it:</p> <pre><code>public class EqualBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        // either obtain already shared object or share new object                                                             \n        SomeState state = bootstrap.sharedState(EqualBundle, () -&gt; new SomeState());\n        ...\n    }\n}\n</code></pre>"},{"location":"decomposition/#parent-child-scenario","title":"Parent-child scenario","text":"<p>Use the following in cases when there is one global bundle, which must initialize some global state and child  bundles, which use or append to this global state:</p> <pre><code>public class GlobalBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        // share global state object\n        bootstrap.shareState(GlobalBundle, new GlobalState());\n    }        \n}    \n\npublic class ChildBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        // access shared object or fail when not found\n        GlobalState state = environment.sharedStateOrFail(GlobalBundle, \n                \"Failed to obtain global state - check if global bundle registered\");\n    }        \n}\n</code></pre>"},{"location":"decomposition/#beforeafter-run-logic","title":"Before/after run logic","text":"<p>If multiple bundles must be synchronized on run phase, use guicey events. </p> <p>To run code after all guicey bundles have been initialized, but before run is called:</p> <pre><code>@Override\npublic void initialize(final GuiceyBootstrap bootstrap) {\n    bootstrap.listen(new GuiceyLifecycleAdapter() {\n        @Override\n        protected void beforeRun(final BeforeRunEvent event)  {\n            // do something before bundles run\n            // NOTE that environment and configuration already available!\n        }\n    });\n}\n</code></pre> <p>To run code after all guicey bundles run methods have been called (delayed init):</p> <pre><code>@Override\npublic void run(final GuiceyEnvironment environment) {\n    environment.listen(new GuiceyLifecycleAdapter() {\n        @Override\n        protected void bundlesStarted(final BundlesStartedEvent event) {\n            // still sdropwizard run phase (anything could be configured)\n            // but all guicey bundles aready executed \n        }\n    });\n}\n</code></pre> <p>Note</p> <p>This will work only for guicey bundles! Registered dropwizard bundles may execute before or after these events. Events are broadcast from the main dropwizard  <code>GuiceBundle</code> run method, so other dropwizard bundles, registered after guice bundle will run after it.  It is assumed that guicey bundles will be used for most configurations, but especially  in complex cases when bundle synchronization is required. </p>"},{"location":"dev/","title":"Development tips","text":"<p>Summary</p> <p>Tips and tricks simplifying development</p>"},{"location":"dev/#auto-reload-static-resources-in-intellij-idea","title":"Auto reload static resources in IntelliJ IDEA","text":"<p>To enable automatic reload of static resources:</p> <ul> <li>Go to Help -&gt; Find Action</li> <li>Type \"Registry\".</li> <li>Find and mark : \u201ccompiler.automake.allow.when.app.running\u201d.</li> <li>Go to \"Settings -&gt; Build, Execution, Deployment -&gt; Compiler\".</li> <li>Mark \"Build project automatically\".</li> </ul> <p>Warning</p> <p>This is not enabled by default in IDEA because this changes application classpath, which may be harmful for some applications. In case of dropwizard applications there should be no problems still (only with your custom logic dealing with  classpath directly)</p> <ul> <li>Advanced settings </li> <li>Click \"Allow auto-make to start even if developed application is currently running\"</li> </ul> <p>Now static resources would \"hot swap\".  </p> <p>Warning</p> <p>Note that template engines (freemarker, mustache) may cache templates </p>"},{"location":"getting-started/","title":"Setup","text":"<p>Getting started guide briefly shows the most commonly used features. Advanced descriptions of guicey concepts may be found in the concepts section.    </p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Core guicey could be used directly:</p> <p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus&lt;/groupId&gt;\n  &lt;artifactId&gt;dropwizard-guicey&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus:dropwizard-guicey:7.2.1'\n</code></pre>"},{"location":"getting-started/#bom","title":"BOM","text":"<p>But, it would be simpler to use it with BOM because of simplified versions management for guice, dropwizard and guicey modules: </p> <p>Gradle:</p> <pre><code>dependencies {\n    implementation platform('ru.vyarus:dropwizard-guicey:7.2.1')\n    // uncomment to override dropwizard and its dependencies versions\n//    implementation platform('io.dropwizard:dropwizard-dependencies:4.0.13')\n\n    // no need to specify versions\n    implementation 'ru.vyarus:dropwizard-guicey'\n\n    // example modules without versions\n    implementation 'io.dropwizard:dropwizard-auth'\n    implementation 'com.google.inject:guice-assistedinject'\n\n    testImplementation 'io.dropwizard:dropwizard-testing'\n}\n</code></pre> <p>Maven:</p> <pre><code>&lt;dependencyManagement&gt;  \n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;ru.vyarus&lt;/groupId&gt;\n            &lt;artifactId&gt;dropwizard-guicey&lt;/artifactId&gt;\n            &lt;version&gt;7.2.1&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt; \n        &lt;!-- uncomment to override dropwizard and its dependencies versions  \n        &lt;dependency&gt;\n            &lt;groupId&gt;io.dropwizard/groupId&gt;\n            &lt;artifactId&gt;dropwizard-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;4.0.13&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt; --&gt;                 \n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;ru.vyarus&lt;/groupId&gt;\n        &lt;artifactId&gt;dropwizard-guicey&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":"<p>Full source of example application is published here</p> <p>Register guice bundle:</p> <pre><code>public class SampleApplication extends Application&lt;Configuration&gt; {\n\n    public static void main(String[] args) throws Exception {\n            new SampleApplication().run(args);\n    }\n\n    @Override\n    public void initialize(Bootstrap&lt;Configuration&gt; bootstrap) {\n        bootstrap.addBundle(GuiceBundle.builder()\n                .enableAutoConfig()\n                .build());\n    }\n\n    @Override\n    public void run(Configuration configuration, Environment environment) throws Exception {\n    }\n}\n</code></pre> <p>Tip</p> <p>Bundle builder contains shortcuts for all available features, so required function  may be found only by looking at available methods (and reading the javadoc).</p> <p>Auto configuration (activated with <code>enableAutoConfig</code>) means that guicey will search for extensions in  the application package and subpackages. Extension classes are detected by \"feature markers\": for example,  resources has <code>@Path</code> annotation, tasks extends <code>Task</code> etc.</p> <p>Tip</p> <p>By default, auto configuration enabled for application package, but  you can declare manually any packages for classpath scan:  <pre><code> .enableAutoConfig(\"com.mycompany.foo\", \"com.mycompany.bar\")\n</code></pre></p> <p>If required, analysed classes could be filtered. For example, you can configure a spring-like approach of recognizing only annotated classes: <pre><code>.autoConfigFilter(ClassFilters.annotated(Component.class, Service.class))\n</code></pre> This way, only classes annotated with <code>@Component</code> or <code>@Service</code> would be recognized.</p> <p>But the better way to use filters is to add additional skip annoatations: <pre><code>.autoConfigFilter(ClassFilters.ignoreAnnotated(Skip.class))\n</code></pre> (so extensions, annoatated with <code>@Skip</code>, would be ignored by classpath scan)</p> <p>The application could be launched by running main class (assumes you will use an IDE run command):</p> <pre><code>SampleApplication server\n</code></pre> <p>Note</p> <p>a config.yml is not passed as a parameter because we don't need additional configuration yet</p>"},{"location":"getting-started/#adding-a-resource","title":"Adding a Resource","text":"<p>Create a custom rest resource class:</p> <pre><code>@Path(\"/sample\")\n@Produces(\"application/json\")\npublic class SampleResource {\n\n    @GET\n    @Path(\"/\")\n    public Response ask() {\n        return Response.ok(\"ok\").build();\n    }\n}\n</code></pre> <p>After creating your resource, when you run the application the resource was installed automatically:</p> <pre><code>INFO  [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources:\n\n    GET     /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource)\n</code></pre> <p>Call <code>http://localhost:8080/sample/</code> to make sure it works.</p> <p>Tip</p> <p>Rest context is mapped to root by default. To change it use configuration file: <pre><code>server:\n    rootPath: '/rest/*'\n</code></pre></p> <p>Resource is a guice bean, so you can use guice injection inside it. To access request scoped objects like <code>jakarta.servlet.http. HttpServletRequest</code>, <code>jakarta.servlet.http.HttpServletResponse</code>, <code>jakarta.ws.rs.core.UriInfo</code>, <code>org.glassfish.jersey.server. ContainerRequest</code>, etc, you must wrap the desired objects in a <code>Provider</code>:</p> <pre><code>@Path(\"/sample\")\n@Produces(\"application/json\")\npublic class SampleResource {\n\n    @Inject\n    private Provider&lt;HttpServletRequest&gt; requestProvider;\n\n    @GET\n    @Path(\"/\")\n    public Response ask() {\n        final String ip = requestProvider.get().getRemoteAddr();\n        return Response.ok(ip).build();\n    }\n}\n</code></pre> <p>The example resource now obtains the caller's remote ip address and returns it in the response body.</p> <p>Warning</p> <p>Providers must be used instead of <code>@Context</code> field injections  But <code>@Context</code> can be used for method parameters</p> <p>Note</p> <p>By default, resources are forced to be singletons (when no scope annotation defined). </p>"},{"location":"getting-started/#adding-a-managed-object","title":"Adding a Managed Object","text":"<p>Dropwizard managed objects are extremely useful for managing resources.</p> <p>Create a simple managed implementation:</p> <pre><code>@Singleton\npublic class SampleBootstrap implements Managed {\n    private final Logger logger = LoggerFactory.getLogger(SampleBootstrap.class);\n\n    @Override\n    public void start() throws Exception {\n        logger.info(\"Starting some resource\");\n    }\n\n    @Override\n    public void stop() throws Exception {\n        logger.info(\"Shutting down some resource\");\n    }\n}\n</code></pre> <p>The managed class will be automatically discovered and installed by Guicey. Guicey always reports installed extensions when they are not reported by dropwizard itself. In the start-up logs of the application, you can see:</p> <pre><code>INFO  [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)\n</code></pre>"},{"location":"getting-started/#adding-a-filter","title":"Adding A Filter","text":"<p>Note</p> <p>Guice ServletModule may be used for servlets and filters definitions, but most of  the time it's more convenient to use simple servlet annotations (@WebFilter,  @WebServlet, @WebListener).  Moreover, guice servlet module is not able to register async filters and servlets.</p> <p>Add a sample filter around rest methods:</p> <pre><code>@WebFilter(urlPatterns = \"/*\")\npublic class CustomHeaderFilter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        if (\"me\".equals(request.getParameter(\"user\"))) {\n            chain.doFilter(request, response);\n        } else {\n            ((HttpServletResponse) response)\n                    .sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Not authorized\");\n        }\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n</code></pre> <p>The filter will only pass through requests with the <code>user=me</code> request parameter. It is used just to show how to register custom filters with annotations. The implementation itself is not useful.</p> <p>Upon start-up, new logs will confirm successful filter installation:</p> <pre><code>INFO  [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters =\n\n    /*                       (ru.vyarus.dropwizard.guice.examples.web.AuthFilter)   .auth\n</code></pre> <p>Call <code>http://localhost:8080/sample/</code> and <code>http://localhost:8080/sample/?user=me</code> to make sure filter works.</p>"},{"location":"getting-started/#adding-a-guice-module","title":"Adding a Guice Module","text":"<p>Guice module registration:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n                ...\n                .modules(new SampleModule())\n                .build());\n</code></pre> <p>Multiple modules could be registered at once: <pre><code>.modules(new SampleModule(), new Some3rdPartyModule())\n</code></pre></p> <p>Note</p> <p>The above registration occurs in dropwizard initialization phase, when neither <code>Configuration</code> nor <code>Environment</code> objects are available. If you need either of them in a module, you may register a module in  guicey bundle's <code>run</code> method, use marker interfaces or delayed bundle callback:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n        ...\n        // same as GuiceyBundle.run (kind of shortcut)\n        .whenConfigurationReady(env -&gt; {\n            env.modules(new ConfAwareModule(env.&lt;AppConfig&gt;configuration().getSomething()))\n        })\n        .modules(new SampleModule())\n        .build());\n</code></pre>"},{"location":"getting-started/#manual-mode","title":"Manual mode","text":"<p>If you don't want to use classpath scanning for extension discovery, then you will have to manually specify all extensions. Example above would look in manual mode like this:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n                .modules(new SampleModule())\n                .extensions(\n                        SampleResource.class,\n                        SampleBootstrap.class,\n                        CustomHeaderFilter.class\n                )\n                .build());\n</code></pre> <p>The only difference is the absence of <code>.enableAutoConfig()</code> and the explicit declaration of desired extensions.</p> <p>Tip</p> <p>Explicit extension declaration could be used together with <code>enableAutoConfig</code> (classpath scan). For example, a classpath scan may only scan for extensions in your application's package and subpackages, while extensions outside of those packages may be specified separately. This avoids large class path scans and improves the startup time of your  application.</p> <p>Note</p> <p>Only distinct extensions are registered. Duplicates are not registered. If some extension is registered manually and also found  with auto config, then only one instance of that extension will be registered. If an extension is registered multiple times  manually, the same rules apply and only one extension instance will be registered. </p>"},{"location":"getting-started/#configuration-from-bindings","title":"Configuration from bindings","text":"<p>Guicey is also able to recognize extensions from declared guice bindings, so manual example above is equal to:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n                .modules(new SampleModule())\n                .build());                 \n\n\npublic class SampleModule extends AbstractModule {\n    @Override\n    protected void configure() {\n         bind(SampleResource.class).in(Singleton.class);\n         bind(SampleBootstrap.class);\n         bind(CustomHeaderFilter.class);                        \n    }   \n}\n</code></pre> <p>Guicey will recognize all three bindings and register extensions. The difference with classpath scanning or manual declaration is only that guicey will not declare default bindings for extensions  (by default, guicey creates untargeted bindings for all extensions: <code>bind(Extension.class)</code>).</p> <p>Tip</p> <p>An extension may be found three ways: by classpath scan, explicit extension declaration on the GuiceBundle, and by  declaring a binding in a guice module. Even if all three were used, the extension would only be registered once.</p>"},{"location":"getting-started/#recognized-extensions","title":"Recognized Extensions","text":"<p>Guicey can recognize and install:</p> <ul> <li>Dropwizard tasks</li> <li>Dropwizard managed objects</li> <li>Dropwizard health checks</li> <li>REST resources</li> <li>REST extensions (exception mappers, message body readers etc.) </li> <li>Jersey features</li> <li>Filters, servlets, listeners</li> <li>Eager singletons, without direct guice registration</li> </ul> <p>It can even simulate simple plugins.</p> <p>Other extension types may be recognized with additional installed modules. For example, jdbi adds  support for jdbi mappers and repositories. You may add others yourself. Any existing extension integration may be  replaced, if it doesn't suit your needs.</p> <p>Tip</p> <p>If you are unsure or don't understand what guicey is using for its configuration, enable diagnostic logs: <pre><code>GuiceBundle.builder()        \n    .printDiagnosticInfo()\n    ...\n</code></pre></p> <p>To see what extensions are supported you can always use: <pre><code>GuiceBundle.builder()        \n    .printAvailableInstallers()    \n</code></pre></p> <p>And to see available guice bindings: <pre><code>GuiceBundle.builder()        \n    .printGuiceBindings()    \n</code></pre></p>"},{"location":"getting-started/#guicey-bundles","title":"Guicey Bundles","text":"<p>Guicey Bundles are intended to extend the functionality of Dropwizard Bundles, not limit them. To get access for these extended  abilities you'll need to use GuiceyBundle instead of a dropwizard <code>ConfiguredBundle</code>.</p> <p>The Guicey Bundle lifecycle and methods are the same as Dropwizard Bundles. Guicey Bundles simply provide more functionality.</p> <p>Attention</p> <p>This does not mean that dropwizard bundles can't be used! An opposite, Guicey provides direct shortcuts for them in its bundles:</p> <pre><code>public class MyBundle implements GuiceyBundle {\n     default void initialize(GuiceyBootstrap bootstrap) throws Exception {\n         bootstrap.dropwizardBundles(new MyDropeizardBundle());\n     }\n}\n</code></pre> <p>Additional features will be available for Dropwizard Bundles registered through guicey api and they also will appear in reports.                          </p> <p>You can always use vanilla Dropwizard Bundles if you don't need to register guice modules  or use other guicey features. Usually Dropwizard Bundles used when the required integration has  already implemented as a 3<sup>rd</sup> party Dropwizard Bundle.</p>"},{"location":"guice/","title":"Guice","text":"<p>Note</p> <p>It is important to say that guicey did not apply any \"guice magic\". Guicey just register additional bindings, which you can use in your beans.  </p> <p>Or you can simply enable full guice report (.printAllGuiceBindings()) and see all added bindings under <code>GuiceBootsrapModule</code>:</p> <pre><code> 7 MODULES with 106 bindings\n    \u2502   \n    \u2514\u2500\u2500 GuiceBootstrapModule         (r.v.d.guice.module)       \n        \u251c\u2500\u2500 &lt;scope&gt;              [@Prototype]     -                                               at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:51)\n        \u251c\u2500\u2500 instance             [@Singleton]     Options                                         at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:57)\n        \u251c\u2500\u2500 instance             [@Singleton]     ConfigurationInfo                               at ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:60)\n        ...\n</code></pre>"},{"location":"guice/#added-bindings","title":"Added bindings","text":"<p>All applied bindings are described in the user guide.</p> <p>Main objects:</p> <ul> <li><code>io.dropwizard.setup.Bootstrap</code> </li> <li><code>io.dropwizard.Configuration</code></li> <li><code>io.dropwizard.setup.Environment</code></li> </ul> <p>Bindings below are not immediately available as HK2 context starts after guice:</p> <ul> <li><code>jakarta.ws.rs.core.Application</code></li> <li><code>jakarta.ws.rs.ext.Providers</code></li> <li><code>org.glassfish.hk2.api.ServiceLocator</code></li> <li><code>org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider</code></li> </ul> <p>Request-scoped bindings:</p> <ul> <li><code>jakarta.ws.rs.core.UriInfo</code></li> <li><code>jakarta.ws.rs.container.ResourceInfo</code></li> <li><code>jakarta.ws.rs.core.HttpHeaders</code></li> <li><code>jakarta.ws.rs.core.SecurityContext</code></li> <li><code>jakarta.ws.rs.core.Request</code></li> <li><code>org.glassfish.jersey.server.ContainerRequest</code></li> <li><code>org.glassfish.jersey.server.internal.process.AsyncContext</code></li> <li><code>jakarta.servlet.http.HttpServletRequest</code></li> <li><code>jakarta.servlet.http.HttpServletResponse</code></li> </ul> <p>Request scoped objects must be used through provider: <pre><code>@Inject Provider&lt;HttpServletRequest&gt; requestProvider;\n</code></pre></p> <p>Warning</p> <p>Pay attention that inside rest resources <code>@Context</code> injection on fields will not work on fields,  but will for method arguments.</p>"},{"location":"guice/#configuration-bindings","title":"Configuration bindings","text":"<p>It is quite common need to access configuration value by path, instead of using entire configuration object. Often this removes boilerplate when one option is used in multiple places, compare:</p> <pre><code>@Inject MyConfiguration config\n...\n\n// in each usage\nconfig.getSub().getFoo()\n</code></pre> <p>and </p> <pre><code>@Inject @Config(\"sub.foo\") String foo;\n\n// and use direct value in all places\n</code></pre> <p>Also, often you have some unique configuration sub object, e.g. </p> <pre><code>public class MyConfig extends Configuration {\n    @JsonProperty\n    AuthConfig auth;\n}\n</code></pre> <p>It may be more convenient to bind it directly, instead of full configuration:</p> <pre><code>@Inject @Config AuthConfig auth;\n</code></pre> <p>See complete description in the user guide</p> <p>Warning</p> <p>If not disabled, guicey will always bind all configuration values (including values from base <code>Configuration</code> class). Don't be confused when use custom config report - it just not shows common bindings for simplicity, but they are still applied.     </p> <p>Note</p> <p>Use configuration bindings report to see available configuration bindings. It is executed before injector creation and so could be used for problems diagnosis.  Bindings may change with configuration values changes (e.g. <code>server</code> section depends on server implementation used).    </p> <p>You can also annotate any configuration property (or getter) with qualifier annotation and property value would be bound with this qualifier directly:</p> <pre><code>public class MyConfig extends Configuration {\n\n    @Named(\"custom\")\n    private String prop1;\n\n    @CustomQualifier\n    private SubObj obj1 = new SubObj();\n\n    ...\n\n@Singleton\npublic class MyService { \n\n    @Inject @Named(\"custom\") String prop;   \n    @Inject @CustomQualifier SubObj obj;\n}\n</code></pre>"},{"location":"guice/#extensions-and-aop","title":"Extensions and AOP","text":"<p>As it was mentioned guice knows about extensions either by  classpath scan search, manual declaration or guice bindings.</p> <p>Recognition from guice binding is not interesting as you bind it manually.</p> <p>Auto scan and manual declaration are essentially the same: guicey have extension class, which must be bound to guice context. In most cases it would be just <code>bind(Extension.class)</code> (but some installers can do more sophisticated bindings,  like plugins installer).</p> <p>As you can see, in all cases extension is constructed by guice and so AOP features will work.</p> <p>Note</p> <p>While HK2 is still used, instance management may be delegated to HK2 but it is not used in core guicey (just an ability; this is almost never required) </p> <p>All extensions recognized from guice bindings are clearly visible in the configuration report.</p>"},{"location":"guice/#servlets-and-filters","title":"Servlets and filters","text":"<p>GuiceFilter is registered on both main and admin contexts. Guice servlets and filters (registered through ServletModule) may co-exist with pure servlets and filters: as guice filter intercept both contexts, it would be able to manage request scope for all calls (even rest).</p> <p>When you register servlets and filters directly, their instances will be managed by guice (because they are extensions), just dispatching will work a bit differently, which is almost never important.</p> <p>As you can see, in case of servlets, AOP features will also be always available. Moreover, scopes will work as expected. </p> <p>Note</p> <p>Web report could show actual mapping difference between pure servlets and <code>GuiceFilter</code>-managed servlets. </p>"},{"location":"guice/#startup","title":"Startup","text":"<p>The only not intuitive step, performed by guicey, is modules analysis: just before injector creation guicey parse all registered modules (using guice SPI):</p> <pre><code>List&lt;Element&gt; elements = Elements.getElements(modules)\n</code></pre> <p>Note</p> <p>Pay attention that guicey looks only actual bindings before injector creation. And that's why it would not \"see\" JIT bindings (bindings that was not declared and created just because guice found an injection point).  This is intentional to force declaration of all important bindings.  </p> <p>To avoid re-parsing elements during injector creation, guicey pack all parsed elements as module with:</p> <pre><code>Module module = Elements.getModule(elements)\n</code></pre> <p>And so guicey injector factory will receive this  synthetic module. So if you need access to raw module, you can either do it with event or disable modules analysis (but in this case some features would not work)</p> <p>Note</p> <p>Guice bindings override (<code>Modules.override()</code>), available through guicey api modulesOverride(), will also cause synthetic module (because overrides are applied before calling injector factory). But this supposed to be used for tests only (just to mention).</p> <p>Tip</p> <p>If you have problems with startup time, guicey provides special reports for investigations:</p> <ul> <li>startup repport</li> <li>guice provision report</li> </ul>"},{"location":"guice/#aop","title":"AOP","text":"<p>Not guicey-related, but still, as it's not always obvious how AOP is applied on beans use AOP report - it shows all affected beans and (more importantly) applied aop handlers order.</p>"},{"location":"tests/","title":"Testing","text":"<p>Core dropwziard testing support proposes atomic testing approach (separate testing of each element, which you still could use when possible).</p> <p>With DI (guice) we have to move towards integration testing because:</p> <ol> <li>It is now harder to mock classes \"manually\" (because of DI \"black box\")</li> <li>We have a core (guice injector, without web services), starting much faster than    complete application.</li> </ol>"},{"location":"tests/#guicey-tests","title":"Guicey tests","text":"<p>Guicey intended to shine in integration tests: it provides a lot of tools for application modification.</p> <p>The most important is hooks mechanism which allows you to re-configure existing application. There are two main testing approaches:</p> <ul> <li>Disable everything not required and register custom versions instead</li> <li>Override some bindings (pure guice <code>Modules.override()</code> method)</li> </ul>"},{"location":"tests/#disable-and-replace","title":"Disable and replace","text":"<p>Suppose we have the following application:</p> <pre><code>public class App extends Application&lt;MyConfig&gt; {\n    public void initialize(Bootstrap&lt;MyConfig&gt; bootstrap) {\n        bootstrap.addBundle(GuiceBundle.builder()\n            .bundles(new SecurityOnlyBundle())\n            .modules(new ServiceModule(), new DaoModule())\n            .build()\n    }\n}\n</code></pre> <p>Specifically for tests we create special module <code>MockDaoModule</code> which applies all the same bindings, but with mock implementations.</p> <p>Just for demonstration, suppose that application registers <code>SecurityOnlyBundle</code> which do nothing except of additional security. Suppose we don't need this in tests.</p> <pre><code>@TestGuiceyApp(App.class)\npublic class MyTest {   \n\n    @EnableHook\n    static GuiceyConfigurationHook HOOK = builder -&gt; \n                                builder.disableBundles(SecurityOnlyBundle.class)\n                                       .disableModules(DaoModule.class)\n                                       .modules(new MockDaoModule());                \n}\n</code></pre> <p>Here hook applied to:</p> <ul> <li>remove <code>SecurityOnlyBundle</code></li> <li>remove <code>DaoModule</code></li> <li>add <code>MockDaoModule</code></li> </ul> <p>This way you can disable everything: module, extensions, guicey and dropwizard bundles and installers.</p> <p>Note</p> <p>Bundles (both guice and dropwizard) and guice modules are actually hierarchical (one bundle/module can register other bundle/module) and you can disable even exact bundle/module inside this hierarchy (not just directly registered). See more: about guice transitive bundles and dropwizard transitive bundles</p> <p>All disables are shown on diagnostic report - you can use it to verify  configuration state. </p>"},{"location":"tests/#override-bindings","title":"Override bindings","text":"<p>We can do the same without replacing module, but overriding bindings using guice <code>Modules.override()</code> feature. This is preferred in cases when modules are not so well structured and you need to override just a subset of bindings (not all bindings in module).</p> <p>Above example would look like:</p> <pre><code>@TestDropwizardApp(App.class)\npublic class MyTest {    \n\n    @EnableHook\n    static GuiceyConfigurationHook HOOK = builder -&gt; \n                                builder.disableBundles(SecurityOnlyBundle.class)                                       \n                                       .modulesOverride(new MockDaoModule());       \n}\n</code></pre> <p>In the previous example all bindings from <code>DaoModule</code> were removed and here we just register overriding bindings so bindings from <code>MockDaoModule</code> will be used instead of (the same) bindings from <code>DaoModule</code>.</p> <p>Note</p> <p>All overrides are visible on guice report - use it to verify override correctness.</p>"},{"location":"tests/#configuration","title":"Configuration","text":"<p>For tests you can use custom configuration file (e.g. <code>src/test/resources/test-config.yml</code>).</p> <pre><code>@TestDropwizardApp(value = MyApp.class, conifg=\"src/test/resources/test-config.yml\")\n</code></pre> <p>Or just override exact values (without declaring config file):</p> <pre><code>@TestDropwizardApp(value = MyApp.class, conifgOverride = \"server.applicationConnectors[0].port: 0\") \n</code></pre>"},{"location":"tests/#lightweight-tests","title":"Lightweight tests","text":"<p>In many cases, you don't need the entire application, but just a working <code>Injector</code> to check core application logic.</p> <p>For such cases, guicey provides lightweight extensions like @TestGuiceyApp:</p> <ul> <li>will not start jetty (no ports bind, no HK2 launched)</li> <li>start <code>Managed</code> objects to simulate lifecycle</li> </ul> <p>These tests work much faster!     </p> <pre><code>@TestGuiceyApp(App.class)\npublic class MyTest {    \n\n    @EnableHook\n    static GuiceyConfigurationHook HOOK = builder -&gt; \n                            builder.disableBundles(SecurityOnlyBundle.class)                                       \n                                   .modulesOverride(new MockDaoModule());    \n\n    @Test\n    public void test(MyService service) {\n         service.doSomething();\n         ...  \n    }       \n}\n</code></pre> <p>Tip</p> <p>There is also a special lightweight REST tests support to  avoid starting entire web server. </p>"},{"location":"tests/#spock","title":"Spock","text":"<p>All examples above was for junit 5, but you can also use groovy-based Spock framework 2.  Spock tests are much easier to write (you can write less code) and more expressive. You'll use the same Junit 5 rules (instead of writing custom spock extensions, junit 5 compatibility layer was implemented,  so you can use any junit 5 extensions with spock).</p> <p>See this article for spock usage motivation.</p> <p>For example, the first junit example will look like in spock:</p> <pre><code>@TestDropwizardApp(App)\nclass MyTest extends Specification {    \n\n    @EnableHook\n    static GuiceyConfigurationHook HOOK = { it.disableBundles(SecurityOnlyBundle)\n                                            .disableModules(DaoModule)\n                                            .modules(new MockDaoModule()) }\n\n    @Inject\n    MyService service\n\n    def 'Check service method'() {\n\n        when: 'calling service method'\n        def res = service.doSoomething()\n\n        then: 'value is correct'\n        res == 12\n    }      \n}\n</code></pre> <p>See Spock 2 docs for more details.</p>"},{"location":"tests/#testing-commands","title":"Testing commands","text":"<p>Guicey also provides special support for testing dropwizard commands:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .run(\"simple\", \"-u\", \"user\")\n\nAssertions.assertTrue(result.isSuccessful());\n</code></pre> <ul> <li>Such run never fails (in case of error exception would be inside result object)</li> <li>Result countain all required objects for assertions and contains </li> <li>Full console output is accessible for assertions</li> <li>Could mock user input (for commands requiring interaction)</li> </ul> <p>Also commands could be used to check application failures on startup (self-checks testing):</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .runApp()\n</code></pre> <p>Such test would fail in case of successful application start. No additional mocks or extensions required because running like this would not cause <code>System.exist(1)</code> call, performed in <code>Application</code> class (see <code>Application.onFatalError</code>).</p>"},{"location":"about/compatibility/","title":"Dropwizard compatibility","text":"Dropwizard Guicey 4.0.0 7.2.1 3.0.0 6.3.1 2.1.0 5.10.2 2.0.0 5.5.0 1.3.0 4.2.3 1.2.0 4.1.0 1.1.0 4.1.0 1.0 4.0.1 0.9 3.3.0 0.8 3.1.0 0.7 1.1.0"},{"location":"about/history/","title":"Version history","text":""},{"location":"about/history/#721-2025-05-12","title":"7.2.1 (2025-05-12)","text":"<ul> <li>Fix NoClassDefFoundError on guicey startup due to junit classes leak into core (#428)</li> </ul>"},{"location":"about/history/#720-2025-05-11","title":"7.2.0 (2025-05-11)","text":"<ul> <li>Update to dropwizard 4.0.13</li> <li>Un-deprecate HK2 support (removed deprecation annotations, but soft deprecation message remain in javadoc)</li> <li>Add methods to the main builder (and hooks) to simplify usage without guicey bundle:<ul> <li>.whenConfigurationReady(...) - delayed configuration (same as GuiceyBunle.run):   simplify extensions or guice modules registration, requiring configuration</li> <li>.onGuiceyStartup() - executes after injector creation (under run phase).   Useful for manual dropwizard configurations</li> <li>.onApplicationStartup() - executes after complete application startup (including guicey lightweight test)</li> <li>.onApplicationShutdown() - executes after application shutdown</li> <li>.listenServer() - shortcut for jetty server startup listen</li> <li>.listenJetty() - shortcut for jetty lifecycle listening</li> <li>.listenJersey() - shortcut for jersey startup events and requests listening</li> </ul> </li> <li>Diagnostic reports:<ul> <li>Add application startup (and shutdown) time detalization report: .printStartupTime()<ul> <li>Add hook alias for showing report on compiled application: -Dguicey.hooks=startup-time</li> </ul> </li> <li>Add guice provision time report (time of guice beans creation): .printGuiceProvisionTime()<ul> <li>Add hook alias for showing report on compiled application: -Dguicey.hooks=provision-time</li> <li>GuiceProvisionTimeHook could be used in tests to record beans creation at runtime</li> </ul> </li> <li>Add the shared state usage report: .printSharedStateUsage()</li> <li>Improve guice bindings report (.printGuiceBindings()):<ul> <li>Fixed scope accuracy for linked bindings</li> <li>Fixed bindings for private modules (missed exposed linked bindings)</li> </ul> </li> </ul> </li> <li>Guicey bundles:<ul> <li>Add \"throws Exception\" for GuiceyBundle#initialize() to simplify usage</li> <li>Support extensions registration in GuiceyBundle run (.extensions() and .extensionsOptional())<ul> <li>ManualExtensionsValidatedEvent moved from configuration into run phase</li> <li>As before, classpath scan performed under configuration phase (but actual extensions registration moved to run phase)</li> </ul> </li> <li>Transitive guicey bundles (.bundles(...)) initialize immediately after registration (unify behavior with dropwizard bundles and guice modules)</li> <li>Add onApplicationShutdown() and listenJersey() listener methods for GuiceyEnvironment (GuiceyBundle.run) </li> </ul> </li> <li>Add \"throws Exception\" for GuiceyConfigurationHook#configure() to simplify usage</li> <li>Private guice modules support:<ul> <li>Add private modules analysis: extensions searched in private module bindings too   (also important for avoiding duplicate binding registration after classpath scan)</li> <li>Add AnalyzePrivateGuiceModules option (enabled by default) to disable private modules   analysis (in case of problems)</li> <li>Disabled modules remove would also affect private modules now (but only first level)</li> </ul> </li> <li>Classpath scan:<ul> <li>Add extensions scan filters: GuiceBundle.builder().autoConfigFilter(cls -&gt; !cls.isAnnotationPresent(Skip.class))   Could be used either to skip some classes from scanning (without @InvisibleForScanner) annotation   or to accept only annotated classes (spring style) (#419)<ul> <li>Added ClassFilters utility with common predicates: .autoConfigFilter(ignoreAnnotated(Skip.class))</li> </ul> </li> <li>Scan could detect package-private and protected extensions with a new option:   GuiceyOptions.ScanProtectedClasses (by default, false) (#404) </li> </ul> </li> <li>Improve disable extensions predicate (bundle.disable(...)):<ul> <li>Fix predicate applied for extension too early (without installer set)</li> <li>Add disable predicates: Disables.jerseyExtension, Disabled.webExtension and Disables.installedBy</li> <li>Predicates for exact type (module, bundle etc.) in Disables now raise item type to simplify further declarations</li> </ul> </li> <li>Shared state: <ul> <li>(breaking) Tie a state key to the stored object type to simplify usage (type-safe) and force   state objects usage instead of whatever values</li> <li>Fix null value supplier behavior (not allowed): .get(key, supplier)</li> <li>Add Options (read only accessor) object: state.getOptions()</li> <li>Add .whenReady() method for reactive state value access<ul> <li>Add .whenSharedStateReady() for GuiceyBootstrap and GuiceyEnvironment   (not required for the main bundle as there is withSharedState() method where whenReady() could be used directly) </li> </ul> </li> <li>Shared state usage report could be obtained at any time directly from the shared state   object (sharedState.getAccessReport())</li> </ul> </li> <li>Tests:<ul> <li>Add the ability to disable managed objects lifecycle for lightweight guicey tests   (start/stop methods on managed objects not called; might be useful for tests with mocks):<ul> <li>new GuiceyTestSupport().disableManagedLifecycle()</li> <li>@TestGuiceyApp(.., managedLifecycle = false)</li> <li>TestGuiceyAppExtension.forApp(..).disableManagedLifecycle()</li> <li>TestSupport.build(App.class).runCoreWithoutManaged(..)</li> </ul> </li> <li>Add manual configuration object creation support for junit 5 extensions registered in field (@EnableSetup)   and TestEnvironmentSetup: .config(() -&gt; {...})</li> <li>Add missed configOverride(key, value) method for a single key-value pair</li> <li>Add configuration modifiers (<code>ConfigModifier</code>) - an alternative for configuration override mechanism:   ability to modify configuration instance before application startup.   Supported by all test extensions (junit5 annotations, setup object, generic builders, command runner)</li> <li>Add custom configuration block for junit5 extensions and TestEnvironmentSetup (to simplify lambda-based configurations): .with({...})</li> <li>Junit ExtensionContext object could be injected as test method parameter</li> <li>Debug option:<ul> <li>Track guicey test extensions time (would appear when debug enabled)</li> <li>Improve debug report: setup objects and hooks registration point are clear now (with direct code links)</li> </ul> </li> <li>Add injectOnce option into test extensions to call injectMembers once per test instance   (useful when TestInstance.Lifecycle.PER_CLASS used) (discussion #394) </li> <li>Setup objects (TestEnvironmentSetup):<ul> <li>Add \"throws Exception\" for TestEnvironmentSetup#setup() to simplify usage</li> <li>TestExtension builder improvements (TestEnvironmentSetup#setup(TestExtension)):<ul> <li>Add getJunitContext() method to be able to configure test application with full context access (discussion #388)</li> <li>Add test lifecycle listeners: could be registered with listen() method or lambda-based on* methods   and provide notifications for guicey extension lifecycle (app start/stop, before/after test).   This is a simple alternative to writing junit extensions for additional integrations (db, testcontainers etc.).</li> <li>Add junit extension debug state method isDebug() so setup objects could   show debug output when debug option is enabled on guicey extension</li> <li>Add shortcut method isApplicationStartedForClass() to simplify beforeAll/beforeEach extension lifecycle detection</li> <li>Add annotated fields search api: findAnnotatedFields(..) to simplify writing annotation-driven extensions</li> </ul> </li> <li>Add automatic setup objects (TestEnvironmentSetup) loading with service loader (simplify plugging-in extensions)</li> <li>Add base class for annotated fields extensions: AnnotatedTestFieldSetup   Handles fields validation and value injection lifecycle, including proper nested tests support   (all new test extensions based on it)</li> </ul> </li> <li>New field-based test extensions:<ul> <li>Add test stub fields: @StubBean(Service.class) ServiceStub   (use guice modules override feature to replace existing service into stub)</li> <li>Add mockito mock support: @MockBean Service. Mock automatically created   and override real dependency (module overrides used)</li> <li>Add mockito spy support: @SpyBean Service. Spy automatically created   and \"proxy\" real service (using aop)</li> <li>Add service trackers: @TrackBean Tracker. Tracker records all service   methods execution and could provide recordings for test verification or print performance   stats. A simpler replacement for mockito stubs. It could be used with mocks, spies and stubs <li>Add REST stub (@StubRest): ability to start rest (or part of rest services) under @TestGuiceyApp   (without starting full container; same as dropwizard's ResourceExtension)</li> <li>Add logs testing support (@RecordLogs): record required logs for validation (only logback)</li> <li>Add option to disable default (new) annotated fields extensions: useDefaultExtensions </li> <li>Internal:<ul> <li>Add BeforeInit guicey event (the first point with available Bootstrap)</li> <li>Add WebInstaller marker interface to identify web extensions (extensions started with jersey)</li> </ul> </li>"},{"location":"about/history/#714-2024-09-14","title":"7.1.4 (2024-09-14)","text":"<ul> <li>Update to dropwizard 4.0.8</li> </ul>"},{"location":"about/history/#713-2024-03-31","title":"7.1.3 (2024-03-31)","text":"<ul> <li>Update to dropwizard 4.0.7</li> <li>Fix guicey ApplicationShutdownEvent typo (#387)</li> </ul>"},{"location":"about/history/#712-2024-02-17","title":"7.1.2 (2024-02-17)","text":"<ul> <li>Update to dropwizard 4.0.6</li> </ul>"},{"location":"about/history/#711-2024-01-08","title":"7.1.1 (2024-01-08)","text":"<ul> <li>Update to dropwizard 4.0.5</li> </ul>"},{"location":"about/history/#710-2023-11-28","title":"7.1.0 (2023-11-28)","text":"<ul> <li>Update to dropwizard 4.0.4</li> <li>Add qualifier annotations support for configuration properties binding:   any configuration property (any level), annotated with qualifier annotation, would be   directly bound with that qualifier. Core dropwizard objects could be qualified on overridden getter</li> <li>Test improvements:<ul> <li>Junit 5 extensions could inject DropwizardTestSupport object itself as test method parameter</li> <li>ClientSupport:<ul> <li>inner jersey client creation is customizable now with TestClientFactory implementation   (new attribute \"clientFactory\" in @TestGuiceyApp and @TestDropwizardApp)</li> <li>default factory would automatically configure:<ul> <li>multipart feature if available in classpath (dropwizard-forms)</li> <li>direct console logging (to see requests and responses directly in console)</li> </ul> </li> <li>New methods:<ul> <li>basePathRoot - root url (only with port)</li> <li>get(), post(), delete(), put() - simple shortcut methods to perform basic operations relative to server root</li> </ul> </li> </ul> </li> <li>Context support object (DropwizardTestSupport) and client (ClientSupport) instances are accessible now statically   for both manual run (TestSupport) and junit extensions: TestSupport.getContext() and TestSupport.getContextClient()</li> <li>New generic builder for flexible DropwizardTestSupport object creation and run (when junit extension can't be used):   TestSupport.builder() (with lifecycle listeners support)</li> <li>TestSupport methods changes:<ul> <li>Creation and run methods updated with config override (strings) support</li> <li>Add creation and run methods application class only (and optional overrides).</li> <li>Run methods without callback now return RunResult containing all objects, required for validation (for example, to examine config)</li> <li>Add captureOutput method to record console output for assertions</li> </ul> </li> <li>Commands test support:<ul> <li>TestSupport.buildCommandRunner() - builds runner for command execution   with the same builder options as in generic builder (TestSupport.builder(); including same configuration)   and user input support.</li> <li>Could be used to test application startup fail (without using system mocks)</li> </ul> </li> </ul> </li> </ul>"},{"location":"about/history/#702-2023-10-06","title":"7.0.2 (2023-10-06)","text":"<ul> <li>Update to dropwizard 4.0.2</li> </ul>"},{"location":"about/history/#701-2023-07-05","title":"7.0.1 (2023-07-05)","text":"<ul> <li>Update to dropwizard 4.0.1</li> <li>[jdbi]<ul> <li>Fix jdbi 3.39 compatibility</li> <li>Avoid redundant transaction isolation level checks (extra queries) (#318)</li> </ul> </li> <li>[gsp]<ul> <li>Fix redirection to error page after direct template rendering fails</li> </ul> </li> </ul>"},{"location":"about/history/#700-2023-05-14","title":"7.0.0 (2023-05-14)","text":"<ul> <li>Update to dropwizard 4<ul> <li>(breaking) Use jakarta namespace instead of javax (servlet, validation)</li> </ul> </li> <li>Update to guice 7 (jakarta.inject namespace)</li> </ul>"},{"location":"about/history/#610-2023-05-14","title":"6.1.0 (2023-05-14)","text":"<ul> <li>Update to guice 6.0</li> </ul>"},{"location":"about/history/#600-2023-04-02","title":"6.0.0 (2023-04-02)","text":"<ul> <li>Update to dropwizard 3<ul> <li>(breaking) Drop java 8 support</li> </ul> </li> <li>Merged with guicey-ext modules repository:<ul> <li>Ext modules version would be the same as guicey</li> <li>dropwizard-guicey POM would not be a BOM anymore (everything moved to guicey-bom)</li> <li>Exclusions not applied in BOM anymore, instead they applied directly in POM</li> </ul> </li> </ul>"},{"location":"about/history/#571-2023-03-09","title":"5.7.1 (2023-03-09)","text":"<ul> <li>Update to dropwizard 2.1.5</li> <li>Revert changing reports log level: now INFO used instead of WARN (#276)</li> </ul>"},{"location":"about/history/#570-2022-12-29","title":"5.7.0 (2022-12-29)","text":"<ul> <li>Update to dropwizard 2.1.4</li> <li>Fix NoClassDefFoundError(AbstractCollectionJaxbProvider) appeared for some jersey provider registrations (#240)</li> <li>Jersey extensions might omit <code>@Provider</code> on known extension types (ExceptionMapper, MessageBodyReader, etc.).   Unifies usage with pure dropwizard (no additional <code>@Provider</code> annotation required). (#265)<ul> <li>New option InstallerOptions.JerseyExtensionsRecognizedByType could disable new behaviour</li> </ul> </li> <li>Support ModelProcessor jersey extension installation (#186)</li> <li>Add extensions help: .printExtensionsHelp() showing extension signs recognized by installers (in recognition order)<ul> <li>Custom installers could participate in report by overriding FeatureInstaller.getRecognizableSigns()   (default interface method).</li> </ul> </li> <li>Change reports log level from INFO to WARN to comply with default dropwizard level</li> <li>Support application reuse between tests (#269)<ul> <li>new reuseApplication parameter in extensions enables reuse</li> <li>reusable application must be declared in base test class: all tests derived   from this base class would use the same application instance</li> </ul> </li> <li>Add SBOM (json and xml with cyclonedx classifier)</li> <li>Add .enableAutoConfig() no-args shortcut for enabling classpath scan in application package</li> </ul>"},{"location":"about/history/#561-2022-07-02","title":"5.6.1 (2022-07-02)","text":"<ul> <li>Update dropwizard to 2.1.1 (fixes java 8 issue by allowing afterburner usage)</li> <li>Fix classpath scan recognition of inner static classes inside jars (#231)</li> <li>Junit 5 extensions:<ul> <li>Fix parallel test methods support (configuration overrides were applied incorrectly)</li> <li>Add \"debug\" option: when enabled, prints registered setup objects, hooks and   applied configuration overrides<ul> <li>Setup objects and hooks not printed by default as before, only when debug enabled</li> <li>Debug could be also enabled with system property -Dguicey.extensions.debug=true   or with alias TestSupport.debugExtensions()</li> </ul> </li> </ul> </li> </ul>"},{"location":"about/history/#560-2022-06-07","title":"5.6.0 (2022-06-07)","text":"<ul> <li>Update dropwizard to 2.1.0</li> <li>Test support objects changes:<ul> <li>Add new interface TestEnvironmentSetup to simplify test environment setup<ul> <li>In contrast to guicey hooks, setup objects used only in tests to replace the need of writing   additional junit extensions (for example, to set up a test db). It provides a simple way to   override application configuration (e.g. to specify credentials to just started db)</li> <li>Registration is the same as with hooks: annotation or inside extension builder and with   field using new annotation @EnableSetup</li> </ul> </li> <li>Hooks and setup objects configured in test are logged now in execution order and   with registration source hint</li> <li>@EnableHook fields might be declared with custom classes (not only raw hook interface)</li> </ul> </li> <li>Junit 5 extensions field registration (@RegisterExtension) changes<ul> <li>Application might be started per-test-method now (when extension registered in non-static field)<ul> <li>In this case support objects might also be registered in non-static fields</li> </ul> </li> <li>Add configOverrideByExtension method to read configuration override value   registered by 3<sup>rd</sup> party junit 5 extension (from junit extension store).</li> <li>hooks(Class) method accepts multiple classes</li> <li>configOverrides(String...) now aggregates multiple calls</li> </ul> </li> </ul>"},{"location":"about/history/#550-2022-03-30","title":"5.5.0 (2022-03-30)","text":"<ul> <li>Test framework-agnostic utilities:<ul> <li>Add GuiceyTestSupport to simplify guice-only manual application runs   (by analogy to DropwizardTestSupport class)</li> <li>Add TestSupport class as a root for test framework-agnostic utilities.   Suitable for application startup errors testing and integration within not supported test runner.</li> </ul> </li> <li>Add Spock 2 support: there is no custom extensions, instead existing junit 5 extensions would be used   through a special library spock-junit5 (developed specifically for this integration)</li> <li>Change \"hooks in base test class\" behaviour: hooks from static fields from base classes applied before hooks in test itself.   Such behaviour is more natural - \"base classes declarations go first\"   (before all field hooks were applied after annotation hooks)</li> <li>Extract Spock 1 and Junit 4 extensions from core into ext modules:<ul> <li>packages remain the same, so there should be no issues with it (just add new dependency)</li> <li>removed deprecation markers from Junit 4 rules (entire module assumed to be deprecated; fewer warnings on build)</li> </ul> </li> <li>BOM changes:<ul> <li>spock version removed in order to avoid problems downgrading spock version for spock1 module</li> <li>system-rules removed because it targets junit4 (ext module provides it)</li> <li>groovy libraries removed (newer groovy 2.x was required for spock1 to run on java 11)</li> <li>add spock-junit5 version</li> </ul> </li> </ul>"},{"location":"about/history/#542-2022-01-26","title":"5.4.2 (2022-01-26)","text":"<ul> <li>Update dropwizard to 2.0.28</li> <li>Update guice to 5.1.0 (java 17 support)</li> </ul>"},{"location":"about/history/#541-2021-12-19","title":"5.4.1 (2021-12-19)","text":"<ul> <li>Fix inner guice class usage in always executable code (#187, OSGi issue)</li> <li>Update dropwizard to 2.0.27 (many dependency updates in the latest versions fixing java 17 support)</li> </ul>"},{"location":"about/history/#540-2021-10-21","title":"5.4.0 (2021-10-21)","text":"<ul> <li>Use direct dependency versions in pom to simplify resolution (dependencyManagement section remains but for usage as BOM only)</li> <li>Fix lambda modules support (modules declared with lambda expression) (#160)</li> <li>Exclude \"sun.*\" objects from configuration analysis (#170, #180)</li> <li>Fix junit5 extensions support for @TestInstance(TestInstance.Lifecycle.PER_CLASS)   (class instance injections now processed in beforeEach hook instead of instancePostProcessor)</li> <li>Add error message when junit5 extensions incorrectly registered with non-static fields (to avoid confusion)</li> <li>SharedConfigurationState:<ul> <li>Add ability for direct static lookup during startup (from main thread):   SharedConfigurationState.getStartupInstance()   (option required for places where neither application not environment object accessible   (e.g. binding installer, bundle lookup, etc.); and could be used for common objects resolution where otherwise   they are not directly accessible)</li> <li>Add shortcut methods on state instance producing providers (lazy) for common objects:   getBootstrap, getApplication, getEnvironment, getConfiguration, getConfigurationTree   (example usage during startup: SharedConfigurationState.getStartupInstance().getApplication() returns Provider) <li>Unify shared state access methods in GuiceyBootstrap, GuiceyEnvironment and DropwizardAwareModule   (removes implicit limitation that shared state must be initialized only in init phase)</li>"},{"location":"about/history/#530-2021-03-06","title":"5.3.0 (2021-03-06)","text":"<ul> <li>Update to guice 5.0.1   (java15 support, removes cglib, fixes \"illegal reflective access\" warnings, update Guava to LATEST 30.1-jre)</li> <li>Update to dropwizard 2.0.20</li> <li>Unify GuiceyAppRule (junit4) behaviour with DropwizardAppRule: config overrides should initialize just   before test and not in the constructor. The issue was causing early evaluation of lazy (deferred) overrides (#151)</li> <li>Add custom ConfigOverride objects support for junit 5 extensions (registered with @RegisterExtension)  </li> </ul>"},{"location":"about/history/#520-2020-11-29","title":"5.2.0 (2020-11-29)","text":"<ul> <li>Update to dropwizard 2.0.16</li> <li>Remove direct usages of logback-classic classes to unlock logger switching (#127)</li> <li>Fix stackoverflow on config introspection caused by EnumMap fields (#87) </li> <li>Prioritize registered jersey provider extensions and add support for @Priority annotation (#97)   Unifies raw dropwizard and guicey behaviour. Possibly breaking, see note below.</li> <li>Add lifecycle event: ApplicationStoppedEvent (triggered on jersey lifecycle stop)   </li> </ul>"},{"location":"about/history/#510-2020-06-02","title":"5.1.0 (2020-06-02)","text":"<ul> <li>Update guice to 4.2.3 (java 14 support)</li> <li>Update to dropwizard 2.0.10</li> <li>Add junit 5 extensions (#74). Works much like existing spock extensions:<ul> <li>@TestGuiceyApp for replacement of GuiceyAppRule</li> <li>@TestDropwizardApp for using instead of DropwizardAppRule (or current dropwizard extension)</li> </ul> </li> <li>Spock extensions updates:<ul> <li>Internally, use DropwizardTestSupport instead of deprecated junit 4 rules</li> <li>New features (port features from junit 5 extensions):<ul> <li>@UseDropwizardApp got new configurations: randomPorts and restMapping </li> <li>@UseGuiceyHooks deprecated: instead additional hooks may be declared in static test field</li> <li>ClientSupport test field will be injected with client support object instance</li> </ul> </li> </ul> </li> <li>Junit 4 rules deprecated GuiceyAppRule, StartupErrorRules             </li> <li>Fix parallel tests support: guice logs interception wasn't thread safe (#103)     </li> <li>Fix invalid Automatic-Module-Name to 'ru.vyarus.dropwizard.guicey' (#106) </li> </ul>"},{"location":"about/history/#501-2020-03-13","title":"5.0.1 (2020-03-13)","text":"<ul> <li>Update to dropwizard 2.0.2 (address CVE-2020-5245)</li> <li>Fix yaml bindings report rendering with values containing string format parameters like %s (#77)</li> </ul>"},{"location":"about/history/#500-2019-12-15","title":"5.0.0 (2019-12-15)","text":"<ul> <li>Update to dropwizard 2.0.0<ul> <li>(breaking in jersey 2.26)<ul> <li>Jersey 2.26 introduces an abstraction for injection layer in order to get rid of hk2 direct usage.   This allows complete hk2 avoidance in the future. Right now it means that all direct hk2 classes must be replaced   by jersey abstractions (but still hk2 is the only production ready integration)<ul> <li>Jersey <code>InjectionManager</code> now bound to guice context instead of hk2 <code>ServiceLocator</code>      (locator still can be retrieved from manager)</li> <li>Rename HK2 mentions into jersey (because now jersey is not tied to hk2)<ul> <li><code>@HK2Managed</code> renamed to <code>@JerseyManaged</code> </li> </ul> </li> <li>JerseyProviderInstaller (installs classes annotated with <code>@Provider</code>) changes:     <ul> <li><code>ValueParamProvider</code> detected instead of <code>ValueFactoryProvider</code> </li> <li><code>Supplier</code> detected instead <code>Factory</code> (Factory implementations are not recognized anymore!)</li> <li><code>org.glassfish.jersey.internal.inject.InjectionResolver</code> detected instead of <code>org.glassfish.hk2.api.InjectionResolver</code></li> </ul> </li> <li>Jersey installers use <code>org.glassfish.jersey.internal.inject.AbstractBinder</code>   instead of hk specific <code>org.glassfish.hk2.utilities.binding.AbstractBinder</code></li> <li>Mark all hk2-related methods and options as deprecated (to be removed in the next version)       </li> </ul> </li> <li>Jersey 2.26 implements jax-rs 2.1 which forced it to change some of it's apis.<ul> <li><code>org.glassfish.jersey.server.AsyncContext</code> binding used instead of      <code>org.glassfish.jersey.server.internal.process.AsyncContext</code> </li> </ul> </li> </ul> </li> <li>(breaking dw 2.0) <ul> <li>Deprecated <code>Bundle</code> usages replaced with <code>ConfigurableBundle</code>    (in new dropwizard version <code>Bundle extends ConfigurableBundle</code>)<ul> <li>Guicey configuration scope <code>ConfigSope.DropwizardBundle</code> now use <code>ConfigurableBundle</code> class for marking guice     bundle scope instead of <code>Bundle</code></li> </ul> </li> <li><code>dropwizard-bom</code> now includes only dropwizard modules. All 3<sup>rd</sup> party dependencies are moved to     <code>dropwizard-dependencies</code> package. So you'll have to update two boms now in order to update dropwizard version.</li> </ul> </li> <li>Update hk2 guice-bridge to 2.6.1            </li> </ul> </li> <li>(breaking) Guicey configuration and lifecycle changes:<ul> <li><code>GuiceyBundle</code> contract and behaviour changed to match dropwizard lifecycle: <ul> <li>GuiceyBundle now contains two methods <code>initialize</code> and <code>run</code> and called according to dropwizard lifecycle.     Now guicey bundles are complete replacement for dropwizard bundles, but with good interoperability      with pure dropwizard bundles </li> <li>The following guicey initializations were moved into dropwizard configuration phase:<ul> <li>Guicey bundles lookup and initialization (to be able to install dropwizard bundles inside guicey bundles)</li> <li>Installers classpath search and instantiation</li> <li>Extensions classpath search and validation (but on run phase it is still possible to disable extensions)</li> </ul> </li> <li>Extensions initialization moved outside injector creation scope. It will affect time report and, in case of    extension installation error, exception will be thrown directly instead of Guice's CreationException.        </li> <li>A lot of guicey lifecycle events obviously changed (and new added) <ul> <li>Add special <code>ApplicationStarted</code> event: always fired after complete dropwizard startup.      Supposed to be used to simplify diagnostic reporting.</li> <li>Support lifecycle listeners deduplication for correct report behaviour in case of multiple registrations.    <code>LinkedHashSet</code> used as listeners holder, so only proper equals and hashcode methods implementation is required for deduplication          </li> </ul> </li> <li>Removed <code>GuiceyOptions.ConfigureFromDropwizardBundles</code> option because it's useless with new bundles lifecycle.     (if required, the same behaviour may be implemented with custom bundles lookup)</li> </ul> </li> <li>Removed <code>GuiceyOptions.BindConfigurationInterfaces</code> option (interfaces are already bound with <code>@Config</code> qualifier)</li> <li>Guicey web installers (<code>WebInstallersBundle</code>) enabled by default.    <code>GuiceBundle.builder()#useWebInstallers()</code> option removed</li> <li>Direct dropwizard bundles support: bundles could be registered directly in main bundle (<code>GuiceBundle.dropwizardBundles()</code>)   or inside guicey bundle (<code>GuiceyBundle.dropwizardBundles()</code>). These bundles could be disabled (same as guicey bundles - with    <code>.disableDropwizardBundles()</code> methods) and are show in reporting.<ul> <li>Transitive dropwizard bundles tracking: all dropwizard bundles registered through guicey api are tracked for   transitive registration with bootstrap proxy. That means that all transitive bundles are shown in reports and    any transitive bundle could be disabled (with <code>.disableDropwizardBundle</code> or custom predicate). Also, deduplication checks    will work (same as for guicey bundles and guice modules).   Tracking may be disabled with <code>GuieyOptions.TrackDropwizardBundles</code> option.  </li> </ul> </li> <li>Allow registration of multiple instances for guice modules and guicey bundles      (multiple instances of the same class)<ul> <li>By default, equal instances of the same type considered duplicate (only one registered).     So, to grant uniqueness of bundle or module, implement correct equals method.     For custom cases (when custom equals method is impossible), <code>DuplicateConfigDetector</code> may be implemented      and registered with <code>GuiceBundle.Builder#duplicateConfigDetector()</code> </li> <li>Legacy behaviour (1 instance per type) could be simulated with: <code>.duplicateConfigDetector(new LegacyModeDuplicatesDetector())</code>   OR method <code>GuiceBundle.Builder#uniqueItems(Class...)</code> may be used to specify   exact items to grant uniqueness for </li> <li><code>ItemId</code> is now used as identity instead of pure <code>Class</code>. ItemId compute object hash string     and preserve it for instance identification. Class types does not contain hash in id.     Required because even scopes, represented previously as classes now could be duplicated     as multiple instances of the same bundle class could be registered. For simplicity,     ItemId equals method consider class-only id's equal to any type instance id.</li> <li>Add bundle loops detection: as multiple bundle instances allowed loops are highly possible     Entire bundle chain is provided in exception to simplify fixing loops.</li> <li>Add base classes for unique bundles and modules (with correct equals and hash code implementations):   <code>UniqueGuiceyBundle</code> and <code>UniqueModule</code> or <code>UniqueDropwizardAwareModule</code> (use class name strings for    comparison to correctly detect even instances of classes from different class loaders).    Note: no such class for dropwizard bundle because it's useless (if you use guicey - use GuiceyBundle instead    and if you need dropwizard bundle - it shouldn't be dependent on guicey classes)     </li> </ul> </li> <li>Support extensions recognition from guice modules (jersey1-guice style): <ul> <li>extensions are detected from declaration in specified guice modules      (essentially same as classpath scan, but from bindings)            </li> <li>extensions declared in:<ul> <li>direct type bindings (all generified or qualified declarations ignored)</li> <li>linked bindings (right part) bind(Something).to(Extension) are also recognized     (which must also be non qualified)    </li> </ul> </li> <li>like in classpath scan <code>@InvisibleForScanner</code> prevents recognition     (or bean may be simply qualified)</li> <li>all extension registration types may work together (classpath scan, manual declaration and binding declaration)    </li> <li>extensions registered directly (or found by classpath scan) and also bound manually in guice module      will not conflict anymore (as manual declaration would be detected) and so @LazyBinding workaround is not needed        </li> <li>extensions declared in guice module may be also disabled (guicey will remove binding declaration in this case      and all chains leading to this declaration to prevent possible context failures)</li> <li>Transitive guice modules (installed by other modules) may be disabled with usual <code>disableModules()</code>     (but only if guice bindings analysis is not disabled).</li> <li>enabled by default, but can be disabled with <code>GuiceyOptions.AnalyzeModules</code> option</li> <li><code>BindingInstaller</code> interface changed (because of direct guice bindings):      it now contains 3 methods for class binding, manual binding validation and reporting</li> </ul> </li> <li>Extension classes loaded by different class loaders now detected as duplicate extension registration        </li> </ul> </li> <li>Guicey hooks, initially supposed to be used for testing only, now considered to be also used for     diagnostic tools<ul> <li>Add guicey hooks lookup from system property <code>guicey.hooks</code> as comma-separated list of classes.</li> <li>Add hook aliases support: alias name assumed to be used instead of full class name in system property (<code>-Dguicey.hooks</code>).   Alias registered with <code>GuiceBundle.builder()#hookAlias()</code>. All registered aliases are logged at startup.</li> <li>Add diagnostic hook, which enables diagnostic reports and lifecycle logs.      Could be enabled with system property: <code>-Dguicey.hooks=diagnostic</code> (where diagnostic is pre-registered hook alias)      Useful to enable diagnostic logs on compiled (deployed) application.</li> <li>(breaking) Removed hooks recognition on registered GuiceyLifecycleLister (as it was very confusing feature)                         </li> </ul> </li> <li>Add shared configuration state (for special configuration-time needs like bundles communication).      This is required only in very special cases. But such unified place will replace all current and future hacks.<ul> <li>Static access by application: <code>SharedConfigurationState.get(app)</code> or <code>SharedConfigurationState.lookup(app, key)</code></li> <li>Static access by environment: <code>SharedConfigurationState.get(env)</code> or <code>SharedConfigurationState.lookup(env, key)</code> </li> <li>Value access from guicey bundle: <code>boostrap.sharedState(key, defSupplier)</code>, <code>environment.sharedState(key)</code></li> <li>Value access from <code>DropwizardAwareModule</code>: <code>sharedState</code></li> <li>Hooks can use <code>GuiceBundle.Builder.withSharedState</code> to access application state.</li> <li>(breaking) <code>InjectorLookup</code> now use global shared state        <ul> <li><code>clear()</code> method removed, but <code>SharedConfigurationState.clear()</code> could be used instead   </li> </ul> </li> </ul> </li> <li>(breaking) Test support changes<ul> <li>Rename test extensions for guicey hooks registration: <ul> <li><code>GuiceyConfigurationRule</code> into <code>GuiceyHooksRule</code> </li> <li><code>@UseGuiceyConfiguration</code> (spock extension) into <code>@UseGuiceyHooks</code></li> </ul> </li> </ul> </li> <li>(breaking) Reporting changes<ul> <li>All reports moved into one top-level <code>debug</code> package.</li> <li>All guicey reports are now guicey lifecycle listeners<ul> <li><code>DiagnosticBundle</code> bundle become <code>ConfigurationDiagnostic</code> guicey listener.     Reporters are no more bound to guice context (they could always be constructed manually).</li> <li><code>DebugGuiceyLifecycle</code> listener renamed into <code>LifecycleDiagnostic</code></li> <li>Guicey reports (listeners) properly implement equals and hashcode in order to    use new deduplication mechanism and avoid reports duplication (for example,   if <code>.printDiagnosticInfo()</code> would be called multiple times, only one report would be shown;   but still different configurations will be reported separately (e.g. list <code>.printDiagnosticInfo()</code> and    <code>.printAvailableInstallers()</code> which internally use one listener))</li> </ul> </li> <li>Report all diagnostic reports as one log message in order to differentiate <code>.printDiagnosticInfo()</code>      and <code>.printAvailableInstallers()</code> reports when both active      </li> <li>Diagnostic report changes (<code>.printDiagnosticInfo()</code>):         <ul> <li>Show both dropwizard and guicey bundles together (dropwizard bundles marked with DW)</li> <li>Always show \"empty\" bundles (bundles without sub registrations) - important for dw bundles</li> <li>Add \"-\" before ignored or disabled items (to visually differentiate from accepted items)</li> <li>Identify instance deduplication:<ul> <li>Instead of registrations count (REG(2)) show exact counter of all registered and accepted items: REG(5/12)</li> <li>Show ignored items even in context where items of the same type were accepted</li> <li>Show exact number of ignored items in context (DUPLICATE(3))</li> </ul> </li> <li>Show extension recognized from guice bindings (as sub report)</li> <li>Stats report improved:<ul> <li>Show guice internal stat logs in stats diagnostic report (intercept guice logs)</li> <li>Show guicey time by phases (init/run/jersey)</li> <li>Show guice modules analysis stats                      </li> </ul> </li> </ul> </li> <li>Show installer marker interfaces in <code>printAvailableInstallers()</code> report to indicate installer actions     (installation by type or instance, custom guice or jersey bindings, options support).</li> <li>Detailed lifecycle report (<code>.printLifecyclePhasesDetailed</code>) show context data for each event                                                                                                     </li> <li>Add guice bindings report (<code>printGuiceBindings()</code> or <code>printAllGuiceBindings()</code>)</li> <li>Add guice aop appliance report (<code>.printGuiceAopMap()</code>). This report supposed to be used as \"a tool\" to look exact    services and so configurable method version is directly available:    <code>.printGuiceAopMap(new GuiceAopConfig().types(...).methods(...))</code></li> <li>Add web mappings report (<code>.printWebMappings()</code>): prints all registered servlets and filters</li> <li>Add jersey config report (<code>.printJerseyConfig</code>): prints all registered jersey extensions        </li> </ul> </li> <li>Fix configuration bindings for recursive configuration object declarations (#60)</li> <li>Guicey version added into BOM (dependencyManagement section in guicey pom) to avoid duplicate versions declarations</li> <li>Java 11 compatibility. Automatic module name (in meta-inf): <code>dropwizard-guicey.core</code></li> <li>(breaking) AdminRestBundle moved into ext modules (bundle become guicey bundle,      now return 404 instead of 403 on main context for admin-only resources)</li> <li>(breaking) Remove useless configuration generic on main bundle: <code>GuiceBundle.&lt;MyConfig&gt;builder()</code> must be just <code>GuiceBundle.builder()</code></li> <li>InjectorLookup:<ul> <li>Add lookup by environment instance: <code>InjectorLookup.get(environment)</code> </li> <li>Add direct lookup for bean instance: <code>InjectorLookup.getInstance(app, MyBean.class)</code> (or with environment)      </li> </ul> </li> <li>Update installers console reporting to use more readable class format: SimpleName   (reduced package)</li> <li>Add optional extensions support: optional extension automatically become disabled when no compatible installer found     Could be registered with new method in main and guicey bundles: <code>.extensionsOptional</code> </li> </ul>"},{"location":"about/history/#422-2018-11-26","title":"4.2.2 (2018-11-26)","text":"<ul> <li>Update to guice 4.2.2 (java 11 compatible)</li> <li>Update to dropwizard 1.3.7</li> <li>Fix inner non static classes detection by classpath scan</li> <li>Fix lifecycle debug messages decoration (unicode fix)</li> </ul>"},{"location":"about/history/#421-2018-07-23","title":"4.2.1 (2018-07-23)","text":"<ul> <li>Show warning when configuration path's value resolution failed instead of startup fail (#53)</li> <li>Add GuiceyOptions.BindConfigurationByPath to be able to disable configuration introspection (for edge cases) (#53)</li> <li>Fix unique sub configuration object access (#54) </li> </ul>"},{"location":"about/history/#420-2018-06-25","title":"4.2.0 (2018-06-25)","text":"<ul> <li>Update to guice 4.2.0<ul> <li>remove guice-multibindings dependency as it's moved to guice core</li> </ul> </li> <li>Update to dropwizard 1.3.5    </li> <li>Add more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions:<ul> <li>Guicey bundles disabled through main builder only: .disableBundles() </li> <li>Other disable methods available in both main bundle and guicey bundles bootstrap:<ul> <li>.disableModules(Class...) - disable guice modules</li> <li>.disableExtensions(Class...) - extensions disabling (for possible replacement) </li> <li>generic disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.)</li> </ul> </li> </ul> </li> <li>Add direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap:      .modulesOverride(Module...)<ul> <li>Add BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case)     </li> </ul> </li> <li>Add hooks for configuration override in integration tests (#23):<ul> <li>New GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods)</li> <li>Junit:<ul> <li>New rule GuiceyConfigurationRule for hook registration </li> </ul> </li> <li>Spock:<ul> <li>New @UseGuiceyConfiguration extension allows base hook definition (in base class)</li> <li>New attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks                      </li> </ul> </li> </ul> </li> <li>Add guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment.      It may be used to write instance specific features (post processing) or just advanced logging<ul> <li>Add new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...)      </li> <li>Add guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic):<ul> <li>.printLifecyclePhases() - identify configuration stages in console logs </li> <li>.printLifecyclePhasesDetailed() -  identify lifecycle phases with detailed configuration report (in console logs) </li> </ul> </li> </ul> </li> <li>Improve options support:<ul> <li>Add OptionsAwareModule interface to let guice modules access options</li> <li>Add OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options() </li> </ul> </li> <li>Add ability to manage jersey extensions with HK2 by default (#41).      It's like using @HK2Managed on all jersey-related beans (resources, filters etc).      This is useful, for example, if you get common to jersey resources features like @Context injection.   <ul> <li>Add option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default.     HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not).</li> <li>Add @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless).    In guice-first mode this annotation is useless.    </li> <li>Builder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling.</li> </ul> </li> <li>Guice beans scope-related improvements:<ul> <li>Singleton scope is not forced for jersey extensions with explicit scoping annotation </li> <li>Add option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions</li> <li>Add annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled</li> <li>Fix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49)</li> </ul> </li> <li>Add Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object)</li> <li>Add ConfigScope enum for special scopes description (to not remember special classes).<ul> <li>Add shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo)        </li> </ul> </li> <li>(breaking) Config reporting api changes:<ul> <li>Diagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items</li> <li>Diagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application)</li> </ul> </li> <li>New configuration bindings:<ul> <li>Configuration object could be bound as:<ul> <li>any class from configuration class hierarchy (as before)</li> <li>any class from hierarchy with @Config qualifier: @Inject @Config Configuration conf</li> <li>interface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config</li> <li>(Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before),     but prefer binding interfaces with qualifier (@Config), which is always available.     Option will be removed in the future versions</li> <li>(Deprecated) bundle's builder.bindConfigurationInterfaces()                 </li> </ul> </li> <li>Configuration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush     Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg</li> <li>Sub configuration objects could be bound without path if object type appear only once in configuration:     @Inject @Config ServerFactory serverCfg</li> <li>ConfigurationTree - configuration introspection object is available for direct binding<ul> <li>and from GuiceyConfigurationInfo bean: getConfigurationTree()</li> </ul> </li> <li>Alternative configuration access:<ul> <li>New configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule):<ul> <li>configuration(String) - configuration value by path</li> <li>configuration(Class) - unique sub configuration object</li> <li>configurations(Class) - all sub configuration objects with assignable type (on any depth)</li> <li>configurationTree() - access raw introspection data for more complex searches                </li> </ul> </li> </ul> </li> <li>Reports to see available config bindings (before injector creation for potential problems solving) in main bundle:<ul> <li>.printConfigurationBindings() - log all bindings (including dropwizard Configuration) </li> <li>.printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes)                  </li> </ul> </li> </ul> </li> <li>Includes much improved generics-resolver</li> </ul>"},{"location":"about/history/#410-2017-05-09","title":"4.1.0 (2017-05-09)","text":"<ul> <li>Update to dropwizard 1.1.0</li> <li>Add StartupErrorRule to simplify dropwizard startup error testing</li> <li>(breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used  to enable bridge (#28)  </li> <li>Fix NPE when used with JRebel (#29)</li> <li>Add binding for jersey javax.ws.rs.container.ResourceInfo (#26)</li> <li>Fix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32)</li> <li>Fix guava conflict in guicey pom. Make guicey pom usable as BOM.</li> </ul>"},{"location":"about/history/#401-2016-11-18","title":"4.0.1 (2016-11-18)","text":"<ul> <li>Update to dropwizard 1.0.5 and fix compatibility (#24)</li> <li>Fix guice version conflict for maven (#20)</li> </ul>"},{"location":"about/history/#400-2016-08-22","title":"4.0.0 (2016-08-22)","text":"<ul> <li>Update to dropwizard 1.0.0</li> <li>(breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle)</li> <li>Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts:<ul> <li>WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter</li> <li>WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet</li> <li>WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener    </li> </ul> </li> <li>Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3<sup>rd</sup> party bundles use its own low-level options.<ul> <li>GuiceyBootstrap option(option) method provides access to defined options from bundles</li> <li>Options guice bean provide access to options from guice services</li> <li>Installers could access options by implementing WithOptions interface</li> <li>OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions())</li> <li>Options reporting added to DiagnosticBundle</li> </ul> </li> <li>(breaking) remove GuiceBundle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean)      (use either shortcuts without parameters or generic options method instead)</li> <li>(breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option </li> <li>(breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava</li> <li>(breaking) InjectorLookup changed to use java8 Optional instead of guava    </li> <li>Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option </li> <li>Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) </li> <li>Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2)</li> <li>Add methods to GuiceBundle builder:<ul> <li>option(option, value) - used to specify custom option value</li> <li>options(Map) - used to provide multiple options at once (for custom options lookup mechanisms)</li> <li>printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features)</li> <li>useWebInstallers() - shortcut for installing WebInstallersBundle</li> <li>noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support  </li> <li>noDefaultInstallers() - disables CoreInstallersBundle automatic installation</li> </ul> </li> </ul>"},{"location":"about/history/#330-2016-08-02","title":"3.3.0 (2016-08-02)","text":"<ul> <li>Update to guice 4.1.0</li> <li>Update to dropwizard 0.9.3</li> <li>Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings</li> <li>ResourceInstaller looks for @Path on directly implemented interface (#10)</li> <li>Fix bundles lookup reporting (correct multiline)</li> <li>Fix duplicate extensions installation when registered both manually and by auto scan</li> <li>Restrict extension installation to one installer (first matching, according to installers order)</li> <li>Improve dropwizard configuration class binding:<ul> <li>Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself)</li> <li>(optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages   (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces()))</li> </ul> </li> <li>Add GuiceyBootstrap methods (extend GuiceyBundle abilities):<ul> <li>bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type.</li> <li>application(): returns current application instance</li> </ul> </li> <li>Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item<ul> <li>Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc)</li> <li>Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). </li> </ul> </li> <li>Add GuiceBundle builder configuration options:<ul> <li>bindConfigurationInterfaces() to enable configuration interface bindings</li> <li>strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests)</li> <li>printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs)</li> <li>shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces()</li> </ul> </li> </ul> <p>NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)    </p>"},{"location":"about/history/#320-2016-01-23","title":"3.2.0 (2016-01-23)","text":"<ul> <li>Clear possible duplicate guicey bundle instances</li> <li>Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources.<ul> <li>Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles.</li> <li>Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions.</li> <li>Add builder bundleLookup method to register custom lookup implementation</li> <li>Add builder disableBundleLookup to disable default look-ups</li> <li>Default lookup implementation logs all resolved bundles</li> </ul> </li> <li>Fix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support.</li> <li>Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed  are managed by HK2 only. May be used in tests as extra validation.</li> <li>Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. </li> <li>Update to dropwizard 0.9</li> <li>Revert system exit on guice injector creation error (added in 3.1.1)</li> </ul>"},{"location":"about/history/#311-2015-11-24","title":"3.1.1 (2015-11-24)","text":"<ul> <li>Exit on guice injector creation error.</li> <li>Add classpath scan packages validation for intersection (to prevent duplicate instances)</li> </ul>"},{"location":"about/history/#310-2015-09-06","title":"3.1.0 (2015-09-06)","text":"<ul> <li>JerseyProviderInstaller: </li> <li>add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor,   ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener</li> <li>support multiple extension interfaces on the same bean</li> <li>Introduce bundles (GuiceyBundle) to simplify extensions:</li> <li>core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed</li> <li>builder bundles() method to add guicey bundles</li> <li>builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism)</li> <li>Add admin context rest support (AdminRestBundle)</li> <li>Add request scoped beans support in admin context</li> </ul>"},{"location":"about/history/#301-2015-07-04","title":"3.0.1 (2015-07-04)","text":"<ul> <li>Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces</li> </ul>"},{"location":"about/history/#300-2015-04-26","title":"3.0.0 (2015-04-26)","text":"<ul> <li>Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) </li> <li>(breaking) Remove static state from GuiceBundle:</li> <li>GuiceBundle.getInjector method remain, but its now instance specific (instead of static)</li> <li>Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() </li> <li>JerseyInstaller interface signature changed: now install method receives injector instance</li> </ul>"},{"location":"about/history/#220-2015-04-17","title":"2.2.0 (2015-04-17)","text":"<ul> <li>Fix ExceptionMapper registration</li> <li>Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10  (to simplify custom installers injection between them)</li> </ul>"},{"location":"about/history/#212-2015-03-03","title":"2.1.2 (2015-03-03)","text":"<ul> <li>Spock 1.0 compatibility</li> </ul>"},{"location":"about/history/#211-2015-01-25","title":"2.1.1 (2015-01-25)","text":"<ul> <li>Dropwizard 0.8-rc2 compatibility</li> </ul>"},{"location":"about/history/#210-2015-01-04","title":"2.1.0 (2015-01-04)","text":"<ul> <li>Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by Nicholas Pace</li> <li>Add spock extensions to use injections directly in specification (like spock-guice do)</li> </ul>"},{"location":"about/history/#200-2014-11-25","title":"2.0.0 (2014-11-25)","text":"<ul> <li>Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)). Jersey integration completely rewritten.</li> <li>Add JerseyInstaller installer type</li> <li>Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)</li> </ul>"},{"location":"about/history/#110-2014-10-23","title":"1.1.0 (2014-10-23)","text":"<ul> <li>Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils</li> <li>Drop java 1.6 compatibility, because dropwizard is 1.7 compatible</li> <li>Add junit rule for lightweight testing (run guice without starting jetty)</li> </ul>"},{"location":"about/history/#100-2014-10-14","title":"1.0.0 (2014-10-14)","text":"<ul> <li>Add dependency on guice-multibindings</li> <li>Installers may choose now from three types of installation (binding, type or instance) or combine them.</li> <li>Add PluginInstaller: shortcut for multibindings mechanism</li> <li>Updated guice (4.0.beta4 -&gt; 4.0.beta5)</li> <li>Force singleton for resources</li> <li>@Eager renamed to @EagerSingleton and now forces singleton scope for bean</li> <li>Add dropwizard style reporting for installed features (like resources or tasks)</li> <li>Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider</li> <li>Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers)</li> <li>Add admin context filter and servlet installers</li> <li>Rename bundle options: features -&gt; installers, disabledFeatures -&gt; disabledInstallers, beans -&gt; extensions</li> </ul>"},{"location":"about/history/#090-2014-09-05","title":"0.9.0 (2014-09-05)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2014-2025, Vyacheslav Rusakov</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/migration/","title":"Migration guide","text":""},{"location":"about/migration/#dropwizard-40","title":"Dropwizard 4.0","text":"<p>Migration to jakarta namespace (<code>jakarta.inject</code>, <code>jakarta.servlet</code>, <code>jakarta.persistence</code> instead of <code>javax.*</code>).</p> <ul> <li>dropwizard upgrade instructions</li> </ul> <p>Guice 7.0 drops javax.* support completely, so you should either migrate to guice annotations (like <code>com.google.guice.Inject</code>) or use jakarta annotations (like <code>jakarta.inject.Inject</code>).</p> <p>If you're upgrading from dropwizard 2.1 it is recommended to perform step-by-step migration (due to many breaking changes):</p> <ul> <li>guicey 5.9.0 - dropwizard 2.1, guice 6 (changed guicey project structure - same as in guicey 6)</li> <li>guicey 6.1.0 - dropwizard 3, guice 6 (changed core dropwizard packaged)</li> <li>guicey 7.0.0 - dropwizard 4, guice 7</li> </ul> <p>There might be problems with 3<sup>rd</sup> party guice libraries still using javax annotations - they would not work as planned if <code>javax.inject</code> annotations used. If possible, migrate such libraries to jakarta namespace or, at least, use guice native annotations (so library could work with all guice versions).</p> <p>As the last option, there is a gradle plugin for automatic conversion of project dependencies from javax to jakarta. This way, application started from gradle project would use repackaged dependencies with correct jakarta namespace. Application delivery would also contain  custom (repackaged) jars.</p> <p>Using this plugin, I did initial automatic guice migration, (appeared before official guice 7 with native jakarta support). You can use this project as an example of 3<sup>rd</sup> party library repackage.</p>"},{"location":"about/migration/#dropwizard-30","title":"Dropwizard 3.0","text":"<p>Java 8 support dropped! Many core packages were changed so there might be problems with 3<sup>rd</sup> party modules. </p> <ul> <li> <p>dropwizard upgrade instructions</p> </li> <li> <p>Guicey core was merged with ext modules to unify versioning. </p> </li> <li>Examples repository was also merged into the main repository</li> <li>There is only one BOM now: <code>ru.vyarus.guicey:guicey-bom</code>. </li> <li>Dropwizard-guicey POM is not a BOM anymore (removing ambiguity). POM simplified by using direct exclusions instead of relying on BOM.</li> </ul> <p>Note</p> <p>Guicey 5.8.0 (for dropwizard 2.1) applies the same project structure as in guicey 6 (dropwizard 3) and so you can use it as the first migration step.</p>"},{"location":"about/migration/#dropwizard-21","title":"Dropwizard 2.1","text":"<ul> <li>dropwizard upgrade notes</li> </ul> <p>Since dropwizard 2.1.0 jackson blackbird used by default instead of afterburner. If you use java 8 then apply afterburner dependency in order to switch into it:</p> <pre><code>implementation 'com.fasterxml.jackson.module:jackson-module-afterburner:2.13.3'\n</code></pre> <p>(omit version if guicey or dropwizard if BOM used). Without it, you'll always see a nasty warning on startup (afterburner is better for java 8, but for java 9+ blackbird should be used)</p> <ul> <li>Java 8 issue discussion</li> <li>dropwizard upgrade instructions</li> </ul>"},{"location":"about/migration/#dropwizard-20","title":"Dropwizard 2.0","text":"<ul> <li>dropwizard upgrade instructions</li> <li>guicey migration guide.</li> </ul>"},{"location":"about/release-notes/","title":"7.2.0 Release Notes","text":"<p>The release contains:</p> <ul> <li>Many improvements simplifying usage (main bundle, guicey bundles, shared state).</li> <li>New reports for measuring application startup performance.</li> <li>Private guice modules support</li> <li>Many test improvements (stubs, mocks, spies, lightweight REST testing etc.)</li> <li>Breaking shared state change (conceptual)</li> </ul>"},{"location":"about/release-notes/#un-deprecated-hk2-support","title":"Un-deprecated HK2 support","text":"<p>All deprecation annotations removed for HK2 related features. Soft deprecation remain in javadoc.</p> <p>It is possible to replace HK2 context with a child guice injector (conceptual prototype was ready long ago). But it requires A LOT of time to finish. Eventually, it would be finished, but, for now, other features are in priority.</p> <p>Hard deprecation removed because there are no alternatives (and will not appear soon). Sorry for the inconvenience.</p>"},{"location":"about/release-notes/#guicebundle-builder","title":"GuiceBundle builder","text":""},{"location":"about/release-notes/#configuration-awareness","title":"Configuration awareness","text":"<p>Before, <code>GuiceyBundle</code> was required to perform any registrations, requiring configuration. Now there is an alternative:</p> <pre><code>GuiceBundle.builder()\n   ...\n   .whenConfigurationReady(env -&gt; {\n        // env is GuiceyEnvironment, like in GuiceyBundle#run\n        AppConfig config = env.configuration();\n        env.modules(new GuiceModule(config));\n   });\n</code></pre>"},{"location":"about/release-notes/#listener-shortcuts","title":"Listener shortcuts","text":"<p>Listener shortcut methods added (same as in <code>GuiceyEnvironment</code>):</p> <pre><code>GuiceBundle.builder()\n    ...\n    // these listeners are shortcuts of guicey listeners (.listen())\n    // guice injector created (dropwizard run phase)\n    .onGuiceyStartup((config, env, injector) -&gt; {\n        // just an example - there could be loginc, usually declared \n        // in application run method\n        env.jersey().register(injector.getInstance(SomeBean.class));\n     })\n    // executes after complete application startup (including guicey lightweight test)   \n    .onApplicationStartup(injector -&gt; ...)\n    //executes after application shutdown\n    .onApplicationShutdown(injector -&gt; ...)\n\n    // these methods just for convenience: \n    // they actually use .onGuiceyStartup() to register provided listeners\n    .listenServer(server -&gt; ...) \n    .listenJetty(new LifeCycle.Listener() {...})\n    .listenJersey(new ApplicationEventListener() {...})\n</code></pre> <p>Note</p> <p>All the same listeners could be registered within <code>.whenConfigurationReady(env -&gt; env.listenServer(...)</code>, but still they remain in the main bundle for more clarity (simpler to find, simpler to use in some cases)</p> <p>Also, note that all these methods are available now for <code>GuiceyConfigurationHook</code>. For example, it could be used in tests:</p> <pre><code>    @EnableHook\n    static GuiceyConfigurationHook hook = builder -&gt; builder\n            .printStartupTime()\n            .onGuiceyStartup((config, env, injector) -&gt; env.lifecycle().manage(...));\n</code></pre>"},{"location":"about/release-notes/#diagnostic-reports","title":"Diagnostic reports","text":""},{"location":"about/release-notes/#application-startup-time-report","title":"Application startup time report","text":"<p>The new report intended to show the entire application startup time information to simplify searching for bottlenecks. It's hard to measure everything exactly from a bundle, but the report will try to show the time spent in each phase (init, run, web) and time of each registered dropwizard bundle.</p> <pre><code>GuiceBundle.builder()\n    .printStartupTime()\n</code></pre> <p>Sample output:</p> <pre><code>INFO  [2025-03-27 09:12:27,435] ru.vyarus.dropwizard.guice.debug.StartupTimeDiagnostic: Application startup time: \n\n    JVM time before                    : 1055 ms\n\n    Application startup                : 807 ms\n        Dropwizard initialization          : 127 ms\n            GuiceBundle                        : 123 ms (finished since start at 127 ms)\n                Bundle builder time                : 38 ms\n                Hooks processing                   : 3.23 ms\n                    StartupDiagnosticTest$Test1$$Lambda/0x0000711de72a1d70: 2.37 ms\n                Classpath scan                     : 44 ms\n                Commands processing                : 4.41 ms\n                    DummyCommand                       : 0.42 ms\n                    NonInjactableCommand               : 3.16 ms\n                Bundles lookup                     : 1.15 ms\n                Guicey bundles init                : 3.24 ms\n                    WebInstallersBundle                : 0.52 ms\n                    CoreInstallersBundle               : 1.83 ms\n                Installers time                    : 21 ms\n                    Installers resolution              : 15 ms\n                    Scanned extensions recognition     : 6.13 ms\n                Listeners time                     : 1.35 ms\n                    ConfigurationHooksProcessedEvent   : 0.23 ms\n                    BeforeInitEvent                    : 0.59 ms\n                    BundlesResolvedEvent               : 0.009 ms\n                    BundlesInitializedEvent            : 0.43 ms\n                    CommandsResolvedEvent              : 0.006 ms\n                    InstallersResolvedEvent            : 0.01 ms\n                    ClasspathExtensionsResolvedEvent   : 0.009 ms\n                    InitializedEvent                   : 0.007 ms\n\n        Dropwizard run                     : 679 ms\n            Configuration and Environment      : 483 ms\n            GuiceBundle                        : 196 ms\n                Configuration analysis             : 20 ms\n        ...     \n</code></pre> <p>Limitations</p> <ul> <li>Can't show init time of dropwizard bundles, registered before the guice bundle (obviously)</li> <li><code>Applicaion#run</code> method time measured as part of \"web\" (the bundle can't see this point, but should not be a problem)</li> </ul> <p>The report could be also enabled for compiled application: <code>-Dguicey.hooks=startup-time</code> </p>"},{"location":"about/release-notes/#guice-provision-time","title":"Guice provision time","text":"<p>The new report intended to show the time of guice beans provision (instance construction,  including provider or provider method time). It shows all requested guice beans and the  number of obtained instances (for prototype scopes). </p> <pre><code>GuiceBundle.builder()\n    .printGuiceProvisionTime()\n</code></pre> <p>All provisions are sorted by time:</p> <pre><code>INFO  [2025-03-27 09:20:32,313] ru.vyarus.dropwizard.guice.debug.GuiceProvisionDiagnostic: Guice bindings provision time: \n\n    Overall 57 provisions took 1.40 ms\n        binding              [@Singleton]     ManagedFilterPipeline                                                                 : 0.88 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:94)\n        binding              [@Singleton]     ManagedServletPipeline                                                                : 0.45 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:95)\n        providerinstance     [@Singleton]     @ScopingOnly GuiceFilter                                                              : 0.02 ms            com.google.inject.servlet.InternalServletModule.provideScopingOnlyGuiceFilter(InternalServletModule.java:106)\n        JIT                  [@Prototype]     JitService                                                                       x10  : 0.02 ms (0.006 ms + 0.002 ms + 0.001 ms + 0.001 ms + 0.001 ms + ...)       \n        binding              [@Singleton]     GuiceyConfigurationInfo                                                               : 0.01 ms            ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:63)\n        binding              [@Singleton]     BackwardsCompatibleServletContextProvider                                             : 0.007 ms           com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:99)\n        instance             [@Singleton]     Bootstrap                                                                             : 0.004 ms           ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.bindEnvironment(GuiceBootstrapModule.java:71)\n        instance             [@Singleton]     @Config(\"server.gzip.minimumEntitySize\") DataSize                                     : 0.002 ms           ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindValuePaths(ConfigBindingModule.java:129)\n        instance             [@Singleton]     Environment                                                                           : 0.0009 ms          ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.bindEnvironment(GuiceBootstrapModule.java:72)\n        instance             [@Singleton]     @Config AdminFactory                                                                  : 0.0008 ms          ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindUniqueSubConfigurations(ConfigBindingModule.java:117)\n        ...\n</code></pre> <p>The report will also try to detect injection mistakes in case when JIT (just in time) binding is used when there are qualified declarations with the same type. </p> <p>The most common mistake is configuration objects misuse: guicey binds unique configuration objects  with <code>@Config</code> qualifier, but, if injection point declared without the qualifier, guice will create a JIT binding (create new object instance) instead of injecting declared instance. This might be hard to spot, especially when lombok is used (which may not copy field annotation into constructor).</p> <pre><code>INFO  [2025-03-27 09:21:33,438] ru.vyarus.dropwizard.guice.debug.GuiceProvisionDiagnostic: Guice bindings provision time: \n\n    Possible mistakes (unqualified JIT bindings):\n\n         @Inject Sub:\n              instance             [@Singleton]     @Config(\"val2\") Sub                                                                   : 0.0005 ms        ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindValuePaths(ConfigBindingModule.java:129)\n              instance             [@Singleton]     @Marker Sub                                                                           : 0.0007 ms        ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindCustomQualifiers(ConfigBindingModule.java:87)\n            &gt; JIT                  [@Prototype]     Sub                                                                                   : 0.006 ms         \n\n         @Inject Uniq:\n              instance             [@Singleton]     @Config Uniq                                                                          : 0.0005 ms        ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindUniqueSubConfigurations(ConfigBindingModule.java:117)\n            &gt; JIT                  [@Prototype]     Uniq                                                                                  : 0.004 ms         \n\n    Overall 53 provisions took 1.45 ms\n        binding              [@Singleton]     ManagedFilterPipeline                                                                 : 0.78 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:94)\n        binding              [@Singleton]     ManagedServletPipeline                                                                : 0.44 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:95)\n</code></pre> <p>In this example, the report detects incorrect injections:</p> <pre><code>   @Inject\n   private Sub val;\n   @Inject\n   private Uniq uniq;\n</code></pre> <p>Detection will also work for generified bindings:</p> <pre><code>    Possible mistakes (unqualified JIT bindings):\n\n         @Inject Service:\n              instance             [@Singleton]     Service&lt;Integer&gt;                                                                      : 0.0006 ms        ru.vyarus.dropwizard.guice.debug.provision.GenerifiedBindingsTest$App.lambda$configure$0(GenerifiedBindingsTest.java:46)\n              instance             [@Singleton]     Service&lt;String&gt;                                                                       : 0.002 ms         ru.vyarus.dropwizard.guice.debug.provision.GenerifiedBindingsTest$App.lambda$configure$0(GenerifiedBindingsTest.java:45)\n            &gt; JIT                  [@Prototype]     Service                                                                               : 0.004 ms         \n</code></pre> <p>The report could be also enabled for compiled application: <code>-Dguicey.hooks=provision-time</code></p> <p>The report shows only provisions performed on application startup, but it could be used in  tests to detect provision problems at runtime:</p> <pre><code>    @EnableHook\n    static GuiceProvisionTimeHook report = new GuiceProvisionTimeHook();\n\n@Test\nvoid testRuntimeReport() {\n    // clear startup data\n    report.clearData();\n    // do something that might cause additional provisions\n    injector.getInstance(Service.class);\n    injector.getInstance(Service.class);\n\n    // assert\n    Assertions.assertThat(report.getRecordedData().keys().size()).isEqualTo(2);\n    // or just print report (only for recorded provisions)\n    System.out.println(report.renderReport());\n}   \n</code></pre>"},{"location":"about/release-notes/#shared-state-report","title":"Shared state report","text":"<p>Guicey shared state is a bundle communication mechanism and safe \"static\" access  for the important objects (quite rarely required). Before, it was not clear the real sequence of state  population and access, and now there is a special report showing all state manipulations:</p> <pre><code>GuiceBundle.builder()\n    .printSharedStateUsage()\n</code></pre> <pre><code>INFO  [2025-03-27 09:49:35,219] ru.vyarus.dropwizard.guice.debug.SharedStateDiagnostic: Shared configuration state usage: \n\n    SET Options (ru.vyarus.dropwizard.guice.module.context.option)                           at r.v.d.g.m.context.(ConfigurationContext.java:167)\n\n    SET List (java.util)                                                                     at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:60)\n        MISS at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:56)\n        GET at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:57)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:60)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:61)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:62)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:73)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:74)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:82)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:84)\n\n    SET Bootstrap (io.dropwizard.core.setup)                                                 at r.v.d.g.m.context.(ConfigurationContext.java:806)\n\n    SET Map (java.util)                                                                      at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:97)\n        MISS at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:93)\n        GET at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:94)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:97)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:98)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:101)\n    ...     \n</code></pre>"},{"location":"about/release-notes/#guice-bindings-report-fixes","title":"Guice bindings report fixes","text":"<p>Guice bindings report (<code>.printGuiceBindings()</code> or <code>.printAllGuiceBindings()</code>) was fixed:</p> <ul> <li>Fixed scope accuracy for linked bindings</li> <li>Fixed bindings for private modules (missed exposed linked bindings)</li> </ul>"},{"location":"about/release-notes/#guiceybundle","title":"GuiceyBundle","text":""},{"location":"about/release-notes/#checked-initialization-exceptions","title":"Checked initialization exceptions","text":"<p>Added <code>throws Exception</code> in bundle init method:</p> <pre><code>public void initialize(final GuiceyBootstrap bootstrap) throws Exception {\n</code></pre> <p>Important</p> <p>This is not a breaking change: all existing bundles will work (even compiled with  the previous guicey version). Existing runtime exception is re-thrown so even tests, relying on the exception type or message would not break. It's even possible to avoid <code>throws Exception</code> in new bundles.</p> <p>Initially, <code>throws Exception</code> was not added to comply with dropwizard bundles (<code>ConfiguredBundle</code>): dropwizard assumes only runtime exceptions in initialization phase and any exception  in run phase.</p> <p>But, it appears that often it is more useful to allow checked exceptions in init method to avoid clumsy exception handling (especially for quick prototyping) and so checked exceptions support was added. Runtime exceptions are rethrown as is.</p>"},{"location":"about/release-notes/#register-extensions-at-run-phase","title":"Register extensions at run phase","text":"<p>Now extensions could be registered in run phase:</p> <pre><code>public class MyBundle implements GuiceyBundle {\n    @Override\n    public void run(final GuiceyEnvironment environment) throws Exception {\n        MyConfig config = environment.configuration();\n        if (config.isFeatureRequired()) {\n            environment.extensions(SomeExtension.class);\n            // OR\n            environment.extensionsOptions(SomeExtension.class);\n        }\n    }\n}\n</code></pre> <p>Initially, it was assumed that all configuration should be done in the configuration phase. But there are cases when extension registration depends on configuration (or even configuration provides  additional extensions).</p> <p>Disabling already registered extensions also appears to not cover all cases.</p> <p>Also, guicey already detects extensions from guice bindings in the run phase, so it was already registering extensions in the run phase.</p> <p>Related internal changes (will not anything, just in case):</p> <ul> <li>Manually registered extensions now validated in run phase (and so <code>ManualExtensionsValidatedEvent</code> called at run phase)</li> <li>As before, classpath scan is performed at configuration phase, but actual extensions   registration appears at run phase (because manual extensions registered in priority)</li> </ul>"},{"location":"about/release-notes/#transitive-guice-bundles-order","title":"Transitive guice bundles order","text":"<pre><code>public class MyBundle implements GuiceyBundle {\n    @Override\n    public void initialize(final GuiceyBootstrap bootstrap) throws Exception {\n        // transitive bundle\n        boostrap.bundles(new MySubBundle());\n    }\n}\n</code></pre> <p>Before, all transitive bundles were initialized after root bundles: <code>MySubBundle.initialize()</code> called after <code>MyBundle.initialize()</code> (and all other root bundles). At run phase bundles were executed in the same sequence: <code>MyBundle.run()</code> then <code>MySubBundle.run()</code>. </p> <p>Usually, initialization order does not matter, but, in some cases, it is important to have the transitive bundle initialized immediately (for example, it could store some important value  into shared state).</p> <p>Also, both dropwizard bundles and guice modules immediately initialize transitives. To unify behavior, transitive guicey bundles now also initialize immediately.</p> <p>So in example above, <code>MySubBundle.initialize()</code> would be called just in time of the bundle registration <code>boostrap.bundles(new MySubBundle())</code> and, after registration  root bundle could rely on transitive bundle (initialized) state.</p> <p>At run phase, the transitive bundle would also be called before the root: <code>MySubBundle.run()</code> then <code>MyBundle.run()</code>.</p>"},{"location":"about/release-notes/#listeners-shortcuts","title":"Listeners shortcuts","text":"<p>Add listener registration shortcuts at bundle run:</p> <pre><code>    @Override\n    public void run(final GuiceyEnvironment environment) throws Exception {\n        environment\n                // executes after application shutdown\n                .onApplicationShutdown(injector -&gt; ...)\n                // jersey startup events and requests listener\n                .listenJersey(new ApplicationEventListener() {...})\n    }\n</code></pre> <p>Just a useful shortcuts.</p>"},{"location":"about/release-notes/#hook","title":"Hook","text":"<p>Added <code>throws Exception</code> for guicey hook:</p> <pre><code>public interface GuiceyConfigurationHook {\n    void configure(GuiceBundle.Builder builder) throws Exception;\n}\n</code></pre> <p>Important</p> <p>This is not a breaking change: all existing hooks will work (even compiled with the previous guicey version). Existing runtime exception is re-thrown so even tests, relying on the exception type or message would not break. It's even possible to avoid <code>throws Exception</code> in new hooks.</p> <p>Avoiding checked exception is especially useful when writing test hooks. </p>"},{"location":"about/release-notes/#private-guice-modules-support","title":"Private guice modules support","text":"<p>Before guicey did not try to search extension inside private guice modules. But this is not quite correct because if extension is declared in private module and it would be also registered manually, then guicey would create another binding for it, which may cause conflicts.</p> <p>Now guicey analyzes private modules too. For example:</p> <pre><code>public class PModule extends PrivateModule {\n    @Override\n    protected void configure() {\n        // ExtImpl is extension (recognition sign absent in interface) \n        bind(IExt.class).to(ExtImpl.class);\n        // extension exposed by interface \n        expose(IExt.class);\n    }\n}\n\npublic interface IExt {... }\npublic class Ext implements IExt, Managed { ... }\n</code></pre> <p>Guicey would detect that <code>ExtImpl</code> is an extension, and it is available (through exposed interface) and so register it as an extension.</p> <p>Important</p> <p>Guicey rely on extension classes and so it would need direct extension access (to be able to call <code>Injector.getInstance(ExtImpl.class)</code>). By default, it is not possible (exposed only interface), but guicey would change private module: it would add an additional <code>expose</code> for <code>ExtImpl</code>.</p> <p>Also, as any guicey extension could be disabled, then <code>.disable(ExtImpl.class)</code> would remove binding inside private module (works only for top-level private modules).</p> <p>If you'll face any problems with private modules behavior, please report it.</p> <p>Old behavior could be reverted with:</p> <pre><code>GuiceBundle.builder()\n    .option(GuiceyOptions.AnalyzePrivateGuiceModules, false)\n</code></pre>"},{"location":"about/release-notes/#classpath-scan","title":"Classpath scan","text":""},{"location":"about/release-notes/#extensions-scan-filters","title":"Extensions scan filters","text":"<p>By default, classpath scanner checks all available classes, and the only way to avoid extension  recognition is <code>@InvisibleForScanner</code> annotation.</p> <p>Now custom conditions could be specified:</p> <pre><code>GuiceBundle.builder()\n    .autoConfigFilter(ignoreAnnotated(Skip.class))\n</code></pre> <p>In this example, classes annotated with <code>@Skip</code> would not be recognized.</p> <p>Note</p> <p>Assumed static import for <code>ClassFilters</code> utility, containing the most common cases. If required, raw predicate could be used: <pre><code>.autoConfigFilter(cls -&gt; !cls.isAnnotationPresent(Skip.class))\n</code></pre></p> <p>It is also possible now to implement spring-like approach when only annotated classes  are recognized:</p> <pre><code>GuiceBundle.builder()\n    .autoConfigFilter(annotated(Component.class, Service.class))\n</code></pre> <p>Here only extensions annotated with <code>@Component</code> or <code>@Service</code> would be recognized.</p> <p>Note</p> <p>This filter affects only extension search: installers and commands search does not use filters (because it would be confusing and error-prone).</p> <p>Tip</p> <p>Multiple filters could be specified: <pre><code>GuiceBundle.builder()\n    .autoConfigFilter(annotated(Component.class, Service.class))\n    .autoConfigFilter(ignoreAnnotated(Skip.class))\n</code></pre></p> <p>Auto config filter also affects extensions recognition from guice bindings and so could be used for ignoring extensions from bindings.</p> <p>It is also possible now to exclude some sub-packages from classpath scan:</p> <pre><code>GuiceBundle.builder()\n    .enableAutoConfig(\"com.company.app\")\n    .autoConfigFilter(ignorePackages(\"com.company.app.internal\"))\n</code></pre>"},{"location":"about/release-notes/#private-extension-classes","title":"Private extension classes","text":"<p>By default, guicey does not search extensions in protected and package-private classes:</p> <pre><code>public class Something {\n    static class Ext1 implements Managed {}\n    protected static class Ext2 implements Managed {}\n}\n</code></pre> <p>Now searching such extensions could be enabled with:</p> <pre><code>GuiceBundle.builder()\n    .option(GuiceyOptions.ScanProtectedClasses, true)\n</code></pre>"},{"location":"about/release-notes/#disable-predicate","title":"Disable predicate","text":"<p>Disable predicate is useful for disabling a wide range of extensions:</p> <pre><code>GuiceBundle.builder()\n    .disable(Disables.inPackage(\"com.company.app.rest.stubs\"))\n</code></pre> <p>But, before predicate was called too early: before actual installer is assigned to the extension item model and so it was impossible to disable extensions by installer.</p> <p>Now extensions could be disabled by installer.</p> <p>For convenience, new installer-related shortcuts added:</p> <ul> <li><code>Disables.jerseyExtension()</code></li> <li><code>Disables.webExtension()</code> (servlets, filters and jersey)</li> <li><code>Disables.installedBy(...)</code></li> </ul> <p>Example usage:</p> <pre><code>@EnableHook\nstatic GuiceyConfigurationHook hook = builder -&gt;\n        builder.disable(installedBy(WebFilterInstaller.class));\n</code></pre> <p>Also, disable shortcuts for exact items type (<code>Disables.module()</code>, <code>Disabled.extension()</code>, etc.) now raise predicate  type to simplify chained usage:</p> <pre><code>builder.disable(module().and(ModuleItemInfo mod -&gt; ! mod.isOverriding()));\n</code></pre>"},{"location":"about/release-notes/#shared-state","title":"Shared state","text":""},{"location":"about/release-notes/#state-key-breaking","title":"State key (BREAKING)","text":"<p>Before, it was recommended to use bundle class as a shared state key, but it appears to be very confusing.</p> <p>Now shared state object class must be used as a key</p> <p>This affects both state storing:</p> <pre><code>// before was: put(Bundle.class, new MyState())\nstate.put(MyState.class, new MyState());\n</code></pre> <p>And access:</p> <pre><code>// before was: MyState myState = state.get(Bundle.class);\nMyState myState = state.get(MyState.class);\n</code></pre> <p>This way shared state usage becomes type-safe (impossible to use a wrong type for  the stored object by mistake).</p>"},{"location":"about/release-notes/#options-accessor","title":"Options accessor","text":"<p>Shared state now holds a reference to guicey options values:</p> <pre><code>SharedConfigurationState.get(environment).get().getOptions()\n</code></pre>"},{"location":"about/release-notes/#reactive-access","title":"Reactive access","text":"<p>Added reactive state access method (action called as soon as value would be set). This is mostly useful for the main guice bundle: </p> <pre><code>GuiceBundle.builder()\n    withSharedState(state -&gt; \n        state.whenReady(MyState.class, mystate -&gt; ...))\n</code></pre> <p><code>whenReady</code> action called either immediately, if value already present, or just after value would be set. Listener calls could be seen on the new shared state report (same as never called listeners)</p>"},{"location":"about/release-notes/#test","title":"Test","text":""},{"location":"about/release-notes/#disable-managed-lifecycle","title":"Disable managed lifecycle","text":"<p>Added ability to disable managed objects lifecycle for lightweight guicey tests:</p> <p>JUnit 5 extensions:</p> <pre><code>@TestGuiceyApp(.., managedLifecycle = false)\n</code></pre> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        ...\n        .disableManagedLifecycle()\n</code></pre> <p>In this case, start/stop method would not be called for managed objects. This might be useful for disabling some heavy application initialization logic, defined in managed objects, but not required in tests.</p> <p>Note</p> <p>Application lifecycle will remain: events like <code>onApplicationStartup</code> would still be  working (and all registered <code>LifeCycle</code> objects would work). Only managed objects ignored.</p> <p>Option is also available for core (non-junit) testing support:</p> <ul> <li><code>new GuiceyTestSupport().disableManagedLifecycle()</code></li> <li><code>TestSupport.build(App.class).runCoreWithoutManaged(..)</code></li> </ul>"},{"location":"about/release-notes/#manual-configuration-objects","title":"Manual configuration objects","text":"<p>It is now possible to manually construct configuration object instance in junit5 extension (for both lightweight and full app tests):</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        .config(() -&gt; new MyConfig())\n        ...\n</code></pre> <p>Or in setup object:</p> <pre><code>@EnableSetup\nstatic **TestEnvironmentSetup** setup = ext -&gt; ext.config(() -&gt; new MyConfig())\n</code></pre> <p>Important</p> <p>Configuration overrides would not work with manually created configuration objects. Use configuration modifiers instead.</p>"},{"location":"about/release-notes/#config-override-for-a-single-key","title":"Config override for a single key","text":"<p>Added config override for a single key-value pair (for the setup object and extension builders):</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt; ext.configOverride(\"some.key\", \"12\");\n</code></pre> <p>(before, only methods with supplier and multiple keys were available)</p>"},{"location":"about/release-notes/#configuration-modifiers","title":"Configuration modifiers","text":"<p>Dropwizard configuration overrides mechanism is limited (for example, it would not work for a collection property).</p> <p>Configuration modifier is an alternative mechanism when all changes are performed on configuration instance. </p> <p>Modifier could be used as lambda:</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        .configModifiers(config -&gt; config.getSomething().setFoo(12))\n        ...\n</code></pre> <p>Or in setup object:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt; \n        ext.configModifiers(config -&gt; config.getSomething().setFoo(12))\n</code></pre> <p>Modifier could be declared in class:</p> <pre><code>public class MyModifier implements ConfigModifier&lt;MyConfig&gt; {\n    @Override\n    public void modify(MyConfig config) throws Exception {\n        config.getSomething().setFoo(12);\n    }\n}\n\n@TestGuiceyApp(.., configModifiers = MyModifier.class)\n</code></pre> <p>Tip</p> <p>Modifier could be used with both manual configuration or usual (yaml) configuration. Configuration modifiers also could be used together with configuration overrides.</p> <p>Limitation</p> <p>Configuration modifiers are called after dropwizard logging configuration, so logging is the only thing that can't be configured (use configuration overrides for logging)</p> <p>Configuration overrides are also available in core test extensions:</p> <ul> <li>Commands runner: <code>TestSupport.buildCommandRunner(..).configModifiers(...)</code> </li> <li>Raw test support builder: <code>TestSupport.build(..).configModifiers(...)</code></li> <li><code>GuiceyTestSupport.configModifiers(..)</code></li> <li>For <code>DropwizardTestSupport</code> custom command must be used to support modifiers:      <code>ConfigOverrideUtils.buildCommandFactory</code></li> </ul>"},{"location":"about/release-notes/#custom-configuration-block","title":"Custom configuration block","text":"<p>To simplify field-based declarations, custom (free) block added (<code>.with()</code>):</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        ...\n        .with(builder -&gt; {\n            if (...) {\n               builder.configOverrides(\"foo.bar\", 12); \n            }\n        }) \n</code></pre> <p>And the same for setup objects:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt;\n        ...\n        .with(builder -&gt; {\n            ...\n        }) \n</code></pre>"},{"location":"about/release-notes/#debug-option-evolution","title":"Debug option evolution","text":"<p>Existing junit extensions debug mechanism was evolved: </p> <pre><code>@TestGuiceyApp(.., debug = true)\n</code></pre>"},{"location":"about/release-notes/#extensions-time","title":"Extensions time","text":"<p>To simplify slow tests (slowness) investigations, guicey now measures and prints extensions time.</p> <p>For example, test with application started in beforeAll, with two test methods (same app for both tests):</p> <pre><code>@TestGuiceyApp(value = App.class, debug = true)\npublic class PerformanceLogTest {\n    @Test\n    public void test1() { ... }\n    @Test\n    public void test2() { ... }\n}\n</code></pre> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 1595d2b2 /\nGuicey time after [Before each] of PerformanceLogTest#test1(): 1204 ms\n\n    [Before all]                       : 1204 ms\n        Guicey fields search               : 2.03 ms\n        Guicey hooks registration          : 0.02 ms\n        Guicey setup objects execution     : 1.92 ms\n        DropwizardTestSupport creation     : 1.47 ms\n        Application start                  : 1172 ms\n\n    [Before each]                      : 0.46 ms\n        Guice fields injection             : 0.19 ms\n\n\n\\\\\\------------------------------------------------------------/ test instance = 45554613 /\nGuicey time after [Before each] of PerformanceLogTest#test2(): 1205 ms ( + 0.33 ms)\n\n    [Before each]                      : 0.69 ms ( + 0.23 ms)\n        Guice fields injection             : 0.36 ms ( + 0.17 ms)\n\n    [After each]                       : 0.10 ms\n\n\n\\\\\\---------------------------------------------------------------------------------------------\nGuicey time after [After all] of PerformanceLogTest: 1207 ms ( + 2.15 ms)\n\n    [After each]                       : 0.11 ms ( + 0.01 ms)\n\n    [After all]                        : 2.14 ms\n        Application stop                   : 1.72 ms\n</code></pre> <p>There are three reports:</p> <ol> <li>Before first test method (see guicey extension startup time)</li> <li>Before the second test method (see guicey time for the second method only)</li> <li>After all (cleanup time)</li> </ol> <p>Only the first report shows all recorded times, next reports only mention time increase. For example, the second report mentions only <code>Guice fields injection             : 0.36 ms ( + 0.17 ms)</code> Meaning guicey perform fields injection just before the second test, spent 0.17 ms on it  (overall injection time for two injections is 0.36 ms) </p>"},{"location":"about/release-notes/#updated-declarations-report","title":"Updated declarations report","text":"<p>All declared setup objects and hooks now showed with a (declaration) source reference (where possible). Simplified report for lambdas (was not very readable before).</p> <pre><code>public static class Test2 extends Base {\n\n    @RegisterExtension\n    static TestGuiceyAppExtension app = TestGuiceyAppExtension.forApp(App.class)\n            .setup(Ext1.class, Ext2.class)\n            .setup(it -&gt; null, new Ext3())\n            .debug()\n            .create();\n\n    @EnableSetup\n    static TestEnvironmentSetup ext1 = it -&gt; null;\n    @EnableSetup\n    static TestEnvironmentSetup ext2 = it -&gt; null;\n</code></pre> <pre><code>Guicey test extensions (Test2.):\n\n    Setup objects = \n        Ext1                            @RegisterExtension.setup(class)                    at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:102)\n        Ext2                            @RegisterExtension.setup(class)                    at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:102)\n        &lt;lambda&gt;                        @RegisterExtension.setup(obj)                      at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:103)\n        Ext3                            @RegisterExtension.setup(obj)                      at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:103)\n        &lt;lambda&gt;                        @EnableSetup Base#base1                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Base#base1\n        &lt;lambda&gt;                        @EnableSetup Base#base2                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Base#base2\n        &lt;lambda&gt;                        @EnableSetup Test2#ext1                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Test2#ext1\n        &lt;lambda&gt;                        @EnableSetup Test2#ext2                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Test2#ext2\n</code></pre>"},{"location":"about/release-notes/#inject-test-fields-once","title":"Inject test fields once","text":"<p>By default, guicey would inject test field values before every test method, even if the same test instance used (<code>TestInstance.Lifecycle.PER_CLASS</code>). This should not be a problem in the majority of cases because guice injection takes very little time. Also, it is important for prototype beans, which will be refreshed for each test.</p> <p>Now it is possible to inject fields just once:</p> <pre><code>@TestGuiceyApp(value = App.class, injectOnce = true)\n// by default new test instance used for each method, so injectOnce option would be useless \n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class PerClassInjectOnceGuiceyTest {\n    @Inject\n    Bean bean;\n\n    @Test\n    public test1() {..}\n\n    @Test\n    public test2() {..}\n}\n</code></pre> <p>In this case, the same test instance used for both methods (<code>Lifecycle.PER_CLASS</code>) and <code>Bean bean</code> field would be injected just once (<code>injectOnce = true</code>)</p> <p>Tip</p> <p>To check the actual fields injection time enable debug (<code>debug = true</code>) and it will print injection time before each test method: <pre><code>[Before each]                      : 2.05 ms\n    Guice fields injection             : 1.58 ms    \n</code></pre></p>"},{"location":"about/release-notes/#setup-objects-evolution","title":"Setup objects evolution","text":"<p>Added <code>throws Exception</code> in setup object method:</p> <pre><code>public class GuiceyEnvironmentSetup {\n    public Object setup(TestExtension extension) throws Exception { }\n}\n</code></pre> <p>Important</p> <p>This is not a breaking change: all existing setup objects will work (even compiled with the previous guicey version). Existing runtime exception is re-thrown so even tests, relying on the exception type or message would not break. It's even possible to avoid <code>throws Exception</code> in new objects.</p> <p>With all extensions below, setup objects could completely replace some native junit extensions: meaning it would be simpler now to implement just a setup object instead of separate junit  extension implementation.</p>"},{"location":"about/release-notes/#junit-context","title":"Junit context","text":"<p>Junit context is now directly accessible in builder:</p> <pre><code>public class MyExt implements GuiceyEnvironmentSetup {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        ExtensionContext context = extension.getJunitContext();\n    }\n}\n</code></pre> <p>Also, <code>ExtensionContext</code> could be injected as test method parameter:</p> <pre><code>@BeforeEach\npublic void setUp(ExtensionContext context) {\n    ...\n}\n</code></pre>"},{"location":"about/release-notes/#lifecycle-listeners","title":"Lifecycle listeners","text":"<p>Added lifecycle listener interface, representing junit phases (before/after) and tested  application (started/stopped):</p> <pre><code>public interface TestExecutionListener {\n    default void starting(final EventContext context) throws Exception {}\n    default void started(final EventContext context) throws Exception {}\n    default void beforeAll(final EventContext context) throws Exception {}\n    default void beforeEach(final EventContext context) throws Exception {}\n    default void afterEach(final EventContext context) throws Exception {}\n    default void afterAll(final EventContext context) throws Exception {}\n    default void stopping(final EventContext context) throws Exception {}\n    default void stopped(final EventContext context) throws Exception {}\n}\n</code></pre> <p><code>EventContext</code> provides access for guice injector, DropwizardTestSupport object and junit 5 context.</p> <p>Raw listener is useful for large setup objects:</p> <pre><code>public class MySetup implements TestEnvironmentSetup, TestExecutionListener {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        extension.listen(this);\n    }\n\n    @Override\n    public void started(final EventContext context) throws Exception {\n        // something\n    }\n}\n</code></pre> <p>For field declarations (lambda-based), special individual shortcuts are available:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt; ext\n        .onApplicationStarting(event -&gt; ...)\n        .onApplicationStart(event -&gt; ...)\n        .onBeforeAll(event -&gt; ...)\n        .onBeforeEach(event -&gt; ...)\n        .onAfterEach(event -&gt; ...)\n        .onAfterAll(event -&gt; ...)\n        .onApplicationStopping(event -&gt; ...)\n        .onApplicationStop(event -&gt; ...)\n</code></pre>"},{"location":"about/release-notes/#extension-debug","title":"Extension debug","text":"<p>For simplicity, setup object could re-use guicey extension debug trigger to  print additional data:</p> <pre><code>@TestGuiceyApp(value = App.class, stup = MySetup.class, debug = true)\n\npublic class MySetup implements TestEnvironmentSetup, TestExecutionListener {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        extension.listen(this);\n\n        if (extension.isDebug()) {\n            System.out.println(\"Debug info: ...\");\n        }\n    }\n\n    @Override\n    public void started(final EventContext context) throws Exception {\n        if (context.isDebug()) {\n            System.out.println(\"Debug info: ...\");\n        }\n    }\n</code></pre>"},{"location":"about/release-notes/#annotated-fields-search-api","title":"Annotated fields search API","text":"<p>Added <code>.findAnnotatedFields()</code> method to search annotated test fields.</p> <pre><code>public class Test {\n     @MyAnn\n     Base field;\n}\n</code></pre> <pre><code>public class CustomFieldsSupport implements TestEnvironmentSetup {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n\n        List&lt;AnnotatedField&lt;MyAnn, Base&gt;&gt; fields = extension\n                .findAnnotatedFields(MyAnn.class, Base.class);\n    }\n</code></pre> <p>Out of the box, API provides many checks, like required base class (it could be Object to avoid check): if annotated field type is different - error would be thrown.</p> <p>Returned object is also abstraction: <code>AnnotatedField</code> - it simplifies working with filed value, plus contains additional checks. </p> <p>Note</p> <p>This api is not generalized (target usage with junit only) because it uses junit annotations search utility internally.</p> <p>Added <code>AnnotatedTestFieldSetup</code> base class which implements base fields workflow (including proper nested tests support).</p> <p>All new field extensions (see below) are using this base class. Using them as  implementation examples, it should be pretty simple to add other field-based test extensions.</p>"},{"location":"about/release-notes/#auto-lookup","title":"Auto lookup","text":"<p>Custom <code>TestEnvironmentSetup</code> objects could be loaded automatically now  with service loader. New default extensions already use service loader.</p> <p>To enable automatic loading of custom extension add:  <code>META-INF/services/ru.vyarus.dropwizard.guice.test.jupiter.env.TestEnvironmentSetup</code></p> <p>And put there required setup object classes (one per line), like this:</p> <pre><code>ru.vyarus.dropwizard.guice.test.jupiter.ext.log.RecordedLogsSupport\nru.vyarus.dropwizard.guice.test.jupiter.ext.rest.RestStubSupport\nru.vyarus.dropwizard.guice.test.jupiter.ext.stub.StubsSupport\nru.vyarus.dropwizard.guice.test.jupiter.ext.mock.MocksSupport\n</code></pre> <p>Now, when setup objects have more abilities, more custom test extensions could be implemented (see new filed-based extensions below). Automatic installation for such 3<sup>rd</sup> party extensions (using service loader) should simplify overall usage.</p> <p>Note</p> <p>Service loading for extensions could be disabled (together with new default extensions): <pre><code>@TestGuiceyApp(.., useDefaultExtensions = false)\n</code></pre></p>"},{"location":"about/release-notes/#new-test-extensions","title":"New test extensions","text":"<p>All new extensions are enabled by default: if any of them will cause any problems,  please report. New extensions could be disabled with (this will also switch off  an extension lookup mechanism) </p> <pre><code>@TestGuiceyApp(.., useDefaultExtensions = false)\n</code></pre> <p>After disabling, some extensions could be registered manually (they are all just setup objects). </p> <p>Tip</p> <p>All recognized extension fields would be printed to console when guicey extension debug  is enabled (<code>debug = true</code>).</p> <p>New extensions:</p> <ul> <li>Stubs (with deep injection)</li> <li>Mockito mocks (with deep injection)</li> <li>Mockito spies </li> <li>Guice bean calls tracker (method arguments and return value captor + time measure)</li> <li>Logs test support</li> <li>Lightweight REST tests support</li> </ul> <p>Note</p> <p>The core logic for all extensions is implemented as guicey hook. These hooks are generic and  could be used without junit (see general docs) </p>"},{"location":"about/release-notes/#stubs","title":"Stubs","text":"<p>Stub is a (manual) replacement for the real bean.  For example, suppose application has a <code>BillingService</code>, but for tests you  want to replace it with a simple (no-external-communication) implementation: <code>StubBillingService extends BillingService</code>.</p> <p>Stubs declared in test class with a new <code>@StubBean</code> annotation:</p> <pre><code>@TestGuiceyApp\npublic class Test {\n\n    @StubBean(BillingService.class)\n    StubBillingService stub;\n}\n</code></pre> <p>In this example, stub is instantiated with guice (but you could do it manually) and  override <code>BillingService</code> injection in guice context (using guice modules override). That means that stub would not only be available in the annotated field, but all guice  beans, requiring <code>BillingService</code> would actually receive stub instance instead of it.</p> <p>If you try to declare service injection in test:</p> <pre><code>@Inject\nBillingService billingService;\n</code></pre> <p>You'll see that it's the same instance as a stub.</p> <p>Note</p> <p>As a stub object injected into guice context, which by default used \"per class\", the same stub instance would be used for all methods in test (of course, if guice extension not declared \"per method\"). A stub object could implement special interface <code>StubLifecycle</code> (with before/after methods) which would be called before and after each test method (could be used to reset state).</p>"},{"location":"about/release-notes/#mocks","title":"Mocks","text":"<p>Requires mockito dependency (version not required if dropwizard (or guicey) BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre> <p>Essentially, mocks are automatic stubs with the ability to dynamically declare method behavior.</p> <p>Mocks declared with a <code>@MockBean</code> annotation:</p> <pre><code>@TestGuiceyApp(...)\npublic class Test {\n\n    @MockBean\n    MyService mock;\n\n    @BeforeEach\n    void setUp() {\n        when(mock.foo()).thenReturn(\"something\");\n    }\n}\n</code></pre> <p>Mock instance created automatically (<code>Mockito.mock(MyService.class)</code>) and override <code>MyService</code> declaration (using guice modules override).</p> <p>Important</p> <p>The main difference with mockito junit extension is that mock instance would be injected in all places using mocked service (replace real service in the entire application)</p> <p>Mock behavior could be declared in test setup method or just before usage in test method.</p> <p>If you try to declare service injection in test:</p> <pre><code>@Inject\nMyService service;\n</code></pre> <p>You'll see that it's the same instance as a mock.</p> <p>Note</p> <p>As a mock object injected into guice context, which by default used \"per class\", the same stub instance would be used for all methods in test (of course, if guice extension not declared \"per method\"). A mock would be reset (<code>Mockito.reset(mock)</code>) automatically after each test method.</p> <p>Mockito provides a mock usage report (<code>Mockito.mockingDetails(value).printInvocations()</code>),  which could be enabled with <code>@MockBean(printSummary = true)</code> (report shown after each test method):</p> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 6d420cdd /\n@MockBean stats on [After each] for MockSummaryTest$Test1#test():\n\n    [Mockito] Interactions of: Mock for Service, hashCode: 1340267778\n     1. service.foo(1);\n      -&gt; at ru.vyarus.dropwizard.guice.test.jupiter.setup.mock.MockSummaryTest$Test1.test(MockSummaryTest.java:55)\n       - stubbed -&gt; at ru.vyarus.dropwizard.guice.test.jupiter.setup.mock.MockSummaryTest$Test1.setUp(MockSummaryTest.java:50)\n</code></pre>"},{"location":"about/release-notes/#spies","title":"Spies","text":"<p>Requires mockito dependency (version not required if dropwizard (or guicey) BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre> <p>Spy is a partial mock: real service instance is proxied. Spies could be used to track instance calls or to modify some method behavior.</p> <p>Spies declared with a <code>@SpyBean</code> annotation:</p> <pre><code>@TestGuiceyApp(...)\npublic class Test {\n\n    @SpyBean\n    MyService spy;\n\n    // just for example (not required)\n    @Inject \n    MyService service;\n\n    // optional\n    @BeforeEach\n    void setUp() {\n        // important declaration reversed (otherwise real method is called during declaration)! \n        doReturn(12).when(spy).foo();\n    }\n\n    @Test\n    public void test() {\n        // calling methods on injected service to show that it is also a spy\n        // (normally spies would be called indirectly (by other beans))\n        Assertions.assertEquals(12, service.foo());\n        Assertions.assertEquals(1, service.bar(1));\n\n        // foo() (mocked method) called once\n        Mockito.verify(spy, Mockito.times(1)).foo();\n        // bar(1) called once \n        Mockito.verify(spy, Mockito.times(1)).bar(1);\n    }\n}\n</code></pre> <p>Spy instance created automatically (<code>Mockito.spy(service)</code>) and override <code>MyService</code> declaration (using guice AOP).</p> <p>In the example above, method <code>foo()</code> is mocked and method <code>bar(..)</code> is not (original service method called).</p> <p>Limitation</p> <p>Spy objects would work only for beans, created by guice.  Spy creation requires original service instance, and so guice AOP used to  intercept call the original bean, create spy dynamically, and redirect calls to the spy object.</p> <p>Note</p> <p>As a spy object tied with guice context, which by default used \"per class\", the same spy instance would be used for all methods in test (of course, if guice extension not declared \"per method\"). A spy would be reset (<code>Mockito.reset(mock)</code>) automatically after each test method.</p> <p>Same as for mocks, a usage report could be printed after each test <code>@SpyBean(printSummary = true)</code></p> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 285bf5ac /\n@SpyBean stats on [After each] for SpySummaryTest$Test1#test():\n\n    [Mockito] Interactions of: ru.vyarus.dropwizard.guice.test.jupiter.setup.spy.SpySummaryTest$Service$$EnhancerByGuice$$60e90c@40fe8fd5\n     1. spySummaryTest$Service$$EnhancerByGuice$$60e90c.foo(\n        1\n    );\n      -&gt; at ru.vyarus.dropwizard.guice.test.jupiter.setup.spy.SpySummaryTest$Test1.test(SpySummaryTest.java:50)\n</code></pre> <p>Tip</p> <p>Spies (in some cases) are not very easy to use for tracking method arguments and return values. <code>@TrackBean</code> extension could be more useful for actual values tracking (could be used together with spies or mocks). </p> <p>Example of how to intercept method call result: <pre><code>public static class ResultCaptor&lt;T&gt; implements Answer {\n    private T result = null;\n    public T getResult() {\n        return result;\n    }\n\n    @Override\n    public T answer(InvocationOnMock invocationOnMock) throws Throwable {\n        result = (T) invocationOnMock.callRealMethod();\n        return result;\n    }\n}\n\nResultCaptor&lt;String&gt; resultCaptor = new ResultCaptor&lt;&gt;();\nMockito.doAnswer(resultCaptor).when(spy).foo();\n\nAssertions.assertThat(resultCaptor.getResult()).isEqualTo(\"something\");\n</code></pre></p>"},{"location":"about/release-notes/#trackers","title":"Trackers","text":"<p>Tracker extension was added to simplify checking guice beans method arguments and result value, because mockito spies are not very handy (see example above).</p> <p>Tracker is declared with <code>@TrackBean</code>, but field type must be <code>Tracker&lt;Service&gt;</code> with target service, declared as generic:</p> <pre><code>public class Test {\n\n    @TrackBean\n    Tracker&lt;MyService&gt; tracker;\n\n    @Inject\n    MyService service;\n\n    @Test\n    public void test() {\n        // call\n        service.foo(\"something\");\n\n        MethodTrack track = serviceTracker.getLastTrack();\n        Assertions.assertTrue(track.toString().contains(\"foo(\\\"something\\\")\"));\n        Assertions.assertEquals(\"something\", track.getArguments()[0]);\n        Assertions.assertNull(track.getResult());\n\n    }\n} \n</code></pre> <p>Limitation</p> <p>Trackers implemented with guice AOP and so would work only for beans, created by guice. </p> <p>As method arguments (and return value) could contain mutable objects (which would lost  the original state after several method calls), the tracker keeps both  raw object version and string version: <code>getRawResult()</code> and <code>getResult()</code>, <code>getRawArguments()</code> and <code>getArguments()</code>. </p> <p>Additionally, there are quoted versions: <code>getQuatedResult()</code> and <code>getQuatedArguments()</code>. These methods are the same as string methods, but all strings are in quotes to clearly see string bounds (quoted versions useful for console printing)</p> <p>When too many method calls are tracked, keeping raw objects might lead to a waste of memeory, in this case only string values could be preserved: <code>@TrackBean(keepRawObjects = false)</code></p> <p>Note</p> <p>By default, tracker data would reset after each test method.  Use <code>@TrackBean(autoRest = false)</code> to keep all data.</p> <p>Tracked data could be reset manually at any time with: <code>tracker.clear()</code></p>"},{"location":"about/release-notes/#searching","title":"Searching","text":"<p>All recorded method calls could be obtained with <code>List&lt;MethodTrack&gt; tracks = tracker.getTracks()</code>. If there was just one call: <code>MethodTrack track = tracker.getLastTrack()</code></p> <p>In the case of many recorded executions, search could be used:</p> <pre><code>// search by method (any argument value)\ntracks = tracker.findTracks(mock -&gt; when(\n               mock.foo(Mockito.anyInt()))\n         );\n\n// search methods with exact argument \ntracks = tracker.findTracks(mock -&gt; when(\n               mock.foo(Mockito.intThat(argument -&gt; argument == 1)))\n        );\n</code></pre> <p>This method uses Mockito stubbing abilities for search criteria declaration: easy to use and type-safe search.</p>"},{"location":"about/release-notes/#performance-metrics","title":"Performance metrics","text":"<p>There is a trace mode printing all method calls into console: <code>@TrackBean(trace = true)</code>:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.11 ms      &lt;@71370fec&gt; .foo(1) = \"1 call\"\n</code></pre> <p>Shows: instance hash, execution time, arguments and return value.</p> <p>By default, tracker would only log executions for slow methods (more than 5 seconds):</p> <pre><code>WARN  [2025-04-01 09:22:28,965] ru.vyarus.dropwizard.guice.test.jupiter.ext.track.Tracker: \n\\\\\\---[Tracker&lt;Service&gt;] 2.07 ms      &lt;@53aa2fc9&gt; .foo() = \"foo\"\n</code></pre> <p>Note that warning is printed with a logger, and not as direct console output like trace. Slow methods configuration: <code>@TrackBean(slowMethods = 5, slowMethodsUnit = ChronoUnit.SECONDS)</code> (<code>0</code> value to disable warnings).</p> <p>When guice extension debug is enabled (<code>@TestGuiceyApp(..., debug = true)</code>), a performance report for all registered tracker objects would be printed:</p> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 2bbb44da /\nTrackers stats (sorted by median) for TrackerSimpleTest#testTracker():\n\n    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    Service                                  foo(int)                                           3          0          0.011 ms   0.161 ms   0.151 ms   0.161 ms   0.161 ms  \n    Service                                  bar(int)                                           1          0          0.066 ms   0.066 ms   0.066 ms   0.066 ms   0.066 ms  \n</code></pre> <p>The report use dropwizard metrics to count percentiles. This is required to collect more informative data when trying to use trackers for performance testing -  due to jvm warm-up first executions would be much slower, but percentiles should show more correct values (closer to hot execution). </p> <p>Tip</p> <p>For each tracker, an individual report could be activated with: <code>@TrackBean(printSummary = true)</code> This report does not depend on the extension debug flag. </p> <p>The summary report also shows the number of service instances involved in stats (in the example  trace was enabled for clarity):</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.28 ms      &lt;@6707a4bf&gt; .foo(1) = \"foo1\"\n\\\\\\---[Tracker&lt;Service&gt;] 0.007 ms     &lt;@79d3473e&gt; .foo(2) = \"foo2\"\n\n\\\\\\------------------------------------------------------------/ test instance = 51f18e31 /\nTracker&lt;Service&gt; stats (sorted by median) for ReportForMultipleInstancesTest$Test1#testTracker():\n\n    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    Service                                  foo(int)                                           2 (2)      0          0.007 ms   0.281 ms   0.281 ms   0.281 ms   0.281 ms  \n</code></pre> <p>Note different instances in trace (<code>&lt;@6707a4bf&gt;</code>, <code>&lt;@79d3473e&gt;</code>) and instances count in calls column: <code>2 (2)</code></p> <p>Method stats (summary of all collected executions for method) could also be used for assertions:</p> <pre><code>TrackerStats stats = tracker.getStats();\nAssertions.assertEquals(1, stats.getMethods().size());\n\nMethodSummary summary = stats.getMethods().get(0);\nAssertions.assertEquals(\"foo\", summary.getMethod().getName());\nAssertions.assertEquals(Service.class, summary.getService());\nAssertions.assertEquals(1, summary.getTracks());\nAssertions.assertEquals(0, summary.getErrors());\nAssertions.assertEquals(1, summary.getMetrics().getValues().length);\nAssertions.assertTrue(summary.getMetrics().getMin() &lt; 1000);\n</code></pre>"},{"location":"about/release-notes/#rest-stubs","title":"REST stubs","text":"<p>Guicey provides lightweight REST testing (the same as dropwizard resource testing support, but with guicey-specific features). Such tests would not start web container: all rest calls are simulated (but still, it tests every part of resource execution).</p> <p>Lightweight REST could be declared with <code>@StubRest</code> annotation under <code>@TestGuiceyApp</code> extension:</p> <pre><code>@TestGuiceyApp(...)\npublic class Test {\n\n    @StubRest\n    RestClient rest;\n\n    @Test\n    public void test() {\n        String res = rest.get(\"/foo\", String.class);\n        Assertions.assertEquals(\"something\", res);\n\n        WebApplicationException ex = Assertions.assertThrows(WebApplicationException.class,\n                () -&gt; rest.get(\"/error\", String.class));\n        Assertions.assertEquals(\"error message\", ex.getResponse().readEntity(String.class));\n    }\n}\n</code></pre> <p>Note</p> <p>Extension naming is not quite correct: it is not a stub, but real application resources are used. The word \"stub\" used to highlight the fact of incomplete startup: only rest without web.</p> <p>By default, all declared resources would be started with all existing jersey extensions (filters, exception mappers, etc.). Servlets and http filters are not started  (guicey disables all web extensions to avoid their (confusing) appearance in console)</p>"},{"location":"about/release-notes/#selecting-resources","title":"Selecting resources","text":"<p>Real tests usually require just one resource (to be tested):</p> <pre><code>@StubRest(MyResource.class)\nRestClient rest;\n</code></pre> <p>This way only one resource would be started (and all resources directly registered in  application, not as guicey extension). All jersey extensions will remain.</p> <p>Or a couple of resources:</p> <pre><code>@StubRest({MyResource.class, MyResource2.class})\nRestClient rest;\n</code></pre> <p>Or you may disable some resources:</p> <pre><code>@StubRest(disableResources = {MyResource2.class, MyResource3.class})\nRestClient rest;\n</code></pre>"},{"location":"about/release-notes/#disabling-jersey-extensions","title":"Disabling jersey extensions","text":"<p>Often jersey extensions, required for the final application, make complications for testing.</p> <p>For example, exception mapper: dropwizard register default exception mapper which returns only the error message, instead of actual exception (and so sometimes we can't check the real cause).</p> <p><code>disableDropwizardExceptionMappers = true</code> disables extensions, registered by dropwizard.</p> <p>When default exception mapper enabled, resource throwing runtime error would return:</p> <pre><code>@Path(\"/some/\")\n@Produces(\"application/json\")\npublic class ErrorResource {\n\n    @GET\n    @Path(\"/error\")\n    public String get() {\n        throw new IllegalStateException(\"error\");\n    }\n}    \n</code></pre> <pre><code>@TestGuiceyApp\npublic class Test {\n\n    @StubRest\n    RestClient rest;\n\n    public void test() {\n        WebApplicationException ex = Assertions.assertThrows(WebApplicationException.class,\n                () -&gt; rest.get(\"/some/error\", String.class));\n\n        // exception hidden, only generic error code\n        Assertions.assertTrue(ex.getResponse().readEntity(String.class)\n                .startsWith(\"{\\\"code\\\":500,\\\"message\\\":\\\"There was an error processing your request. It has been logged\"));\n    }\n}\n</code></pre> <p>Without dropwizard exception mapper, we can verify exact exception:</p> <pre><code>public class Test {\n\n    @StubRest(disableDropwizardExceptionMappers = true)\n    RestClient rest;\n\n    public void test() {\n        ProcessingException ex = Assertions.assertThrows(ProcessingException.class,\n                () -&gt; rest.get(\"/error\", String.class));\n        // exception available\n        Assertions.assertTrue(ex.getCause() instanceof IllegalStateException);\n    }\n}\n</code></pre> <p>It might be useful to disable application extensions also with <code>disableAllJerseyExtensions</code>:</p> <pre><code>@StubRest(disableDropwizardExceptionMappers = true, \n          disableAllJerseyExtensions = true)\nRestClient rest;\n</code></pre> <p>This way raw resource would be called without any additional logic.</p> <p>Note</p> <p>Only extensions, managed by guicey could be disabled: extensions directly registered in dropwizard would remain.</p> <p>Also, you can select exact extensions to use (e.g., to test it):</p> <pre><code>@StubRest(jerseyExtensions = CustomExceptionMapper.class)\nRestClient rest;\n</code></pre> <p>Or disable only some extensions (for example, disabling extension implementing security):</p> <pre><code>@StubRest(disableJerseyExtensions = CustomSecurityFilter.class)\nRestClient rest;\n</code></pre>"},{"location":"about/release-notes/#debug","title":"Debug","text":"<p>Use debug output to see what extensions were actually included and what disabled:</p> <pre><code>@TestGuiceyApp(.., debug = true)\npublic class Test {\n    @StubRest(disableDropwizardExceptionMappers = true,\n            disableResources = Resource2.class,\n            disableJerseyExtensions = RestFilter2.class)\n    RestClient rest;\n}\n</code></pre> <pre><code>REST stub (@StubRest) started on DebugReportTest$Test1:\n\n    Jersey test container factory: org.glassfish.jersey.test.inmemory.InMemoryTestContainerFactory\n    Dropwizard exception mappers: DISABLED\n\n    2 resources (disabled 1):\n        ErrorResource                (r.v.d.g.t.j.s.r.support)  \n        Resource1                    (r.v.d.g.t.j.s.r.support)  \n\n    2 jersey extensions (disabled 1):\n        RestExceptionMapper          (r.v.d.g.t.j.s.r.support)  \n        RestFilter1                  (r.v.d.g.t.j.s.r.support)  \n\n    Use .printJerseyConfig() report to see ALL registered jersey extensions (including dropwizard)\n</code></pre>"},{"location":"about/release-notes/#requests-logging","title":"Requests logging","text":"<p>By default, rest client would log requests and responses:</p> <pre><code>@TestGuiceyApp(...)\npublic class Test {\n\n    @StubRest\n    RestClient rest;\n\n    @Test\n    public void test() {\n        String res = rest.get(\"/foo\", String.class);\n        Assertions.assertEquals(\"something\", res);\n    }\n}\n</code></pre> <pre><code>[Client action]---------------------------------------------{\n1 * Sending client request on thread main\n1 &gt; GET http://localhost:0/foo\n\n}----------------------------------------------------------\n\n\n[Client action]---------------------------------------------{\n1 * Client response received on thread main\n1 &lt; 200\n1 &lt; Content-Length: 3\n1 &lt; Content-Type: application/json\nsomething\n\n}----------------------------------------------------------\n</code></pre> <p>Logging could be disabled with <code>logRequests</code> option: <code>@StubRest(logRequests = false)</code></p>"},{"location":"about/release-notes/#container","title":"Container","text":"<p>By default, InMemoryTestContainerFactory used.</p> <pre><code>In-Memory container is not a real container. It starts Jersey application and \ndirectly calls internal APIs to handle request created by client provided by \ntest framework. There is no network communication involved. This containers \ndoes not support servlet and other container dependent features, but it is a \nperfect choice for simple unit tests.\n</code></pre> <p>If it is not enough (in-memory container does not support all functions), then use <code>GrizzlyTestContainerFactory</code></p> <pre><code>The GrizzlyTestContainerFactory creates a container that can run as a light-weight, \nplain HTTP container. Almost all Jersey tests are using Grizzly HTTP test container \nfactory.\n</code></pre> <p>To activate grizzly container add dependency (version managed by dropwizard BOM):</p> <pre><code>testImplementation 'org.glassfish.jersey.test-framework.providers:jersey-test-framework-provider-grizzly2'\n</code></pre> <p>By default, <code>@StubRest</code> would use grizzly, if it's available on classpath or in-memory. If you need to force any container type use:</p> <pre><code>// use in-memory container, even if grizly available in classpath\n// (use to force more lightweight container, even if some tests require grizzly)\n@StubRest(container = TestContainerPolicy.IN_MEMORY)\n</code></pre> <pre><code>// throw error if grizzly container not available in classpath\n// (use to avoid accidental in-memory use)\n@StubRest(container = TestContainerPolicy.GRIZZLY)\n</code></pre>"},{"location":"about/release-notes/#rest-client","title":"Rest client","text":"<p><code>RestClient</code> is almost the same as <code>ClientSupport</code>, available for guicey extensions. It is just limited only for rest (and so simpler to use).</p> <p>Note</p> <p>Just in case: <code>ClientSupport</code> would not work with <code>@StubRest</code> </p> <p>Client provides base methods with response mapping:</p> <pre><code>@StubRest\nRestClient rest;\n</code></pre> <ul> <li><code>rest.get(path, Class)</code></li> <li><code>rest.post(path, Object/Entity, Class)</code></li> <li><code>rest.put(path, Object/Entity, Class)</code></li> <li><code>rest.delete(path, Class)</code></li> </ul> <p>To not overload default methods with parameters, additional data could be set with defaults:</p> <ul> <li><code>rest.defaultHeader(String, String)</code></li> <li><code>rest.defaultQueryParam(String, String)</code></li> <li><code>rest.defaultAccept(String...)</code></li> <li><code>rest.defaultOk(Integer...)</code></li> </ul> <p><code>defaultOk</code> used for void responses (response class == null) to check correct response  status (default 200 (OK) and 204 (NO_CONTENT)).</p> <p>So if we need to perform a post request with query param and custom header:</p> <pre><code>rest.defaultHeader(\"Secret\", \"unreadable\")\n    .defaultQueryParam(\"foo\", \"bar\");\nOtherModel res = rest.post(\"/somehere\", new SomeModel(), OtherModel.class);\n</code></pre> <p>Note</p> <p>Multipart support is enabled automatically when dropwizard-forms available in classpath</p> <pre><code>FormDataMultiPart multiPart = new FormDataMultiPart();\nmultiPart.setMediaType(MediaType.MULTIPART_FORM_DATA_TYPE);\n\nFileDataBodyPart fileDataBodyPart = new FileDataBodyPart(\"file\",\n        file.toFile(),\n        MediaType.APPLICATION_OCTET_STREAM_TYPE);\nmultiPart.bodyPart(fileDataBodyPart);\n\nrest.post(path, Entity.entity(multiPart, multiPart.getMediaType()), Something.class);\n</code></pre> <p>To clear defaults: </p> <pre><code>rest.reset() \n</code></pre> <p>Might be a part of call chain:</p> <pre><code>rest.reset().post(...) \n</code></pre> <p>When test needs to verify cookies, response headers, etc. use <code>.request(path)</code>:</p> <pre><code>Response response = rest.request(path).get() // .post(), .put(), .delete();\n</code></pre> <p>All defaults are also applied in this case.</p> <p>To avoid applying configured defaults, raw <code>rest.target(path)...</code> could be used.</p>"},{"location":"about/release-notes/#testing-logs","title":"Testing logs","text":"<p>Important</p> <p>Logs testing works only with logback!</p> <p><code>@RecordLogs</code> extension could record log messages for one or multiple classes:</p> <pre><code>@TestGucieyApp(...)\npublic class Test {\n\n    @RecordLogs(value = Service.class, level = Level.DEBUG)\n    RecordedLogs logs;\n\n    @Inject\n    Service service;\n\n    @Test\n    public void test() {\n        // here some actions with service, involving logging\n        service.doSomething();\n\n        Assertions.assertEquals(2, logs.count());\n        Assertions.assertTrue(logs.has(Level.DEBUG));\n        Assertions.assertEquals(Arrays.asList(\"message 1\", \"message 2\"), \n                logs.messages());\n    }\n}\n</code></pre> <p>Logs could be collected for any custom logger name or entire package:</p> <pre><code>@RecordLogs(loggers = \"ru.vyarus.dropwizard.guice.test\", level = Level.TRACE)\nRecordedLogs logs;\n</code></pre> <p>Important</p> <p>To collect logs, logger level must be set to the required level and so these logs would  also appear in console output.  This allows using log recorder as a simple way to enable required logs for tests.</p> <p>Dropwizard resets logging two times during startup, but the extension also configures required loggers multiple times. In most cases, all required logged messages should be intercepted.</p> <p>To avoid tons of selection methods with different parameters, all selection methods return sub-selector object for further selections.  For example, to select messages by level and logger:</p> <pre><code>logs.logger(SomeClass.class).level(Level.DEBUG).messages().\n</code></pre> <p>Also, original event objects are available: <code>.events()</code>.</p>"},{"location":"about/release-notes/#internal","title":"Internal","text":""},{"location":"about/release-notes/#beforeinit-event","title":"BeforeInit event","text":"<p>Added <code>BeforeInitEvent</code> - (\"meta\" event) the first point where <code>Bootstrap</code> reference is available (<code>GuiceBundle</code> initialization started), but guicey actually did not start any actions, except hooks processing.</p> <p>Example usage:</p> <pre><code>GuiceBundle.builder()\n    .listen(new GuiceyLifecycleAdapter(){\n        @Override\n        protected void beforeInit(final BeforeInitEvent event) { ... }\n    })\n</code></pre> <p>Event used by the new startup time report (to modify <code>Bootstrap</code> object for execution  time tracking).</p>"},{"location":"about/release-notes/#web-installers-marker","title":"Web installers marker","text":"<p>Added a new marker interface <code>WebInstaller</code>. It must be applied for all web (jetty) and jersey related installers.</p> <p>Marker used to mark extensions as web extensions and be able to disable them all at once (for example):</p> <pre><code>@EnableHook\nstatic GuiceyConfigurationHook hook = builder -&gt;\n        builder.disable(webExtension());\n</code></pre> <p>This is used in the new rest stubs to disable web extensions (not started with the jersey test  support to avoid confusing console output).</p>"},{"location":"about/release-notes/#migration-guide","title":"Migration guide","text":"<ul> <li>If guicey shared state was used, then you'll have to update places accessing stored objects:   before it was recommended to use bundle name as a key, now stored object class must be used   (initial approach was not very easy to use (even confusing) now access is type-safe)</li> <li>Guicey now analyzes bindings exposed from private guice modules to detect extensions.   Also, disabling extension, declared in private module would lead to private binding remove.   If any problems appear, old behavior could be restored with:   <code>.option(GuiceyOptions.AnalyzePrivateGuiceModules, false)</code></li> <li>If junit 5 used for tests, pay attention to new features:</li> <li>Configuration modifiers (could be more useful than the configuration overrides mechanism)</li> <li><code>GuiceyEnvironmentSetup</code> objects now have direct access to junit context and test lifecycle events     and so could completely replace some junit extensions (where guicey integration is required)</li> <li>New field-based extensions:         * <code>@StubBean</code> - replacing guice beans with custom stubs (without additional modules declaration)         * <code>@MockBean</code> - replacing guice beans with Mockito mocks         * <code>@SpyBean</code> - replacing guice beans with Mockito spies         * <code>@TrackBean</code> - simpler alternative to Mockito spies to track guice beans methods calls         * <code>@StubRest</code> - lightweight rest services testing (without starting web)         * <code>@RecordLogs</code> - test logs </li> </ul>"},{"location":"about/support/","title":"Support","text":"<ul> <li>Github issues - bug reports / enhancement requests</li> <li>Github discussions - questions / propositions / discussions</li> <li>Gitter - chat</li> </ul>"},{"location":"examples/authentication/","title":"Authentication","text":"<p>Example of dropwizard authentication usage with guice.</p>"},{"location":"examples/authentication/#simple-auth","title":"Simple auth","text":"<p>Using dropwizard oauth example as basement. Other auth types are configured in similar way.</p> <pre><code>@Provider\npublic class OAuthDynamicFeature extends AuthDynamicFeature {\n\n    @Inject\n    public OAuthDynamicFeature(OAuthAuthenticator authenticator, \n                                UserAuthorizer authorizer, \n                                Environment environment) {\n        super(new OAuthCredentialAuthFilter.Builder&lt;User&gt;()\n                .setAuthenticator(authenticator)\n                .setAuthorizer(authorizer)\n                .setPrefix(\"Bearer\")\n                .buildAuthFilter());\n\n        environment.jersey().register(RolesAllowedDynamicFeature.class);\n        environment.jersey().register(new AuthValueFactoryProvider.Binder(User.class));\n    }\n\n    // classes below may be external (internal for simplicity)\n\n    @Singleton\n    public static class OAuthAuthenticator implements Authenticator&lt;String, User&gt; {\n\n        @Override\n        public Optional&lt;User&gt; authenticate(String credentials) throws AuthenticationException {\n            return Optional.fromNullable(\"valid\".equals(credentials) ? new User() : null);        }\n    }\n\n    @Singleton\n    public static class UserAuthorizer implements Authorizer&lt;User&gt; {\n        @Override\n        public boolean authorize(User user, String role) {\n            return user.getName().equals(\"good-guy\") &amp;&amp; role.equals(\"ADMIN\");\n        }\n    }   \n}\n</code></pre> <p>The class is automatically picked up by the jersey installer. <code>OAuthAuthenticator</code> and <code>UserAuthorizer</code> are simple guice beans (no special installation required).</p> <p>Constructor injection is used to obtain required guice managed instances and then configure authentication the same way as described in dropwizard docs.</p> <p>If autoconfiguration is enabled, then the class will be resolved and installed automatically.</p> <p>Complete OAuth example source</p>"},{"location":"examples/authentication/#chained-auth","title":"Chained auth","text":"<p>Chained auth can be used to support different authentication schemes.</p> <p>Integration approach is the same as in simple case:</p> <pre><code>@Provider\npublic class ChainedAuthDynamicFeature extends AuthDynamicFeature {\n\n    @Inject\n    public ChainedAuthDynamicFeature(BasicAuthenticator basicAuthenticator,\n                                      OAuthAuthenticator oauthAuthenticator, \n                                      UserAuthorizer authorizer, \n                                      Environment environment) {\n        super(new ChainedAuthFilter(Arrays.asList(\n                new BasicCredentialAuthFilter.Builder&lt;&gt;()\n                            .setAuthenticator(basicAuthenticator)\n                            .setAuthorizer(authorizer)\n                            .setPrefix(\"Basic\")\n                            .buildAuthFilter(),\n                new OAuthCredentialAuthFilter.Builder&lt;&gt;()\n                            .setAuthenticator(oauthAuthenticator)\n                            .setAuthorizer(authorizer)\n                            .setPrefix(\"Bearer\")\n                            .buildAuthFilter()\n        )));                \n\n        environment.jersey().register(RolesAllowedDynamicFeature.class);\n        environment.jersey().register(new AuthValueFactoryProvider.Binder(User.class));\n    }   \n}\n</code></pre>"},{"location":"examples/authentication/#polymorphic-auth","title":"Polymorphic auth","text":"<p>Polymorphic auth allows using different auth schemes simultaneously.</p> <p>Integration approach is the same as in simple case:</p> <pre><code>@Provider\npublic class PolyAuthDynamicFeature extends PolymorphicAuthDynamicFeature {\n\n    @Inject\n    public PolyAuthDynamicFeature(BasicAuthenticator basicAuthenticator,\n                                   OauthAuthenticator oauthAuthenticator,\n                                   UserAuthorizer authorizer,\n                                   Environment environment) {\n        super(ImmutableMap.of(\n                  BasicPrincipal.class, new BasicCredentialAuthFilter.Builder&lt;BasicPrincipal&gt;()\n                                                .setAuthenticator(basicAuthenticator)\n                                                .setAuthorizer(authorizer)\n                                                .setRealm(\"SUPER SECRET STUFF\")\n                                                .buildAuthFilter(),\n                  OAuthPrincipal.class, new OAuthCredentialAuthFilter.Builder&lt;OAuthPrincipal&gt;()\n                                                .setAuthenticator(oauthAuthenticator)\n                                                .setAuthorizer(authorizer)\n                                                .setPrefix(\"Bearer\")\n                                                .buildAuthFilter()));             \n\n        final AbstractBinder binder = new PolymorphicAuthValueFactoryProvider.Binder&lt;&gt;(\n            ImmutableSet.of(BasicPrincipal.class, OAuthPrincipal.class));\n\n        environment.jersey().register(binder);\n        environment.jersey().register(RolesAllowedDynamicFeature.class);\n    }\n}\n</code></pre>"},{"location":"examples/eventbus/","title":"Guava EventBus integration","text":"<p>Example of guicey-eventbus extension usage.</p> <p>Example source code</p> <p>The eventbus extension is used for:</p> <ul> <li>automatic listeners registration</li> <li>binding eventbus instance in guice context (for publication)</li> <li>printing available listeners to console</li> </ul>"},{"location":"examples/eventbus/#configuration","title":"Configuration","text":"<p>An additional dependency is required:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-eventbus:7.2.1'\n</code></pre> <p>Note</p> <p>guicey-eventbus version could be managed with BOM</p> <p>Register eventbus bundle:</p> <pre><code>GuiceBundle.builder()\n      .bundles(new EventBusBundle())\n</code></pre>"},{"location":"examples/eventbus/#event","title":"Event","text":"<p>Events are simple POJOs. Create event classes with properties you need (or without everything):</p> <pre><code>public class FooEvent {\n    private String something;\n\n    public FooEvent(String something) {\n        this.something = something;\n    }\n\n    public void getSomething() {\n        return something;\n    }\n}\n</code></pre> <p>Use event hierarchies, if appropriate:</p> <pre><code>public abstract class BaseEvent {}\n\npublic class FooEvent extends BaseEvent {}\n\npublic class BarEvent extends BaseEvent {}\n</code></pre> <p>For simplicity, properties are omitted.</p>"},{"location":"examples/eventbus/#publication","title":"Publication","text":"<p>Inject the eventbus instance to enable publication:</p> <pre><code>@Inject EventBus eventbus;\n\npublic void someAction() {\n    ...\n    eventbus.post(new FooEvent());\n}\n</code></pre>"},{"location":"examples/eventbus/#listening","title":"Listening","text":"<p>Listener methods must be annotated with <code>@Subscribe</code> and contain only one parameter of the target event type:</p> <pre><code>@Subscribe\npublic void onFooEvent(FooEvent event) {}\n\n@Subscribe\n// listen for all events of type (FooEvent, BarEvent)\npublic void onMultipleEvents(BaseEvent event) {}\n</code></pre> <p>Attention</p> <p>Listener methods will only be registered for \"known\" guice beans. That means any extension or manually declared guice bean (using module) or bean created with guice AOT (because it's declared as dependency for other bean) will be searched for listener methods.</p> <p>See a complete example </p>"},{"location":"examples/governator/","title":"Governator integration","text":"<p>Include the Netflix Governator dependency:</p> <pre><code>implementation \"com.netflix.governator:governator:1.17.8\"\n</code></pre> <p>Governator owns injector creation,  so we need to create custom guicey <code>InjectorFactory</code></p> <pre><code>public class GovernatorInjectorFactory implements InjectorFactory {\n    public Injector createInjector(final Stage stage, final Iterable&lt;? extends Module&gt; modules) {\n        return LifecycleInjector.builder().withModules(modules).inStage(stage).build().createInjector();\n    }\n}\n</code></pre> <p>Configure the new factory in the guice bundle:</p> <pre><code>@Override\npublic void initialize(Bootstrap&lt;Configuration&gt; bootstrap) {\n    bootstrap.addBundle(GuiceBundle.builder()\n            .injectorFactory(new GovernatorInjectorFactory())\n            .enableAutoConfig(\"com.mycompany.myapp\")\n            ...\n            .build()\n    );\n}\n</code></pre> <p>Warning</p> <p>Guicey by default parses configured guice modules and so injector factory receives single synthetic module of parsed elements, instead of  configured module instances. Some governator features may require exact module instances and so you may need to disable guicey analysis.    </p> <p>Also, when using overriding modules configuration (with <code>#modulesOverride</code> configuration) injector factory also receives syntetic module after {@code Modules.override(modules).with(overridingModules)}. So you will have not to use this feature when direct module instances required (for some governator features).  </p> <p>Note</p> <p>Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).</p>"},{"location":"examples/governator/#governator-lifecycle","title":"Governator Lifecycle","text":"<p>Many Governator enhancements are only available when the Governator LifecycleManager  is properly started and closed  with the application. </p> <p>Use dropwizard's managed object  to control governator lifecycle:</p> <pre><code>import io.dropwizard.lifecycle.Managed;\nimport ru.vyarus.dropwizard.guice.GuiceBundle;\nimport com.netflix.governator.lifecycle.LifecycleManager;\nimport jakarta.inject.Inject;\n\npublic class GovernatorLifecycle implements Managed {\n\n    @Inject\n    private LifecycleManager manager;\n\n    @Override\n    public void start() throws Exception {\n        manager.start();\n    }\n\n    @Override\n    public void stop() throws Exception {\n        manager.close();\n    }\n}\n</code></pre> <p>Guicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard.  This will \"bind\" the governator lifecycle to the dropwizard lifecycle.</p> <p>Note</p> <p>If you need to control the order which the managed beans are started, use the @Order annotation. </p>"},{"location":"examples/hibernate/","title":"Hibernate integration","text":"<p>Example of dropwizard-hibernate bundle usage with guicey.</p> <p>Example source code</p>"},{"location":"examples/hibernate/#configuration","title":"Configuration","text":"<p>Additional dependencies required:</p> <pre><code>    implementation 'io.dropwizard:dropwizard-hibernate:4.0.2'\n    implementation 'com.h2database:h2:2.2.224'\n</code></pre> <p>Note</p> <p>Both versions are managed by BOM</p> <p>For simplicity, an embedded H2 database is used.</p> <p>Overall configuration is exactly the same as described in dropwizard docs,  but extracted to separate class for simplicity:</p> <pre><code>public class HbnBundle extends HibernateBundle&lt;HbnAppConfiguration&gt; {\n\n    public HbnBundle() {\n        super(Sample.class);\n    }\n\n    @Override\n    public PooledDataSourceFactory getDataSourceFactory(HbnAppConfiguration configuration) {\n        return configuration.getDataSourceFactory();\n    }\n}\n</code></pre> <p>Note</p> <p>All model classes are configured inside the constructor: <code>super(Sample.class);</code></p> <p>Configuration class:</p> <pre><code>public class HbnAppConfiguration extends Configuration {\n    @Valid\n    @NotNull\n    @JsonProperty\n    private DataSourceFactory database = new DataSourceFactory();\n\n    public DataSourceFactory getDataSourceFactory() {\n        return database;\n    }\n}\n</code></pre> <p>Configuration file for in-memory database and automatic schema creation:</p> <pre><code>database:\n  driverClass: org.h2.Driver\n  user: sa\n  password:\n  url: jdbc:h2:mem:sample\n\n  properties:\n    charSet: UTF-8\n    hibernate.dialect: org.hibernate.dialect.H2Dialect\n    hibernate.hbm2ddl.auto: create\n</code></pre>"},{"location":"examples/hibernate/#guice-integration","title":"Guice integration","text":"<p>Guice module used to provide SessionFactory instance into guice context:</p> <pre><code>public class HbnModule extends AbstractModule {\n\n    private final HbnBundle hbnBundle;\n\n    public HbnModule(HbnBundle hbnBundle) {\n        this.hbnBundle = hbnBundle;\n    }\n\n    @Override\n    protected void configure() {\n        bind(SessionFactory.class).toInstance(hbnBundle.getSessionFactory());\n    }\n}\n</code></pre> <p>Application:</p> <pre><code>@Override\npublic void initialize(Bootstrap&lt;HbnAppConfiguration&gt; bootstrap) {\n    final HbnBundle hibernate = new HbnBundle();\n    // register hbn bundle before guice to make sure factory initialized before guice context start\n    bootstrap.addBundle(hibernate);\n    bootstrap.addBundle(GuiceBundle.builder()\n            .enableAutoConfig(\"com.myapp.package\")\n            .modules(new HbnModule(hibernate))\n            .build());\n}\n</code></pre>"},{"location":"examples/hibernate/#usage","title":"Usage","text":"<p>It is simpler to use dropwizard <code>AbstractDAO</code> for hibernate logic:</p> <pre><code>public class SampleService extends AbstractDAO&lt;Sample&gt; {\n\n    @Inject\n    public SampleService(SessionFactory factory) {\n        super(factory);\n    }\n\n    public void create(Sample sample) {\n        return persist(sample);\n    }\n\n    public List&lt;Sample&gt; findAll() {\n        return list(currentSession().createQuery(\"from Sample\"));\n    }\n}\n</code></pre> <p>You will need to use dropwizard <code>@UnitOfWork</code> annotation to declare transaction scope.</p> <p>For example:</p> <pre><code>@Path(\"/sample\")\n@Produces(\"application/json\")\npublic class SampleResource {\n\n    @Inject\n    private SampleService service;\n\n    @GET\n    @Path(\"/\")\n    @Timed\n    @UnitOfWork\n    public Response doStaff() {\n        final Sample sample = new Sample(\"sample\");\n        service.create(sample);\n        final List&lt;Sample&gt; res = service.findAll();\n        // using response to render entities inside unit of work and avoid lazy load exceptions\n        return Response.ok(res).build();\n    }\n}\n</code></pre>"},{"location":"examples/jdbi3/","title":"JDBI3 integration","text":"<p>Example of guicey-jdbi3 extension usage.</p> <p>Example source code</p> <p>The JDBI3 extension allows:</p> <ul> <li>using jdbi proxies as guice beans</li> <li>using injection inside proxies</li> <li>using AOP on proxies</li> <li>using annotations for transaction definition</li> <li>automatic repository and mapper installation</li> </ul>"},{"location":"examples/jdbi3/#configuration","title":"Configuration","text":"<p>Additional dependencies required:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-jdbi3:7.2.1'\nimplementation 'com.h2database:h2:2.2.224'\n</code></pre> <p>Note</p> <p>Both versions are managed by BOM</p> <p>dropwizard-jdbi3 is used to configure  and create dbi instance:</p> <pre><code>public class Jdbi3AppConfiguration extends Configuration {\n\n    @Valid\n    @NotNull\n    @JsonProperty\n    private DataSourceFactory database = new DataSourceFactory();\n\n    public DataSourceFactory getDatabase() {\n        return database;\n    }\n}\n</code></pre> <p>For simplicity, an embedded H2 database is used:</p> <pre><code>database:\n  driverClass: org.h2.Driver\n  user: sa\n  password:\n  url: jdbc:h2:~/sample\n  properties:\n    charSet: UTF-8\n  maxWaitForConnection: 1s\n  validationQuery: \"SELECT 1\"\n  validationQueryTimeout: 3s\n  minSize: 8\n  maxSize: 32\n  checkConnectionWhileIdle: false\n  evictionInterval: 10s\n  minIdleTime: 1 minute\n</code></pre> <p>Warning</p> <p>Database scheme must be created manually. You can use  dropwizard-flyway module to prepare database.  See example app source for details. </p> <p>JDBI instance created exactly as described in dropwizard docs  using provided db configuration:</p> <pre><code>GuiceBundle.builder()\n    .bundles(JdbiBundle.&lt;JdbiAppConfiguration&gt;forDatabase((conf, env) -&gt; conf.getDatabase()))\n    .withPlugins(new H2DatabasePlugin()))\n</code></pre> <p>Note</p> <p>You can use pre-build jdbi instance instead.</p>"},{"location":"examples/jdbi3/#repository-definition","title":"Repository definition","text":"<p>Warning</p> <p>All jdbi repositories must be annotated with <code>@JdbiRepository</code> to let the repository installer recognize and properly install them.</p> <pre><code>@JdbiRepository\n@InTransaction\npublic interface UserRepository extends Crud&lt;User&gt; {\n\n    @Inject\n    RandomNameGenerator getGenerator();\n\n    // sample of hybrid method in repository, using injected service\n    default User createRandomUser() {\n        final User user = new User();\n        user.setName(getGenerator().generateName());\n        save(user);\n        return user;\n    }\n\n    @Override\n    @SqlUpdate(\"insert into users (name, version) values (:name, :version)\")\n    @GetGeneratedKeys\n    long insert(@UserBind User entry);\n\n    @SqlUpdate(\"update users set version=:version, name=:name where id=:id and version=:version - 1\")\n    @Override\n    int update(@UserBind User entry);\n\n    @SqlQuery(\"select * from users\")\n    List&lt;User&gt; findAll();\n\n    @SqlQuery(\"select * from users where name = :name\")\n    User findByName(@Bind(\"name\") String name);\n}\n</code></pre> <p>Where <code>Crud</code> base interface tries to unify repositories and provide hibernate-like optimistic locking behaviour  (on each entity save version field is assigned/incremented and checked during update to prevent data loss):</p> <pre><code>public interface Crud&lt;T extends IdEntity&gt; {\n\n    @InTransaction\n    default T save(final T entry) {\n        // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database\n        if (entry.getId() == 0) {\n            entry.setVersion(1);\n            entry.setId(insert(entry));\n        } else {\n            final int ver = entry.getVersion();\n            entry.setVersion(ver + 1);\n            if (update(entry) == 0) {\n                throw new ConcurrentModificationException(String.format(\n                        \"Concurrent modification for object %s %s version %s\",\n                        entry.getClass().getName(), entry.getId(), ver));\n            }\n        }\n        return entry;\n    }\n\n    long insert(T entry);\n\n    int update(T entry);\n}\n</code></pre> <p>You don't necessarily need to use <code>Crud</code> - it's an advanced usage example.</p> <p>The repository is annotated with <code>@InTransaction</code> to allow direct usage; repository method calls are the smallest transaction scope.  The transaction scope can be enlarged by using annotations on calling guice beans or  declaring transactions manually. In order to better understand how transactions work, read the unit of work docs section.</p> <p>Note</p> <p><code>@InTransaction</code> is handled with guice AOP, so you can use any other guice aop related features.</p> <p>Attention</p> <p>Constructor injection is impossible in repositories, but you can use getter injections: <pre><code> @Inject\n RandomNameGenerator getGenerator();\n</code></pre></p>"},{"location":"examples/jdbi3/#row-mapper","title":"Row mapper","text":"<p>Row mapper is used to map query result set to entity: </p> <pre><code>public class UserMapper implements RowMapper&lt;User&gt; {\n\n    @Override\n    public User map(ResultSet r, StatementContext ctx) throws SQLException {\n        User user = new User();\n        user.setId(r.getLong(\"id\"));\n        user.setVersion(r.getInt(\"version\"));\n        user.setName(r.getString(\"name\"));\n        return user;\n    }\n}\n</code></pre> <p>Mappers are installed with the mapper installer. If auto scan is enabled then all mappers will be detected automatically and registered in the jdbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop  (it's only not shown in example mapper).</p> <p>Note</p> <p>The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you don't want to use auto configuration then you can register it manually in jdbi instance, making it available for injection.</p> <p>Also, see complementing binding annotation, used to bind object to query parameters:</p> <pre><code>@SqlStatementCustomizingAnnotation(UserBind.UserBinder.class)\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.PARAMETER)\npublic @interface UserBind {\n\n    class UserBinder implements SqlStatementCustomizerFactory {\n\n        @Override\n        public SqlStatementParameterCustomizer createForParameter(\n                Annotation annotation,\n                Class&lt;?&gt; sqlObjectType,\n                Method method,\n                Parameter param,\n                int index,\n                Type paramType) {\n\n            return (stmt, obj) -&gt; {\n                User arg = (User) obj;\n                ((SqlStatement) stmt)\n                        .bind(\"id\", arg.getId())\n                        .bind(\"version\", arg.getVersion())\n                        .bind(\"name\", arg.getName());\n            };\n        }\n    }\n}\n</code></pre> <p>See <code>@UserBind</code> usage above in repository definition.</p> <p>There is no custom installer for annotation because it's detected automatically by JDBI.  </p>"},{"location":"examples/jdbi3/#usage","title":"Usage","text":"<p>Repositories are used as normal guice beans:</p> <pre><code>@Path(\"/users\")\n@Produces(\"application/json\")\npublic class UserResource {\n\n    @Inject\n    private final UserRepository repository;\n\n    @POST\n    @Path(\"/\")\n    public User create(String name) {\n        User user = new User();\n        user.setName(name);\n        return repository.save(user);\n    }\n\n    @GET\n    @Path(\"/\")\n    public List&lt;User&gt; findAll() {\n        return repository.findAll();\n    }\n}\n</code></pre> <p><code>UserMapper</code> and <code>UserBind</code> are used implicitly to convert the POJO into a db record and back.</p> <p>You can use <code>@InTransaction</code> on repository method to enlarge transaction scope, but, in contrast to hibernate you don't have to always declare it to avoid lazy initialization exception  (because jdbi produces simple pojos).</p> <p>Note</p> <p><code>@InTrasaction</code> is named to avoid confusion with the commonly used <code>@Transactional</code> annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)</p>"},{"location":"extras/admin-rest/","title":"Admin REST","text":"<p>Mirror all resources in admin context: on admin side special servlet simply redirects all incoming requests into the jersey context. Hides admin-only resources from user context: resource is working under admin context and return 404 on user context.</p> <p>Such approach is better than registering a completely separate jersey context for admin rest because of no overhead and the simplicity of jersey extensions management.</p> <p>Features: * All user context rest available in admin context * Admin-only resources not visible in user context</p>"},{"location":"extras/admin-rest/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-admin-rest&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-admin-rest:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/admin-rest/#usage","title":"Usage","text":"<p>Register bundle:</p> <pre><code>GuiceBundle.builder()\n    .bundles(new AdminRestBundle());\n</code></pre> <p>In this case, rest is registered either to '/api/', if main context rest is mapped to root ('/') or to the same path as main context rest.</p> <p>To register on a custom path:</p> <pre><code>.bundles(new AdminRestBundle(\"/custom/*\"));\n</code></pre> <p>Note</p> <p>In case if multiple bundles registered, only first registration will be used (due to de-duplication)</p>"},{"location":"extras/admin-rest/#security","title":"Security","text":"<p>In order to hide specific resource methods or entire resources on the main context, annotate resource methods or resource classes with the <code>@AdminResource</code> annotation.</p> <p>For example:</p> <pre><code>@GET\n@Path(\"/admin\")\n@AdminResource\npublic String admin() {\n    return \"admin\"\n}\n</code></pre> <p>This (annotated) method will return 404 error when called from main context, but should function normally  when called from the admin context.</p>"},{"location":"extras/bom/","title":"Guicey BOM","text":"<p>Maven BOM contains guicey and guicey ext modules versions. Also includes dropwizard and guice boms.</p> <p>Tip</p> <p>BOMs are useful for versions management. After including bom you can simply include required dependencies (dropwizard, guice, guicey, guicey-ext) without versions: bom will control all versions.</p>"},{"location":"extras/bom/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;!-- Implicitly imports Dropwizard and Guice BOMs --&gt;\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n            &lt;artifactId&gt;guicey-bom&lt;/artifactId&gt;\n            &lt;version&gt;7.2.1&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;  \n        &lt;!-- uncomment to override dropwizard and its dependencies versions  \n        &lt;dependency&gt;\n            &lt;groupId&gt;io.dropwizard/groupId&gt;\n            &lt;artifactId&gt;dropwizard-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;4.0.13&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt; --&gt; \n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;!-- declare guice and ext modules without versions --&gt;\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;ru.vyarus&lt;/groupId&gt;\n      &lt;artifactId&gt;dropwizard-guicey&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- For example, using dropwizard module (without version) --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.dropwizard&lt;/groupId&gt;\n      &lt;artifactId&gt;dropwizard-auth&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Example of extension module usage --&gt;\n    &lt;dependency&gt;\n          &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n          &lt;artifactId&gt;guicey-eventbus&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Gradle:</p> <pre><code>// declare guice and ext modules without versions \ndependencies {\n    implementation platform('ru.vyarus.guicey:guicey-bom:7.2.1')\n    // uncomment to override dropwizard and its dependencies versions    \n    //implementation platform('io.dropwizard:dropwizard-dependencies:4.0.13')\n\n    implementation 'ru.vyarus:dropwizard-guicey'\n    // For example, using dropwizard module (without version)\n    implementation 'io.dropwizard:dropwizard-auth'\n    // Example of extension module usage\n    implementation 'ru.vyarus.guicey:guicey-eventbus' \n}\n</code></pre> <p>Bom includes:</p> BOM Artifact Guicey modules <code>ru.vyarus.guicey:guicey-[module]</code> Dropwizard BOM <code>io.dropwizard:dropwizard-bom</code> Guice BOM <code>com.google.inject:guice-bom</code> HK2 bridge <code>org.glassfish.hk2:guice-bridge</code> Spock-junit5 <code>ru.vyarus:spock-junit5</code>"},{"location":"extras/bom/#dependencies-override","title":"Dependencies override","text":"<p>You may override BOM version for any dependency by simply specifying exact version in dependency declaration section.</p> <p>If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly:</p> <ul> <li><code>io.dropwizard:dropwizard-dependencies:$VERSION</code> for dropwizard</li> <li><code>com.google.inject:guice-bom:$VERSION</code> for guice</li> </ul>"},{"location":"extras/eventbus/","title":"Guava EventBus integration","text":"<p>Integrates Guava EventBus with guice.</p> <p>Features:</p> <ul> <li>EventBus available for injection (to publish events)</li> <li>Automatic registration of listener methods (annotated with <code>@Subscribe</code>)</li> <li>Console reporting of registered listeners</li> </ul>"},{"location":"extras/eventbus/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-eventbus&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-eventbus:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/eventbus/#usage","title":"Usage","text":"<p>Register bundle:</p> <pre><code>GuiceBundle.builder()        \n        .bundles(new EventBusBundle())\n        ...\n</code></pre> <p>Create event:</p> <pre><code>public class MyEvent {\n    // some state\n}\n</code></pre> <p>Inject <code>EventBus</code> to publish new events.</p> <pre><code>public class SomeService {\n    @Inject\n    private EventBus eventbus;    \n\n    public void inSomeMethod() {\n        evetbus.post(new MyEvent());\n    }\n}\n</code></pre> <p>Listen for event:</p> <pre><code>public class SomeOtherService {\n\n    @Subscribe\n    public void onEvent(MyEvent event) {\n         // handle event   \n    }\n}\n</code></pre> <p>After server start you should see all registered event listeners in the log:</p> <pre><code>INFO  [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = \n\n    MyEvent\n        com.foo.something.SomeOtherService        \n</code></pre> <p>Note</p> <p>Only subscriptions of beans registered at the time of injector startup will be shown. For example, if MyBean has a subscription method but a binding for it is not declared (and no-one depends on it), a JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs. </p>"},{"location":"extras/eventbus/#consuming-multiple-events","title":"Consuming multiple events","text":"<p>Note that you can build event hierarchies and subscribe to some base event to receive any derived event.   </p> <p>To receive all events use:</p> <pre><code>@Subscribe\npublic void onEvent(Object event){    \n}\n</code></pre>"},{"location":"extras/eventbus/#event-bus","title":"Event bus","text":"<p>By default, events will be handled synchronously (<code>bus.push()</code> waits while all subscribers process).</p> <p>If you want events to be async use custom eventbus:</p> <pre><code>new EventBusBundle(\n        new AsyncEventBus(someExecutor)\n)\n</code></pre> <p>By default, event listeners are not considered thread safe and no parallel events processing (for single method)  will be performed. To mark subscriber as thread safe use <code>@AllowConcurrentEvents</code>:</p> <pre><code>@Subscribe\n@AllowConcurrentEvents\npublic void onEvent(MyEvent event)      \n</code></pre> <p>If a listener method fails to process an event (throws an exception), then other listeners will still be processed and the exception will be logged. If you want to change this behaviour, set a custom exception  handler by creating a custom eventbus instance:</p> <pre><code>new EventBusBundle(\n        new EventBus(customExceptionHandler)\n)\n</code></pre>"},{"location":"extras/eventbus/#listeners-recognition","title":"Listeners recognition","text":"<p>The guice type listener is used to intercept all bean instances and thus looks at every method in the  class hierarchy; however, only beans that actually have <code>@Subscribe</code>rs will be registered with the event bus.  This process is fast and usually causes no issues. If needed, you can reduce the scope with a  custom class matcher:</p> <pre><code>new EventBusBundle()\n    .withMatcher(Matchers.inSubpackage(\"some.package\"))\n</code></pre> <p>If you want maximum performance, then you can add a marker annotation (e.g. <code>@HasEvents</code>) and reduce scope to just annotated classes:</p> <pre><code>new EventBusBundle()\n    .withMatcher(Matchers.annotatedWith(HasEvents.class))\n</code></pre>"},{"location":"extras/eventbus/#console-reporting","title":"Console reporting","text":"<p>You can switch off console reporting (for example, if you have too many listeners):</p> <pre><code>new EventBusBundle().noReport()\n</code></pre> <p>Note</p> <p>Reporting has to use reflection to get subscribers list. If this fails with a newer guava version (not yet supported), then simply disable reporting and everything will work as expected.</p>"},{"location":"extras/eventbus/#subscribers-info-bean","title":"Subscribers info bean","text":"<p><code>EventSubscribersInfo</code> is a registered (available for injection) bean that provides active listeners and used event types. As described above, it uses reflection internally to access the eventbus listeners map.  It may be useful for testing. </p>"},{"location":"extras/gsp/","title":"Guicey Server Pages","text":"<p>Brings the simplicity of JSP to dropwizard-views.  Basement for pluggable and extendable ui applications (like dashboards).</p> <p>EXPERIMENTAL MODULE </p> <p>Features:</p> <ul> <li>Use standard dropwizard modules: dropwizard-views and dropwizard-assets</li> <li>Support direct templates rendering (without rest resource declaration) </li> <li>Static resources, direct templates and dropwizard-views rest endpoints are handled under the same url (like everything is stored in the same directory - easy to link css, js and other resources)</li> <li>Multiple ui applications declaration with individual errors handling (error pages declaration like in servlet api, but not global)</li> <li>Ability to extend applications (much like good old resources copying above exploded war in tomcat)</li> </ul>"},{"location":"extras/gsp/#problem","title":"Problem","text":"<p>Suppose you want to serve your ui to from the root url, then you need to re-map rest:</p> <pre><code>server:\n  rootPath: '/rest/*'\n  applicationContextPath: /\n</code></pre> <p>Static resources are in classpath:</p> <pre><code>com/something/\n    index.html\n    style.css\n</code></pre> <p>Using dropwizard assets bundle to configure application:</p> <pre><code>bootstrap.addBundle(new AssetsBundle(\"/com/something/\", \"/\", \"index.html\"));\n</code></pre> <p>Note that <code>index.html</code> could reference css with relative path:</p> <pre><code>&lt;link href=\"style.css\" rel=\"stylesheet\"&gt;\n</code></pre> <p>Now if we want to use template instead of pure html we configure dropwizard views:</p> <pre><code>bootstrap.addBundle(new ViewBundle&lt;MyConfiguration&gt;());\n</code></pre> <p>Renaming <code>index.html</code> to <code>index.ftl</code> and add view resource:</p> <pre><code>@Path(\"/ui/\")\n@Produces(MediaType.TEXT_HTML)\npublic class IndexResource {\n\n    public static class IndexView extends View {\n        public IndexView() {\n            super(\"/com/something/index.ftl\");\n        } \n    }\n\n    @GET\n    public IndexView get() {\n        return new IndexView();\n    }\n}\n</code></pre> <p>As a result, index page url become <code>/rest/ui/</code> so we need to link css resource with full path (<code>/style.css</code>) instead of relative (or even re-configure server to back rest mapping to into root).</p> <p>It is already obvious that asset servlet and templates are not play well together.</p>"},{"location":"extras/gsp/#solution","title":"Solution","text":"<p>The solution is obvious: make assets servlet as major resources supplier and with an additional filter to detect template requests and redirect rendering to actual rest.</p> <p>So example above should become:</p> <pre><code>com/something/\n    index.ftl\n    style.css\n</code></pre> <p>Where <code>index.ftl</code> could use</p> <pre><code>&lt;link href=\"style.css\" rel=\"stylesheet\"&gt;\n</code></pre> <p>because it is queried by url <code>/index.ftl</code>: no difference with usual <code>index.html</code> - template rendering is hidden (and direct template file even don't need custom resource). </p> <p>When we need custom resource (most likely, for parameters mapping) we can still use it:</p> <pre><code>@Path(\"/views/ui/\")\n@Template(\"foo.ftl\")\n@Produces(MediaType.TEXT_HTML)\npublic class IndexResource {\n\n    @GET\n    @Path(\"/foo/{id}\")\n    public IndexView get(@PathParam(\"id\") String id) {\n        return new TemplateView();\n    }\n}\n</code></pre> <p>It would be accessible from assets root <code>/foo/12</code> (more on naming and mapping details below). Under the hood <code>/foo/12</code> will be recognized as template call and redirected (server redirect) to <code>/rest/ui/foo/12</code>. </p> <p>As you can see rest endpoints and templates are now \"a part\" of static resources.. just like good-old  JSP (powered with rest mappings). And it is still pure dropwizard views.</p> <p>GSP implements per-application error pages support so each application could use its own errors. In pure  dropwizard-views such things should be implemented manually, which is not good for application encapsulation.</p>"},{"location":"extras/gsp/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-server-pages&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>compile 'ru.vyarus.guicey:guicey-server-pages:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/gsp/#usage","title":"Usage","text":"<p>First of all, global GSP bundle must be installed in main application class. It  configures and installs dropwizard-views (global). It supports the same configurations as pure dropwizard-views bundle.</p> <pre><code>GuiceBundle.builder()\n    .bundles(ServerPagesBundle.builder().build());\n</code></pre> <p>Remove direct dropwizard-views bundle registrations (<code>ViewBundle</code>) if it was already used in application.  </p>"},{"location":"extras/gsp/#template-engines","title":"Template engines","text":"<p>Out of the box dropwizard provides <code>freemarker</code> and <code>mustache</code> engines support.  You will need to add dependency to one of them (or both) in order to activate it (or, maybe, some third party engine):</p> <ul> <li>implementation (<code>io.dropwizard:dropwizard-views-freemarker</code>) </li> <li>implementation (<code>io.dropwizard:dropwizard-views-mustache</code>)</li> </ul> <p>Other template engines available as 3<sup>rd</sup> party modules. If your template engine is not yet supported then simply implement <code>io.dropwizard.views.ViewRenderer</code> in order to support it.</p> <p><code>ViewRenderer</code> implementations are loaded automatically using ServiceLoader mechanism.  If your renderer is not declared as service then simply add it directly:</p> <pre><code>.bundles(ServerPagesBundle.builder()\n        .addViewRenderers(new MyTempateSupport())\n        .build());\n</code></pre> <p>Duplicate renderers are automatically removed.</p> <p>List of detected template engines will be printed to console. You can get list of used renderers from bundle instance <code>ServerPagesBundle#getRenderers()</code> </p> <p>Note</p> <p>This is pure dropwizard-views staff (everything is totally standard).</p>"},{"location":"extras/gsp/#configuration","title":"Configuration","text":"<p>Views yaml configuration binding is the same as in dropwizard-views.</p> <pre><code>views:\n  freemarker:\n    strict_syntax: true\n  mustache:\n    cache: false\n</code></pre> <p>Where <code>freemarker</code> and <code>mustache</code> are keys from installed template renderer  <code>io.dropwizard.views.ViewRenderer#getConfigurationKey()</code>. </p> <pre><code>public class AppConfig extends Configuration {\n    @JsonProperty\n    private Map&lt;String, Map&lt;String, String&gt;&gt; views;\n\n    public Map&lt;String, Map&lt;String, String&gt;&gt; getViews() { return views;} \n}\n</code></pre> <pre><code>.bundles(ServerPagesBundle.builder()\n        .viewsConfiguration(AppConfig::getViews)\n        .build());\n</code></pre> <p>If <code>AppConfig#getViews</code> return <code>null</code> then empty map will be used instead as config.</p> <p>Additionally, to direct yaml configuration binding, you can apply exact template engine modifications</p> <pre><code>.bundles(ServerPagesBundle.builder()\n        .viewsConfiguration(AppConfig::getViews)\n        .viewsConfigurationModifier(\"freemarker\", \n                map -&gt; map.put(\"cache_storage\", \"freemarker.cache.NullCacheStorage\"))\n        .build());\n</code></pre> <p>Modifier always receive not null map (empty map is created automatically in global configuration).</p> <p>Multiple modifiers could be applied (even for the same section). Each GSP application could also apply modifiers (this is useful to tune defaults: e.g. in case of freemarker, application may need to apply default imports).</p> <p>The final configuration (after all modifiers) could be printed to console with <code>.printViewsConfiguration()</code>. Also, configuration is accessible from the bundle instance: <code>ServerPagesBundle#getViewsConfig()</code>.</p>"},{"location":"extras/gsp/#applications","title":"Applications","text":"<p>Each GSP application is registered as separate bundle in main or admin context:</p> <pre><code>.bundles(ServerPagesBundle.app(\"projectName-ui\", \"com.app.ui\", \"/\")\n                    .indexPage(\"index.ftl\")\n                    .build())\n\n.bundles(ServerPagesBundle.adminApp(\"projectName-admin\", \"com.app.admin\", \"/admin\")\n                    .build())                    \n</code></pre> <p>Unlimited number of applications may be registered on each context.</p> <pre><code>app(\"projectName-ui\", \"com.app.ui\", \"/\")\n</code></pre> <ul> <li><code>projectName-ui</code> - unique(!) application name. Uniqueness is very important as name used for rest paths.     To avoid collisions it's recommended to use domain-prefixed names to better identify application related resources. </li> <li><code>com.app.ui</code> - classpath package with resources (application \"root\" folder; the same meaning as in dropwizard-assets);     Also, it may be configured as <code>/com/app/ui/</code>, but package notion is easier to understand </li> <li><code>/</code> - application mapping url (in main or admin context; the same as in dropwizard-assets)     (if context is prefixed (<code>server.applicationContextPath: /some</code> or <code>server.adminContextPath: /admin</code>) then GSP      application will be available under this prefix)</li> </ul> <p>Warning</p> <p>It is a common desire to map ui on main context's root path (<code>/</code>), but, by default, dropwizard maps rest there and so you may see an error:</p> <pre><code>java.lang.IllegalStateException: Multiple servlets map to path /*: app[mapped:JAVAX_API:null],io.dropwizard.jersey.setup.JerseyServletContainer-1280682[mapped:EMBEDDED:null]\n</code></pre> <p>In this case simply re-map rest in yaml config: <pre><code>server:\n  rootPath: '/rest/*'\n</code></pre></p> <p>If application requires resources from multiple paths, use:</p> <pre><code>ServerPagesBundle.app(\"projectName-ui\", \"com.app.path1\", \"/\")\n    .attachAssets(\"com.app.path1\")\n    ...\n</code></pre> <p>For example, this can be useful to attach some shared resources. To attach webjars there is a pre-defined shortcut.</p> <p>You can even attach resources path for exact sub url:</p> <pre><code>ServerPagesBundle.app(\"projectName-ui\", \"com.app.path1\", \"/\")\n    .attachAssets(\"/sub/path/\", \"com.app.path.sub\")\n    ...\n</code></pre> <p>And for urls starting from <code>/sub/path/</code> application will look static resources (and templates) inside <code>/com/app/path/sub/</code> first, and only after that under root paths. </p> <p>This way, you can map resources from different packages as you want. This is like if you copied everything from different packages into one place (like exploded war).</p>"},{"location":"extras/gsp/#template-engine-constraint","title":"Template engine constraint","text":"<p>As GSP application declaration is separated from views configuration (GSP application may be even a 3<sup>rd</sup> party bundle) then it must be able to check required template engines presence.</p> <p>For example, this application requires freemarker:</p> <pre><code>.bundles(ServerPagesBundle.app(\"projectName-ui\", \"com.app.ui\", \"/\")\n                    .requireRenderers(\"freemarker\")\n                    .build())\n</code></pre> <p>Template engine name is declared in <code>io.dropwizard.views.ViewRenderer#getConfigurationKey()</code> (same name used in configuration).   </p>"},{"location":"extras/gsp/#templates-support","title":"Templates support","text":"<p>As dropwizard-views is used under the hood, all templates are always rendered with rest endpoints. All these rest endpoints are part of global rest.</p> <p>It is recommended to start all view rest with <code>/view/</code> to make it clearly distinguishable from application rest. Also, rest views, related to one GSP application must also start with a common prefix: for example, <code>/view/projectName/ui/..</code>.</p> <p>You need to map required rest prefix in GSP application:</p> <pre><code>.bundles(ServerPagesBundle.app(\"projectName-ui\", \"com.app.ui\", \"/\")\n                    .mapViews(\"/view/projectName/ui/\")\n</code></pre> <p>This will \"map\" all view rest paths after prefix directly to GSP application root. So if you have view resource <code>/view/projectName/ui/page1/action</code> you can access it relatively to application mapping root (\"/\" in the example above) as <code>/page1/action</code>.</p> <p>By default, if views mapping is not declared manually, it would be set to application name (<code>/...</code> -&gt; <code>/projectName-ui/...</code>)</p> <p>Under startup dropwizard logs all registered rest endpoints, so you can always see original rest mapping paths. For each registered GSP application list of \"visible\" paths will be logged as: </p> <pre><code>INFO  [2019-06-07 04:10:47,978] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources:\n\n    GET     /rest/views/projectName/ui/sample (com.project.ui.SampleViewResource)\n    POST    /rest/views/projectName/ui/other (com.project.ui.SampleViewResource)\n\nINFO  [2019-06-07 04:10:47,982] ru.vyarus.guicey.gsp.app.ServerPagesApp: Server pages app 'com.project.ui' registered on uri '/*' in main context\n\n    Static resources locations:\n        com.app.ui\n\n    Mapped handlers:\n        GET     /sample  (com.project.ui.SampleViewResource #sample)\n        POST    /other  (com.project.ui.SampleViewResource #other)\n</code></pre> <p>Here you can see real rest mapping <code>GET     /rest/views/projectName/ui/sample</code> and how it could be used relative to application path <code>GET     /sample</code>. </p> <p>This report will always contain all correct view paths which must simplify overall understanding: if path not appear in the report - it's incorrectly mapped and when it's appear - always use the path from application report to access it.</p> <p>But that's not all: you can actually map other rest prefixed to sub urls:</p> <pre><code>.bundles(ServerPagesBundle.app(\"projectName-ui\", \"com.app.ui\", \"/\")\n                    .mapViews(\"/sub/path/\", \"/view/projectName2/ui/something/\")\n</code></pre> <p>This way, it is possible to combine rest endpoints, written for different applications (or simply prepare common view resource groups). Just note that in contrast to resources mapping, only one prefix may be mapped on each url!</p> <p>You will also need to map static resources location accordingly if you use relative template paths.</p>"},{"location":"extras/gsp/#direct-templates","title":"Direct templates","text":"<p>You can also render template files without declaring view rest at all (good old jsp way).</p> <p>If we call supported template type directly like <code>http://localhost:8080/template.ftl</code> it will be recognized as direct template call and rendered. Template file must be placed under registered classpath path root: <code>/com/app/ui/template.ftl</code>.</p> <p>Templates in sub folders will be rendered the same way, e.g. <code>http://localhost:8080/sub/path/template.ftl</code> will render <code>/com/app/ui/sub/path/template.ftl</code>. </p>"},{"location":"extras/gsp/#template-rest-declaration","title":"Template rest declaration","text":"<p>Declaration differences with pure dropwizard-views:</p> <ul> <li><code>@Path</code> value must start with mapped prefix (see the chapter above) </li> <li>Resource class must be annotated with <code>@Template</code> (even without exact template declaration)</li> <li><code>TemplateView</code> must be used instead of dropwizard <code>View</code> as a base class for view models.</li> </ul> <p>Suppose we declaring page for gsp application <code>.app(\"projectName-ui\", \"com.app.ui\", \"/\")</code></p> <p>As in pure views, in most cases we will need custom model object:</p> <pre><code>public class SampleView extends TemplateView {\n    private String name;\n\n    public SampleView(String name) {\n        this.name = name;\n    }\n\n    public String getName() { return this.name; } \n}\n</code></pre> <p>Note</p> <p>Custom model is optional - you can use <code>TemplateView</code> directly, as default \"empty\" model.</p> <pre><code>@Path(\"/views/projectName/ui/sample/\")\n@Template(\"sample.ftl\")\npublic class SamplePage {\n\n    @Path(\"{name}\")\n    public SampleView doSomething(@PathParam(\"name\") String name) {\n        return new SampleView(name);        \n    }    \n}\n</code></pre> <p>And example template:</p> <pre><code>&lt;#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Sample page&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    Name: ${name}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>After application startup, new url must appear in GSP application console report.</p> <p>If we call new page with <code>http://localhost:8080/sample/fred</code> we should see <code>Name: fred</code> as a result.</p> <p>Note</p> <p>Can pure dropwizard-views resources be used like that? Actually, yes, but they must be annotated with <code>@Template</code> because not annotated resources are not  considered as potential GSP application views (and will not be shown in console report).</p>"},{"location":"extras/gsp/#template","title":"@Template","text":"<p><code>@Template</code> annotation must be used on ALL template resources. It may declare default template for all methods in resource (<code>@Template(\"sample.ftl\")</code>) or be just a marker annotation (<code>@Template</code>).</p> <p>Annotation differentiate template resources from other api resources and lets you declare jersey extension only for template resources:</p> <pre><code>@Provider\n@Template\npublic class MyExtensions implements ContainerRequestFilter {\n    ...\n} \n</code></pre> <p>This request filter will be applied only to template resources. Such targeting is used  internally in order to not affect global api with GSP specific handling logic.</p> <p>Template path resolution:</p> <ul> <li>If path starts with <code>/</code> then it would be resolved from classpath root</li> <li>Resolution relative to resource class</li> <li>Resolution relative to static resources location (<code>/com/app/ui/</code> in the example above) </li> </ul> <p>Examples: </p> <ul> <li><code>@Template(\"/com/project/custom/path/sample.ftl\")</code> - absolute declaration.</li> <li><code>@Template(\"sub/sample.ftl\")</code> - relative declaration</li> <li><code>@Template(\"../sub/sample.ftl\")</code> - relative declaration</li> </ul> <p>Even if template is configured in the annotation, exact resource method could specify it's own  template directly in <code>TemplateView</code> constructor:</p> <pre><code>@Path(\"/views/projectName/ui/sample/\")\n@Template(\"sample.ftl\")  // default template\npublic class SamplePage {\n\n    @Path(\"/\")\n    public TemplateView doSomething() {\n        // override template\n        return new TemplateView(\"otherTemplate.ftl\");        \n    }    \n}\n</code></pre> <p>Template path resolution rules are the same as with annotation.</p>"},{"location":"extras/gsp/#templatecontext","title":"TemplateContext","text":"<p><code>TemplateContext</code> contains all template contextual information. It could be accessed inside template with model's <code>getContext()</code>, e.g.:</p> <pre><code>&lt;#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Sample page&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    Current url: ${context.url}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In rest view resources it could be accessed with a static lookup: <code>TemplateContext.getInstance()</code>.</p> <p>This way you can always know current gsp application name, original url (before redirection to rest), root application mapping prefix and get original request object (which may be required for error pages).</p>"},{"location":"extras/gsp/#index-page","title":"Index page","text":"<p>Index page is a page shown for root application url (<code>/</code>). It could be declared as:</p> <pre><code>.bundles(ServerPagesBundle.app(\"com.project.ui\", \"/com/app/ui/\", \"/\")\n                    .indexPage('index.html')\n                    .build())\n</code></pre> <p>It could be: * Direct resource: <code>index.html</code> * Direct template: <code>index.ftl</code> * Rest powered template: <code>/mapping/</code> </p> <p>Note</p> <p>By default, index page is set to <code>\"\"</code> because most likely your index page will be  handled with rest and <code>\"\"</code> will redirect to root path (for current application): <code>/com.project.ui/</code> </p>"},{"location":"extras/gsp/#error-pages","title":"Error pages","text":"<p>Each GSP application could declare its own error pages (very similar to servlet api). </p> <p>It could be one global error page and different pages per status:</p> <pre><code>.bundles(ServerPagesBundle.app(\"com.project.ui\", \"/com/app/ui/\", \"/\")\n                    .errorPage('error.html')\n                    .errorPage(500, '500.html')\n                    .errorPage(401, '401.html')\n                    .build())\n</code></pre> <p>As with index pages, error page may be direct static html, direct template or rest path.</p> <p>Important</p> <p>Error pages are shown ONLY if requested type was <code>text/html</code> and pass error as is  in other cases. Simply because it is not correct to return html when client was expecting different type. </p> <p>Errors handling logic detects:</p> <ol> <li>Static resources errors (404)</li> <li>Exceptions during view resource processing (including rendering errors)</li> <li>Direct error codes return without exception (<code>Resounce.status(404).build()</code>) </li> </ol> <p>Error pages may use special view class (or extend it) <code>ErrorTemplateView</code> which collects additional error-related info.</p> <p>For example, even direct error template could show:</p> <pre><code>&lt;#-- @ftlvariable name=\"\" type=\"ru.vyarus.guicey.gsp.views.template.ErrorTemplateView\" --&gt;\n\n&lt;h3&gt;Url ${erroredUrl} failed to render with ${errorCode} status code&lt;/h3&gt;\n&lt;div&gt;Error: ${error.class.simpleName}&lt;/div&gt;\n&lt;pre&gt;\n  ${errorTrace}\n&lt;/pre&gt;\n</code></pre> <p>For rest-powered error page:</p> <pre><code>@Path(\"/views/projectName/ui/error/\")\n@Template(\"error.ftl\")\npublic class ErrorPage {\n\n    @Path(\"/\")\n    public TemplateView render() {\n        // it may be any extending class if additional properties are required (the same as usual)\n        ErrorTemplateView view = new ErrorTemplateView();\n        WebApplicationException ex = view.getError();\n        // analyze error\n        return view;\n    }        \n}\n</code></pre> <p>(this error page can be mapped as <code>.errorPage(\"/error/\")</code>).</p> <p><code>view.getError()</code> always return <code>WebApplicationException</code> so use <code>ex.geCause()</code> to get original exception. But there will not always be useful exception because direct exception is only one of error cases (see above).</p> <p>In order to differentiate useful exceptions, you can check:</p> <pre><code>if (ex instanceof TracelessException) {\n    // only status code availbale\n    int status = ((TracelessException) ex).getStatus();\n} else {\n    // actually throwed exception to analyze\n    Throwable actualCause = ex.getCause()\n}\n</code></pre> <p><code>TracelessException</code> may be either <code>AssertError</code> for static resource fail or <code>TemplateRestCodeError</code> for direct non 200 response code in rest.</p> <p>Important</p> <p>GSP errors handling override ExceptionMapper and views errors mechanisms because it intercept exceptions before them (using <code>RequestEventListener</code>)! So your  <code>ExceptionMapper</code> will be called, but user will still see GSP error page. </p> <p>The motivation is simple: otherwise it would be very hard to write side effect free GSP applications because template resources exceptions could be intercepted with <code>ExceptionMapper</code>'s declared in dropwizard application.  </p> <p>To overcome this limitation, you can disable errors handling with <code>@ManuaErrorHandling</code>. It may be applied on resource method or to resource class (to disable on all methods).</p> <p>For example:</p> <pre><code>@Path(\"/com.project.ui/error/\")\n@Template(\"page.ftl\")\npublic class ErrorPage {\n\n    @ManualErrorHandling\n    @Path(\"/\")\n    public TemplateView render() {\n        // if exception appear inside this method, it would be handled with ExceptionMapper\n        // GSP error page will not be used\n\n        // Also, if method return non 200 error code (&gt;=400) like \n        // return Response.status(500).build()\n        // it would be also not handled with GSP error mechanism (only pure dropwizard staff) \n    }        \n}\n</code></pre> <p>Note that disabled errors will be indicated as <code>[DISABLED ERRORS]</code> in console report. </p>"},{"location":"extras/gsp/#spa-routing","title":"SPA routing","text":"<p>If you use Single Page Applications then you may face the need to recognize html5 client routing urls and redirect to index page. You can read more about it in guicey SPA module.</p> <p>As guicey SPA module can't be used directly with GSP, it's abilities is integrated directly and could  be activated with:</p> <pre><code>.bundles(ServerPagesBundle.app(\"projectName-ui\", \"com.app.ui\", \"/\")\n                    .spaRouting()\n                    .build())\n</code></pre> <p>Or, if custom detection regex is required: <code>.spaRouting(customRegex)</code></p> <p>Most likely, usage use-case would be: index page requires some server-size templating.</p>"},{"location":"extras/gsp/#template-requests-detection","title":"Template requests detection","text":"<p>GSP must differentiate static resource calls from template calls. It assumes that static resources would always end with an extension (e.g. <code>/something/some.ext</code>) and so:</p> <ol> <li>If request without extension - it's a template</li> <li>If extension is recognized as template extension - render as template</li> <li>Other cases are static resources</li> </ol> <p>The following regular expression used for extension detection: <pre><code>(?:^|/)([^/]+\\.(?:[a-zA-Z\\d]+))(?:\\?.+)?$\n</code></pre></p> <p>If it does not cover you specific cases, it could be changed using:</p> <pre><code>.bundles(ServerPagesBundle.app(\"com.project.ui\", \"/com/app/ui/\", \"/\")\n                    .filePattern(\"(?:^|/)([^/]+\\\\.(?:[a-zA-Z\\\\d]+))(?:\\\\?.+)?$\")\n                    .build())\n</code></pre> <p>In case when you have static files without extension, you can include them directly  into detection regexp (using regex or (|) syntax).</p> <p>Pattern must return detected file name as first matched group (so direct template could be detected). Pattern is searched (find) inside path, not matched (so simple patterns will also work).</p>"},{"location":"extras/gsp/#extending-applications","title":"Extending applications","text":"<p>In \"war world\" there is a a very handy thing as overlays: when we can apply our resources \"above\" existing war. This way we can replace existing files (hack &amp; tune) and add our own files so they would live inside app as they were always be there.</p> <p>In order to achieve similar goals there is a application extension mechanism. </p> <p>For example we application:</p> <pre><code>.bundles(ServerPagesBundle.app(\"projectName-ui\", \"com.app.ui\", \"/\")\n                    .build())\n</code></pre> <p>With multiple pages inside:</p> <pre><code>/com/app/ui/\n    page1.ftl\n    page2.ftl\n    style.css\n</code></pre> <p>Each page could include style relatively as <code>style.css</code>. Most likely, there will even be master template (freemarker) which unifies styles and common script installation.</p> <p>This application is distributed as 3<sup>rd</sup> party bundle (jar). If we need to add one more page  to this application in our current dropwizard application, we can:</p> <pre><code>.bundles(ServerPagesBundle.extendApp(\"projectName-ui\")\n        .attachAssets(\"com.otherApp.ui.ext\")\n        .build())\n</code></pre> <p>And put another page into classpath:</p> <pre><code>/com/otherApp/ui/ext/\n    page3.ftl    \n</code></pre> <p>This page could also reference <code>style.css</code> relatively, the same as pages in the main application.</p> <p>On application startup, you will notice new resources location:</p> <pre><code>    Static resources locations:\n        /com/app/ui/\n        /com/otherApp/ui/ext/\n</code></pre> <p>Now both locations are \"roots\" for the application. The same way as if we copied <code>/com/otherApp/ui/ext/</code> into <code>/com/app/ui/</code>.</p> <p><code>http://localhost:8080/page3.ftl</code> would correctly render new page.</p> <p>There may be unlimited number of application extensions. If extended application is not available, it is not considered as an error: it's assumed as optional application extension, which will be activated if some 3<sup>rd</sup> party jar with GSP application appear in classpath.</p> <p>You can also map addition rest prefixes:</p> <pre><code>.bundles(ServerPagesBundle.extendApp(\"projectName-ui\")\n        .mapViews(\"/sub/folder/\", \"/views/something/ext/\")\n        .build())\n</code></pre> <p>In some cases, extensions may depend on dropwizard configuration, but bundles created under initialization phase. To work around this you can  use delayed extension init:</p> <pre><code>.bundles(ServerPagesBundle.extendApp(\"projectName-ui\")\n        .delayedConfiguration((env, assets, views) -&gt; {\n            if (env.configuration().isExtensionsEnabled()) {\n                assets.attach(\"com.foo.bar\")\n            }           \n         })\n        .build())\n</code></pre>"},{"location":"extras/gsp/#webjars-usage","title":"Webjars usage","text":"<p>If you want to use resources from webjars in GSP application:</p> <pre><code>.bundles(ServerPagesBundle.app(\"com.project.ui\", \"/com/app/ui/\", \"/\")\n                    .attachWebjars()\n                    .build())\n</code></pre> <p>For example, to add jquery:</p> <pre><code>implementation 'org.webjars.npm:jquery:3.4.1'\n</code></pre> <p>And it could be referenced as:</p> <pre><code>&lt;script src=\"jquery/3.4.1/dist/jquery.min.js\"/&gt;\n</code></pre> <p>Under the hood <code>.attachWebjars()</code> use extensions mechanism and adds  <code>META-INF/resources/webjars/</code> as application resources path:</p> <pre><code>ServerPagesBundle.app(\"com.project.ui\", \"/com/app/ui/\", \"/\")\n    ...\n    .attachAssets(\"META-INF/resources/webjars/\")\n</code></pre> <p>OR</p> <pre><code>.bundles(ServerPagesBundle.extendApp(\"app name\")\n    .attachAssets(\"META-INF/resources/webjars/\")\n    .build())\n</code></pre> <p>Tip</p> <p>You can always see the content of webjar on webjars site by clicking on package \"Files\" column. Use everything after \"META-INF/resources/webjars/\" to reference file.</p>"},{"location":"extras/gsp/#custom-classloaders","title":"Custom classloaders","text":"<p>Very specific case</p> <p>There is a limited support for custom classloaders. Assumed case is when application resources could be loaded with different class loaders.</p> <p>Custom classloader could be specified during application registration, for example:</p> <pre><code>.bundles(ServerPagesBundle.app(\"com.project.ui\", \"/com/app/ui/\", \"/\", classLoader)                    \n                    .build())\n</code></pre> <p>The same for admin app and extension.</p> <p>Warning</p> <p>This will affect only static resources! Template engine will not be able to resolve resources because it is not aware of custom loaders.</p> <p>Info</p> <p>The main problem here is dropwizard's <code>View</code> class which accepts only file path (String), so even if correct URL object is known (which is enough to load resource) before view construction it can't be used further.  </p> <p>To workaround this, resolved absolute template path passed to view constructor. GSP module is able to found correct resourse later in correct class loader, but it requires obvious changes to template engine templates resolution mechanism.    </p> <p>To resolve this, special templates resolver is required. For freemarker it is provided out of the box,  but must be enabled on main bundle:</p> <pre><code>ServerPagesBundle.builder()\n    .enableFreemarkerCustomClassLoadersSupport()\n    ...\n</code></pre> <p>For mustache module it is impossible to write such integration.</p>"},{"location":"extras/jdbi3/","title":"JDBI3 integration","text":"<p>Integrates JDBI3 with guice. Based on dropwizard-jdbi3 integration.</p> <p>Features:</p> <ul> <li>JDBI instance available for injection</li> <li>Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional)</li> <li>Repositories (JDBI proxies for interfaces):<ul> <li>installed automatically (when classpath scan enabled)</li> <li>are normal guice beans, supporting aop and participating in global (thread bound) transaction.</li> <li>no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction.</li> <li>can reference guice beans (with annotated getters)</li> </ul> </li> <li>Automatic installation for custom <code>RowMapper</code> </li> </ul> <p>Added installers:</p> <ul> <li>RepositoryInstaller - sql proxies</li> <li>MapperInstaller - row mappers  </li> </ul>"},{"location":"extras/jdbi3/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-jdbi3&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-jdbi3:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/jdbi3/#usage","title":"Usage","text":"<p>Register bundle:</p> <pre><code>GuiceBundle.builder()        \n        .bundles(JdbiBundle.&lt;ConfType&gt;forDatabase((conf, env) -&gt; conf.getDatabase()))\n        ...\n</code></pre> <p>Here default JDBI instance will be created from database configuration (much like it's described in  dropwizard documentation).</p> <p>Or build JDBI instance yourself:</p> <pre><code>JdbiBundle.forDbi((conf, env) -&gt; locateDbi())\n</code></pre> <p>Jdbi3 introduce plugins concept. Dropwizard will automatically register <code>SqlObjectPlugin</code>, <code>GuavaPlugin</code>, <code>JodaTimePlugin</code>. If you need to install custom plugin:</p> <pre><code>JdbiBundle.forDbi((conf, env) -&gt; locateDbi())\n    .withPlugins(new H2DatabasePlugin())\n</code></pre> <p>Also, If custom registration must be performed on jdbi instance:</p> <pre><code>JdbiBundle.forDbi((conf, env) -&gt; locateDbi())\n    .withConfig((jdbi) -&gt; { jdbi.callSomething() })\n</code></pre> <p>Such configuration block will be called just after jdbi instance creation (but before injector creation).</p>"},{"location":"extras/jdbi3/#unit-of-work","title":"Unit of work","text":"<p>Unit of work concept states for: every database related operation must be performed inside unit of work.</p> <p>In JDBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction.</p> <p>Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by <code>@InTransaction</code> annotation (note that such name was intentional to avoid confusion with JDBI's own Transaction annotation and more common Transactional annotations).</p> <p>At the beginning of unit of work, JDBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work.</p>"},{"location":"extras/jdbi3/#intransaction","title":"@InTransaction","text":"<p>Annotation on method or class declares transactional scope. For example:</p> <pre><code>@Inject MyDAO dao\n\n@InTransaction\npublic Result doSomething() {\n   dao.select();\n   ...\n}\n</code></pre> <p>Transaction opened before doSomething() method and closed after it.  Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back.</p> <p>Nested annotations are allowed (they simply ignored).</p> <p>Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work).  But, for simplicity, you may think of it as the same things, if you always use <code>@InTransaction</code> annotation. </p>"},{"location":"extras/jdbi3/#transaction-configuration","title":"Transaction configuration","text":"<p>Transaction isolation level and readonly flag could be defined with annotation:</p> <pre><code>@InTransaction(TransactionIsolationLevel.READ_UNCOMMITTED)\n\n@InTransaction(readOnly = true)\n</code></pre> <p>In case of nested transactions error will be thrown if:</p> <ul> <li>Current transaction level is different than the nested one</li> <li>Current transaction is read only and nested transaction is not  (note that some drivers, like h2, ignore readOnly flag completely)</li> </ul> <p>For example:</p> <pre><code>@InTransaction\npublic void action() {\n    nestedAction();\n}\n\n@InTransaction(TransactionIsolationLevel.READ_UNCOMMITTED)\npublic void nestedAction() {\n...    \n}\n</code></pre> <p>When <code>action()</code> method called new transaction is created with default level (usually READ_COMMITTED). When <code>nestedAction()</code> is called exception will be thrown because it's transaction level requirement (READ_UNCOMMITTED) contradict with current transaction.</p>"},{"location":"extras/jdbi3/#custom-transactional-annotation","title":"Custom transactional annotation","text":"<p>If required, you may use your own annotation for transaction definition:</p> <pre><code>JdbiBundle.forDatabase((conf, env) -&gt; conf.getDatabase())\n    .withTxAnnotations(MyCustomTransactional.class);\n</code></pre> <p>Note that this will override default annotation support. If you want to support multiple annotations then specify all of them:</p> <pre><code>JdbiBundle.forDatabase((conf, env) -&gt; conf.getDatabase())\n    .withTxAnnotations(InTransaction.class, MyCustomTransactional.class);\n</code></pre> <p>If you need to support transaction configuration (level and read only settings) with your annotation then:</p> <ol> <li>Add required properties into annotation itself (see <code>@InTransaction</code> as example).</li> <li>Create implementation of <code>TxConfigFactory</code> (see <code>InTransactionTxConfigFactory</code> as example)</li> <li>Register factory inside your annotation with <code>@TxConfigSupport(MyCustomAnnotationTxConfigFactory.class)</code> </li> </ol> <p>Your factory will be instantiated as guice bean so annotate it as Singleton, if possible to avoid redundant instances creation.</p> <p>Configuration is resolved just once for each method, so yur factory will be called just once  for each annotated (with your custom annotation) method. </p>"},{"location":"extras/jdbi3/#context-handle","title":"Context Handle","text":"<p>Inside unit of work you may reference current handle by using:</p> <pre><code>@Inject Provider&lt;Handle&gt;\n</code></pre>"},{"location":"extras/jdbi3/#manual-transaction-definition","title":"Manual transaction definition","text":"<p>You may define transaction (with unit of work) without annotation using:</p> <pre><code>@Inject TransactionTempate template;\n...\ntemplate.inTrasansaction((handle) -&gt; doSomething())\n</code></pre> <p>Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as  with annotation.</p> <p>You can also specify transaction config (if required):</p> <pre><code>@Inject TransactionTempate template;\n...\ntemplate.inTrasansaction(\n        new TxConfig().level(TransactionIsolationLevel.READ_UNCOMMITTED), \n        (handle) -&gt; doSomething())\n</code></pre>"},{"location":"extras/jdbi3/#repository","title":"Repository","text":"<p>Declare repository (interface or abstract class) as usual, using DBI annotations.  It only must be annotated with <code>@JdbiRepository</code> so installer could recognize it and register in guice context.</p> <p>Note</p> <p>singleton scope will be forced for repositories.</p> <pre><code>@JdbiRepository\n@InTransaction\npublic interface MyRepository {     \n\n    @SqlQuery(\"select name from something where id = :id\")\n    String findNameById(@Bind(\"id\") int id);\n}\n</code></pre> <p>Note the use of <code>@InTransaction</code>: it was used to be able to call repository methods without extra annotations (the lowest transaction scope its repository itself). It will make beans \"feel the same\" as usual JDBI on demand sql object proxies.</p> <p><code>@InTransaction</code> annotation is handled using guice aop. You can use any other guice aop related features.</p> <p>Warning</p> <p>Don't use JDBI <code>@Transaction</code> and <code>@CreateSqlObject</code> annotations anymore: probably they will even work, but they are not needed now and may confuse.</p> <p>All installed repositories are reported into console:</p> <pre><code>INFO  [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi3.installer.repository.RepositoryInstaller: repositories = \n\n    (ru.vyarus.guicey.jdbi3.support.repository.SampleRepository)\n</code></pre>"},{"location":"extras/jdbi3/#manual-bindings","title":"Manual bindings","text":"<p>Repository can't be recognized from guice binding because repository type is abstract and guice would complain about it. But repository can be recognized from the chain.</p> <p>For example, suppose there is a base interface <code>Storage</code> and JDBI implementation is only one possible implementation: <code>JdbiStorage extends Storage</code>. In this case you can bind: <code>bind(Storage.class).to(JdbiStorage.class)</code> and use everywhere in code <code>@Inject Storage storage;</code> (installer would bind interface to implementation and guice would be able to correctly track binding to the generated instance).</p> <p>Only in this case repository class could be recognized from guice binding (even if it's not declared as extension and classpath scan not used).</p> <p>In all other cases, repository declaration would cause an error (to identify incorrect declaration).</p>"},{"location":"extras/jdbi3/#laziness","title":"Laziness","text":"<p>By default, JDBI proxies for declared repositories created only on first repository method call. Lazy behaviour is important to take into account all registered JDBI extensions. Laziness also slightly speeds up application startup. </p> <p>If required, you can enable eager initialization during bundle construction:   </p> <pre><code>JdbiBundle.forDatabase((conf, env) -&gt; conf.getDatabase())\n    .withEagerInitialization()\n</code></pre> <p>In the eager mode all proxies would be constructed after application initialization (before web part initialization).</p>"},{"location":"extras/jdbi3/#guice-beans-access","title":"Guice beans access","text":"<p>You can access guice beans by annotating getter with <code>@Inject</code> (jakarta or guice):</p> <pre><code>@JdbiRepository\n@InTransaction\npublic interface MyRepository {     \n\n    @Inject\n    MyOtherRepository getOtherRepo();\n\n    @SqlQuery(\"select name from something where id = :id\")\n    String findNameById(@Bind(\"id\") int id);\n\n    default String doSomething(int id) {\n        String name = findNameById(id);\n        return getOtherRepo().doSOmethingWithName(name);\n    }\n}\n</code></pre> <p>Here call to <code>getOtherRepo()</code> will return <code>MyOtherRepository</code> guice bean, which is actually another proxy.  </p>"},{"location":"extras/jdbi3/#row-mapper","title":"Row mapper","text":"<p>If you have custom implementations of <code>RowMapper</code>, it may be registered automatically.  You will be able to use injections there because mappers become usual guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically.</p> <pre><code>public class CustomMapper implements RowMapper&lt;Custom&gt; {\n    @Override\n    Custom map(ResultSet rs, StatementContext ctx) throws SQLException {\n        // mapping here\n        return custom;\n    }\n}\n</code></pre> <p>And now Custom type could be used for queries:</p> <pre><code>@JdbiRepository\n@InTransaction\npublic interface CustomRepository {     \n\n    @SqlQuery(\"select * from custom where id = :id\")\n    Custom findNameById(@Bind(\"id\") int id);\n}\n</code></pre> <p>All installed mappers are reported to console:</p> <pre><code>INFO  [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi3.installer.MapperInstaller: jdbi mappers = \n\n    Sample               (ru.vyarus.guicey.jdbi3.support.mapper.SampleMapper)\n</code></pre>"},{"location":"extras/jdbi3/#manual-unit-of-work-definition","title":"Manual unit of work definition","text":"<p>If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use  assigned handle directly:</p> <pre><code>@Inject UnitManager manager;\n\nmanager.beginUnit();\ntry {\n    Handle handle = manager.get();\n    // logic executed in unit of work but without transaction\n} finally {\n    manager.endUnit();\n}\n</code></pre> <p>Repositories could also be called inside such manual unit (as unit of work is correctly started).        </p>"},{"location":"extras/lifecycle-annotations/","title":"Lifecycle annotations","text":"<p>Allows using lifecycle annotations for initialization/destruction methods in guice beans. Main motivation is to replace <code>Managed</code> usage in places where it's simpler to just annotate method, rather than register extension.</p> <ul> <li><code>@PostCostruct</code> - same as <code>Managed.start()</code></li> <li><code>@PostStartup</code> - called after server startup (application completely started)</li> <li><code>@PreDestroy</code> - same as <code>Managed.stop()</code></li> </ul>"},{"location":"extras/lifecycle-annotations/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-lifecycle-annotations&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus.guicey:lifecycle-annotations:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/lifecycle-annotations/#usage","title":"Usage","text":"<p>By default, no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work.</p> <pre><code>import jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport ru.vyarus.guicey.annotations.lifecycle.PostStartup;\n\npublic class SampleBean {    \n\n    @PostConstruct\n    private void start() {\n        // same time as Managed.start()\n    }\n\n    @PostStartup\n    private void afterStartup() {\n        // application completely started\n    }\n\n    @PreDestroy\n    private void stop() {\n        // same time as Managed.stop()\n    }\n}\n</code></pre> <ul> <li>Annotated methods must not contain parameters. Method could have any visibility.</li> <li><code>@PostConstruct</code> or <code>@PostStartup</code> methods fail fails entire application startup (fail fast)</li> <li><code>@PreDestroy</code> method fails are just logged to guarantee that all destroy methods will be processed</li> <li>If both current class and super class have annotated methods - both methods will be executed (the only obvious exception is overridden methods)</li> </ul> <p>Important</p> <p>If bean is created on demand (lazy creation by guice JIT), annotated methods will still be called, even if actual lifecycle event was already passed. Warning log message will be printed to indicate this \"not quite correct\" execution, but you can be sure that your methods will always be processed.</p>"},{"location":"extras/lifecycle-annotations/#reducing-scope","title":"Reducing scope","text":"<p>Annotations are applied using guice TypeListener api which means that all guice beans are introspected for annotated methods.</p> <p>If you want to limit the scope of processed beans then register bundle manually  (in this case lookup will be ignored):</p> <pre><code>GuiceBundle.builder()\n           .bundles(new LifecycleAnnotationsBundle(\"package.to.apply\"))\n           .build()\n</code></pre> <p>In this example only beans lying in specified package will be checked. </p> <p>Also, direct <code>Matcher</code> implementation could be specified for more sophisticated cases. For example, if I want to exclude only one class:</p> <pre><code>new LifecycleAnnotationsBundle(new AbstractMatcher&lt;TypeLiteral&lt;?&gt;&gt;() {                               \n           @Override\n           public boolean matches(TypeLiteral&lt;?&gt; o) {\n               return o.getRawType() != SomeExcludedBean.class;\n           }\n       })\n</code></pre>"},{"location":"extras/spa/","title":"Single page applications support","text":"<p>Provides a replacement for dropwizard-assets  bundle for single page applications (SPA) to properly handle html5 client routing.</p> <p>Features:</p> <ul> <li>Pure dropwizard bundle, but can be used with guicey bundles </li> <li>Build above dropwizard-assets servlet</li> <li>Support registration on main and admin contexts</li> <li>Multiple apps could be registered</li> <li>Sets no-cache headers for index page</li> <li>Regex could be used to tune routes detection</li> </ul>"},{"location":"extras/spa/#problem","title":"Problem","text":"<p>The problem with SPA is html5 routing. For example, suppose your app base url is <code>/app</code> and client route url is <code>/app/someroute</code> (before there were no problem because route would look like <code>/app/#!/someroute</code>). When user hit refresh (or bookmark) such route, server is actually called with route url. Server must recognize it and return index page.</p> <p>For example, Angular 2 router use html5 mode my default.</p>"},{"location":"extras/spa/#solution","title":"Solution","text":"<p>The problem consists of two points:</p> <ol> <li>Correctly process resource calls (css, js, images, etc) and return 404 for missed resources</li> <li>Recognize application routes and return index page instead</li> </ol> <p>Bundles register dropwizard-assets servlet with special filter above it. Filter tries to process all incoming urls. This approach grants that all calls to resources will be processed and  index page will not be returned instead of resource (solves problem 1).</p> <p>If resource is not found - index page returned. To avoid redirection in case of bad resources request, filter will redirect only requests accepting 'text/html'. Additional regexp (configurable)  is used to recognize most resource calls and avoid redirection (show correct 404).</p> <p>From example above, <code>/app/someroute</code> will return index page and <code>/app/css/some.css</code> will return css. <code>/app/css/unknown.css</code> will return 404 as resource call will be recognized and css file is not exists.</p>"},{"location":"extras/spa/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-spa&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-spa:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/spa/#usage","title":"Usage","text":"<p>Register bundle:</p> <pre><code>GuiceBundle.builder()\n    .bundles(SpaBundle.app(\"app\", \"/app\", \"/\").build());\n</code></pre> <p>This will register app with name \"app\" (name is used to name servlets and filters and must be unique). Application files are located in \"app\" package in classpath (e.g. resources inside jar). Application is mapped to root context (note that this will work only if rest is mapped  to some sub context: e.g. with <code>server.rootPath: '/rest/*'</code> configuration).</p> <pre><code>http://localhost:8080/ -&gt; app index\nhttp://loclahost:8080/css/app.css -&gt; application resource, located at /app/css/app.css in classpath\nhttp://localhost:8080/someroute -&gt; application client route - index page returned\n</code></pre> <p>Example registration to admin context:</p> <pre><code>.bundles(SpaBundle.adminApp(\"admin\", \"/com/mycompany/adminapp/\", \"/manager\").build());\n</code></pre> <p>Register \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager\"  admin context (note that admin root is already used by dropwizard admin servlet).</p> <p>Tip</p> <p>Resources location can be declared both as path (<code>/com/mycompany/adminapp/</code>) or as package (<code>com.mycompany.adminapp</code>).</p> <pre><code>http://localhost:8081/manager -&gt; admin app index\n</code></pre> <p>You can register as many apps as you like. They just must use different urls and have different names:</p> <pre><code>.bundles(SpaBundle.app(\"app\", \"/app\", \"/\").build(),\n         SpaBundle.app(\"app2\", \"/app2\", \"/\").build(),\n         SpaBundle.adminApp(\"admin\", \"/com/mycompany/adminapp/\", \"/manager\").build(),\n         SpaBundle.adminApp(\"admin2\", \"/com/mycompany/adminapp2/\", \"/manager2\").build());\n</code></pre> <p>Note</p> <p>If you publish SPA application not in the root path, don't forget to set appropriate <code>&lt;base href=\"/path/\"/&gt;</code> tag. All modern client side routers rely on it. Pay attention that path in base tag must end with <code>/</code>.</p>"},{"location":"extras/spa/#index-page","title":"Index page","text":"<p>By default, index page assumed to be \"index.html\". Could be changed with:</p> <pre><code>.bundles(SpaBundle.app(\"app\", \"/app\", \"/\").indexPage(\"main.html\").build());\n</code></pre>"},{"location":"extras/spa/#prevent-redirect-regex","title":"Prevent redirect regex","text":"<p>By default, the following regex is used to prevent resources redirection (to not send index for missed resource):</p> <pre><code>\\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$\n</code></pre> <p>Could be changed with:</p> <pre><code>.bundles(SpaBundle.app(\"app\", \"/app\", \"/\")\n        .preventRedirectRegex(\"\\\\.\\\\w{2,5}(\\\\?.*)?$\")\n        .build());\n</code></pre> <p>This regexp implements naive assumption that all app routes does not contain \"extension\".</p> <p>Note: regexp is applied with <code>find</code> so use <code>^</code> or <code>$</code> to apply boundaries. </p>"},{"location":"extras/validation/","title":"Validation","text":"<p>By default, dropwizard allows you to use validation annotations on rest services. This module allows you to use validation annotations the same way on any guice bean method.</p> <p>Bundle is actually a wrapper for guice-validator project.</p>"},{"location":"extras/validation/#setup","title":"Setup","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ru.vyarus.guicey&lt;/groupId&gt;\n  &lt;artifactId&gt;guicey-validation&lt;/artifactId&gt;\n  &lt;version&gt;7.2.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus.guicey:guicey-validation:7.2.1'\n</code></pre> <p>Omit version if guicey BOM used</p>"},{"location":"extras/validation/#usage","title":"Usage","text":"<p>By default, no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work.</p> <p>For example:</p> <pre><code>import jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport ru.vyarus.guicey.annotations.lifecycle.PostStartup;\n\npublic class SampleBean {    \n\n    private void doSomething(@NotNull String param) {        \n    }\n\n}\n</code></pre> <p>Call <code>bean.doSomething(null)</code> will fail with <code>ConstraintValidationException</code>.</p> <p>For more usage examples see guice-validator documentation </p>"},{"location":"extras/validation/#explicit-mode","title":"Explicit mode","text":"<p>By default, validations work in implicit mode: any method containing validation annotations would trigger validation on call.</p> <p>If you want more explicitly mark methods requiring validation then register bundle manually:</p> <pre><code>.bundles(new ValidationBundle()\n                    .validateAnnotatedOnly())\n</code></pre> <p>Now, only methods annotated with <code>@ValidateOnExecution</code> (or all methods in annotated class) will trigger validation.</p> <p>If you want, you can use your own annotation:</p> <pre><code>.bundles(new ValidationBundle()\n                .validateAnnotatedOnly(MyAnnotation.class))\n</code></pre>"},{"location":"extras/validation/#reducing-scope","title":"Reducing scope","text":"<p>By default, validation is not applied to resource classes (annotated with <code>@Path</code>) because dropwizard already performs validation there. And rest methods, annotated with <code>@GET</code>, <code>@POST</code>, etc.  are skipped (required for complex declaration cases, like dynamic resource mappings or sub resources). </p> <p>You can reduce this scope even further:</p> <pre><code>.bundles(new ValidationBundle()\n                    .targetClasses(Matchers.subclassesOf(SomeService.class)\n                         .and(Matchers.not(Matchers.annotatedWith(Path.class)))))\n</code></pre> <p>Here <code>SomeService</code> is excluded from validation (its methods would not trigger validation).  Note that default condition (not resource) is appended.</p> <p>Or excluding methods:</p> <pre><code>.bundles(new ValidationBundle()\n                    .targetMethods(Matchers.annotatedWith(SuppressValidation.class)\n                         .and(new DirectMethodMatcher())))\n</code></pre> <p>Now methods annotated with <code>@SuppressValidation</code> will not be validated. Note that <code>.and(new DirectMethodMatcher())</code> condition was added to also exclude synthetic and bridge methods (jvm generated methods).</p> <p>Note</p> <p>You can verify AOP appliance with guicey <code>.printGuiceAopMap()</code> report.</p>"},{"location":"extras/validation/#validation-groups","title":"Validation groups","text":"<p>By default, <code>Default</code> validation group is always enabled allowing you to not specify groups for each call. </p> <p>This could be disabled with bundle option:</p> <pre><code>.bundles(new ValidationBundle().strictGroupsDeclaration())\n</code></pre> <p>Read more in guice-validator docs.</p>"},{"location":"guide/bundles/","title":"Guicey bundles","text":"<p>Analogous to Dropwizard Bundles, Guicey has its own <code>GuiceyBundle</code>. These bundles contain many of the same options as the main <code>GuiceBundle</code> builder. The purpose of Guicey Bundles is the same as Dropwizard Bundles:  encapsulate logic by grouping installers, extensions and guice modules related to specific features and libraries.</p> <p>Note</p> <p>Guicey bundles are assumed to be used instead of dropwizard bundles in guicey-powered application.</p> <p>It does not mean that drowpizard bundles can't be used - of course they can! There are many existing dropwizard bundles and it would be insane to get rid of them.</p> <p>It is not possible to register guice modules and use many guicey features from dropwizard bundles.       </p> <p>Guicey and Dropwizard Bundles share the same lifecycle:</p> <pre><code>public interface ConfiguredBundle&lt;T&gt; {\n    default void initialize(Bootstrap&lt;?&gt; bootstrap) {}    \n    default void run(T configuration, Environment environment) throws Exception {}\n}\n\npublic interface GuiceyBundle {\n    default void initialize(GuiceyBootstrap bootstrap) throws Exception {} \n    default void run(GuiceyEnvironment environment) throws Exception {}\n}\n</code></pre> <p>Note</p> <p>Dropwizard bundles <code>initialize</code> method does not throw exceptions: assumed  only runtime exceptions (which are not handled by dropwizard).</p> <p>Initially, guicey bundle init method also did not allow checked exceptions. But, it appears that often it is more useful to allow checked exceptions in init method to avoid clumsy exception handling (especially for quick prototyping) and so checked exceptions support was added. Runtime exceptions are rethrown as is.</p> <p>Guicey Bundles are an extension to dropwizard bundles (without restrictions),  so it is extremely simple to switch from dropwizard bundles.</p> <p>Tip</p> <p>With Guicey Bundles, it is possible to implement plug-and-play bundles to automatically install a bundle when its jar appears on the classpath. </p> <p>Example Guicey bundle:</p> <pre><code>public class MyFeatureBundle implements GuiceyBundle {\n\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap\n            .installers(MyFeatureExtensionInstaller.class)\n            // dropwizard bundle usage\n            .dropwizardBundle(new RequiredDwBundle())\n            .modules(new MyFeatureModule());     \n\n        // dropwizard bootstrap access\n        bootstrap.bootstrap().addCommand(new MyFeatureCommand());\n    }   \n\n    @Override    \n    public void run(GuiceyEnvironment environment) throws Exception {\n        // configuration access\n        environment\n            .modules(new SpecialModle(environment.configuration().getSomeValue()))\n            .onApplicationStartup(() -&gt; logger.info(\"Application started!\"));\n\n        // dropwizard environment access        \n        environment.environment().setValidator(new MyCustomValudatior());\n    }\n}\n\nbootstrap.addBundle(GuiceBundle.builder()                        \n        .bundles(new MyFeatureBundle())\n        .build()\n);\n</code></pre> <p>Example bundles can be found in Guicey itself:</p> <ul> <li><code>CoreInstallersBundle</code> - all default installers</li> <li><code>WebInstallersBundle</code> - servlet and filter annotations support</li> <li><code>HK2DebugBundle</code> - guice - HK2 scope debug tool</li> </ul> <p>Even more examples are in extensions modules</p>"},{"location":"guide/bundles/#configuration","title":"Configuration","text":"<p>See all bundle configuration options</p> <p>Note</p> <p>Most configurations appear during the initialization phase.</p> <p>On run phase it is possible to register guice modules, often requiring direct configuration values. Also, some extension registration may depend on configuration value.</p>"},{"location":"guide/bundles/#bundle-de-duplication","title":"Bundle De-duplication","text":"<p>Your bundles may be installed multiple times, and you must always think of what should be expected behaviour in these cases.</p> <p>For example:</p> <pre><code>.bundles(new MyBundle(), new MyBundle())\n</code></pre> <p>Bundles are often intended to be used multiple times (for example, spa bundle).</p> <p>But in some cases, only one bundle instance must be installed. For example, eventbus bundle must be installed just once. The opposite may be true: a common bundle could be installed by multiple other bundles.</p> <p>In order to manage these cases guicey provides a de-duplication mechanism.</p> <p>To avoid redundant bundle instances, you can:</p> <ul> <li>extend <code>UniqueGuiceyBundle</code> to allow only one bundle instance</li> <li>implement <code>equals</code> method (where you can implement any deduplication rules (e.g. based on bundles constructor arguments))</li> </ul> <p>Note</p> <p>Deduplication could also help in case when your bundle is available through lookup with default configuration, but could be registered with customized configuration.</p> <p>In this case, you can also use <code>UniqueGuiceyBundle</code>: manually registered bundle will  always be registered first, and bundle obtained with lookup mechansm would be considered  as duplicate and not used (for example, eventbus bundle use this)</p>"},{"location":"guide/bundles/#bundle-lookup","title":"Bundle Lookup","text":"<p>The bundle lookup mechanism is used to lookup guicey bundles in various sources. It may be used to activate specific bundles in tests (e.g. HK2 scope control bundle) or to install 3<sup>rd</sup> party extensions from classpath.</p> <p>Bundle lookup is equivalent to registering bundle directly using builder <code>bundles</code> method.</p> <p>Note</p> <p>Bundles from lookup will always be registered after all manually registered bundles, so you can use de-duplication to accept manual instance and deny lookup. </p> <p>By default, two lookup mechanisms active: by property and  with service loader. </p> <p>All found bundles are logged into console:</p> <pre><code>INFO  [2019-10-17 14:50:14,304] ru.vyarus.dropwizard.guice.bundle.DefaultBundleLookup: guicey bundles lookup =\n\n    ru.vyarus.dropwizard.guice.diagnostic.support.bundle.LookupBundle\n</code></pre> <p>You can disable default look-ups with:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n        .disableBundleLookup()\n        .build()\n</code></pre>"},{"location":"guide/bundles/#system-property-lookup","title":"System property lookup","text":"<p>System property <code>guicey.bundles</code> could contain comma separated list of guicey bundle classes. These bundles  must have no-args constructor.</p> <p>For example, activate HK2 debug bundle for tests:</p> <pre><code>java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle\n</code></pre> <p>Alternatively, system property may be set in code:</p> <pre><code>PropertyBundleLookup.enableBundles(HK2DebugBundle.class)\n</code></pre>"},{"location":"guide/bundles/#service-loader-lookup","title":"Service loader lookup","text":"<p>Using default java ServiceLoader  mechanism, loads all <code>GuiceyBundle</code> services.</p> <p>This is useful for automatically installing 3<sup>rd</sup> party extensions (additional installers, extensions, guice modules).</p> <p>Note</p> <p>This could be used to install bundles with default configuration and proper de-duplication. If a user register custom bundle version, it will be used and bundle from lookup will be ignored.</p> <p>For example, eventbus bundle works like this</p> <p>3<sup>rd</sup> party jar must contain services file:</p> <pre><code>META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle\n</code></pre> <p>The file must contain one GuiceyBundle implementation per line. </p> <p>For example: <pre><code>com.foo.Bundle1\ncom.foo.Bundle2\n</code></pre></p> <p>Then Bundle1, Bundle2 would be loaded automatically on startup and appear in logs.</p>"},{"location":"guide/bundles/#customizing-lookup-mechanism","title":"Customizing lookup mechanism","text":"<p>Custom bundle lookup must implement <code>GuiceyBundleLookup</code> interface:</p> <pre><code>public class CustomBundleLookup implements GuiceyBundleLookup {\n\n    @Override\n    public List&lt;GuiceyBundle&gt; lookup() {\n        List&lt;GuiceyBundle&gt; bundles = Lists.newArrayList();\n        ...\n        return bundles;\n    }\n}\n</code></pre> <p>Custom lookup implementation may be registered through:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n        .bundleLookup(new CustomBundleLookup())\n        .build()\n</code></pre> <p>But it's better to register it through default implementation <code>DefaultBundleLookup</code>, which performs composition  of multiple lookup implementations and logs resolved bundles to console.</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n        .bundleLookup(new DefaultBundleLookup().addLookup(new CustomBundleLookup()))\n        .build()\n</code></pre> <p>To override the list of default look-ups:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n        .bundleLookup(new DefaultBundleLookup(new ServiceLoaderBundleLookup(), new CustomBundleLookup()))\n        .build()\n</code></pre> <p>Here, only two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).</p>"},{"location":"guide/bundles/#dropwizard-bundles","title":"Dropwizard bundles","text":"<p>Dropwizard bundles can be used as before, registered directly in <code>Bootstrap</code>.</p> <p>Guicey provides direct api for dropwizard bundles registration:</p> <pre><code>GuiceBundle.builder()\n    .dropwizardBundles(new MyDwBundle())\n</code></pre> <p>and in bundles:</p> <pre><code>public class MyBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.dropwizardBundle(new MyDwBundle());\n    }\n}\n</code></pre> <p>Note</p> <p>The most common case is extending some existing 3<sup>rd</sup> party integration (Dropwizard Bundle) with guice bindings (or adding guicey installers for simplified usage). </p> <pre><code>public class XIntegratuionBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap\n            .dropwizardBundle(new DropwizardXBundle());\n            .modules(new XBindingsModule())\n    }\n}\n</code></pre> <p>JDBI bundle could be king of such example: it does not use dropwizard bundle, but it defines additional extension types to simplify configuration. </p> <p>When you register dropwizard bundles through guicey api:</p> <ul> <li>Bundle (and all transitive bundles) appear in report</li> <li>Bundle itself or any transitive bundle could be disabled</li> <li>De-duplication mechanism will work for a bundle, and its transitive bundles</li> </ul> <p>So, if you have a \"common bundle\" problem (when 2 bundles register some common bundle and so you can use these bundles together) it could be solved just by registering bundle through the guicey api with  proper configuration.</p>"},{"location":"guide/bundles/#transitive-bundles-tracking","title":"Transitive bundles tracking","text":"<p>Transitive dropwizard bundles are tracked with a <code>Bootstrap</code> object proxy so guicey could intercept the <code>addBundle</code> call.</p> <p>If you have problems with the proxy, you can switch off transitive bundles tracking:</p> <pre><code>.option(GuiceyOptions.TrackDropwizardBundles, false)\n</code></pre> <p>If you don't want to switch off tracking, but still have problems registering some bundle, you can always register it directly in  bootstrap object:</p> <pre><code>public class MyBundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.bootstrap().addBundle(new MyDwBundle());\n    }\n}\n</code></pre> <p><code>bootstrap.bootstrap()</code> - is a raw bootstrap (not a proxy).</p>"},{"location":"guide/commands/","title":"Dropwizard commands support","text":""},{"location":"guide/commands/#guice-injections","title":"Guice injections","text":"<p>Guicey calls <code>injector.injectMembers(command)</code> for all registered <code>EnvironmentCommand</code>s, so you can inject guice beans directly:</p> <pre><code>public class MyCommand extends EnvironmentCommand&lt;MyConfiguration&gt; {\n\n    @Inject\n    private MyService myservice;\n\n    public MyCommand(Application application) {\n        super(application, \"mycli\", \"my super useful cli\");\n    }\n\n    @Override\n        protected void run(Environment environment, \n                             Namespace namespace, \n                             MyConfiguration configuration) throws Exception { \n            myservice.doSomething();        \n        }\n}\n</code></pre> <p>Note</p> <p>It doesn't matter if command was registered manually, by some bundle or with commands search (see below).</p> <p>Warning</p> <p>You can use guice injections only in <code>EnvironmentCommand</code>s because only these commands start bundles (and so launch guice context creation).</p>"},{"location":"guide/commands/#automatic-installation","title":"Automatic installation","text":"<p>Automatic scan for commands is disabled by default. It could be enabled by: </p> <pre><code>GuiceBundle.builder()\n    .enableAutoConfig(\"package.to.scan\")\n    .searchCommands()\n</code></pre> <p>When enabled, all classes extending <code>Command</code> are instantiated using default constructor and registered in dropwizard bootstrap object. </p>"},{"location":"guide/commands/#simple-commands","title":"Simple commands","text":"<p>For example, if command below would be inside scanned package, then guicey will automatically register it.</p> <pre><code>public class MyCommand extends Command {\n\n    public MyCommand() {\n        super(\"hello\", \"Prints a greeting\");\n    }\n\n    @Override\n    public void run(Bootstrap&lt;?&gt; bootstrap, Namespace namespace) throws Exception {\n        System.out.println(\"Hello world\");\n    }\n}\n</code></pre>"},{"location":"guide/commands/#environment-commands","title":"Environment commands","text":"<p>Important</p> <p><code>EnvironmentCommand</code> must have constructor with <code>Application</code> argument.</p> <pre><code>public class SyncCommand extends EnvironmentCommand&lt;AppConfiguration&gt; {\n\n    @Inject\n    private RemoteSynchronizer synchronizer;\n    @Inject\n    private DbManager manager;\n\n    public SyncCommand(Application&lt;AppConfiguration&gt; application) {\n        super(application, \"sync\", \"Perform remote synchronization\");\n    }\n\n    @Override\n    protected void run(Environment environment, \n                        Namespace namespace, \n                        AppConfiguration configuration) throws Exception {\n        manager.start();\n        try {\n            synchronizer.synchronize();\n        } finally {\n            manager.stop();\n        }\n    }\n}\n</code></pre> <p>This example shows workaround for managed initialization in commands: <code>DbManager</code> is some <code>Managed</code> bean which would run automatically  in server mode. But commands never call managed objects, so we have to manually start and stop them.</p>"},{"location":"guide/configuration/","title":"Configuration","text":"<p>Guicey main dropwizard bundle must be registered:</p> <pre><code>@Override\npublic void initialize(Bootstrap&lt;Configuration&gt; bootstrap) {\n    bootstrap.addBundle(GuiceBundle.builder() \n            // &lt;configuration methods&gt;           \n            .build());\n}\n</code></pre> <p>Guicey could be configured through:</p> <ul> <li>Main (dropwizard) bundle</li> <li>Bundles</li> <li>Hooks</li> </ul>"},{"location":"guide/configuration/#main-bundle","title":"Main bundle","text":"<p>Tip</p> <p>Bundle builder contains shortcuts for all guicey features, so required function may be found only by looking at available methods (and reading javadoc).       </p>"},{"location":"guide/configuration/#configuration-items","title":"Configuration items","text":"<code>.enableAutoConfig(String... basePackages)</code> Enable classpath scan for automatic extension registration, custom installers search and commands search (if enabled)  <code>.enableAutoConfig()</code> (without packages) Enabling classpath scan on application package <code>.autoConfigFilter(Predicate)</code> Filter classes to scan <code>.modules(Module... modules)</code> <p>Guice modules registration</p> <p>Here guice modules are created in initialization phase, when <code>Configuration</code> and <code>Environment</code> are not yet available. If they are required for module either use \"Aware\" interfaces  or register module in GuiceyBundle's run method (under run phase).    </p> <code>.modulesOverride(Module... modules)</code> <p>Overriding registered guice modules bindings (using guice <code>Modules.override()</code> api)</p> <p>Extensions are not recognized in overriding modules (intentionally)!</p> <code>.installers(Class&lt;? extends FeatureInstaller&gt;... installers)</code> <p>Guicey extension installers registration. Required if you have custom installers or to specify installers after disabling all default installers: <code>.noDefaultInstallers()</code></p> <p>Custom installers are registered automatically when classpath scan is enabled.  </p> <code>.extensions(Class&lt;?&gt;... extensionClasses)</code> Manual extension registration. May be used together with classpath scan and  binding extensions <code>.extensionsOptional(Class&lt;?&gt;... extensionClasses)</code> Optional extension registration. The difference with <code>.extensions</code> is that such extensions will be automatically disabled if there are no compatible installers (instead of throwing exception).   <code>.bundles(GuiceyBundle... bundles)</code> Guicey bundles registration.  <code>.bundleLookup(GuiceyBundleLookup bundleLookup)</code> Custom lookup mechanism for guicey bundles. By default, lookup  by system property and ServiceLoader  are enabled. To disable all look-ups use: <code>.disableBundleLookup()</code> <code>.dropwizardBundles(ConfiguredBundle... bundles)</code> Shortcut for dropwizard bundles registration. This way guicey could apply  disable and de-duplication rules to registered bundles (and, also, registered bundles appear in reports) <code>.searchCommands()</code> Search and register custom dropwizard commands. Requires enabled classpath scan"},{"location":"guide/configuration/#disable-items","title":"Disable items","text":"<p>Registered configuration items could be disabled. This is mostly useful for tests where entire application parts could be disabled and replaced (e.g. with mocks) this way. Could be also useful to \"hack\" third party items.</p> <code>.disableInstallers(Class&lt;? extends FeatureInstaller&gt;... installers)</code> <code>.disableExtensions(Class&lt;?&gt;... extensions)</code> <code>.disableModules(Class&lt;? extends Module&gt;... modules)</code> Affects transitive guice modules <code>.disableBundles(Class&lt;? extends GuiceyBundle&gt;... bundles)</code> <code>.disableDropwizardBundles(Class&lt;? extends ConfiguredBundle&gt;... bundles)</code> Affects only dropwizard bundles registered through guicey api and  their transitive bundles <code>.disable(Predicate&lt;ItemInfo&gt;... predicates)</code> Custom disable predicate useful to disable groups of items (by some sign)"},{"location":"guide/configuration/#items-de-duplication","title":"Items de-duplication","text":"<p>Guicey detects instances of the same type (bundles, modules). By default, two instances  considered as duplicates if they are equal, so duplicates could be controlled with proper  equals method implementation. When it's not possible, custom de-duplication implementation  could be used.</p> <p>Tip</p> <p>Special base classes are available with correct equals implementations: <code>UniqueModule</code> (for guice modules) and <code>UniqueGuiceyBundle</code> (for bundles).</p> <code>.duplicateConfigDetector(DuplicateConfigDetector detector)</code> Special implementation provided to replicate legacy guicey behaviour  \"one instance per class\": <code>duplicateConfigDetector(new LegacyModeDuplicatesDetector())</code> <code>.uniqueItems(Class&lt;?&gt;... configurationItems)</code> Register special de-duplication implementation which will allow only one instance of provided types."},{"location":"guide/configuration/#options","title":"Options","text":"<p>Guicey generic options mechanism may be used for guicey (or other 3<sup>rd</sup> party bundles) fine-tuning.</p> <p>Guicey option enums: <code>GuiceyOptions</code> and <code>InstallersOptions</code> </p> <code>.option(K option, Object value)</code> Set option value (override default) <code>.options(Map&lt;Enum, Object&gt; options)</code> Set multiple options at once (e.g. map system properties as option values)"},{"location":"guide/configuration/#guiceyoptions","title":"GuiceyOptions","text":"<p>Note</p> <p>Some options are configured through main bundle shortcut methods and so they are not  shown in the table below.           </p> Option Type Default Description BindConfigurationByPath Boolean true Introspect configuration to be able to bind separate values TrackDropwizardBundles Boolean true Recognize transitive dropwizard bundles (for bundles registered through guicey api) AnalyzeGuiceModules Boolean true Extension recognition in guice bindings, transitive modules disable support GuiceFilterRegistration <code>EnumSet&lt;DispatcherType&gt;</code> [REQUEST] Guice filter registration options UseHkBridge Boolean false Activates HK2-guice bridge (bridge dependency must be available on the classpath)"},{"location":"guide/configuration/#installersoptions","title":"InstallersOptions","text":"Option Type Default Description DenyServletRegistrationWithClash Boolean false Throw error if <code>@WebServlet</code> annotated servlets clash with already registered servlets DenySessionListenersWithoutSession Boolean false Throw error for registered <code>SessionListener</code> (annotated <code>@WebListener</code>) if sessions support not enabled (default) ForceSingletonForJerseyExtensions Boolean true Force singleton scope for registered jersey extensions (resources, exception handlers etc) if no explicit scope declared"},{"location":"guide/configuration/#injector","title":"Injector","text":"<code>.injectorFactory(InjectorFactory injectorFactory)</code> Use custom injector factory implementation. May be useful for tests or for integration of 3<sup>rd</sup> party library (like governator) <code>.build(Stage stage)</code> Build bundle with custom guice stage (by default, <code>Production</code>)  <code>.build()</code> Build bundle with default guice stage"},{"location":"guide/configuration/#lifecycle","title":"Lifecycle","text":"<code>.listen(GuiceyLifecycleListener... listeners)</code> Listen for guicey lifecycle events <code>.onGuiceyStartup(GuiceyStartupListener listener)</code> Shortcut for manual configuration under run phase with available injector <code>.onApplicationStartup(ApplicationStartupListener listener)</code> <p>Shortcut for manual actions after complete application start (jetty started)</p> <p>It is also called after guicey initialization in lightweight guicey tests</p> <code>.onApplicationShutdown(ApplicationShutdownListener listener)</code> Shortcut for manual actions after complete application shutdown <code>.listenServer(ServerLifecycleListener listener)</code> Shortcut for <code>environment().lifecycle().addServerLifecycleListener()</code> <code>.listenJetty(LifeCycle.Listener listener)</code> Shortcut for <code>environment().lifecycle().addLifeCycleListener()</code> <code>.listenJersey(new ApplicationEventListener() {...})</code> Shortcut for <code>environment.jersey().register(listener)</code> <code>.noGuiceFilter()</code> Disable GuiceFilter registration.This will remove guice request and session scopes and also it would become impossible to use <code>ServletModule</code>s <code>.strictScopeControl()</code> Explicitly detect when guice bean is instantiated with HK2 and vice versa.Bean target container is defined with <code>@JerseyManaged</code> and <code>@GuiceManaged</code> annotations or default (either guice or hk2 used as default (for jersey extensions)) <code>.useHK2ForJerseyExtensions()</code> Use HK2 by default for jersey extensions (change default). With this <code>@GuiceManaged</code> annotation may be used to override default for bean.Beans managed by HK2 can't use guice AOP, so AOP-based features will not work with such beans       <p>Danger</p> <p>In the next version guicey will get rid of HK2 and so all HK2 related options will be removed (only guice will be used). Also, <code>.noGuiceFilter()</code> will be removed because request scope will be required.  </p>"},{"location":"guide/configuration/#diagnostic-tools","title":"Diagnostic tools","text":"<p>Guicey provide many bundled console reports to help with problems diagnostic (or to simply clarify how application works) during development, like:</p> <pre><code>.printDiagnosticInfo()\n</code></pre> <p>See diagnostic section for a full list of available reports.</p>"},{"location":"guide/configuration/#hooks-related","title":"Hooks-related","text":"<code>.hookAlias(String name, Class&lt;? extends GuiceyConfigurationHook&gt; hook)</code> Hook alias registration for simplified usage (various diagnostic tools quick enabling with a system property) <code>.withSharedState(Consumer&lt;SharedConfigurationState&gt; stateAction)</code> This method is mainly useful for hooks, because it's the only way to access application shared state from hook."},{"location":"guide/configuration/#configuration-awareness","title":"Configuration awareness","text":"<p>To configure bundle when application configuration object is required:</p> <pre><code>GuiceBundle.builder()\n   ...\n   .whenConfigurationReady(env -&gt; {\n        // env is GuiceyEnvironment, like in GuiceyBundle#run\n        AppConfig config = env.configuration();\n        env.modules(new GuiceModule(config));\n   });\n</code></pre>"},{"location":"guide/configuration/#guicey-bundle","title":"Guicey bundle","text":"<p><code>GuiceyBundle</code>s are like dropwizard bundles, but with greater abilities. Supposed to be used instead of  dropwizard bundles. Bundles are registered either directly (in main bundle or other guicey bundle)  or resolved by bundles lookup.</p>"},{"location":"guide/configuration/#initialization","title":"Initialization","text":"<pre><code>public class MyBundle implements GuiceyBundle {\n\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        ...\n    }      \n}\n</code></pre> <p>Bundle initialization share many methods in common with main guice bundle:</p> <p><code>.modules(Module... modules)</code> <code>.modulesOverride(Module... modules)</code> <code>.installers(Class&lt;? extends FeatureInstaller&gt;... installers)</code> <code>.extensions(Class&lt;?&gt;... extensionClasses)</code> <code>.extensionsOptional(Class&lt;?&gt;... extensionClasses)</code> <code>.bundles(GuiceyBundle... bundles)</code> <code>.dropwizardBundles(ConfiguredBundle... bundles)</code></p> <p><code>.disableInstallers(Class&lt;? extends FeatureInstaller&gt;... installers)</code> <code>.disableExtensions(Class&lt;?&gt;... extensions)</code> <code>.disableModules(Class&lt;? extends Module&gt;... modules)</code></p> <p>No disable for bundles because at this moment some bundles were already executed and so  real state could be inconsistent with configuration (and highly depend on processing order). </p> <code>.listen(GuiceyLifecycleListener... listeners)</code> Listener registered in bundle will \"hear\" only events starting with <code>GuiceyLifecycle#BundlesInitialized</code> <p>Shortcuts:</p> <p><code>.bootstrap()</code> <code>.application()</code> </p> <p>Option value access:</p> <code>.option(T option)</code> Bundle can't declare option value because it would make options state not predictable (highly dependent on initialization order)   <p>Shared state access:</p> <code>.shareState(Class&lt;?&gt; key, Object value)</code> Declare shared state (primary module scenario) <code>.sharedState(Class&lt;?&gt; key, Supplier&lt;T&gt; defaultValue)</code> Get or init shared state (equal bundles scenario) <code>.sharedStateOrFail(Class&lt;?&gt; key, String message, Object... args)</code> Shortcut to get shared state or immediately fail if not declared"},{"location":"guide/configuration/#run","title":"Run","text":"<pre><code>public class MyBundle implements GuiceyBundle {\n\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n        ...\n    }      \n}\n</code></pre> <p>All bundles must be registered under initialization phase.</p> <p>On run phase modules and extensions registration is available (to perform registration, using application configuration, or avoid extension registration based on configuration value).  </p> <p>Shortcuts:</p> <code>.configuration()</code> <code>.environment()</code> <code>.application()</code> <code>.register(Object... items)</code> Shortcut for <code>environment().jersey().register(Object)</code> <code>.register(Class&lt;?&gt;... items)</code> Shortcut for <code>environment().jersey().register(Class)</code> <code>.manage(Managed managed)</code> Shortcut for <code>environment().lifecycle().manage()</code> <code>.listenServer(ServerLifecycleListener listener)</code> Shortcut for <code>environment().lifecycle().addServerLifecycleListener()</code> <code>.listenJetty(LifeCycle.Listener listener)</code> Shortcut for <code>environment().lifecycle().addLifeCycleListener()</code> <code>.listenJersey(new ApplicationEventListener() {...})</code> Shortcut for <code>environment.jersey().register(listener)</code> <p>Extended configuration access:</p> <p><code>.configuration(String yamlPath)</code> <code>.configuration(Class&lt;T&gt; type)</code> <code>.configurations(Class&lt;T&gt; type)</code> <code>.annotatedConfiguration(ann)</code> <code>.annotatedConfiguration(Class)</code> <code>.configurationTree()</code> </p> <p>Modules registration:</p> <code>.modules(Module... modules)</code> Only here modules may be created directly with configuration values <p><code>.modulesOverride(Module... modules)</code></p> <p>Disables:</p> <p><code>.disableExtensions(final Class&lt;?&gt;... extensions)</code> <code>.disableModules(Class&lt;? extends Module&gt;... modules)</code> </p> <p>Option value access:</p> <p><code>.option(T option)</code></p> <p>Shared state:</p> <p><code>.sharedStateOrFail(Class&lt;?&gt; key, String message, Object... args)</code> <code>.sharedState(Class&lt;?&gt; key)</code></p> <p>Guicey listeners:</p> <code>.listen(GuiceyLifecycleListener... listeners)</code> Listener registered in run phase will \"hear\" only events starting  with <code>GuiceyLifecycle#BundlesStarted</code> <code>.onGuiceyStartup(GuiceyStartupListener listener)</code> Shortcut for manual configuration under run phase with available injector <code>.onApplicationStartup(ApplicationStartupListener listener)</code> <p>Shortcut for manual actions after complete application start (jetty started) </p> <p>It is also called after guicey initialization in lightweight guicey tests</p> <code>.onApplicationShutdown(ApplicationShutdownListener listener)</code> Shortcut for manual actions after complete application shutdown"},{"location":"guide/configuration/#hooks","title":"Hooks","text":"<p>Guicey hooks are registered statically before main guice bundle registration:</p> <pre><code>public class MyHook implements GuiceyConfigurationHook {\n\n    @Override\n    public void configure(final GuiceBundle.Builder builder) {\n        builder.printDiagnosticInfo();\n    }\n}    \n\n// static registration\nnew MyHook().register() \n</code></pre> <p>On execution hook receives the same builder as used in main <code>GuiceBundle</code>.  So hooks could configure everything.</p> <p>Hooks are intended to be used in tests and to implement a pluggable diagnostic tools  activated with system property <code>-Dguicey.hooks=...</code> (as an example, see guicey <code>DiagnosticHook</code>).</p>"},{"location":"guide/deduplication/","title":"Configuration de-duplication","text":"<p>Guice modules, bundles and dropwizard bundles allow registration of multiple instance of the same type. For example:</p> <pre><code>.modules(new MyModule(\"one\"), new MyModule(\"two\"))\n</code></pre> <p>Note</p> <p>Before, guice did not allow to register multiple modules of the same type, but multiple instances support is more logical in context of dropwizard, because  dropwizard itself allows registration of multiple bundles of the same type.</p>"},{"location":"guide/deduplication/#duplicates","title":"Duplicates","text":"<p>But in some cases it is desirable to avoid such registrations. For example, if two bundles  install the same common bundle it would be installed twice:</p> <pre><code>public class Feature1Bundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.bundles(new CommonBundle);\n    }\n}\n\npublic class Feature2Bundle implements GuiceyBundle {\n    @Override\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.bundles(new CommonBundle);\n    }\n}\n\nGuiceBundle.buider()\n    .bundles(new Feature1Bundle(). new Feature2Bundle())\n    ...\n</code></pre> <p>To work around such cases deduplication mechanism* was introduced: instances of the same  type are considered duplicate if they are equal. </p>"},{"location":"guide/deduplication/#equals-method","title":"Equals method","text":"<p>In order to resolve \"common bundle/module problem\" bundle/module must only  properly implement equals method:</p> <pre><code>public class CommonBundle implements GuiceyBundle {\n    ...\n\n    @Override\n    public boolean equals(final Object obj) {\n        return obj != null &amp;&amp; getClass().equals(obj.getClass());\n    }\n}\n</code></pre> <p>Tip</p> <p>Guicey provide base classes for such cases: <code>UniqueGuiceyBundle</code> for unique bundles  and <code>UniqueModule</code> (or <code>UniqueDropwizardAwareModule</code>) for unique guice modules. So bundle above could be simplified to:</p> <pre><code>public class CommonBundle extends UniqueGuiceyBundle { ... }\n</code></pre> <p>Equals logic could be more complicated: for example, it may involve constructor parameters comparison to treat as duplicates only instances with the same parameters.    </p>"},{"location":"guide/deduplication/#unique-items","title":"Unique items","text":"<p>When it is impossible to properly implement equals method (for example, because target bundle or module is 3<sup>rd</sup> party) you can simply explicitly declare them as unique:</p> <pre><code>GuiceBundle.builder()\n    .uniqueItems(Some3rdPartyBundle.class, \n                 Some3rdPartyModule.class)\n</code></pre> <p>Now only one instance of <code>Some3rdPartyBundle</code> and <code>Some3rdPartyModule</code> will be registered and all other instances considered as duplicate.</p>"},{"location":"guide/deduplication/#general-unique-logic","title":"General unique logic","text":"<p>.uniqueItems() method above is actually a shortcut for custom deduplication mechanism registration (most common case).</p> <p>But you can implement your own deduplication logic and register with: </p> <pre><code>GuiceBundle.builder()\n    ...\n    .duplicateConfigDetector((List&lt;Object&gt; registered, Object newItem) -&gt; {\n         if (newItem isntanceof Some3rdPartyBundle) {\n             // decide if item collide with provided registered instances (of the same type)\n             return detectedDuplicate // instance that registered is duplicate to or null to accept item\n         }           \n         // allow instance registration\n         return null;    \n    })\n</code></pre> <p>Important</p> <p>This does not override equals method logic: custom de-duplication mechanism is called only after equals check.</p> <p>Warning</p> <p>You can't use <code>.duplicateConfigDetector()</code> and <code>.uniqueItems()</code> at the same time - one would override another (depends on order). In case of override you will only see warning in logs.</p>"},{"location":"guide/deduplication/#legacy-mode","title":"Legacy mode","text":"<p>Old guicey \"1 instance per class\" behaviour could be recovered with bundled detector:</p> <pre><code>.duplicateConfigDetector(new LegacyModeDuplicatesDetector())\n</code></pre>"},{"location":"guide/deduplication/#reporting","title":"Reporting","text":"<p>Configuration diagnostic report (<code>.printDiagnosticInfo()</code>)  shows all registered instances and ignored duplicates.</p> <p>For example, if we have module declared to be unique by constructor value:</p> <pre><code>public class VMod extends AbstractModule {\n\n    private int value;\n\n    public VMod(int value) {\n        this.value = value;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return obj instanceof VMod &amp;&amp; value.equals(obj.value);\n    }\n\n}   \n</code></pre> <p>If modules are registered like this:</p> <pre><code> GuiceBundle.builder()\n    .modules(new VMod(1), new VMod(1), new VMod(2), new VMod(2))\n    .printDiagnosticInfo()\n    .build()\n</code></pre> <p>Report would contain:</p> <pre><code>GUICE MODULES =\n        VMod                          (com.mycompany) *REG(2/4) \n\nAPPLICATION\n    \u251c\u2500\u2500 module     VMod                          (com.mycompany)\n    \u251c\u2500\u2500 module     -VMod                         (com.mycompany) *DUPLICATE\n    \u251c\u2500\u2500 module     VMod#2                        (com.mycompany)\n    \u251c\u2500\u2500 module     -VMod#2                       (com.mycompany) *DUPLICATE\n</code></pre> <p>Where you can see that 2 of 4 registered modules of type VMod were registered. Note that instances are numbered (#2) in order of registration (without duplicates)  so you can always see what bundle were considered as original (and see registration order when bundles of the same type are registered in different bundles). </p>"},{"location":"guide/deduplication/#limitations","title":"Limitations","text":""},{"location":"guide/deduplication/#guice-modules","title":"Guice modules","text":"<p>Transitive guice modules are not counted during de-duplication.</p> <p>For example,</p> <pre><code>public class MyModule extends AbstractModule {}\n\npublic class SomeModule extends AbstractModule {\n    @Override\n    public void configure() {   \n        // transitive module\n        install(new MyModule());\n    }\n}                           \n\nGuiceBindle.builder()\n    .modules(new OtherModule(), new MyModule())\n    .uniqueItems(MyModule.class)\n</code></pre> <p>This will not work because guicey is not aware of transitive modules (guicey can only know modules tree on class level,  but can't see exact instances).</p> <p>BUT guice natively support de-duplication of equal modules, so if your module have proper equals</p> <pre><code>public class MyModule extends UniqueModule {}\n</code></pre> <p>Then guice will perform de-duplication itself.</p> <p>Warning</p> <p>Guice will perform de-duplication itself only if both <code>equals</code> and <code>hashCode</code> properly implemented (like in <code>UniqueModule</code>)  </p> <p>Note</p> <p>Guice can also de-duplicate bindings: if bindings from different module instances are the same then guice will simply ignore duplicate bindings. </p>"},{"location":"guide/deduplication/#dropwizard-bundles","title":"Dropwizard bundles","text":"<p>Guicey can see transitive dropwizard bundles and properly apply de-duplication logic. For example,</p> <pre><code>public class MyBundle implements ConfiguredBundle {}\n\npublic class OtherBundle implements ConfiguredBundle {\n    @Override\n    public void initialize(Bootstrap bootstrap) {   \n        // transitive bundle\n        bootstrap.addBundle(new MyBundle());\n    }\n}                           \n\nGuiceBindle.builder()\n    .dropwizardBundles(new OtherBundle(), new MyBundle())\n    .uniqueItems(MyBundle.class)\n</code></pre> <p>This will work because guicey use special proxy to intercept transitive registrations (so, essentially, transitive registrations are treated the same as direct)</p> <p>Note</p> <p>This means that if you have \"common dropwizard bundle\" problem, then you can simply  register it with guicey and it will be able to properly de-duplicate it.</p> <p>BUT guicey does not \"see\" directly installed bundles (intentionally!). For example,</p> <pre><code>bootstrap.addBundle(new MyBundle())\nbootstrap.addBundle(GuiceBindle.builder()\n                .dropwizardBundles(new OtherBundle())\n                .uniqueItems(MyBundle.class)\n                .build())\n</code></pre> <p>This will not work because guicey see only directly registered bundles: <code>OtherBundle</code> and transitive <code>MyBundle</code>, and so <code>MyBundle</code> would be registered twice.  </p>"},{"location":"guide/disables/","title":"Disables","text":"<p>Guicey allows disabling (removing) of any registered configuration items:</p> <ul> <li>Extensions</li> <li>Installers</li> <li>Guice modules</li> <li>Bundles</li> <li>Dropwizard bundles</li> </ul> <p>This is mostly useful in tests, where you can easily modify application context (replacing entire application parts with hooks).</p> <p>But it also could be used for workarounds: when 3<sup>rd</sup> party item contains bug or does  not fit well - it could be always disabled and replaced by different item. For example,  bundle may register some other optional bundle, which you doesn't need - it could be simply disabled to avoid installation. </p> <p>Note</p> <p>It doesn't matter if item was already registered or not (in time of disabling). Item  may not be registered at all.</p> <p>Disables are available in main bundle and in guicey bundles.</p> <p>Warning</p> <p>Disable is performed by class, so disabling modules and bundles disables all instances of type. The only way to disable exact instance is to use disable by predicate. </p>"},{"location":"guide/disables/#disable-extensions","title":"Disable extensions","text":"<pre><code>.disableExtensions(ExtensionOne.class, ExtensionTwo.class)\n</code></pre> <p>It doesn't matter if extension was already registered or not (it may be not registered at all) or what source used (manual, classpath scan or binding).</p> <p>Note</p> <p>Extension disable will work for extensions, declared in guice modules! In this case guicey will simply remove such binding.</p> <p>Tip</p> <p>Extension disable may be also used when classpath scanner detected class you don't need to  be installed and you can't use <code>@InvisibleForScanner</code> annotation on it.</p> <p>Generally, all configuration must appear under initialization phase, but it is allowed to disable  extensions under run phase inside guicey bundle to be able to disable features by  configuration values (because it's almost never possible to not register, based on configuration values, so disables is the only way to switch off features, based on configuration).  </p>"},{"location":"guide/disables/#disable-installers","title":"Disable installers","text":"<pre><code>.disableInstallers(ManagedInstaller.class, ResourceInstaller.class)\n</code></pre> <p>Installer is the core guicey concept because installers implement dropwizard integration - properly register guice beans in dropwizard. It may appear that existing installer does not fit your needs or simply contains bug. You can easily remove it and register replacement (probably fixed version):</p> <pre><code>GuiceBundle.builder()\n    ...\n    .disableInstallers(ResourceInstaller.class)\n    .installers(CustomizedResourceInstaller.class)\n</code></pre> <p>Tip</p> <p>Custom installers are detected automatically by classpath scan (if enabled).</p> <p>This could also be used to change installers order (declared with <code>@Order</code> annotation on each installer).  </p>"},{"location":"guide/disables/#disable-guice-modules","title":"Disable guice modules","text":"<pre><code>.disableInstallers(ModleOne.class, ModuleTwo.class)\n</code></pre> <p>Disabling affects both normal (<code>.modules()</code>) and overriding (<code>.modulesOverride()</code>) modules.</p> <p>Important</p> <p>Disabling affect transitive modules!</p> <p><pre><code>public class MyModule extends AbstractModule {\n    @Override\n    public void configure() {   \n        install(new TransitiveModule());\n    }\n}                           \n\nGuiceBindle.builder()\n    .disableModules(TrannsitiveModule.clas)\n    ...\n</code></pre> Will remove <code>TransitiveModule</code> (actually, guicey will remove all bindings of this module, but result is the same)</p> <p>Modules disable could be used to prevent some additional module  installation by 3<sup>rd</sup> party bundle (or to override such module).    </p>"},{"location":"guide/disables/#disable-bundles","title":"Disable bundles","text":"<p>Guicey bundles could be disabled only in main bundle, because  bundle must be disabled before it's execution and transitive bundles are registered during  execution (so disable may appear too late)  </p> <pre><code>.disableBundles(MyBundle.class)\n</code></pre> <p>Could be used to disable some not required transitive bundle, installed by 3<sup>rd</sup> party bundle.</p>"},{"location":"guide/disables/#disable-dropwizard-bundles","title":"Disable dropwizard bundles","text":"<pre><code>.disableDropwizardBundles(MyBundle.class)\n</code></pre> <p>Warning</p> <p>Only bundles registered through guicey api could be disabled!</p> <pre><code>bootstrap.addBundle(new MyBundle())\nbootstrap.addBundle(GuiceBindle.builder()\n                .disableDropwizardBundles(MyBundle.class)\n                .build())\n</code></pre> <p>Disable wIll not work becuase <code>MyBundle</code> is not registered through guicey api.</p> <p>Important</p> <p>Disable affects transitive bundles!</p> <pre><code>public class MyBundle implements ConfiguredBundle {\n    @Override\n    public void initialize(Bootstrap bootstrap) {   \n        bootstrap.addBundle(new TransitiveBundle());\n    }\n}                           \n\nGuiceBindle.builder()\n    .disableDropwizardBundles(TransitiveBundle.class)\n    ...\n</code></pre> <p>Will remove <code>TransitiveBundle</code> (this works due to bootsrap object proxying for  bundles registered through guicey api). </p>"},{"location":"guide/disables/#disable-by-predicate","title":"Disable by predicate","text":"<p>There is also a generic disable method using predicate. With it you can disable items (bundles, modules, installers, extensions) by package or by installation bundle or some other custom condition (e.g. introduce your disabling annotation and handle it with predicate).</p> <p>Note</p> <p>This is the only way to register exact module or bundle instance (if you have multiple items of the same type).</p> <pre><code>import static ru.vyarus.dropwizard.guice.module.context.Disables.*\n\n.disable(inPackage(\"com.foo.feature\", \"com.foo.feature2\"));\n</code></pre> <p>Disable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module. If you use package by feature approach then you can easily switch off entire features in tests.</p> <pre><code>import static ru.vyarus.dropwizard.guice.module.context.Disables.*\n\n.disable(installer()\n         .and(registeredBy(Application.class))\n         .and(type(SomeInstallerType.class).negate());\n</code></pre> <p>Disable all installers, directly registered in main bundle except <code>SomeInstallerType</code></p> <pre><code>import static ru.vyarus.dropwizard.guice.module.context.Disables.*\n\n.disable(type(MyExtension.class,\n         MyInstaller.class,\n         MyBundle.class,\n         MyModule.class));\n</code></pre> <p>Simply disable items by type.</p> <p>Disable extensions, installed by the exact installer:</p> <pre><code>@EnableHook\nstatic GuiceyConfigurationHook hook = builder -&gt;\n        builder.disable(installedBy(WebFilterInstaller.class));\n</code></pre> <p>The condition is java <code>Predicate</code>. Use <code>Predicate#and(Predicate)</code>, <code>Predicate#or(Predicate)</code> and <code>Predicate#negate()</code> to compose complex conditions from simple ones.</p> <p>There are disable shortcuts for exact items type (<code>Disables.module()</code>, <code>Disabled.extension()</code>, etc.) now raise predicate type to simplify chained usage:</p> <pre><code>builder.disable(module().and(ModuleItemInfo mod -&gt; ! mod.isOverriding()));\n</code></pre> <p>There are special shortcuts for web and jersey extensions (jersey extension is also a web extension): <code>Disables.jerseyExtension()</code> and <code>Disables.webExtension()</code> (servlets, filters and jersey).</p> <p>Most common predicates could be build with <code>ru.vyarus.dropwizard.guice.module.context.Disables</code> utility (examples above).</p>"},{"location":"guide/disables/#reporting","title":"Reporting","text":"<p>Configuration diagnostic report (<code>.printDiagnosticInfo()</code>)  shows all disables and disabled items. </p> <p>For example:</p> <pre><code>    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)  \n\n    ...\n\n    \u251c\u2500\u2500 installer  -LifeCycleInstaller           (r.v.d.g.m.i.feature)         *DISABLED  \n</code></pre>"},{"location":"guide/events/","title":"Guicey lifecycle events","text":"<p>Guicey broadcast lifecycle events in all major points. Each event  provides access to all available state at this point.</p> <p>Events could be used for configuration analysis, reporting or to add some special  post processing for configuration items (e.g. post process modules before injector creation). </p> <p>Important</p> <p>Event listeners could not modify configuration itself (can't add new extensions, installers, bundles or disable anything).   </p>"},{"location":"guide/events/#events","title":"Events","text":"<p>All events are listed in <code>GuiceyLifecycle</code> enum (in execution order). </p> Event Description Possible usage Dropwizard initialization phase ConfigurationHooksProcessed<sup>?</sup> Called after all registered hooks processing. Not called when no hooks used. Only for info DropwizardBundlesInitialized<sup>?</sup> Called after dropwizard bundles initialization (for dropwizard bundles registered through guicey api). Not called if no bundles were registered. Logging, bundle instances modification (to affect run method) BundlesFromLookupResolved<sup>?</sup> Called after resolution bundles through lookup mechanism. Not called if no bundles found. Logging or post processing of found bundles. BundlesResolved Called with all known top-level bundles (transitive bundles are not yet known). Always called to indicate configuration state. Could be used to modify top-level bundle instances BundlesInitialized<sup>?</sup> Called after all bundles initialization (including transitive, so list of bundles could be bigger). Not called when no bundles registered. Logging, post processing CommandsResolved<sup>?</sup> Called if commands search is enabled and at least one command found Logging InstallersResolved Called when all configured (and resolved by classpath scan) installers initialized Potentially could be used to configure installer instances ManualExtensionsValidated<sup>?</sup> Called when all manually registered extension classes are recognized by installers (validated). But only extensions, known to be enabled at that time are actually validated (this way it is possible to exclude extensions for non existing installers). Called only if at least one manual extension registered. Logging, assertions ClasspathExtensionsResolved<sup>?</sup> Called when classes from classpath scan analyzed and all extensions detected (if extension is also registered manually it would be also counted as from classpath scan). Called only if classpath scan is enabled and at least one extension detected. Logging, assertions Initialized Meta event, called after GuiceBundle initialization (most of configuration done). Pure marker event, indicating guicey work finished under dropwizard configuration phase. Last chance to modify Bootstrap Dropwizard run phase BeforeRun Meta event, called before any guicey actions just to indicate first point where Environment, Configuration and introspected configuration are available For example, used by <code>bundle.printConfigurationBindings()</code> to print configuration bindings before injector start (help with missed bindings debug) BundlesStarted<sup>?</sup> Called after bundles start (run method call). Not called if no bundles were used at all. Called only if bindings analysis is not disabled. Logging ModulesAnalyzed Called after guice modules analysis and repackaging. Reveals all detected extensions and removed bindings info. Logging, analysis validation logic ExtensionsResolved Called to indicate all enabled extensions (manual, from classpath scan and modules). Always called to indicate configuration state. Logging or remembering list of all enabled extensions (classes only) InjectorCreation Called just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called. Logging. Note that it is useless to modify module instance here, because they were already processed. Guice injector created ExtensionsInstalledBy Called when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later. Logging of installed extensions. Extension instance could be obtained from injector and post processed. ExtensionsInstalled<sup>?</sup> Called after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled) Logging or extensions post processing ApplicationRun Meta event, called when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty would be started yet) and all guice singletons initialized. At this point injection to registered commands is performed (this may be important if custom command run application instead of \"server\"). Point is just before <code>Application.run</code> method. Ideal point for jersey and jetty listeners installation (with shortcut methods in event). Jersey initialization JerseyConfiguration Jersey context starting. Both jersey and jetty are starting. First point where jersey's <code>InjectionManager</code> (and <code>ServiceLocator</code>) become available JerseyExtensionsInstalledBy Called when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty) Logging of installed extensions. Extension instance could be obtained from injector/locator and post processed. JerseyExtensionsInstalled<sup>?</sup> Called after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions) Logging or extensions post processing ApplicationStarted Meta event, called after complete dropwizard startup. This event also will be fired in guicey lightweight tests May be used as assured \"started\" point (after all initializations). For example, for reporting. ApplicationShutdown Meta event, called on server shutdown start. This event also will be fired in guicey lightweight tests May be used for shutdown logic. ApplicationStoppedEvent Meta event, called after application shutdown. This event also will be fired in guicey lightweight tests May be used in rare cases to cleanup fs resources after application stop. <p><sup>?</sup> - event may not be called</p>"},{"location":"guide/events/#listeners","title":"Listeners","text":"<p>Events listener registration: </p> <pre><code>GuiceBundle.builder()\n    .listen(new MyListener(), new MyOtherListener())\n    ...\n    .build()\n</code></pre> <p>Note</p> <p>Listeners could be also registered in guicey bundle, but they will not receive all events:</p> <ul> <li><code>&gt;= BundlesInitialized</code> for listeners registered in initialization method </li> <li><code>&gt;= BundlesStarted</code> for listeners registered in run method  </li> </ul> <p>Event listener could implement generic event interface <code>GuiceyLifecycleListener</code> and use enum to differentiate required events:</p> <pre><code>public class MyListener implements GuiceyLifecycleListener {\n\n    public void onEvent(GuiceyLifecycleEvent event) {\n        switch (event.getType()) {\n            case InjectorCreation:\n                InjectorCreationEvent e = (InjectorCreationEvent) event;\n                ...\n        }\n    }\n}  \n</code></pre> <p>Or use <code>GuiceyLifecycleAdapter</code> adapter and override only required methods:</p> <pre><code>public class MyListener extends GuiceyLifecycleAdapter {\n\n    @Override\n    protected void injectorCreation(final InjectorCreationEvent event) {\n           ...\n    }        \n}\n</code></pre> <p>Tip</p> <p>In <code>ApplicationStarted</code> and <code>ApplicationShutdown</code> events lightweight guicey test environment may be differentiated from real server startup with <code>.isJettyStarted()</code> method.</p>"},{"location":"guide/events/#de-duplication","title":"De-duplication","text":"<p>Event listeners are also support de-duplication to prevent unnecessary  duplicates usage (for example, two bundles may register one listener because they are not always used together). But it is not the same mechanism as configuration items de-duplication.</p> <p>Simply listeners are registered in the <code>LinkedHashSet</code> and so listeners could control de-duplication with a proper <code>equals</code> and <code>hashCode</code> implementations</p> <p>Many reports use this feature (because all of them are based on listeners). For example, diagnostic report use the following implementations:</p> <pre><code>@Override\npublic boolean equals(final Object obj) {\n    // allow only one instance with the same title\n    return obj instanceof ConfigurationDiagnostic\n            &amp;&amp; reportTitle.equals(((ConfigurationDiagnostic) obj).reportTitle);\n}\n\n@Override\npublic int hashCode() {\n    return reportTitle.hashCode();\n}\n</code></pre> <p>And with it, <code>.printDiagnosticInfo()</code> can be called multiple times and still only one report will be actually printed.</p>"},{"location":"guide/events/#events-hierarchy","title":"Events hierarchy","text":"<p>All event classes inherit from some base event classes. Base event classes are extending each other: as lifecycle phases go, more objects become available. So you can access any available (at this point) object from event instance. </p> Base event Description GuiceyLifecycleEvent The lowest event type. Provides access to event type and options. ConfigurationPhaseEvent Initialization phase event. Provides access to Bootstrap. RunPhaseEvent Dropwizard run phase. Provides access to Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer InjectorPhaseEvent Guice injector created. Available injector and GuiceyConfigurationInfo (guicey configuration). Shortcuts for configuration reports renderer JerseyPhaseEvent Jersey starting. Jersey's <code>InjectionManager</code> available."},{"location":"guide/extensions/","title":"Extensions","text":"<p>Extensions mechanism supposed to be used in guicey for all dropwizard specific features registration (instead of manual registrations). </p> <p>All extensions are recognized and installed with appropriate installer. This page supposed to reference declaration examples of most common extensions. See installers  section for details.</p> <p>Warning</p> <p>Extension is recognized only by one installer (according to installers order), even if it contains multiple signs! See installers report for installers order.</p> <p>Declaration sources:</p> <ul> <li>Classpath scan</li> <li>Manual declaration</li> <li>Guice binding</li> </ul> <p>Tip</p> <p>More installers (and so supported extensions types) could be available due to installed extension bundles. Use installers report to see all available installers.</p> <p>Some extensins support order declaration with <code>@Order()</code> - see report.</p> <p>Note</p> <p>If you have problems with injection inside extensions (NPE errors) first check that you did not register extension manually! It is a quite often mistake (especially with jersey extensions):</p> <p><pre><code>environment.jersey().register(new MyResource())\n</code></pre> This way <code>MyResource</code> will not be managed by guice and so injections inside it will not work</p> <p>Use constructor injection to prevent such errors (manual places will reveal immediately): <pre><code>@Path(\"/\")\npublic class MyResource {\n    private final MyService service;\n\n    @Inject\n    public MyResource(MyService service) {\n        this.service = service;\n    }\n}\n</code></pre></p>"},{"location":"guide/extensions/#resource","title":"Resource","text":"<pre><code>@Path(\"/res\")\n@Produces('application/json')   \n@Singleton\nclass SampleResource {\n\n    @Inject\n    private MyService service;\n\n    @GET\n    @Path(\"/sample\")\n    public Response sample() {\n        return Response.ok(service.result()).build();\n    }\n}\n</code></pre> <p>Recognized by <code>@Path</code> annotation on class or implemented interface.</p>"},{"location":"guide/extensions/#task","title":"Task","text":"<pre><code>@Singleton\npublic class MyTask extends Task {\n\n    @Inject\n    private MyService service;\n\n    public TruncateDatabaseTask() {\n        super(\"mytask\");\n    }\n\n    @Override\n    public void execute(ImmutableMultimap&lt;String, String&gt; parameters, PrintWriter output) throws Exception {\n        service.doSomething();\n    }\n}\n</code></pre> <p>Recognized by base <code>Task</code> class.</p>"},{"location":"guide/extensions/#managed","title":"Managed","text":"<pre><code>@Singleton\npublic class MyService implements Managed {\n\n    @Override\n    public void start() throws Exception {\n        ...\n    }\n\n    @Override\n    public void stop() throws Exception {\n        ...\n    }\n}\n</code></pre> <p>Recognized by <code>Managed</code> base class.</p>"},{"location":"guide/extensions/#health-check","title":"Health check","text":"<pre><code>@Singleton\npublic class MyHealthCheck extends NamedHealthCheck {\n\n    @Inject\n    private MyService service;\n\n    @Override\n    protected Result check() throws Exception {\n        if (service.isOk()) {\n            return Result.healthy();\n        } else {\n            return Result.unhealthy(\"Service is not ok\");\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"my-service\";\n    }\n}\n</code></pre> <p>Recognized by base <code>NamedHealthCheck</code> class. Custom guicey base class  used because it would be impossible to automatically register health check without name.  </p>"},{"location":"guide/extensions/#jersey-extensions","title":"Jersey extensions","text":"<p>All jersey extensions are recognized by <code>jakarta.ws.rs.ext.Provider</code> jersey annotation.  There are many extensions supported.</p> <pre><code>@Provider\n@Singleton\npublic class DummyExceptionMapper implements ExceptionMapper&lt;RuntimeException&gt; {\n\n    private final Logger logger = LoggerFactory.getLogger(DummyExceptionMapper.class);\n\n    @Override\n    public Response toResponse(RuntimeException e) {\n        logger.debug(\"Problem while executing\", e);\n        return Response.status(Response.Status.BAD_REQUEST)\n                .type(MediaType.TEXT_PLAIN)\n                .entity(e.getMessage())\n                .build();\n    }\n\n}\n</code></pre> <p>or </p> <pre><code>@Provider       \n@Singleton\npublic class MyContainerRequestFilter implements ContainerRequestFilter {\n\n    @Override\n    public void filter(ContainerRequestContext requestContext) throws IOException {\n    }\n}\n</code></pre>"},{"location":"guide/extensions/#eager-singleton","title":"Eager singleton","text":"<pre><code>@EagerSingleton\npublic class MyService {}\n</code></pre> <p>Recognized by <code>@EagerSingleton</code> annotation. Replacement of manual <code>bind(MyService.class).asEagerSingleton()</code>.</p>"},{"location":"guide/extensions/#more","title":"More","text":"<p>This was only subset of supported extensions - see installers  section.</p> <p>You can add additional extensions support with a custom installer.</p>"},{"location":"guide/hk2/","title":"HK2","text":"<p>Danger</p> <p>Someday guicey will get rid of HK2 usage completely, which means HK2-related api and features would be removed.</p> <p>But, as it requires a lot of efforts, all HK2-related apis and deprecated softly not - this means, there are no direct deprecation and only javadoc mention \"soft deprecation\". Please try to avoid using HK2 at all.      </p> <p>Previous strong deprecation was removed because there are no replacemenets provided for current api (and its not clear when complete removal whill happen). </p> <p>By default, guicey manage all extensions under guice context and only register  extensions in HK2 by instance. Normally you shouldn't know about HK2 at all.</p>"},{"location":"guide/hk2/#jersey-objects","title":"Jersey objects","text":"<p>Guice started before HK2 and so all jersey-related beans could be registered in guice context  only with lazy providers:</p> <pre><code>binder.bind(jerseyType).toProvider(new JerseyComponentProvider(injectorProvider, jerseyType));\n</code></pre> <p>This provider will use jersey's <code>InjectionManager</code> to lookup bean:</p> <pre><code>injectionManagerInstance.getInstance(type);\n</code></pre> <p>See more details in jersey bindings module.</p>"},{"location":"guide/hk2/#access-hk2-context-from-guice","title":"Access HK2 context from guice","text":"<p>Jersey's <code>InjectionManager</code> is available for injection inside guice context:</p> <pre><code>@Inject Provider&lt;InjectionManager&gt; jerseyInjector;\n</code></pre> <p>Provider is important because jersey starts after guice.</p> <p>Note</p> <p><code>InjectionManager</code> is jersey's new DI-agnostic api. You can obtain HK2  <code>ServiceLocator</code> from it, if required: </p> <pre><code>ServiceLocator locator = jerseyInjector.getInstance(ServiceLocator.class);\n</code></pre>"},{"location":"guide/hk2/#jersey-extensions","title":"Jersey extensions","text":"<p>Jersey-related extensions (resources, features  and providers) are registered in HK2 with lazy factories (laziness is important to respect scopes and help with cycled initialization cases (when guice beans depend on HK2 beans)):</p> <pre><code>binder.bindFactory(new GuiceComponentFactory&lt;&gt;(injector, guiceType)).to(guiceType)\n</code></pre> <p>And internally this factory will obtain instance from guice injector:</p> <pre><code>guiceInjector.getInstance(guiceType);\n</code></pre> <p>To see more details on how it works look jersey providers installer.</p>"},{"location":"guide/hk2/#hk2-delegation","title":"HK2 delegation","text":"<p>You can delegate extension instance management into HK2 with <code>@JerseyManaged</code> annotation:</p> <pre><code>@Provider\n@JerseyManaged\npublic class MapperManagedByHK2 implements ExceptionMapper { ... }\n</code></pre> <p>Now this extension will not be instantiated by guice - HK2 will instantiate it.</p> <p>Warning</p> <p>Delegated beans will not be affected with guice AOP and will not see guice beans (if bridge not activated)</p> <p>Tip</p> <p>You can use <code>.strictScopeControl()</code> to make sure that beans are nto instantiated by both DI containers.</p>"},{"location":"guide/hk2/#hk2-guice-bridge","title":"HK2 guice bridge","text":"<p>HK2 bridge may be required ONLY if you delegate some beans creation to HK2 (instead of guice) but beans still require guice-managed beans injection (HK2 must be able to see guice bindings).</p> <p>To activate bridge:</p> <ul> <li>Add dependency: <code>org.glassfish.hk2:guice-bridge:2.6.1</code> (version must match HK2 version, used by dropwizard)</li> <li>Enable option: <code>.option(GuiceyOptions.UseHkBridge, true)</code></li> </ul> <p>After that, HK2 beans could inject guice beans:</p> <pre><code>@JerseyManaged\npublic class HkService {\n\n    @Inject\n    private GuiceService service;\n}\n</code></pre>"},{"location":"guide/hk2/#use-hk2-for-jersey-extensions","title":"Use HK2 for jersey extensions","text":"<p>By default, guice is used to construct all extensions, including jersey related  (resources, features  and providers) which are registered in HK2 context as instances.</p> <p>If you want to delegate all jersey extensions to HK2 then use:</p> <pre><code>GuiceBundle.builder()\n    ...\n   .useHK2ForJerseyExtensions()\n   .build() \n</code></pre> <p>(It is the same as if you annotate all jersey extensions with <code>@JerseyManaged</code>)</p> <p>After enabling, all jersey extensions will be created by HK2.  Option requires HK2-guice bridge (error will be thrown if bridge is not available in classpath) to use guice services inside HK2 managed beans.</p> <p>Warning</p> <p>Guice AOP will work only for instances created by guice, so after enabling this option you will not be able to use aop on jersey extensions.</p> <p>By analogy with <code>@JerseyManaged</code>, you can use <code>@GuiceManaged</code> to mark exceptional extensions, which must be still managed by guice.</p>"},{"location":"guide/hk2/#hk2-scope-debug","title":"HK2 scope debug","text":"<p>Special <code>HK2DebugBundle</code> bundle is provided to check that beans properly instantiated by guice or HK2  (and no beans are instantiated by both).</p> <p>It could be activated with shortcut:</p> <pre><code>.strictScopeControl();\n</code></pre> <p>Affects only beans installed by installers implementing <code>JerseyInstaller</code> (<code>ResourceInstaller</code>, <code>JerseyProviderInstaller</code> etc) because other extensions does not support delegation to HK2.</p> <p>Checks that beans annotated with <code>@GuiceManaged</code> are instantiated by guice and beans annotated with <code>@JerseyManaged</code> are created by HK2.</p> <p>In default guice-first mode non annotated beans are assumed to be instantiated in guice (and so error thrown if bean created in HK2 context). </p> <p>In HK2-first mode, error will be thrown if non annotated jersey extension is created by guice.</p>"},{"location":"guide/hooks/","title":"Configuration hooks","text":"<p>Guicey provides special mechanism for external configuration:</p> <pre><code>public class MyHook implements GuiceyConfigurationHook {\n    @Override\n    public void configure(GuiceBundle.Builder builder) throws Exception {\n        builder.bundles(new AdditinoalBundle());    \n    }       \n}\n</code></pre> <p>Hook implementation receive the same builder instance as used in <code>GuiceBundle</code>  and so it is able to change everything (for example, <code>GuiceyBundle</code> abilities are limited).</p> <p>Note</p> <p>Hooks intended to be used in tests (e.g. to activate some diagnostic tools or disable application parts) and to activate diagnostic/tracking tools on compiled application.</p>"},{"location":"guide/hooks/#registration","title":"Registration","text":"<p>When hook implemented as separate class it could be registered directly:</p> <pre><code>new MyHook().register()\n</code></pre> <p>For lambda-hook registration use:</p> <pre><code>ConfigurationHooksSupport.register(builder -&gt; { \n    // do modifications \n})\n</code></pre>"},{"location":"guide/hooks/#lifecycle","title":"Lifecycle","text":"<p>All hooks are executed just before guice bundle builder finalization (when you call last <code>.build()</code>  method of <code>GuiceBundle</code>). Hooks registered after this moment will simply be never used.           </p>"},{"location":"guide/hooks/#tests","title":"Tests","text":"<p>Note</p> <p>For hooks usage in tests there is a special test support (spock and junit).</p> <p>In context of tests, the most important hook modifications are:</p> <ul> <li>Change options</li> <li>Disable any bundle, installer, extension, module</li> <li>Register disable predicate (to disable features by package, registration source etc.)</li> <li>Override guice bindings</li> <li>Register additional bundles, extensions, modules (usually test-specific, for example guicey tests register  additional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations))</li> </ul>"},{"location":"guide/hooks/#diagnostic","title":"Diagnostic","text":"<p>Hooks could be activated on compiled application with a system property:</p> <pre><code>-Dguicey.hooks=com.company.MyHook1,com.company.MyHook2 \n</code></pre> <p>To simplify usage you can register hook alias:</p> <pre><code>GuiceBindle.builder()\n    .hookAlias(\"alias1\", MyHook1.class)\n    .hookAlias(\"alias2\", MyHook2.class)   \n</code></pre> <p>Now, hooks could be activated as: </p> <pre><code>-Dguicey.hooks=alias1,alias2 \n</code></pre> <p>Moreover, you will always see these aliases in application startup logs (to not forget about this abilities):</p> <pre><code>INFO  [2019-09-16 16:26:35,229] ru.vyarus.dropwizard.guice.hook.ConfigurationHooksSupport: Available hook aliases [ -Dguicey.hooks=alias ]: \n\n    alias1                    com.company.MyHook1\n    alias2                    com.company.MyHook2\n</code></pre> <p>Note</p> <p>By default, guicey register diagnostic hook to easily activate diagnostic reports on compiled application: <pre><code>-Dguicey.hooks=diagnistic\n</code></pre></p>"},{"location":"guide/installers/","title":"Installers","text":"<p>Installer is a core integration concept: every extension point has its own installer.  Installers are registered manually or detected by classpath scan.</p>"},{"location":"guide/installers/#default-installers","title":"Default installers","text":"<ul> <li>Rest resource </li> <li>Dropwizard task </li> <li>Dropwizard managed object </li> <li>Jetty lifecycle </li> <li>Health check </li> <li>Jersey extensions</li> <li>Jersey feature </li> <li>@EagerSingleton</li> <li>Plugins support</li> <li>Http servlet</li> <li>Http filter</li> <li>Servlet context, request, session listener</li> </ul> <p>Tip</p> <p>In real application more installers may be available due to 3<sup>rd</sup> party bundles. Use installers report to see all available installers. </p>"},{"location":"guide/installers/#how-it-works","title":"How it works","text":"<p>All registered manually extensions,  classes from classpath scan and unqualified guice bindings are recognized by registered installers:</p> <pre><code>public class FeatureInstaller{\n    boolean matches(Class&lt;?&gt; type);\n}\n</code></pre> <p>Detected extensions are bound to guice context either with default <code>binder.bind(foundClass)</code> or by installer itself (default binding is required to support guice <code>.requireExplicitBindings()</code> option).</p> <p>After injector creation, installers register extension in dropwizard (not necessary, but most often).  For example, installation of extension instance (obtained from injector <code>injector.getInstance(foundClass)</code>):</p> <pre><code>public interface InstanceInstaller&lt;T&gt; {    \n    void install(Environment environment, T instance);\n}\n</code></pre> <p>Jersey-related extensions are installed later, during jersey context startup:</p> <pre><code>public interface JerseyInstaller&lt;T&gt; {\n    void install(AbstractBinder binder, Injector injector, Class&lt;T&gt; type);\n}\n</code></pre> <p>Installers are ordered.</p> <p>Each extension is installed by only one installer!</p> <p>If extension could be recognized by more then one installers, it will be installed only by first  matching installer (according to installers order). </p>"},{"location":"guide/installers/#writing-custom-installer","title":"Writing custom installer","text":"<p>Just for example, suppose we have some scheduling framework and we want to detect extensions, implementing <code>ScheduledTask</code> class.</p> <p>First of all, installer must implement <code>FeatureInstaller</code> interface. Here extension detection must be implemented</p> <pre><code>public class ScheduledInstaller implements FeatureInstaller {\n     @Override\n    public boolean matches(final Class&lt;?&gt; type) {\n        return FeatureUtils.is(type, ScheduledTask.class);\n    }\n\n    // NOTE: report() method will describe later\n}  \n</code></pre> <p>Next, installer must register extension somehow. There may be different options:</p> <ul> <li><code>BindingInstaller</code> allows custom guice bindings. If installer doesn't implement this interface simple <code>bind(type)</code> will be called to register in guice.</li> <li><code>TypeInstaller</code> used for registration based on type (no instance created during installation).</li> <li><code>InstanceInstaller</code> used for instance registration. Instance created using <code>injector.getInstance(type)</code>.</li> <li><code>JerseyInstaller</code> used for registration of bindings in HK2 context.</li> </ul> <p>Note that extensions may use <code>@LazyBinding</code> annotation. In general case such extensions will not be registered in guice. In case of <code>BindingInstaller</code>, special hint will be passed and installer should decide how to handle it (may throw exception as not supported).</p> <p><code>BindingInstaller</code> called in time of injector creation, whereas <code>TypeInstaller</code> and <code>InstanceInstaller</code> are called just after injector creation. <code>JerseyInstaller</code> is called on jersey start.</p> <p>Installers are not guice beans! So injections can't be used inside them.  This is because installers also used during initialization phase and instantiated before injector creation.</p> <p>For example, our installer would register extension instance into some scheduler framework:</p> <pre><code>public class ScheduledInstaller implements FeatureInstaller,\n                                           InstanceInstaller&lt;ScheduledTask&gt; {\n    ...    \n\n    @Override\n    public void install(Environment environment, ScheduledTask instance) {\n        SchedulerFramework.registerTask(instance);\n    }   \n}\n</code></pre> <p>Tip</p> <p><code>TypeInstaller</code> and <code>InstanceInstaller</code> could access injector with <pre><code>InjectorLookup.getInjector(environment).get();\n</code></pre></p> <p>And shared state: <pre><code>SharedConfigurationState.get(environment).get();\n</code></pre></p> <p>The last remaining part is reporting - we must see all installed beans in console:</p> <pre><code>public class ScheduledInstaller implements FeatureInstaller,\n                                           InstanceInstaller&lt;ScheduledTask&gt; {\n\n    private final Reporter reporter = \n            new Reporter(ScheduledInstaller.class, \"scheduled tasks =\");\n    ...    \n\n    @Override\n    public void install(Environment environment, ScheduledTask instance) {\n        SchedulerFramework.registerTask(instance);\n        // register for reporting\n        reporter.line(\"(%s)\", FeatureUtils.getInstanceClass(instance).getName());\n    }   \n\n    @Override\n    public void report() {\n        reporter.report();    \n    }\n}\n</code></pre> <p>Report method will be called automatically after all extensions installation. More complex installers may require special reporter (like jersey extensions installer). </p> <p>Another example, suppose <code>CustomFeature</code> is a base class for our jersey extensions.  Then installer will be:</p> <pre><code>public class CustomInstaller implements FeatureInstaller, JerseyInstaller&lt;CustomFeature&gt; {\n    @Override\n    public boolean matches(final Class&lt;?&gt; type) {\n        return FeatureUtils.is(type, CustomFeature.class);\n    }\n\n    @Override\n    public void install(final AbstractBinder binder, final Class&lt;CustomFeature&gt; type) {\n        JerseyBinding.bindComponent(binder, type, false, false); \n        ...\n    }\n\n    @Override\n    public void report() { \n        ...\n    }\n}\n</code></pre> <p>Jersey extensions are more usually complex due to binding aspects (especially for native jersey extensions). But, hopefully you'll never need to do it yourself. </p> <p>Tip</p> <p>For jersey installers see <code>AbstractJerseyInstaller</code> base class, containing common utilities.</p>"},{"location":"guide/installers/#ordering","title":"Ordering","text":"<p>In order to support ordering, installer must implement <code>Ordered</code> interface.</p> <p>Important</p> <p>If installer doesn't implement <code>Ordering</code> extensions will not be sorted,  even if extensions has <code>@Order</code> annotations. </p> <p>As example, see ManagedInstaller</p>"},{"location":"guide/installers/#options","title":"Options","text":"<p>Installer could also use guicey options: </p> <ul> <li>it must implement <code>WithOptions</code> marker interface</li> <li>or extend form <code>InstallerOptionsSupport</code> base class (implemented boilerplate)</li> </ul>"},{"location":"guide/installers/#reporting","title":"Reporting","text":"<p>Installers <code>report()</code> method will be called after it finish installation of all found extensions. Report provides user visibility of installed extensions. </p> <p>To simplify reporting use predefined Reporter class.  See example usage in ManagedInstaller</p> <pre><code>INFO  [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.support.feature.DummyManaged)\n</code></pre> <p>For complex cases, reporter may be extended to better handle installed extensions. As examples see  plugin installer reporter and provider installer reporter</p> <pre><code>INFO  [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins =\n\n    Set&lt;PluginInterface&gt;\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1)\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2)\n\n    Map&lt;DummyPluginKey, PluginInterface&gt;\n        ONE        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1)\n        TWO        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)\n</code></pre>"},{"location":"guide/installers/#generics","title":"Generics","text":"<p>Guicey brings generics-resolver which you  can use in installers implementation.</p> <p>For example, to get extension interface parametrization:</p> <pre><code>interface Extension&lt;V&gt; {}\n\nclass ListExtension implements Extension&lt;List&lt;String&gt;&gt; {}\n\nGenericsResolver.resolve(ListExtension.class)\n        .type(Extension.class)\n        .genericType(\"V\") == List&lt;String&gt; // (ParameterizedType) \n</code></pre> <p>Guicey itself use it for:</p> <ul> <li>types resolution during configuration introspection (<code>ConfigTreeBuilder</code>)</li> <li>to introspect type hierarchy and recognize all jersey extensions (<code>JerseyProviderInstaller</code>)</li> <li>format type for console reporting (<code>ProviderReporter</code>) </li> <li>bing jersey extensions to correct types (<code>JerseyBinding</code>) </li> </ul>"},{"location":"guide/lifecycle/","title":"Guicey lifecycle","text":"<p>Tip</p> <p>Guicey broadcast events in all major points. You can see most of them with enabled lifecycle report.     </p>"},{"location":"guide/lifecycle/#configuration-phase","title":"Configuration phase","text":"<p>Note</p> <p>All manual registrations must be performed under this phase (the only exception is  guice modules). All bundles are registered and initialized only under configuration phase.</p> <p>Everything below happens under bundle registration call:</p> <pre><code>@Override\npublic void initialize(Bootstrap&lt;Configuration&gt; bootstrap) {\n    bootstrap.addBundle(GuiceBundle.builder()\n            ...\n            .build());\n\n    // everything here will be called after all steps below\n}\n</code></pre> <ul> <li>Main bundle configuration</li> <li>Apply configuration hooks</li> <li>All option values set and can't be modified anymore.</li> <li>Apply registered dropwizard bundles (init delayed to count  dropwizard bundle disables).  </li> <li>Perform classpath scan (if configured). Scan resolve all classes in configured packages to use  them later for detection.  </li> <li>Perform bundles lookup</li> <li>Initialize bundles </li> <li>Search for commands (if classpath scan enabled)</li> <li>Prepare installers:<ul> <li>Detect installers with classpath scan (if configured)</li> <li>Instantiate not disabled installers</li> </ul> </li> <li>Resolve extensions:<ul> <li>Validate all enabled manually registered extensions: one of prepared installers must recognize extension or error will be thrown.</li> <li>Recognize extensions from classpath scan classes (if configured)              </li> </ul> </li> </ul>"},{"location":"guide/lifecycle/#run-phase","title":"Run phase","text":"<ul> <li>Run bundles<ul> <li>Guice modules may be registered here</li> <li>Extensions may still be disabled</li> </ul> </li> <li>Autowire modules</li> <li>Analyze enabled modules<ul> <li>Detect extensions from bindings</li> <li>Remove disabled modules and disabled extensions</li> <li>Re-package modules (to avoid duplicate modules parsing by guice)</li> <li>Register <code>GuiceBootsrapModule</code> </li> <li>Apply overriding modules</li> </ul> </li> <li>Create injector (with injector factory)<ul> <li><code>GuiceBootsrapModule</code> configures:<ul> <li>Additional bindings (like environment,  configuration and jersey-objects)</li> <li>Performs extensions registration (either default binding or specific,  performed by <code>BindingInstaller</code>)</li> <li>Register <code>GuiceFeature</code> (jersey <code>Feature</code>), which will perform jersey initialization</li> <li>Activate guice ServletModule support </li> </ul> </li> <li>Since that moment injector could be referenced statically</li> </ul> </li> <li>Install extensions (except jersey extensions)</li> <li>Inject commands</li> </ul> <p>Note</p> <p>As dropwizard bundles were registered under <code>GuiceBundle</code> configuration, they will be run by dropwizard after <code>GuiceBundle</code>.</p> <p>Note</p> <p>Your <code>Application.run()</code> method will be called after guicey startup, so you can use created  injector there.   </p>"},{"location":"guide/lifecycle/#jersey-startup","title":"Jersey startup","text":"<p>Note</p> <p>Jersey startup will initiate hk2 context creation</p> <ul> <li>Managed beans started</li> <li>hk2 context creation activates <code>GuiceFeature</code> (registered earlier)<ul> <li>Apply guice bridge (if required)</li> <li>Run jersey specific installers (resource, extension): installers will register required bindings in hk2 context</li> </ul> </li> </ul> <p>Note</p> <p>Any <code>EnvironmentCommand</code> did no start jersey, so managed objects will not be started (but you can start required  services manually). Also, all jersey related extensions will not be started. Still, core guice context will be completely operable. </p> <p>When guice context is created, jersey context doesn't exist and when jersey context is created it doesn't aware of guice existence.</p>"},{"location":"guide/modules/","title":"Modules","text":"Module Description Admin REST Admin context rest support. Lifecycle annotations <code>@PostConstruct</code>, <code>@PostStartup</code>, <code>@PreDestroy</code> support EventBus Guava eventbus integration JDBI3 JDBI3 integration (based on dropwizard-jdbi3) SPA HTML5 routing support for single page applications Server pages JSP-like templates support (based on dropwizard-views) Validation use validation annotations on guice beans (same behaviour as rest)"},{"location":"guide/options/","title":"Options","text":"<p>Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific, options are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours.</p> <p>Options are declared with enums. Enums used to naturally group options (also cause pretty reporting).  Enums must implement <code>Option</code> interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum), but provides required option info).</p> <p>Guicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through <code>GuiceyOptions</code> enum (for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle). Another use is in web installers to change default behaviour though <code>InstallersOptions</code> enum. </p> <p>Custom options may be defined for 3<sup>rd</sup> party bundle or even application. Options is a general mechanism providing configuration and access points with  standard reporting (part of diagnostic reporting). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize application state in tests (just to name a few).</p>"},{"location":"guide/options/#usage","title":"Usage","text":"<p>Options may be set only in main GuiceBundle using <code>.option</code> method. This is important to let configuration parts to see the same values. For example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and, for sure, this will eventually lead to inconsistent behaviour.</p> <p>Option could not be set to null. Option could be null only if it's default value is null and custom value not set. Custom option value is checked for compatibility with option type (from option definition) and error thrown if does not match. Of course, type checking is limited to top class and generics are ignored (so <code>List&lt;String&gt;</code> could not be specified and so can't be checked), but it's a compromise between complexity and easy of use (the same as <code>Enum &amp; Option</code> pair).</p> <p>Options could be accessed by:</p> <ul> <li>Guicey bundles using <code>bootstrap.option()</code></li> <li>Installer by implementing <code>WithOptions</code> interface </li> <li>Any guice bean could inject <code>Options</code> bean and use it to access options.</li> <li>Guice module could access options by implementing <code>OptionsAwareModule</code> marker interface</li> </ul> <p>Guicey tracks options definition and usage and report all used options as part of diagnostic reporting. Pay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options.</p> <p>Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used. Try to consume options closer to actual usage to let user be aware if option not used with current configuration. For example, GuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.</p>"},{"location":"guide/options/#custom-options","title":"Custom options","text":"<p>Options must be enum and implement <code>Option</code> interface, like this:</p> <pre><code>enum MyOptions implements Option {\n\n    DoExtraWork(Boolean, true),\n    EnableDebug(Boolean, false),\n    InternalConfig(String[], new String[]{\"one\", \"two\", \"three\"});\n\n    private Class type\n    private Object value\n\n    // generic used only to check type - value correctness\n    &lt;T&gt; SampleOptions(Class&lt;T&gt; type, T value) {\n        this.type = type\n        this.value = value\n    }\n\n    @Override\n    public Class getType() {\n        return type\n    }\n\n    @Override\n    public Object getDefaultValue() {\n        return value\n    }\n}\n</code></pre> <p>Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value. This will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []).</p> <p>Now you can use option, for example, in bean:</p> <pre><code>import static MyOptions.DoExtraWork;\n\npublic class MyBean {\n    @Inject Options options;\n\n    pulic void someMethod() {\n        ... \n        if (options.get(DoExtraWork)) {\n            // extra work impl\n        }\n    }\n}\n</code></pre> <p>To provide custom option value:</p> <pre><code>    GuiceBundle.builder()\n        .option(DoExtraWork, false)\n        ...\n</code></pre>"},{"location":"guide/options/#options-lookup","title":"Options lookup","text":"<p>Guicey provides simple mapping utility to map properties to system properties, environment variables  or simply bind from string (obtained manually somewhere). </p> <pre><code>GuiceBundle.builder()\n    ...\n    .options(new OptionsMapper()\n                    .prop(\"myprop\", Myoptions.SomeOption)\n                    .env(\"STAGE\", GuiceyOptions.InjectorStage)\n                    .string(Myoptions.SomeOtherOption, \"property value\")\n                    .map()) \n    .build()                \n</code></pre> <p>Here:</p> <ul> <li><code>Myoptions.SomeOption</code> could be changed with \"myprop\" system property (<code>-Dmyprop=something</code>)</li> <li><code>GuiceyOptions.InjectorStage</code> could be changed with environment variable \"STAGE\"</li> <li><code>Myoptions.SomeOtherOption</code> set from string (string could be obtained somewhere else manually) </li> </ul> <p>Important</p> <p>Missed mappings are ignored: e.g. if system property or environment variable is not  defined - option will remain with default value (null will not be set!)</p>"},{"location":"guide/options/#supported-conversions","title":"Supported conversions","text":"<p>Each option declares required option type</p> <p>Mapper could automatically convert string to:</p> <ul> <li>String</li> <li>Boolean</li> <li>Integer</li> <li>Double</li> <li>Short</li> <li>Byte</li> <li>Enum constant: <ul> <li>If option type is exact enum then value must be constant name</li> <li>If option type is generic <code>Enum</code> then value must be 'fullEnumClass.constantName'</li> </ul> </li> <li>Array or any type (from above): values must be separated by comma (\"one, two, three\")</li> <li>EnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName')   </li> </ul> <p>Tip</p> <p>You can use sting conversion directly somewhere else, if required: <code>StringConverter.convert(TargetType, stringValue)</code></p> <p>Exception is thrown when type is not supported for conversion. In this case use manual converter:</p> <pre><code>new OptionsMapper()\n            .prop(\"myprop\", Myoptions.SomeOption, val -&gt; convertVal(val))\n            .map()\n</code></pre> <p>Converter is actually any <code>java.util.Function</code> (here, lambda with method call (<code>::convertVal</code>)).</p>"},{"location":"guide/options/#system-properties","title":"System properties","text":"<p>As shown before, you can bind single system property to option. But you can also allow to set any option with system property:</p> <pre><code>new OptionsMapper().props().map()\n</code></pre> <p>It will bind all properties in format: <code>option.enumClasName.enumValue</code>. For example, <code>-Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true</code> </p> <p>Different prefix could be used: <code>.props(\"myprefix\")</code> </p> <p>Warning</p> <p>All properties with matched prefix must be mappable to option (target enum exists), otherwise error will be thrown.</p> <p>If any property requires custom value conversion then bind it before with converter and it will be ignored during mass mapping by prefix:</p> <pre><code>new OptionsMapper()\n        .prop(\"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\", \n                GuiceyOptions.UseHkBridge, val - &gt; convert(val))\n        .props()\n        .map()\n</code></pre>"},{"location":"guide/options/#debug","title":"Debug","text":"<p>You can enable mapped options print with <code>.printMappings()</code>:</p> <pre><code>new OptionsMapper()\n            .prop(\"myprop\", Myoptions.SomeOption, val -&gt; convertVal(val))\n            .printMappings()\n            .map()\n</code></pre> <p>When enabled, all mapped options will be printed to console (logger is not used because it's not yet initialized).</p> <p>Example output: <pre><code>    env: VAR                   Opts.OptInt = 1\n    prop: foo                  Opts.OptStr = bar\n                               Opts.OptBool = true\n</code></pre></p> <p>for mapper: <pre><code>new OptionsMapper()\n        .printMappings()\n        .env(\"VAR\", Opts.OptInt)\n        .env(\"VAR2\", Opts.OptDbl)\n        .prop(\"foo\", Opts.OptStr)\n        .prop(\"foo2\", Opts.OptShort)\n        .string(Opts.OptBool, \"true\")\n        .map()\n</code></pre></p> <p>Here \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped. </p>"},{"location":"guide/options/#custom-lookup","title":"Custom lookup","text":"<p>You can directly specify map of options (<code>.options(Map&lt;Enum, Object&gt;)</code>) or write your own lookup mechanism:</p> <pre><code>    GuiceBundle.builder()\n        .options(new MyOptionsLookup().getOptions())\n        ...\n</code></pre> <p><code>.options()</code> method contract simplified for just <code>Enum</code>, excluding <code>Option</code> for  simpler usage, but still only option enums must be provided</p>"},{"location":"guide/ordering/","title":"Ordering","text":"<p>Note</p> <p>Guicey always preserve items registration order, which may be changed only  by using explicit <code>@Order</code> annotation).</p>"},{"location":"guide/ordering/#general","title":"General","text":"<p>Order is natural. For example, <code>@Order(10)</code> will be before <code>@Order(20)</code>.</p> <p>When no annotation present, class order set to <code>Integer.MAX_VALUE</code>, so all classes without order annotation are always goes last.</p>"},{"location":"guide/ordering/#extensions-order","title":"Extensions order","text":"<p>Note</p> <p>Not all extensions supports ordering: look specific installer page or  installers report.     For example, managed, servlets and  filters installers support order.</p> <p>The most common case for ordering is ordering managed objects. For example:</p> <pre><code>@Order(20)\npublic class Managed1 implements Managed { ... }\n\n@Order(10)\npublic class Managed2 implements Managed { ... }\n\npublic class Managed3 implements Managed { ... }\n</code></pre> <p>Will be ordered as: <code>Managed2</code>, <code>Managed1</code>, <code>Managed3</code></p> <p>Note</p> <p>Guicey remembers extensions registration order:</p> <pre><code>.extensions(Ext1.class, Ext2.class)\n</code></pre> <p>So when no explicit ordering defined (or for elements with the same order value) registration order will be preserved.  </p> <p>Tip</p> <p>You can use diagnostic report to see actual extensions order. </p>"},{"location":"guide/ordering/#installers-order","title":"Installers order","text":"<p>All bundled installers are ordered from 0 to ~110 with gap 10 between them to let you easily put your installers between (if required).</p> <p>Use <code>@Order</code> annotation to order custom installer, otherwise it will go after all default installers.</p> <p>Tip</p> <p>You can use installers report to see actual installers order.</p>"},{"location":"guide/ordering/#bundles-order","title":"Bundles order","text":"<p>Attention</p> <p>Bundles can't be explicitly ordered.</p> <p>Bundles are transitive and transitive registrations appear at the middle of bundle configuration, so it is physically impossible to order bundles.</p> <p>Still there are implicit order of bundle processing:</p> <ul> <li>Manually registered bundles (including transitive)</li> <li>Bundles lookup</li> </ul> <p>But, again, don't count on this order because, for example, bundle resolved through lookup mechanism could be also manually registered and so processed with manual bundles.</p>"},{"location":"guide/ordering/#modules-order","title":"Modules order","text":"<p>Attention</p> <p>Modules can't be explicitly ordered.</p> <p>According to guice guice: modules should not contain conditional logic So modules should only register bindings and order does not matter in that case.</p>"},{"location":"guide/scan/","title":"Classpath scan","text":"<p>Summary</p> <p>Use scan only for application package. When part of application extracted to its own library (usually already mature part)  create guicey bundle for it with explicit extensions definition. Use manual bundles installation  or bundle lookup mechanism to install custom bundles.</p>"},{"location":"guide/scan/#configuration","title":"Configuration","text":"<p>Classpath scanning is activated by specifying package to scan in bundle:</p> <pre><code>GuiceBundle.builder()\n    .enableAutoConfig(\"package.to.scan\")\n</code></pre> <p>Or multiple packages:</p> <pre><code>GuiceBundle.builder()\n    .enableAutoConfig(\"com.mycompany.pkg1\", \"com.mycompany.pkg2\")\n</code></pre> <p>If no packages specified, classpath scan would be activated for application package:</p> <pre><code>GuiceBundle.builder()\n    .enableAutoConfig()\n</code></pre> <p>(equivalent to <code>.enableAutoConfig(getClass().getPackage().getName())</code></p>"},{"location":"guide/scan/#filter-classes","title":"Filter classes","text":"<p>By default, classpath scanner checks all available classes, and the only way to avoid extension  recognition is <code>@InvisibleForScanner</code> annotation.</p> <p>Now custom conditions could be specified:</p> <pre><code>GuiceBundle.builder()\n    .autoConfigFilter(ignoreAnnotated(Skip.class))\n</code></pre> <p>In this example, classes annotated with <code>@Skip</code> would not be recognized.</p> <p>Note</p> <p>Assumed static import for <code>ClassFilters</code> utility, containing the most common cases. If required, raw predicate could be used: <pre><code>.autoConfigFilter(cls -&gt; !cls.isAnnotationPresent(Skip.class))\n</code></pre></p> <p>It is also possible now to implement spring-like approach when only annotated classes  are recognized:</p> <pre><code>GuiceBundle.builder()\n    .autoConfigFilter(annotated(Component.class, Service.class))\n</code></pre> <p>Here only extensions annotated with <code>@Component</code> or <code>@Service</code> would be recognized.</p> <p>Note</p> <p>This filter affects only extension search: installers and commands search does not use filters (because it would be confusing and error-prone).</p> <p>Tip</p> <p>Multiple filters could be specified: <pre><code>GuiceBundle.builder()\n    .autoConfigFilter(annotated(Component.class, Service.class))\n    .autoConfigFilter(ignoreAnnotated(Skip.class))\n</code></pre></p> <p>Auto config filter also affects extensions recognition from guice bindings and so could be used for ignoring extensions from bindings.</p> <p>It is also possible now to exclude some sub-packages from classpath scan:</p> <pre><code>GuiceBundle.builder()\n    .enableAutoConfig(\"com.company.app\")\n    .autoConfigFilter(ignorePackages(\"com.company.app.internal\"))\n</code></pre>"},{"location":"guide/scan/#private-classes","title":"Private classes","text":"<p>By default, guicey does not search extensions in protected and package-private classes:</p> <pre><code>public class Something {\n    static class Ext1 implements Managed {}\n    protected static class Ext2 implements Managed {}\n}\n</code></pre> <p>But such extensions could be enabled with:</p> <pre><code>GuiceBundle.builder()\n    .option(GuiceyOptions.ScanProtectedClasses, true)\n</code></pre>"},{"location":"guide/scan/#how-it-works","title":"How it works","text":"<p>When auto scan enabled:</p> <ul> <li>Extension installers are searched in classpath (classes implementing <code>FeatureInstaller</code>).</li> <li>Extensions are searched using registered installers (<code>FeatureInstaller#matches</code> method).</li> <li>If commands search is enabled (<code>.searchCommands()</code>), performs search for all classes extending <code>Command</code> and install them into bootstrap.</li> </ul> <p>Classes are searched in specified packages and all their subpackages. Abstract classes are ignored. </p> <p>Inner static classes are also resolved:</p> <pre><code>public abstract class AbstractExceptionMapper&lt;T extends Exception&gt; implements ExceptionMapper&lt;T&gt; {\n\n    @Provider\n    public static class FooExceptionMapper extends AbstractExceptionMapper&lt;IOException&gt; { ... }\n\n    @Provider\n    public static class BarExceptionMapper extends AbstractExceptionMapper&lt;ServletException&gt; { ... }\n}\n</code></pre> <p><code>FooExceptionMapper</code> and <code>BarExceptionMapper</code> would be detected and installed.</p>"},{"location":"guide/scan/#hide-class-from-scan","title":"Hide class from scan","text":"<p><code>@InvisibleForScanner</code> annotation hides class from scanner (for example, to install it manually or to avoid installation at all)</p> <pre><code>@Provider\n@InvisibleForScanner\npublic static class FooExceptionMapper extends AbstractExceptionMapper&lt;IOException&gt; { ... }\n</code></pre> <p>In this case <code>FooExceptionMapper</code> will be ignored by classpath scanner. But you still can install extension manually.</p> <p>Tip</p> <p>If you can't use annotation on extension for some reason, you can simply disable extension </p>"},{"location":"guide/scan/#motivation","title":"Motivation","text":"<p>Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). </p> <p>Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like reflections,  fast scanner or even jersey's internal classpath scan parse class structure instead of loading classes.  In general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal.  Moreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple).</p> <p>Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer. Actual application configuration could always be checked with diagnostic output), so there should not be any problems for using classpath scan for production too.</p> <p>Warning</p> <p>It's a bad idea to use classpath scan for resolving extensions from 3<sup>rd</sup> party jars. Group extensions from external  jars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often,  so it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions. If you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup  (enabled by default) which could load bundles with service loader definition.</p>"},{"location":"guide/shared/","title":"Shared configuration state","text":"<p>Sometimes, it is required to pass configuration values between different application parts or implement bundles communication. In these cases usually you have to use <code>ThreadLocal</code> (direct static fields can't  be used because it will make problems for tests).</p> <p>Attention</p> <p>Use it only when it's not possible to avoid.</p> <p>Guicey adds shared state support in order to replace all current and future hacks (and  so avoid unexpected side effects for tests).</p> <p>Shared state is created together with <code>GuiceBundle</code> creation and destroyed with application shutdown. Internally it is implemented as static map with value reference by application instance.</p> <p>Note</p> <p>Don't abuse it! It must be used only for edge cases. To better understand shared state usage, there is a special report.</p> <p>Guicey use it for storing <code>Injector</code> object (InjectorLookup is actually a shortcut for shared state access). Also, all main dropwizard objects are stored there for direct reference.</p> <p>SPA bundle use it to avoid colliding paths:</p> <pre><code>public class SpaBundle implements GuiceyBundle {\n    @Override\n    public void initialize(final GuiceyBootstrap bootstrap) {\n        // state shared between all spa bundles\n        // NOTE: not a static field for proper parallel tests support\n        bootstrap.sharedState(SpaBundleState.class, SpaBundleState::new).checkUnique(assetName);\n    }\n}\n\npublic class SpaBundleState {\n    private final List&lt;String&gt; usedAssetNames = new ArrayList&lt;&gt;();\n\n    public void checkUnique(final String assetName) {\n        checkArgument(!usedAssetNames.contains(assetName),\n                \"SPA with name '%s' is already registered\", assetName);\n        usedAssetNames.add(assetName);\n    }\n}\n</code></pre> <p>GSP bundles use it for bundles communication. Core bundle register global configuration:</p> <pre><code>public class ServerPagesBundle extends UniqueGuiceyBundle {\n    @Override\n    public void initialize(final GuiceyBootstrap bootstrap) {\n        loadRenderers();\n\n        // register global config\n        bootstrap\n                .shareState(ServerPagesGlobalState.class, config)\n    }\n}\n</code></pre> <p>Application bundle reference this state:</p> <pre><code>public class ServerPagesAppBundle implements GuiceyBundle {\n    @Override\n    public void initialize(final GuiceyBootstrap bootstrap) {\n        this.config = bootstrap.sharedStateOrFail(ServerPagesGlobalState.class,\n                \"Either server pages support bundle was not installed (use %s.builder() to create bundle) \"\n                        + \" or it was installed after '%s' application bundle\",\n                ServerPagesBundle.class.getSimpleName(), app.name);\n        // register application globally\n        config.register(app);\n    }\n}\n</code></pre> <p>This way, duplicate registrations could be checked, and global views support could be configured by application bundles. </p>"},{"location":"guide/shared/#shared-state-restrictions","title":"Shared state restrictions","text":"<p>Internally shared state is a <code>Map&lt;String, Object&gt;</code>, but state API force you to use Class as key for type safety: it is assumed that unique class would be created for shared state (even if you just need to store a simple value) and the stored object type would be a key.</p> <p>Other restrictions:</p> <ul> <li>State value can be set just once! This is simply to avoid hard to track problems with overridden state.</li> <li>State value can't be null! Again, to avoid problems with NPE errors.</li> </ul>"},{"location":"guide/shared/#state-usage-technics","title":"State usage technics","text":""},{"location":"guide/shared/#parent-child","title":"Parent-child","text":"<p>Value stored in one place (some parent bundle):</p> <pre><code>bootstrap.shareState(SomeState.class, config);\n</code></pre> <p>And accessed in some other place (other child bundle or module):</p> <pre><code>SomeState state = bootstrap\n        .sharedStateOrFail(SomeState.class, \"State not declared\");\n</code></pre> <p>Here, error would be thrown if state is not initialized.</p> <p>Note</p> <p>Guicey bundles registration works the same way as for dropwizard bundles: if you register some bundle from the core bundle, it would be initialized immediately.</p> <pre><code>public class MyBundle implements GuiceyBundle {\n    public void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        // assume bundle initialize shared state value\n        // (this bundle could be a unique bundle so guicey would remove duplicates)\n        bootstarp.bundles(new ParentBundle());        \n        // shared value could be used here\n        SomeState state = bootstrap\n            .sharedStateOrFail(SomeState.class, \"State not declared\");\n    }\n}\n</code></pre>"},{"location":"guide/shared/#indirect-registration","title":"Indirect registration","text":"<p>In some cases, we might have a \"race condition\" if we're not sure when state value is initialized (for example, two bundles could be declared in the different order).</p> <p>For such cases, there is delayed access:</p> <pre><code>bootstrap.whenSharedStateReady(SomeState.class, (state) -&gt; ...)\n</code></pre> <p>Important</p> <p>Listener could be not called at all if target value would not be initialized. All not used listeners could be seen in shared state report</p>"},{"location":"guide/shared/#first-wins","title":"First wins","text":"<p>As shown in the SPA example above, shared state may be used by different instances of the same bundle to perform global validations.</p> <p>In this case \"get or initialize\" approach used:</p> <pre><code>SomeState state = bootstrap.sharedState(SomeState.class, SomeState::new)\n</code></pre> <p>Here existing state would be requested (if already registered) or new one stored. </p>"},{"location":"guide/shared/#utility","title":"Utility","text":"<p>During startup shared state could be obtained with a static call:</p> <pre><code>SharedConfigurationState.getStartupInstance() \n</code></pre> <p>Static reference is possible only from the main application thread (which is always the case during initialization)</p> <p>Shared state holds references to the main dropwizard objects, see methods:</p> <ul> <li>getBootstrap()</li> <li>getApplication()</li> <li>getEnvironment()</li> <li>getConfiguration()</li> <li>getConfigurationTree()</li> <li>getInjector()</li> <li>getOptions()</li> </ul> <p>All of them return providers: e.g. <code>SharedConfigurationState.getStartupInstance().getBootsrap()</code> would return <code>Provider&lt;Bootstrap&gt;</code>. This is required because target object might not be available yet, still there would be a way to initialize some logic with \"lazy object\" (to call it later, when object would be available) at any configuration stage.</p>"},{"location":"guide/shared/#main-bundle","title":"Main bundle","text":"<p>It is assumed that there should be no need to access shared state from main bundle. So the only state-related method actually assumed to be used by hooks:</p> <pre><code>static class XHook implements GuiceyConfigurationHook {\n    @Override\n    void configure(GuiceBundle.Builder builder) throws Exception {\n        builder.withSharedState(state -&gt; {\n            state.put(XHook, new SharedObject());\n        });\n    }\n}\n</code></pre>"},{"location":"guide/shared/#guicey-bundle","title":"Guicey bundle","text":"<p>Shared state is assumed to be used by bundles. Bundle provides special shortcut methods  for accessing state. It is assumed that state is declared under initialization phase and could be accessed under both phases (but not restricted, so state could be declared in run phase too).</p> <p>For usage examples see decomposition section.</p>"},{"location":"guide/shared/#guice-modules","title":"Guice modules","text":"<p>Shared state is not intended to be used in guice modules, but it is possible.  To simplify usage there are shortcuts available in dropwizard aware module base class. </p>"},{"location":"guide/shared/#static-access","title":"Static access","text":"<p>If required, shared state could be accessed statically everywhere:</p> <pre><code>SharedConfigurationState.get(application)\n</code></pre> <p>Direct static access (<code>SharedConfigurationState.getStartupInstance()</code>) is available only during startup, at runtime you can reference state only with Environment or Application objects.</p> <p>Or direct value access:</p> <pre><code>SharedConfigurationState.lookup(application, XBundle.class)\n</code></pre> <p>And it is possible to use <code>Environment</code> instance for access:</p> <pre><code>SharedConfigurationState.get(environment)\nSharedConfigurationState.lookup(environment, XBundle.class)\n</code></pre> <p>Special shortcut methods may be used for \"get or fail behaviour\":</p> <pre><code>SharedConfigurationState.lookupOrFail(app, XBundle.class, \n        \"Failed to lookup %s service\", XBundle.class.getSimpleName())\n</code></pre> <p>It will throw IllegalStateException if shared context is not available or no value. Note that message is formatted with <code>String.format</code>. </p>"},{"location":"guide/shared/#tests","title":"Tests","text":"<p>Shared state is referenced by application instance, so there should not be any problems with tests.</p> <p>The only possible side effect is when you test many application startup error situations,  when application did not shutdown properly and so some shared contexts may not be removed. If it (hard to imagine how) will affect your tests, you can forcefully clean all states:</p> <pre><code>SharedConfigurationState.clear()\n</code></pre>"},{"location":"guide/shared/#default-objects","title":"Default objects","text":"<p>The following objects are available in shared state just in case:</p> <ul> <li>Bootstrap</li> <li>Environment</li> <li>Configuration</li> <li>ConfigurationTree</li> <li>Options</li> <li>Injector</li> </ul> <p>So any of it could be accessed statically with application or environment instance:</p> <pre><code>Optional&lt;Bootstrap&gt; bootstrap = SharedConfigurationState\n            .lookup(environment, Bootstrap.class);\n</code></pre> <p>or</p> <pre><code>Bootstrap bootstrap = SharedConfigurationState\n            .lookupOrFail(environment, Bootstrap.class, \"No bootstrap available\");\n</code></pre> <p>Tip</p> <p>During startup these objects might be referenced as lazy objects with shortcuts</p>"},{"location":"guide/web/","title":"Web features","text":""},{"location":"guide/web/#servlets-filters","title":"Servlets, filters","text":"<p>Servlets and filters could be registered either with guice ServletModule or using extensions.</p>"},{"location":"guide/web/#guice-servlet-module","title":"Guice servlet module","text":"<p>Example:</p> <pre><code>public class WebModule extends ServletModule {\n\n    @Override\n    protected void configureServlets() {\n        filter(\"/*\").through(MyFilter.class);\n        serve(\"/myservlet\").with(MyServlet.class);\n    }\n}  \n</code></pre> <p>Pros</p> <p>Only <code>ServletModule</code> allows mappings by regexp:</p> <pre><code>serveRegex(\"(.)*ajax(.)*\").with(MyAjaxServlet.class)\n</code></pre> <p>Warning</p> <p>It is important to note that <code>GuiceFilter</code> dispatch all requests for filters and servlets  registered by <code>ServletModule</code> internally and so you may have problems combining servlets from  <code>ServletModule</code> with filters in main scope.</p> <p>It is never a blocking issues, but often \"not obvious to understand\" situations.</p>"},{"location":"guide/web/#web-extensions","title":"Web extensions","text":"<p>Extensions declared with standard <code>jakarta.servlet</code> annotations.</p> <p>Servlet registration: </p> <pre><code>@WebServlet(\"/mapped\")\npublic class MyServlet extends HttpServlet { ... }\n</code></pre> <p>Extension recognized by <code>@WebServlet</code> annotation.</p> <p>Could be registered on admin context:</p> <pre><code>@WebServlet(\"/mapped\")\n@AdminContext\npublic class MyServlet extends HttpServlet { ... }\n</code></pre> <p>Or even on both contexts at the same time: <code>@AdminContext(andAdmin=true)</code>. </p> <p>Filter:</p> <pre><code>@WebFilter(\"/some/*\")\npublic class MyFilter implements Filter { ... }\n</code></pre> <p>Extension recognized by <code>@WebFilter</code> annotation. </p> <p>Web listeners (servlet, request, session):</p> <pre><code>@WebListener\npublic class MyListener implements ServletContextListener {...}\n</code></pre> <p>Extension recognized by <code>@WebListener</code> annotation.</p> <p>Pros</p> <p>Installation through extensions has more abilities comparing to <code>ServletModule</code>:</p> <ul> <li>Installation into admin context</li> <li>Async support</li> <li>Filter may be applied to exact servlet(s) (<code>@WebFilter(servletNames = \"servletName\")</code>)</li> <li>Request, servlet context or session listeners installation</li> </ul> <p>If you don't want to use web installers or have problems with it (e.g. because they use <code>jakarta.servlet</code> annotations) you can disable all of them at once by disabling bundle:</p> <pre><code>GuiceBundle.builder()\n    .disableBindles(WebInstallersBundle.class)\n    ...\n</code></pre>"},{"location":"guide/web/#manual-registration","title":"Manual registration","text":"<p>Alternatively, you can always register servlet or filter manually with dropwizard api:</p> <pre><code>public class App extends Application {\n    public void initialize(Bootstrap bootstrap) {\n        bootstrap.addBundle(GuiceBundle.builder().build());\n    }\n\n    public void run(Configuration configuration, Environment environment) {\n        final MyFilter filter = InjectorLookup.getInstance(this, MyFilterBean.class).get();\n        environment.servlets().addFilter(\"manualFilter\", filter)\n            .addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, \"/*\");\n    }\n}\n</code></pre>"},{"location":"guide/web/#resources","title":"Resources","text":"<p>Dropwizard provides AssetsBundle  for serving static files from classpath:</p> <pre><code>bootstrap.addBundle(new AssetsBundle(\"/assets/app/\", \"/\", \"index.html\"));\n</code></pre> <p><code>http://localhost:8080/foo.css</code> \u2192 <code>src/main/resources/assets/app/foo.css</code> <code>http://localhost:8080/</code> \u2192 <code>src/main/resources/assets/app/index.html</code></p>"},{"location":"guide/web/#html5-routing","title":"HTML5 routing","text":"<p>But, if you develop SPA application with HTML5 routes, server will not handle these routes properly. Use guicey SPA bundle which adds proper SPA routing support above dropwizard <code>AssetBundle</code> </p> <pre><code>GuiceBundle.builder()\n    .bundles(SpaBundle.app(\"spaApp\", \"/assets/app/\", \"/\").build());\n</code></pre> <p><code>http://localhost:8080/</code> \u2192 <code>src/main/resources/assets/app/index.html</code> <code>http://localhost:8080/route/path</code> \u2192 <code>src/main/resources/assets/app/index.html</code></p>"},{"location":"guide/web/#templates","title":"Templates","text":"<p>Dropwizard provides ViewBundle for handling templates (freemarker and mustache out of the box, more engines could be plugged).</p> <pre><code>bootstrap.addBundle(new ViewBundle());\n</code></pre> <p>Which allows you to serve rendered templates from rest endpoints.</p>"},{"location":"guide/web/#templates-resources","title":"Templates + resources","text":"<p>But it is not quite handful to use it together with static resources (AssetsBundle) because static resources will have different urls (as they are not served from rest).  </p> <p>If you would like to have JSP-like behaviour (when templates and resources live at the same location and so could easily reference each other) - then use guicey GSP bundle  (which is actually just a \"glue\" for dropwizard <code>ViewBundle</code> and <code>AssetsBundle</code>).</p> <pre><code>com/exmaple/app/\n    person.ftl\n    foo.ftl\n    style.css\n</code></pre> <pre><code>&lt;#-- Sample template without model (/foo.ftl) --&gt;\n&lt;html&gt;\n    &lt;body&gt;        \n        &lt;h1&gt;Hello, it's a template: ${12+22}!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;#-- Template with model, rendered by rest endpoint (/person/) --&gt;\n&lt;#-- @ftlvariable name=\"\" type=\"com.example.views.PersonView\" --&gt;\n&lt;html&gt;   \n    &lt;head&gt;  \n        &lt;link href=\"/style.css\" rel=\"stylesheet\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!-- calls getPerson().getName() and sanitizes it --&gt;\n        &lt;h1&gt;Hello, ${person.name?html}!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>public class PersonView extends TemplateView {\n    private final Person person;\n\n    public PersonView(Person person) {    \n        super('person.ftl');\n        this.person = person;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n}\n</code></pre> <pre><code>// Path starts with application name  \n@Path(\"/com.example.app/person/\")  \n@Produces(MediaType.TEXT_HTML)    \n// Important marker\n@Template\npublic class PersonPage {      \n\n    @Inject\n    private PersonDAO dao;\n\n    @GET  \n    @Path(\"/\")\n    public PersonView getMaster() {\n        return new PersonView(dao.find(1));\n    }    \n\n    @GET  \n    @Path(\"/{id}\")\n    public PersonView getPerson(@PathParam(\"id\") String id) {\n        return new PersonView(dao.find(id));\n    }   \n}\n</code></pre> <pre><code>GuiceBundle.builder()                                     \n    .bundles(\n             // global views support\n             ServerPagesBundle.builder().build(),\n             // application registration\n             ServerPagesBundle.app(\"com.example.app\", \"/com/example/app/\", \"/\")   \n                                 // rest path as index page\n                                 .indexPage(\"person/\")\n                                 .build());\n</code></pre> <p>Static resource call:</p> <p><code>http://localhost:8080/style.css</code> \u2192 <code>src/main/resources/com/example/app/style.css</code></p> <p>Direct template call:</p> <p><code>http://localhost:8080/foo.ftl</code> \u2192 <code>src/main/resources/com/example/app/foo.ftl</code></p> <p>Rest-driven template call:</p> <p><code>http://localhost:8080/person/12</code> \u2192 <code>/rest/com.example.app/person/12</code></p> <p>Index page:</p> <p><code>http://localhost:8080/</code> \u2192 <code>/rest/com.example.app/person/</code></p> <p>Summary</p> <p>Declaration differences from pure dropwizard views:</p> <ul> <li>Model extends <code>TemplateView</code></li> <li>Rest endpoints always annotated with <code>@Template</code></li> <li>Rest endpoints paths starts with registered application name (<code>ServerPagesBundle.app(\"com.example.app\"</code>) to be able to differentiate rest for different UI applications     </li> </ul> <p>Warning</p> <p>Standard errors handling in views (templates, custom pages) is replaced by  custom mechanism, required to implement per-ui-app errors support.</p>"},{"location":"guide/yaml-values/","title":"Yaml values","text":"<p>Guicey introspects <code>Configuration</code> object instance using jackson serialization api to allow direct access to yaml configuration values.</p> <p>Introspected configuration is accessible as:</p> <ul> <li>Direct guice bindigs for unique sub objects, and all properties</li> <li>Bindings for manually qualified properties</li> <li><code>ConfigurationTree</code> object (binding) containing all introspection data (could be used for manual searches and, for example, for reports)</li> <li>Guice modules and guicey bundles could access introspected configuration with help of <code>ConfigurationAwareModule</code> interface and <code>GuiceyEnvironment</code> object.</li> </ul> <p>Warning</p> <p>Jackson will see all properties that either have getter and setter or annotated with <code>@JsonProperty</code>. For example, <pre><code>public class MyConfig extends Configuration {\n\n    private String one // visible (getter and setter)\n    @JsonProperty\n    private String two // visible (annotation)\n    private String three // invisible (no getter)\n\n    public void setOne(String one) { ... }\n    public String getOne() { ... }\n\n    public void setTwo(String two) { ... }\n\n    public void setThree(String three) { ... }\n}\n</code></pre></p> <p>Tip</p> <p>To prevent binding of configuration property use <code>@JsonIgnore</code> on property getter <pre><code>private String prop\n\n// dropwizard will set value from yaml\npublic void setProp(Stirng prop) { ... }\n\n// property will not be available as path binding\n@JsonIgnore    \npublic String getProp() { ... }\n</code></pre></p> <p>Important</p> <p>Guice does not allow null value bindings  by default, so if you bind configuration property with null value injector creation would fail.</p> <p>To workaround it, use <code>@jakarta.inject.Nullable</code> for injected field.</p>"},{"location":"guide/yaml-values/#unique-sub-configuration","title":"Unique sub configuration","text":"<p>It is quite common to group configuration properties into sub objects like:</p> <pre><code>public class MyConfig extends Configuration {\n    @JsonProperty AuthConfig auth;\n    @JsonProperty DbConfig db;\n}\n</code></pre> <p>Guicey detects such unique objects and provides direct bindings for them:</p> <pre><code>@Inject @Config AuthConfig auth;\n@Inject @Config DbConfig db;\n</code></pre> <p>This is very useful for re-usable modules, which are not aware of your configuration  object structure, but require only one sub configuration object:</p> <pre><code>public class MyConfig extends Configuration {\n    @JsonProperty FeatureXConfig featureX;\n}\n</code></pre> <p>Somewhere in module service:</p> <pre><code>public class FeatureXService {\n    @Inject @Config FeatureXConfig featureX; \n}\n</code></pre> <p>Important</p> <p>Sub configuration object uniqueness is checked as direct match, so you may have <pre><code>@JsonProperty SubConfig sub\n@JsonProperty SubConfigExt subExt\n</code></pre> where <code>class SubConfigExt extends SubConfig</code>, but still both objects would be considered unique. Whereas <pre><code>@JsonProperty SubConfig sub1\n@JsonProperty SubConfig sub2\n</code></pre> will not.</p> <p>Tip</p> <p>Guicey bundles and guice modules also could use sub configuration objects directly: <pre><code>GuiceyEnvironment#configuration(SubConfig.class)\nDropwizardAwareModule#configuration(SubConfig.class)\n</code></pre></p>"},{"location":"guide/yaml-values/#qualified-bindings","title":"Qualified bindings","text":"<p>Automatic unique objects bindings require using guicey binding annotation.  In some cases, this is not possible: for example, generic 3<sup>rd</sup> party guice module.  You can use qualified bindings then.</p> <p>The idea is simple: just annotate any configuration property or getter with a qualified  annotation and it would be bound in guice context. Moreover, if multiple properties (same type!) would be annotated with the same annotation - they would be bound as <code>Set</code>.</p> <p>For example,</p> <pre><code>public class MyConfig extends Configuration {\n\n    @Named(\"custom\")\n    private String prop1;\n\n    @CustomQualifier\n    private SubObj obj1 = new SubObj();\n</code></pre> <p>Tip</p> <p>Custom qualifying annotation must be annotated with guice <code>@BindingAnnotation</code> or jakarta <code>@Qualifier</code> (see guice and jakarta <code>@Named</code> annotations as an example).</p> <pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})\n@BindingAnnotation\npublic @interface CustomQualifier {}\n</code></pre> <p>Would mean two additional bindings:</p> <pre><code>@Inject @Named(\"custom\") String prop1;\n@Inject @CustomQualifier SubObj obj1;\n</code></pre> <p>Important</p> <p>If you expect null values then identify it (otherwise injector creation would fail for null value):  <code>@Inject @Named(\"custom\") @jakarta.inject.Nullable String prop1;</code> </p> <p>And binding like this:</p> <pre><code>@Named(\"sub-prop\")\nprivate String prop2;\n@Named(\"sub-prop\")\nprivate String prop3;\n</code></pre> <p>Would result in aggregated binding:</p> <pre><code>@Inject @Named(\"sub-prop\") Set&lt;String&gt; prop23;\n</code></pre> <p>Note</p> <p>Qualifying annotations may be used on any configuration depth (not only in the root  configuration object).</p> <p>Core dropwizard objects could also be bound with a qualified overridden getter:</p> <pre><code>@Named(\"metrics\")  \n@Override\nMetricsFactory getMetricsFactory() {\n    return super.getMetricsFactory();\n}\n</code></pre> <p>Note</p> <p>All custom bindings are visible in the configuration report: <code>.printCustomConfigurationBindings()</code></p> <p>Tip</p> <p>Guicey bundles and guice modules also could use qualified configuration values directly: <pre><code>GuiceyEnvironment#annotatedConfiguration(Ann.class)\nDropwizardAwareModule#annotatedConfiguration(Ann.class)\n</code></pre></p>"},{"location":"guide/yaml-values/#configuration-by-path","title":"Configuration by path","text":"<p>All visible configuration paths values are directly bindable:</p> <pre><code>public class MyConfig extends Configuration {\n    SubConf sub;\n}\n\npublic class SubConf {\n    String smth;\n    List&lt;String&gt; values;\n}\n</code></pre> <pre><code>@Inject @Config(\"sub\") SubConf sub;\n@Inject @Config(\"sub.smth\") String smth;\n@Inject @Config(\"sub.values\") List&lt;String&gt; values;\n</code></pre> <p>Note</p> <p>Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations).  The only exception is conditional mapping like dropwizard \"server\" when available paths could change, depending on configuration (what configuration class will be used)</p> <p>Note</p> <p>Generified types are bound only with generics (with all available type information). If you will have <code>SubConf&lt;T&gt; sub</code> in config, then it will be bound with correct generic <code>SubConfig&lt;String&gt;</code> (suppose generic T is declared as String).</p> <p>Value type, declared in configuration class is used for binding, but there are two exceptions.</p> <p>If declared type is declared as collection (Set, List, Map) implementation then binding will use base collection interface:</p> <pre><code>ArrayList&lt;String&gt; value\n\n@Inject @Config(\"value\") List&lt;String&gt; vlaue;\n</code></pre> <p>If, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence:</p> <ul> <li><code>@Config(\"path\") Object val</code> - when value is null</li> <li><code>@Config(\"path\") ValueType val</code> - actual value type, when value is not null       </li> </ul> <p>It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\").</p> <p>Tip</p> <p>You can declare you own additional bindings using <code>ConfigurationTree</code> (accessible from guice module),  which contains all paths information (including declaration and actual types with generics).</p>"},{"location":"guide/yaml-values/#introspected-configuration","title":"Introspected configuration","text":"<p><code>ConfigurationTree</code> object provides access for introspected configuration tree:</p> <ul> <li><code>getRootTypes()</code> - all classes in configuration hierarchy (including interfaces)</li> <li><code>getPaths()</code> - all paths (including all steps (\"sub\", \"sub.value\"))</li> <li><code>getUniqueTypePaths()</code> - paths of unique sub configuration types</li> </ul> <p>Each path item (<code>ConfigPath</code>) contains:</p> <ul> <li>Root path reference (\"sub.value\" reference \"sub\")</li> <li>Child sub-paths (\"sub\" reference \"sub.value\")</li> <li>Declaration class (type used in configuration class)</li> <li>Value type (type of actual value; when value null - declaration type (but they still could be different for collections))</li> <li>Current path name</li> <li>Current path value</li> <li>Generics for declaration and value types (may be incomplete for value type)</li> <li>Custom type marker: contains sub paths or just looks like sub configuration</li> <li>Declaration type (class where property was declared - configuration object containing property)</li> </ul> <p>You can traverse up or down from any path (tree structure).</p> <p><code>ConfigurationTree</code> provides basic search methods (more as usage example):</p> <ul> <li><code>findByPath(String)</code> - search path by case-insensitive match</li> <li><code>findAllByType(Class)</code> - find all paths with assignable declared value</li> <li><code>findAllFrom(Class&lt;? extends Configuration&gt;)</code> - find all paths, started in specified configuration class</li> <li><code>findAllRootPaths()</code> - get all root paths (1<sup>st</sup> level paths) </li> <li><code>findAllRootPathsFrom(Class&lt;? extends Configuration&gt;)</code> - all 1<sup>st</sup> level paths of configuration class</li> <li><code>valueByPath(String)</code> - return path value or null if value null or path not exists</li> <li><code>valuesByType(Class)</code> - all not null values with assignable type</li> <li><code>valueByType(Class)</code> - first not null value with assignable type</li> <li><code>valueByUniqueDeclaredType(Class)</code> - value of unique sub configuration or null if value is null or config is not unique</li> </ul> <p>Methods to work with qualified configurations:</p> <ul> <li><code>findAllByAnnotation(ann | Class)</code> - find all annotated properties by annotation instance or annotation class</li> <li><code>findByAnnotation(ann | Class)</code> - find exactly one annotated property or throw error if more then one found</li> <li><code>annotatatedValues(ann | Class)</code> - all non-null values from annotated properties</li> <li><code>annotatatedValue(ann | Class)</code> - an annotated property value (throw error if more properties annotated)</li> </ul> <p>Tip</p> <p>Searching by annotation instance if required for annotations with \"state\". For example, <code>@Named(\"something\")</code> and <code>@Named(\"other\")</code> are different qualifying annotations, and searching only by type would be incorrect in this case.</p> <p>It is not possible to directly create annotation instance, but any annotation is and interface and could be implemented. It is important that real annotation (from class) and provided object would be equal. As an example see how guice <code>Names.named()</code> consrtructs \"@Named\" insatnces.</p> <p>Paths are sorted by configuration class (to put custom properties upper) and by path name (for predictable paths order).</p>"},{"location":"guide/yaml-values/#disable-configuration-introspection","title":"Disable configuration introspection","text":"<p>Introspection process should not fail application startup. In worse case it will show warning log that property can't be introspected:</p> <pre><code>WARN  [2018-07-23 09:11:13,034] ru.vyarus.dropwizard.guice.module.yaml.ConfigTreeBuilder: Can't bind configuration \npath 'sub.sample' due to IllegalArgumentException: Failed to getValue() with method \nru.vyarus.dropwizard.guice.yaml.support.FailedGetterConfig#getSample(0 params): null. Enable debug logs to \nsee complete stack trace or use @JsonIgnore on property getter.\n</code></pre> <p>Such warnings could be hidden by using <code>@JsonIgnore</code> on property getter.</p> <p>If this is not enough, or you need to avoid configuration introspection for other reasons, you can disable introspection completely with option:</p> <pre><code>GuiceBundle.builder()\n    .option(GuiceyOptions.BindConfigurationByPath, false)\n    ...\n</code></pre> <p>When introspection disabled, only configuration object would be bound and  bindings by path would not be available. Note that even <code>ConfigurationTree</code> object will not  contain configuration paths (option completely disables introspection mechanism).</p>"},{"location":"guide/diagnostic/aop-report/","title":"AOP report","text":"<p>Guice AOP report shows all registered aop handlers and how (what order) they apply to guicey beans. </p> <pre><code>GuiceBundle.builder()\n    ...\n    .printGuiceAopMap()     \n    .build()\n</code></pre> <p>Example output:</p> <pre><code>    2 AOP handlers declared\n    \u251c\u2500\u2500 AopModule/Interceptor1                                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.AopModule.configure(AopModule.java:23)\n    \u2514\u2500\u2500 AopModule/Interceptor2                                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.AopModule.configure(AopModule.java:24)\n\n\n    1 bindings affected by AOP\n    \u2502\n    \u2514\u2500\u2500 Service    (r.v.d.g.d.r.g.s.AopModule)\n        \u251c\u2500\u2500 something()                                                       Interceptor1\n        \u2514\u2500\u2500 somethingElse(List)                                               Interceptor1, Interceptor2\n</code></pre> <p>This report shows all affected beans with all methods. In real application it may lead to the giant report. In real life it would be more suitable to always fine-tune report as a tool.</p> <p>Important</p> <p>Report is build using guice SPI from raw modules because it's the only way to detect  registered aop listeners. But this also cause an additional execution of <code>configure()</code> method of all modules when report is enabled.</p> <p>In most cases, this is not a problem (modules should only declare bindings). Report use stage <code>TOOL</code>, so, if required, you can easilly avoid duplicate execution for sensitive logic:  <pre><code>if (binder.currentStage() != Stage.TOOL) {\n    // do only on normal run\n}\n</code></pre> For example, guicey itself use this in installers to avoid duplicate console output on startup when report enabled.</p> <p>Kotlin</p> <p>If you're using kotlin, keep in mind that it makes methods final by default so guice will not be able to apply aop. The workaround is to put open keyword before method.  </p>"},{"location":"guide/diagnostic/aop-report/#tool","title":"Tool","text":"<p>Important</p> <p>Report is intended to be used as a tool in order to reveal aop on exact bean or even method (or showing appliances of exact handler).</p> <p>Partial aop map activation:</p> <pre><code>.printGuiceAopMap(new GuiceAopConfig()\n                .types(...)\n                .methods(...)\n                .interceptors(...))\n</code></pre> <p>Where usual guice matchers used for type and method matching.</p> <p>For example, to see only bindings of exact bean:</p> <pre><code>.printGuiceAopMap(new GuiceAopConfig()\n            .types(Matchers.subclassesOf(MyService.class)))\n</code></pre> <p>All methods returning <code>List</code>:</p> <pre><code>.printGuiceAopMap(new GuiceAopConfig()\n                .methods(Matchers.returns(Matchers.subclassesOf(List))))\n</code></pre> <p>All appliances of exact interceptor:</p> <pre><code>.printGuiceAopMap(new GuiceAopConfig()\n                .hideDeclarationsBlock()\n                .interceptors(MyInterceptor))\n</code></pre> <p>Note</p> <p>In the last case still all handlers applied to filtered methods will be shown (to see overall picture).</p>"},{"location":"guide/diagnostic/aop-report/#report-customization","title":"Report customization","text":"<p>Report is implemented as a guicey event listener, so you can register it directly  in your bundle if required (without main bundle shortcuts):</p> <pre><code>listen(new GuiceAopDiagnostic(new GuiceAopConfig()));\n</code></pre> <p>Report rendering logic may also be used directly as report provide separate renderer object implementing <code>ReportRenderer</code>. Renderer not bound to guice context and assume direct instantiation. </p> <p>For examples of direct renderer usage see events implementation:</p> <ul> <li><code>InjectorPhaseEvent.ReportRenderer</code> </li> </ul>"},{"location":"guide/diagnostic/configuration-model/","title":"Configuration model","text":"<p>All recorder guicey configuration is accessible as:</p> <pre><code>@Inject GuiceyConfigurationInfo info;\n</code></pre> <ul> <li>Configuration items</li> <li>Startup stats</li> <li>Option values and usage info</li> <li>Parsed configuration values</li> </ul>"},{"location":"guide/diagnostic/configuration-model/#configuration-items","title":"Configuration items","text":""},{"location":"guide/diagnostic/configuration-model/#identity","title":"Identity","text":"<p>Attention</p> <p>Configuration items (extensions, installers, bundles etc) are identified with special <code>ItemId</code> objects. This is important because guicey supports multiple instances of the same type.</p> <p><code>ItemId</code> object equals behaviour may seem non intuitive (see below). </p> <p>For classes <code>ItemId</code> is essentially the same as class: </p> <pre><code>ItemId.from(SomeClass.class).equals(ItemId.from(SomeClass.class)) == true\n</code></pre> <p>For instances, item id compute object hash (using <code>System.identityHashCode()</code>). ItemId could be always created from object instance:</p> <pre><code>ItemId.from(instance).equals(ItemId.from(instance)) == true\n</code></pre> <p>but for different instances obviously:</p> <pre><code>ItemId.from(instance).equals(ItemId.from(otherInstance)) == false\n</code></pre> <p>But instance identity myst also be recognized by class, because otherwise it is  hard to analyze items, so:</p> <pre><code>ItemId.from(instance.getClass()).equals(ItemId.from(otherInstance)) == true\n</code></pre> <p>Class identity equals all instance identities of the same class.   </p> <p>This allows you to use <code>ItemId.from(MyBundle.class)</code> to get all instance configs for required bundle types.</p>"},{"location":"guide/diagnostic/configuration-model/#model","title":"Model","text":"<p>Each configuration item is stored using model object. All model classes are inherited from <code>ItemInfo</code>:</p> Model class Description ItemInfo Base class for all models ClassItemInfo Base class for class-based models: extension, installer InstanceItemInfo Base class for instance-based models: bundles, modules ExtensionItemInfo Extension model InstallerItemInfo Installer model ModuleItemInfo Module model GuiceyBundleItemInfo Guicey bundle model DropwizardBundleItemInfo Dropwizard bundle model <p>For example, when you configure extension:</p> <pre><code>.extensions(MyExtension,class)\n</code></pre> <p>Guicey will create new instance of <code>ExtensionItemInfo</code> to store item registration data. </p> <p>For each registered item registration scope is tracked. It could be </p> <ul> <li>Application (if item registered in main bundle)</li> <li>Guicey bundle class (for items registered in this bundle)</li> <li>ClasspathScan (for classes from classpath scan)  </li> <li>etc ..</li> </ul> <p>All scopes are described in <code>ConfigScope</code> enum.</p> <p>Note</p> <p><code>ItemId</code> is also used for scopes, because we may have multiple bundles of the same type and so need to differentiate them as different scopes. </p> <p>For class based extensions only one model instance will be created for all registrations of the same type. But all registration scopes will be preserved, so it is possible to know all extension duplicate points (and you can see it on diagnostic report)</p> <p>For instance based extensions, different model instances will be created for different items. So if some object was detected as duplicate, it's id will be only added to original object model (<code>InstanceItemInfo#getDuplicates()</code>) to be able to track duplicates.</p>"},{"location":"guide/diagnostic/configuration-model/#querying-model","title":"Querying model","text":"<p>All raw data is actually available through: <code>GuiceyConfigurationInfo#getData()</code>,  but <code>GuiceyConfigurationInfo</code> provides many shortcut methods to simplify raw data querying.  </p> <p>Data querying is based on java <code>Predicate</code> usage. <code>Filters</code> class provides common predicate builders. Many examples of its usage may be found in code.</p> <p>Note</p> <p>For some reports it is important to know only types of used configuration items, ignoring duplicates. Special helper is included directly inside <code>ItemId</code>: <code>ItemId.typesOnly(...)</code> </p> <p>For example, <code>getInstallers()</code> from <code>GuiceyConfigurationInfo</code>:</p> <pre><code> public List&lt;Class&lt;FeatureInstaller&gt;&gt; getInstallers() {\n    return typesOnly(getData().getItems(ConfigItem.Installer, Filters.enabled()));\n}\n</code></pre> <p>More advanced queries are applied with predicate composition:</p> <pre><code> public List&lt;Class&lt;Object&gt;&gt; getExtensionsRegisteredManually() {\n    return typesOnly(getData().getItems(ConfigItem.Extension,\n            Filters.&lt;ExtensionItemInfo&gt;enabled()\n                    .and(it -&gt; it.getRegistrationScopeType().equals(ConfigScope.Application)\n                            || it.getRegistrationScopeType().equals(ConfigScope.GuiceyBundle))));\n}\n</code></pre> <p>For exact configuration item type you can always get its configuration model:</p> <pre><code>@Inject GuiceyConfigurationInfo info;\n\nItemInfo model = info.getInfo(MyExtension.class)\n</code></pre> <p>For instance-based items, you can receive all models for instances of type:</p> <pre><code>List&lt;BundleItemInfo&gt; models = info.getInfos(MyBundle.class)\n</code></pre> <p>And the last example is if you know exact extension instance and wasn't to get its info:</p> <pre><code>BundleItemInfo model = info.getData().getInfo(ItemId.from(myBundleInstance))\n</code></pre>"},{"location":"guide/diagnostic/configuration-model/#instances","title":"Instances","text":"<p>Bundles and modules are configured by instance and this instance is stored in configuration model.</p> <p>For example, to obtain all configured (and not disabled)  guice modules:</p> <pre><code>@Inject GuiceConfigurationInfo info;\n\nList&lt;Module&gt; modules = info.getModuleIds().stream()\n                           .map(it -&gt; info.getData().&lt;ModuleItemInfo&gt;getInfo(it).getInstance())\n                           .collect(Collectors.toList());\n</code></pre> <p>Here all used module ids (<code>ItemId</code>) obtained. Then complete configuration model loaded for each item and instance obtained from model. </p> <p>Note</p> <p>It may look overcomplicated to load ids first and only later obtain instances, but it is actually a restriction of the model: correct registration order is preserved on id level and so this way is the only way to get all instances in registration order.</p> <p>Note</p> <p>Direct model object load by id shortcut was not added directly to <code>GuiceyConfigurationInfo</code> intentionally to avoid mistakes by accidentally using class-based info loading instead of id-based (which may lead to configuration items loss in your reporting or analysis).</p>"},{"location":"guide/diagnostic/configuration-model/#startup-stats","title":"Startup stats","text":"<p>Startup stats ar available through: <code>GuiceyConfigurationInfo#getStats()</code>.</p> <p>All available stats are listed in <code>Stat</code> enum. Usage examples see in bundles report renderers.</p>"},{"location":"guide/diagnostic/configuration-model/#options","title":"Options","text":"<p>Options usage info is available through: <code>GuiceyConfigurationInfo#getOptions()</code>.</p> <p>Apart from actual option values, it could tell if custom option value was set and if this option value was ever queried (by application).</p>"},{"location":"guide/diagnostic/configuration-model/#configuration-tree","title":"Configuration tree","text":"<p>Parsed configuration object is available through <code>GuiceyConfigurationInfo#getConfigurationTree()</code></p>"},{"location":"guide/diagnostic/configuration-report/","title":"Configuration report","text":"<p>Note</p> <p>During startup guicey records startup metrics and remembers all details of configuration process.  All this information is available through GuiceyConfigurationInfo bean:</p> <pre><code>@Inject GuiceyConfigurationInfo info;\n</code></pre> <p>For usage details see conifguration model</p> <p>Configuration diagnostic report is the most commonly used report allowing you to see guicey startup and  configuration details (the last is especially important for de-duplication logic diagnostic).</p> <pre><code>GuiceBundle.builder() \n    ...\n    .printDiagnosticInfo()\n    .build());\n</code></pre> <p>Report intended to answer:</p> <ul> <li>How guicey spent time</li> <li>What options used</li> <li>What was configured</li> <li>From where configuration items come from</li> </ul> <p>Example report:</p> <pre><code>INFO  [2019-10-11 04:25:47,022] ru.vyarus.dropwizard.guice.debug.ConfigurationDiagnostic: Diagnostic report\n\n---------------------------------------------------------------------------[STARTUP STATS]\n\n    GUICEY started in 431.2 ms (150.2 ms config / 279.4 ms run / 1.594 ms jersey)\n    \u2502   \n    \u251c\u2500\u2500 [0.70%] CLASSPATH scanned in 3.088 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [24%] BUNDLES processed in 105.8 ms\n    \u2502   \u251c\u2500\u2500 1 resolved in 12.22 ms\n    \u2502   \u251c\u2500\u2500 7 initialized in 23.75 ms\n    \u2502   \u2514\u2500\u2500 1 dropwizard bundles initialized in 69.58 ms\n    \u2502   \n    \u251c\u2500\u2500 [2.6%] COMMANDS processed in 11.34 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms\n    \u2502   \u251c\u2500\u2500 7 modules autowired\n    \u2502   \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms\n    \u2502   \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings\n    \u2502   \n    \u251c\u2500\u2500 [7.4%] INSTALLERS processed in 32.60 ms\n    \u2502   \u251c\u2500\u2500 registered 12 installers\n    \u2502   \u2514\u2500\u2500 4 extensions recognized from 10 classes in 11.63 ms\n    \u2502   \n    \u251c\u2500\u2500 [47%] INJECTOR created in 204.2 ms\n    \u2502   \u251c\u2500\u2500 Module execution: 124 ms\n    \u2502   \u251c\u2500\u2500 Interceptors creation: 2 ms\n    \u2502   \u251c\u2500\u2500 TypeListeners &amp; ProvisionListener creation: 2 ms\n    \u2502   \u251c\u2500\u2500 Scopes creation: 1 ms\n    \u2502   \u251c\u2500\u2500 Binding creation: 20 ms\n    \u2502   \u251c\u2500\u2500 Module annotated method scanners creation: 1 ms\n    \u2502   \u251c\u2500\u2500 Binding initialization: 29 ms\n    \u2502   \u251c\u2500\u2500 Collecting injection requests: 2 ms\n    \u2502   \u251c\u2500\u2500 Static validation: 3 ms\n    \u2502   \u251c\u2500\u2500 Instance member validation: 3 ms\n    \u2502   \u251c\u2500\u2500 Provider verification: 1 ms\n    \u2502   \u251c\u2500\u2500 Static member injection: 7 ms\n    \u2502   \u251c\u2500\u2500 Instance injection: 3 ms\n    \u2502   \u2514\u2500\u2500 Preloading singletons: 4 ms\n    \u2502   \n    \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms\n    \u2502   \u251c\u2500\u2500 4 extensions installed\n    \u2502   \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding\n    \u2502   \n    \u251c\u2500\u2500 [0.23%] JERSEY bridged in 1.594 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 3 jersey extensions installed in 501.8 \u03bcs\n    \u2502   \n    \u2514\u2500\u2500 [7.4%] remaining 32 ms\n\n\n---------------------------------------------------------------------------[OPTIONS]\n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        BindConfigurationByPath        = true                           \n        TrackDropwizardBundles         = true                           \n        AnalyzeGuiceModules            = true                           \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]                      \n        UseHkBridge                    = false                          \n\n\n    Installers                (r.v.d.g.m.i.InstallersOptions)\n        JerseyExtensionsManagedByGuice = true                           \n        ForceSingletonForJerseyExtensions = true                           \n\n\n---------------------------------------------------------------------------[CONFIGURATION]\n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN, GUICE_ENABLED\n\n\n    BUNDLES = \n        FooDwBundle                  (r.v.d.g.d.s.dwbundle)     *DW\n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *HOOK, REG(1/2)\n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *HOOK\n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n            WebInstallersBundle          (r.v.d.g.m.installer)      \n        LookupBundle                 (r.v.d.g.d.s.bundle)       *LOOKUP\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(1/2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(1/3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n            ModuleFeature                (r.v.d.g.d.s.m.ModuleWithExtensions) *BINDING\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2/2)\n        ModuleWithExtensions         (r.v.d.g.d.s.module)       \n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        OverridingModule             (r.v.d.g.d.s.module)       *OVERRIDE\n        GuiceBootstrapModule         (r.v.d.guice.module)       \n\n\n---------------------------------------------------------------------------[CONFIGURATION TREE]\n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 extension  -FooBundleResource           (r.v.d.g.d.s.bundle)       *DUPLICATE\n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     ModuleWithExtensions         (r.v.d.g.d.s.module)       \n    \u251c\u2500\u2500 module     GuiceBootstrapModule         (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u251c\u2500\u2500 FooDwBundle                  (r.v.d.g.d.s.dwbundle)     *DW\n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  -FooBundleResource           (r.v.d.g.d.s.bundle)       *DUPLICATE\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     FooModule#2                  (r.v.d.g.d.s.features)     \n    \u2502   \n    \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n    \u2502   \u251c\u2500\u2500 extension  HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n    \u2502   \u2514\u2500\u2500 module     HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n    \u2502   \n    \u251c\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  -JerseyFeatureInstaller      (r.v.d.g.m.i.f.jersey)     *DUPLICATE\n    \u2502   \u251c\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n    \u2502   \u2514\u2500\u2500 WebInstallersBundle          (r.v.d.g.m.installer)      \n    \u2502   \n    \u251c\u2500\u2500 BUNDLES LOOKUP\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 LookupBundle                 (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     OverridingModule             (r.v.d.g.d.s.module)       \n    \u2502   \n    \u251c\u2500\u2500 CLASSPATH SCAN\n    \u2502   \u2514\u2500\u2500 extension  FooResource                  (r.v.d.g.d.s.features)     \n    \u2502   \n    \u251c\u2500\u2500 GUICE BINDINGS\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 ModuleWithExtensions         (r.v.d.g.d.s.module)       \n    \u2502       \u2514\u2500\u2500 extension  ModuleFeature                (r.v.d.g.d.s.m.ModuleWithExtensions) \n    \u2502   \n    \u2514\u2500\u2500 HOOKS\n        \u251c\u2500\u2500 -HK2DebugBundle              (r.v.d.g.m.j.debug)        *DUPLICATE\n        \u2502   \n        \u2514\u2500\u2500 GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n            \u2514\u2500\u2500 module     GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle)     \n</code></pre>"},{"location":"guide/diagnostic/configuration-report/#timings","title":"Timings","text":"<p>Note</p> <p>There are also another \"time-report\" available which shows entire application startup timings.</p>"},{"location":"guide/diagnostic/configuration-report/#startup-timings","title":"Startup timings","text":"<pre><code>    GUICEY started in 431.2 ms (150.2 ms config / 279.4 ms run / 1.594 ms jersey)\n</code></pre> <p>Guicey time (<code>431.2 ms</code>) is measured as <code>GuiceBundle</code> methods plus part of jersey configuration time (jersey started after bundle). It also shows time spent on each application starting phase: <code>150.2 ms</code> configuration (initialization), <code>279.4 ms</code> run and <code>1.594 ms</code> during jersey startup.</p> <p>All items below represent guicey time details. Each child item always includes the time detail of the direct parent.                                                                     </p> <p>Tip</p> <p>Application startup during development may be improved with VM options: <pre><code>-XX:TieredStopAtLevel=1 -noverify\n</code></pre> It does not show a big difference on test sample, but it's already a notable change (~20% faster): <pre><code>GUICEY started in 304.0 ms (88.18 ms config / 214.6 ms run / 1.130 ms jersey)\n</code></pre></p>"},{"location":"guide/diagnostic/configuration-report/#classpath-scan","title":"Classpath scan","text":"<pre><code>    \u251c\u2500\u2500 [0.70%] CLASSPATH scanned in 3.088 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n</code></pre> <p>Classpath scan performed just once. Represents only time spent resolving all classes in configured packages.  Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. </p> <code>scanned 5 classes</code> means that 5 classed were found (overall) in configured packages. <code>recognized 4 classes</code> show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command). <p>Note</p> <p>Classpath scan time will be obviously bigger for real applications (with larger classes count).  But most of this time spent on class loading (because guicey loads all classes during scan and not  just parse class structure). If you use all these classes then they will be loaded  in any case. If you disable classpath scan to save time then this time will just move to other places (where classes are used). </p>"},{"location":"guide/diagnostic/configuration-report/#bundles","title":"Bundles","text":"<pre><code>    \u251c\u2500\u2500 [24%] BUNDLES processed in 105.8 ms\n    \u2502   \u251c\u2500\u2500 1 resolved in 12.22 ms\n    \u2502   \u251c\u2500\u2500 7 initialized in 23.75 ms\n    \u2502   \u2514\u2500\u2500 1 dropwizard bundles initialized in 69.58 ms\n</code></pre> <p>Bundles time includes bundles lookup time (if not .disableBundleLookup()), bundles execution (both init and run) and dropwizard bundles (known by guicey) init time (run time is not tracked because it appears after  <code>GuiceBundle.run</code>).</p> <code>1 resolved</code> indicated bundles resolved with guicey bundle lookup. <code>7 initialized</code> overall processed bundles (all registered bundles, including transitives). Time cover both init and run. <code>1 dropwizard bundles initialized</code> dropwizard bundles (registered through guicey api!) initialization time.Dropwizard bundles always include ~50ms overhead of Bootstrap object proxying, required for transitive bundles tracking."},{"location":"guide/diagnostic/configuration-report/#commands","title":"Commands","text":"<pre><code>    \u251c\u2500\u2500 [2.6%] COMMANDS processed in 11.34 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n</code></pre> <p>Commands time includes time spent on commands search (in classes from already performed classpath scan),  and calling <code>.injectMemebers</code> on found environment commands (last part is always performed, but it's very fast so most likely commands section will not appear  if <code>.searchCommands()</code> is not enabled)</p> <p>Note</p> <p>Most of commands time will be command objects instantiation (reflection).</p>"},{"location":"guide/diagnostic/configuration-report/#modules","title":"Modules","text":"<pre><code>    \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms\n    \u2502   \u251c\u2500\u2500 7 modules autowired\n    \u2502   \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms\n    \u2502   \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings\n</code></pre> <code>7 modules autowired</code> <code>Aware*</code> interfaces processing for registered modules (user modules + overrides + 1 guicey module)  <code>8 elements found in 5 user modules</code> Guicey performs modules introspection before injector creation (with guice SPI) and shows all found elements.  Only user modules are introspected (except override and guicey module). <code>1 extensions detected from 3 acceptable bindings</code> Shows detected extensions from bindings. Note that overall modules elements count include aop, listeners etc. Also, bindings are searched only in direct class bindings, so acceptable elements count will almost always be lower then overall elements count."},{"location":"guide/diagnostic/configuration-report/#installers","title":"Installers","text":"<pre><code>    \u251c\u2500\u2500 [7.4%] INSTALLERS processed in 32.60 ms\n    \u2502   \u251c\u2500\u2500 registered 12 installers\n    \u2502   \u2514\u2500\u2500 4 extensions recognized from 10 classes in 11.63 ms\n</code></pre> <p>Shows installers initialization and processing time.</p> <code>registered 12 installers</code> Overall count of used installers (core and custom, without disables). <code>4 extensions recognized from 10 classes</code> Overall recognition time (potential extension classes introspection time). Includes class from classpath scan, all manual extension classes and checked (acceptable) bindings."},{"location":"guide/diagnostic/configuration-report/#injector","title":"Injector","text":"<pre><code>    \u251c\u2500\u2500 [47%] INJECTOR created in 204.2 ms\n    \u2502   \u251c\u2500\u2500 Module execution: 124 ms\n    \u2502   \u251c\u2500\u2500 Interceptors creation: 2 ms\n    \u2502   \u251c\u2500\u2500 TypeListeners &amp; ProvisionListener creation: 2 ms\n    \u2502   \u251c\u2500\u2500 Scopes creation: 1 ms\n    \u2502   \u251c\u2500\u2500 Binding creation: 20 ms\n    \u2502   \u251c\u2500\u2500 Module annotated method scanners creation: 1 ms\n    \u2502   \u251c\u2500\u2500 Binding initialization: 29 ms\n    \u2502   \u251c\u2500\u2500 Collecting injection requests: 2 ms\n    \u2502   \u251c\u2500\u2500 Static validation: 3 ms\n    \u2502   \u251c\u2500\u2500 Instance member validation: 3 ms\n    \u2502   \u251c\u2500\u2500 Provider verification: 1 ms\n    \u2502   \u251c\u2500\u2500 Static member injection: 7 ms\n    \u2502   \u251c\u2500\u2500 Instance injection: 3 ms\n    \u2502   \u2514\u2500\u2500 Preloading singletons: 4 ms\n</code></pre> <p>Pure injector creation time. Sub logs are intercepted guice internal logs (from <code>com.google.inject.internal.util</code>). Only lines with non 0 time are shown.</p>"},{"location":"guide/diagnostic/configuration-report/#extensions","title":"Extensions","text":"<pre><code>    \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms\n    \u2502   \u251c\u2500\u2500 4 extensions installed\n    \u2502   \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding\n</code></pre> <p>Extensions are installed just after injector creation. Time represent installers installation logic time. </p> <code>4 extensions installed</code> All used (installed, not disabled) extensions <code>declared as: 2 manual, 1 scan, 1 binding</code> Extensions sources: manual registration, classpath scan, bindings in guice modules. One extension could appear multiple times in counters (if it was detected in multiple sources)"},{"location":"guide/diagnostic/configuration-report/#jersey","title":"Jersey","text":"<pre><code>    \u251c\u2500\u2500 [0.23%] JERSEY bridged in 1.594 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 3 jersey extensions installed in 501.8 \u03bcs\n</code></pre> <p>Jersey starts after dropwizard bundles processing and so after <code>GuiceBundle</code> execution.  Guicey register required HK2 bindings (and some HK2 beans in guice) and executes jersey  installers (installers implementing <code>JerseyInstaller</code>) to process jersey specific features.  For example, all resources and jersey extensions installed here (because requires HK2 specific bindings).</p> <code>using 2 jersey installers</code> All jersey feature installers (not disabled)     <code>3 jersey extensions installed</code> All jersey extensions (not disabled) <p>Note that extensions installation time is so tiny (<code>501.8 \u03bcs</code>) just because empty resources (without methods) were used.  In real application installation time will be bigger.</p>"},{"location":"guide/diagnostic/configuration-report/#remaining","title":"Remaining","text":"<pre><code>    \u2514\u2500\u2500 [7.4%] remaining 32 ms\n</code></pre> <p>Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.</p>"},{"location":"guide/diagnostic/configuration-report/#used-options","title":"Used options","text":"<p>Shows all guicey options set or requested (by application logic). If you use your own options here they will also be printed.</p> <pre><code>    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        BindConfigurationByPath        = true                           \n        TrackDropwizardBundles         = true                           \n        AnalyzeGuiceModules            = true                           \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]                      \n        UseHkBridge                    = false                          \n\n\n    Installers                (r.v.d.g.m.i.InstallersOptions)\n        JerseyExtensionsManagedByGuice = true                           \n        ForceSingletonForJerseyExtensions = true \n</code></pre> <p>Used markers:</p> <ul> <li><code>CUSTOM</code> - option value set by user</li> <li><code>NOT_USED</code> - option was set by user but never used</li> </ul> <p>Note</p> <p><code>NOT_USED</code> marker just indicates that option is \"not yet\" used. Options may be consumed lazily by application logic, so it is possible that it's not used at reporting time. There is no such cases with guicey options,  but may be with your custom options (it all depends on usage scenario).</p>"},{"location":"guide/diagnostic/configuration-report/#configuration-summary","title":"Configuration summary","text":"<p>Section intended to show all configuration summary (to quickly see what was configured).</p> <p>This and the next sections used condensed package notion:</p> <pre><code>CoreInstallersBundle         (r.v.d.g.m.installer)    \n</code></pre> <p>Assumed that all classes in application will be uniquely identifiable by name so package info shown just to be able to  understand exact class location. Logback shrinker used.</p> <p>Report indicates duplicate registrations and items of the same type registrations: <code>REG(1/3)</code>, where first number is accepted instances count and last number is overall registrations count. For extensions it's always <code>1/N</code>, but for instances (modules, bundles) it indicates  de-duplication mechanism work. </p>"},{"location":"guide/diagnostic/configuration-report/#commands_1","title":"Commands","text":"<pre><code>    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN, GUICE_ENABLED\n</code></pre> <p>Shows commands resolved with classpath scan (enabled with <code>.searchCommands()</code>).</p> <p>The following markers used:</p> <ul> <li><code>SCAN</code> - item from classpath scan (always)</li> <li><code>GUICE_ENABLED</code> - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)</li> </ul>"},{"location":"guide/diagnostic/configuration-report/#bundles_1","title":"Bundles","text":"<pre><code>    BUNDLES = \n        FooDwBundle                  (r.v.d.g.d.s.dwbundle)     *DW\n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *HOOK, REG(1/2)\n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *HOOK\n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n            WebInstallersBundle          (r.v.d.g.m.installer)      \n        LookupBundle                 (r.v.d.g.d.s.bundle)       *LOOKUP\n</code></pre> <p>All registered bundles are shown as a tree (to indicate transitive bundles).</p> <p>Markers used:</p> <ul> <li><code>LOOKUP</code> - bundle resolved with bundle lookup mechanism</li> <li><code>DW</code> - dropwizard bundle</li> <li><code>HOOK</code> - registered by configuration hook</li> </ul>"},{"location":"guide/diagnostic/configuration-report/#installers-and-extensions","title":"Installers and extensions","text":"<pre><code>    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(1/2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(1/3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n            ModuleFeature                (r.v.d.g.d.s.m.ModuleWithExtensions) *BINDING\n</code></pre> <p>Shows used installers (only installers which install extensions) and installed extensions. </p> <p>Both installers and extensions are shown in the processing order (sorted according to <code>@Order</code> annotations).</p> <p>Markers used:</p> <ul> <li><code>SCAN</code> - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan)</li> <li><code>LAZY</code> - extensions annotated with <code>@LazyBinding</code></li> <li><code>JERSEY</code> - extension annotated with <code>@JerseyManaged</code></li> <li><code>HOOK</code> - registered by configuration hook</li> <li><code>BINDING</code> - extension recognized from guice binding</li> </ul>"},{"location":"guide/diagnostic/configuration-report/#modules_1","title":"Modules","text":"<pre><code>    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2/2)\n        ModuleWithExtensions         (r.v.d.g.d.s.module)       \n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        OverridingModule             (r.v.d.g.d.s.module)       *OVERRIDE\n        GuiceBootstrapModule         (r.v.d.guice.module) \n</code></pre> <p>All registered guice modules: user modules + override modules + guicey <code>GuiceBootstrapModule</code>. Overriding modules are marked with <code>OVERRIDE</code>.</p>"},{"location":"guide/diagnostic/configuration-report/#configuration-tree","title":"Configuration tree","text":"<p>Configuration tree is useful to understand from where configuration items come from.</p> <p>Note</p> <p>Configuration tree shows both guicey bundles and dropwizard bundle trees (for dropwizard bundles, registered through guicey api). Dropwizard bundles are identified with marker <code>DW</code>.</p> <p>There are several sections in tree:</p> <ul> <li><code>APPLICATION</code> - for everything registered in <code>GuiceBundle</code></li> <li><code>BUNDLES LOOKUP</code> - for bundles resolved with lookup mechanism</li> <li><code>CLASSPATH SCAN</code> - for items resolved by classpath scan</li> <li><code>GUICE BINDINGS</code> - for extensions resolved from guice module bindings</li> <li><code>HOOKS</code> - for registered hooks</li> </ul> <p>Markers:</p> <ul> <li><code>DW</code> - dropwizard bundle</li> <li><code>DISABLED</code> - item manually disabled</li> <li><code>DUPLICATE</code> - item considered as duplicate for already registered item</li> </ul>"},{"location":"guide/diagnostic/configuration-report/#disables","title":"Disables","text":"<p>Manual disable is identified (to quickly understand who disabled item) as:</p> <pre><code>    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)  \n</code></pre> <p>And disabled items would be also identified:</p> <pre><code>    \u251c\u2500\u2500 installer  -LifeCycleInstaller           (r.v.d.g.m.i.feature)         *DISABLED  \n</code></pre> <p>Disabled bundles are shown without context (to identify disable):</p> <pre><code>    -HK2DebugBundle              (r.v.d.g.m.j.debug)        *DISABLED\n</code></pre>"},{"location":"guide/diagnostic/configuration-report/#de-duplication","title":"De-duplication","text":"<p>Duplicate registration or instance de-duplications are identified as:</p> <pre><code>    \u251c\u2500\u2500 extension  -FooBundleResource           (r.v.d.g.d.s.bundle)       *DUPLICATE\n</code></pre> <p>If extension is registered more then once in the same context, it would be identified:</p> <pre><code>    \u251c\u2500\u2500 extension  FooBundleResource           (r.v.d.g.d.s.bundle) \n    \u251c\u2500\u2500 extension  -FooBundleResource           (r.v.d.g.d.s.bundle)       *DUPLICATE\n</code></pre> <p>If more then one instance (in this context) is considered to be duplicate then number will appear:</p> <pre><code>    \u251c\u2500\u2500 extension  -FooBundleResource           (r.v.d.g.d.s.bundle)       *DUPLICATE(3)\n</code></pre> <p>When multiple instances of the same type is registered (form modules or bundles), they would be numbered in order of registration (to differentiate):</p> <pre><code>    APPLICATION\n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)\n    ... \n    \u2502   \u2514\u2500\u2500 FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     FooModule#2                  (r.v.d.g.d.s.features) \n</code></pre> <p>In order to better track duplicates, items, recognized as duplicates, will be shown with registered instance they considered to be duplicate to. For example, for above sample, if another <code>FooModule</code> registered and it would be considered as duplicate to second instance, it would be printed as:</p> <pre><code>\u2514\u2500\u2500 module     -FooModule#2                 (r.v.d.g.d.s.features)  *DUPLICATE\n</code></pre>"},{"location":"guide/diagnostic/configuration-report/#guice-bindings","title":"Guice bindings","text":"<p>Extensions detected from guice bindings are shown as a sub tree:</p> <pre><code>    \u251c\u2500\u2500 GUICE BINDINGS\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 ModuleWithExtensions         (r.v.d.g.d.s.module)       \n    \u2502       \u2514\u2500\u2500 extension  ModuleFeature                (r.v.d.g.d.s.m.ModuleWithExtensions) \n</code></pre> <p>Note</p> <p>Extensions are shown relative to top-most registered modules!</p> <p>For example, if <code>ModuleWithExtensions</code> internally install module <code>ExtensionModule</code> which  actually contains extension bingind, then still <code>ExtensionModule</code> will not be shown and  extension will remain under <code>ModuleWithExtensions</code> (on report).</p> <p>This was done to not confuse users: report shows guicey configration and user must clearly see configuration source.    </p> <p>Bindings are not shown under main configuration tree (where modules are registered) because guicey only knows about the module class, but actually multiple module instances could be registered and so it is impossible to known what module instance extension is related to.</p> <p>Tip</p> <p>Detailed guice modules tree could be seen on guice report</p>"},{"location":"guide/diagnostic/configuration-report/#customization","title":"Customization","text":"<p><code>.printDiagnosticInfo()</code> shortcut register report with default settings. If you need customized report then register report listener directly. For example, installers report is a  configured configuration report:</p> <pre><code>.listen(ConfigurationDiagnostic.builder(\"Available installers report\")\n                    .printConfiguration(new DiagnosticConfig()\n                            .printInstallers()\n                            .printNotUsedInstallers()\n                            .printInstallerInterfaceMarkers())\n                    .printContextTree(new ContextTreeConfig()\n                            .hideCommands()\n                            .hideDuplicateRegistrations()\n                            .hideEmptyBundles()\n                            .hideExtensions()\n                            .hideModules())\n                    .build());\n</code></pre> <p>Report rendering logic may also be used directly as all sub-reports provide separate renderer object implementing <code>ReportRenderer</code>. Renderers not bound to guice context and assume direct instantiation. </p> <p>For examples of direct renderers usage see events implementation:</p> <ul> <li><code>InjectorPhaseEvent.ReportRenderer</code> </li> </ul>"},{"location":"guide/diagnostic/diagnostic-tools/","title":"Diagnostic tools","text":"<p>Guicey provide many bundled console reports to help with problems diagnostic (or to simply clarify how application works) during development. All reports may be enabled on main guice bundle:</p> <code>.printStartupTime()</code> Detailed application startup time <code>.printExtensionsHelp()</code> Extensions recognition help <code>.printDiagnosticInfo()</code> Detailed guicey configuration information <code>.printAvailableInstallers()</code> Prints available installers (helps understanding supported extensions) <code>.printCustomConfigurationBindings()</code> <code>.printConfigurationBindings()</code> Show yaml config introspection result (shows available yaml value bindings) <code>.printGuiceBindings()</code> <code>.printAllGuiceBindings()</code> Guice bindings from registered modules <code>.printGuiceProvisionTime()</code> Guice provision time <code>.printGuiceAopMap()</code> <code>.printGuiceAopMap(GuiceAopConfig config)</code> AOP appliance map <code>.printWebMappings()</code> Prints all registered servlets and filters (including guice <code>ServletModule</code> declarations) <code>.printJerseyConfig()</code> Prints all registered jersey extensions (exception mappers, filters etc.): including everything registered by  dropwizard itself and all direct manual registrations.  <code>.printLifecyclePhases()</code> <code>.printLifecyclePhasesDetailed()</code> Guicey lifecycle stages (separates logs to clearly see what messages relates to what phase) <code>.printSharedStateUsage()</code> Shared state usage <code>.strictScopeControl()</code> In case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation,  you can enable strict control which will throw exception in case of wrong owner."},{"location":"guide/diagnostic/diagnostic-tools/#diagnostic-hook","title":"Diagnostic hook","text":"<p>It is obviously impossible to enable diagnostic reports without application re-compilation.  But, sometimes, it is required to validate installed application. To work around this situation, guicey provides special diagnostic hook, which can be enabled with a system property:</p> <pre><code>-Dguicey.hooks=diagnostic\n</code></pre> <p>Hook activates the most commonly used reports:</p> <pre><code>public class DiagnosticHook implements GuiceyConfigurationHook {\n    public void configure(final GuiceBundle.Builder builder) {\n        builder.printDiagnosticInfo()\n                .printLifecyclePhasesDetailed()\n                .printCustomConfigurationBindings()\n                .printGuiceBindings()\n                .printWebMappings()\n                .printJerseyConfig();\n    }\n}\n</code></pre> <p>Tip</p> <p>If provided hook doesn't cover all required reports, you can always make your own hook and register it's shortcut for simplified usage </p>"},{"location":"guide/diagnostic/diagnostic-tools/#reports-implementation","title":"Reports implementation","text":"<p>Report is implemented as guicey event listener. All sub-reports provide additional configuration options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration.</p> <p>For example, available installers report is re-configured configuration report:</p> <pre><code>public Builder&lt;T&gt; printAvailableInstallers() {\n    return listen(ConfigurationDiagnostic.builder(\"Available installers report\")\n            .printConfiguration(new DiagnosticConfig()\n                    .printInstallers()\n                    .printNotUsedInstallers()\n                    .printInstallerInterfaceMarkers())\n            .printContextTree(new ContextTreeConfig()\n                    .hideCommands()\n                    .hideDuplicateRegistrations()\n                    .hideEmptyBundles()\n                    .hideExtensions()\n                    .hideModules())\n            .build());\n}\n</code></pre> <p>Report rendering logic may also be used directly as all reports (except lifecycle) provide separate renderer object implementing <code>ReportRenderer</code>. Renderers not bound to guice context and assume direct instantiation. </p> <p>For examples of direct renderers usage see events implementation:</p> <ul> <li><code>RunPhaseEvent.renderConfigurationBindings()</code></li> <li><code>InjectorPhaseEvent.ReportRenderer</code> </li> </ul> <p>Note</p> <p>These shortcut methods allow easy render of report into string  using received event object (in listener). </p>"},{"location":"guide/diagnostic/extensions-report/","title":"Extensions help","text":"<p>Shows extension signs recognized by registered installers.</p> <pre><code>GuiceBundle.builder()\n    ...\n    .printExtensionsHelp()\n    .build()\n</code></pre> <p>Example report:</p> <pre><code>INFO  [2022-12-28 14:57:01,445] ru.vyarus.dropwizard.guice.debug.ExtensionsHelpDiagnostic: Recognized extension signs\n\n    lifecycle            (r.v.d.g.m.i.f.LifeCycleInstaller)     \n        implements LifeCycle\n\n    managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n        implements Managed\n\n    jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) \n        implements Feature\n\n    jerseyprovider       (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) \n        @Provider on class\n        implements ExceptionMapper\n        implements ParamConverterProvider\n        implements ContextResolver\n        implements MessageBodyReader\n        implements MessageBodyWriter\n        implements ReaderInterceptor\n        implements WriterInterceptor\n        implements ContainerRequestFilter\n        implements ContainerResponseFilter\n        implements DynamicFeature\n        implements ValueParamProvider\n        implements InjectionResolver\n        implements ApplicationEventListener\n        implements ModelProcessor\n\n    resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n        @Path on class\n        @Path on implemented interface\n\n    eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller) \n        @EagerSingleton on class\n\n    healthcheck          (r.v.d.g.m.i.f.h.HealthCheckInstaller) \n        extends NamedHealthCheck\n\n    task                 (r.v.d.g.m.i.feature.TaskInstaller)    \n        extends Task\n\n    plugin               (r.v.d.g.m.i.f.plugin.PluginInstaller) \n        @Plugin on class\n        custom annotation on class, annotated with @Plugin\n\n    webservlet           (r.v.d.g.m.i.f.w.WebServletInstaller)  \n        extends HttpServlet + @WebServlet\n\n    webfilter            (r.v.d.g.m.i.f.web.WebFilterInstaller) \n        implements Filter + @WebFilter\n\n    weblistener          (r.v.d.g.m.i.f.w.l.WebListenerInstaller) \n        implements EventListener + @WebListener\n</code></pre> <p>All signs are grouped by installer. Installers listed in processing order, which is important,  because first installer recognized extension \"owns\" it (even if extension contains signs, recognizable by other installers).</p>"},{"location":"guide/diagnostic/extensions-report/#custom-installers","title":"Custom installers","text":"<p>Custom installers should implement new method to participate in report (not required!). Example implementation from singleton installer:</p> <pre><code>public class EagerSingletonInstaller implements FeatureInstaller {\n    ...\n\n    @Override\n    public List&lt;String&gt; getRecognizableSigns() {\n        return Collections.singletonList(\"@\" + EagerSingleton.class.getSimpleName() + \" on class\");\n    }\n}\n</code></pre>"},{"location":"guide/diagnostic/guice-provision-report/","title":"Guice provision time","text":"<p>The report intended to show the time of guice beans provision (instance construction, including provider or provider method time). It shows all requested guice beans and the number of obtained instances (for prototype scopes).</p> <pre><code>GuiceBundle.builder()\n    .printGuiceProvisionTime()\n</code></pre> <p>All provisions are sorted by time:</p> <pre><code>INFO  [2025-03-27 09:20:32,313] ru.vyarus.dropwizard.guice.debug.GuiceProvisionDiagnostic: Guice bindings provision time: \n\n    Overall 57 provisions took 1.40 ms\n        binding              [@Singleton]     ManagedFilterPipeline                                                                 : 0.88 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:94)\n        binding              [@Singleton]     ManagedServletPipeline                                                                : 0.45 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:95)\n        providerinstance     [@Singleton]     @ScopingOnly GuiceFilter                                                              : 0.02 ms            com.google.inject.servlet.InternalServletModule.provideScopingOnlyGuiceFilter(InternalServletModule.java:106)\n        JIT                  [@Prototype]     JitService                                                                       x10  : 0.02 ms (0.006 ms + 0.002 ms + 0.001 ms + 0.001 ms + 0.001 ms + ...)       \n        binding              [@Singleton]     GuiceyConfigurationInfo                                                               : 0.01 ms            ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.configure(GuiceBootstrapModule.java:63)\n        binding              [@Singleton]     BackwardsCompatibleServletContextProvider                                             : 0.007 ms           com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:99)\n        instance             [@Singleton]     Bootstrap                                                                             : 0.004 ms           ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.bindEnvironment(GuiceBootstrapModule.java:71)\n        instance             [@Singleton]     @Config(\"server.gzip.minimumEntitySize\") DataSize                                     : 0.002 ms           ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindValuePaths(ConfigBindingModule.java:129)\n        instance             [@Singleton]     Environment                                                                           : 0.0009 ms          ru.vyarus.dropwizard.guice.module.GuiceBootstrapModule.bindEnvironment(GuiceBootstrapModule.java:72)\n        instance             [@Singleton]     @Config AdminFactory                                                                  : 0.0008 ms          ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindUniqueSubConfigurations(ConfigBindingModule.java:117)\n        ...\n</code></pre> <p>The report will also try to detect injection mistakes in case when JIT (just in time) binding is used when there are qualified declarations with the same type.</p> <p>The most common mistake is configuration objects misuse: guicey binds unique configuration objects with <code>@Config</code> qualifier, but, if injection point declared without the qualifier, guice will create a JIT binding (create new object instance) instead of injecting declared instance. This might be hard to spot, especially when lombok is used (which may not copy field annotation into constructor).</p> <pre><code>INFO  [2025-03-27 09:21:33,438] ru.vyarus.dropwizard.guice.debug.GuiceProvisionDiagnostic: Guice bindings provision time: \n\n    Possible mistakes (unqualified JIT bindings):\n\n         @Inject Sub:\n              instance             [@Singleton]     @Config(\"val2\") Sub                                                                   : 0.0005 ms        ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindValuePaths(ConfigBindingModule.java:129)\n              instance             [@Singleton]     @Marker Sub                                                                           : 0.0007 ms        ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindCustomQualifiers(ConfigBindingModule.java:87)\n            &gt; JIT                  [@Prototype]     Sub                                                                                   : 0.006 ms         \n\n         @Inject Uniq:\n              instance             [@Singleton]     @Config Uniq                                                                          : 0.0005 ms        ru.vyarus.dropwizard.guice.module.yaml.bind.ConfigBindingModule.bindUniqueSubConfigurations(ConfigBindingModule.java:117)\n            &gt; JIT                  [@Prototype]     Uniq                                                                                  : 0.004 ms         \n\n    Overall 53 provisions took 1.45 ms\n        binding              [@Singleton]     ManagedFilterPipeline                                                                 : 0.78 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:94)\n        binding              [@Singleton]     ManagedServletPipeline                                                                : 0.44 ms            com.google.inject.servlet.InternalServletModule.configure(InternalServletModule.java:95)\n</code></pre> <p>In this example, the report detects incorrect injections:</p> <pre><code>   @Inject\n   private Sub val;\n   @Inject\n   private Uniq uniq;\n</code></pre> <p>Detection will also work for generified bindings:</p> <pre><code>    Possible mistakes (unqualified JIT bindings):\n\n         @Inject Service:\n              instance             [@Singleton]     Service&lt;Integer&gt;                                                                      : 0.0006 ms        ru.vyarus.dropwizard.guice.debug.provision.GenerifiedBindingsTest$App.lambda$configure$0(GenerifiedBindingsTest.java:46)\n              instance             [@Singleton]     Service&lt;String&gt;                                                                       : 0.002 ms         ru.vyarus.dropwizard.guice.debug.provision.GenerifiedBindingsTest$App.lambda$configure$0(GenerifiedBindingsTest.java:45)\n            &gt; JIT                  [@Prototype]     Service                                                                               : 0.004 ms         \n</code></pre> <p>The report could be also enabled for compiled application: <code>-Dguicey.hooks=provision-time</code></p> <p>The report shows only provisions performed on application startup, but it could be used in tests to detect provision problems at runtime:</p> <pre><code>    @EnableHook\n    static GuiceProvisionTimeHook report = new GuiceProvisionTimeHook();\n\n@Test\nvoid testRuntimeReport() {\n    // clear startup data\n    report.clearData();\n    // do something that might cause additional provisions\n    injector.getInstance(Service.class);\n    injector.getInstance(Service.class);\n\n    // assert\n    Assertions.assertThat(report.getRecordedData().keys().size()).isEqualTo(2);\n    // or just print report (only for recorded provisions)\n    System.out.println(report.renderReport());\n}   \n</code></pre>"},{"location":"guide/diagnostic/guice-report/","title":"Guice bindings report","text":"<p>Guice bindings report show all available guice bindings.</p> <pre><code>GuiceBundle.builder()\n    ...\n    .printGuiceBindings()\n     // or printAllGuiceBindings() to see also guicey bindings (from GuiceBootstrapModule) \n    .build()\n</code></pre> <p>Example report:</p> <pre><code> 1 MODULES with 3 bindings\n    \u2502\n    \u2514\u2500\u2500 CasesModule                  (r.v.d.g.d.r.g.support)\n        \u251c\u2500\u2500 &lt;typelistener&gt;                        CustomTypeListener                              at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:19)\n        \u251c\u2500\u2500 &lt;provisionlistener&gt;                   CustomProvisionListener                         at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:26)\n        \u251c\u2500\u2500 &lt;aop&gt;                                 CustomAop                                       at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:33)\n        \u251c\u2500\u2500 untargetted          [@Singleton]     AopedService                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:36) *AOP\n        \u251c\u2500\u2500 linkedkey            [@Prototype]     BindService                                     at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:37) *OVERRIDDEN\n        \u2514\u2500\u2500 instance             [@Singleton]     BindService2                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:38) *OVERRIDDEN\n\n\n    1 OVERRIDING MODULES with 2 bindings\n    \u2502\n    \u2514\u2500\u2500 OverrideModule               (r.v.d.g.d.r.g.support)\n        \u251c\u2500\u2500 linkedkey            [@Prototype]     BindService                                     at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:16) *OVERRIDE\n        \u2514\u2500\u2500 instance             [@Singleton]     BindService2                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:17) *OVERRIDE\n\n\n    1 UNDECLARED bindings\n    \u2514\u2500\u2500 JitService                   (r.v.d.g.d.r.g.s.exts)\n\n\n    BINDING CHAINS\n    \u2514\u2500\u2500 BindService  --[linked]--&gt;  OverrideService\n</code></pre> <p>Important</p> <p>Report is build using guice SPI from raw modules and that's why it shows everything that modules configure (listeners, aop). But this also cause an additional execution of  <code>configure()</code> method of all modules when report is enabled.</p> <p>In most cases, this is not a problem (modules should only declare bindings). Report use stage <code>TOOL</code>, so, if required, you can easilly avoid duplicate execution for sensitive logic:  <pre><code>if (binder.currentStage() != Stage.TOOL) {\n    // do only on normal run\n}\n</code></pre> For example, guicey itself use this in installers to avoid duplicate console output on startup when report enabled.</p> <p>Tip</p> <p>If you run application in IDE then binding traces (on the right) should be clickable in console (strange format of \"at + full class name\" used exactly to activate such links because IDE will consider these lines as stacktrace elements).</p> <p>Note</p> <p>You may use multiple modules of the same type (e.g. <code>.modules(new MyModule(), new MyModule())</code>) but report will always show each module only once (because it's impossible to know exact  instance for binding, only module class). </p> <p>Report contains 4 sections:</p> <ul> <li>Bindings of modules (registered with <code>.modules()</code>)</li> <li>Overriding bindings (from modules in <code>.modulesOverride()</code>)</li> <li>Undeclared bindings - JIT bindings (not declared in modules, but existing in runtime due to injection request)</li> <li>Binding chains. In most cases it's connection of interface to implementation like <code>bind(MyIface.class).to(MyIFaceImpl.class)</code>. Especially useful for binding overrides because show actual chain (with applied override).    </li> </ul> <p>Used markers:</p> <ul> <li><code>EXTENSION</code> - recognized extension binding</li> <li><code>REMOVED</code>- extension or module disabled and binding(s) removed</li> <li><code>AOP</code> - bean affected by guice AOP</li> <li><code>OVERRIDDEN</code> (only in modules tree) - binding is overridden with binding from overriding module</li> <li><code>OVERRIDES</code> (only in overriding modules tree) - binding override something in main modules</li> <li><code>WEB</code> - indicates modules extending <code>ServletModule</code></li> <li><code>PRIVATE</code> - indicates private module</li> </ul>"},{"location":"guide/diagnostic/guice-report/#binding-types","title":"Binding types","text":"<p>Note</p> <p>All non-binding declarations (listeners, aop handlers) are put into square braces (e.g. `lt;typelistener&gt;)</p> Name Example &lt;scope&gt; <code>bindScope(..)</code> &lt;aop&gt; <code>bindInterceptor(..)</code> &lt;typelistener&gt; <code>bindListener(..)</code> &lt;provisionlistener&gt; <code>bindListener(..)</code> &lt;typeconverter&gt; <code>convertToTypes(..)</code> &lt;filterkey&gt; <code>filter(\"/1/*\").through(MyFilter.class)</code> (in <code>ServletModule</code>) &lt;filterinstance&gt; <code>filter(\"/1/*\").through(new MyFilter())</code> (in <code>ServletModule</code>) &lt;servletkey&gt; <code>serve(\"/1/foo\").with(MyServlet.class)</code> (in <code>ServletModule</code>) &lt;servletinstance&gt; <code>serve(\"/1/foo\").with(new MyServlet())</code> (in <code>ServletModule</code>) instance <code>bing(Smth.class).toInstance(obj)</code> providerinstance <code>bind(Smth.class).toProvider(obj)</code> linkedkey <code>bind(Smth.class).to(Other.class)</code> (<code>Other</code> may be already declared with separate binding) providerkey <code>bind(Smth.class).toProvider(DmthProv.class)</code> untargeted <code>bind(Smth.class)</code> providermethod Module method annotated with <code>@Provides</code> exposed <code>expose(PrivateService.class)</code> (service expose in <code>PrivateModule</code>) <p>Warning</p> <p>Multibindings extension bindings are showed as raw bindings. There are no special support to aggregate them (maybe will be added later). </p> <pre><code> MultibindingsModule          (r.v.d.g.d.r.g.support)    \n        \u251c\u2500\u2500 linkedkey            [@Prototype]     @Element Plugin (multibinding)                  at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.MultibindingsModule.configure(MultibindingsModule.java:17)\n        \u251c\u2500\u2500 instance             [@Singleton]     @Element Plugin (multibinding)                  at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.MultibindingsModule.configure(MultibindingsModule.java:18)\n</code></pre> <p>for</p> <pre><code>Multibinder.newSetBinder(binder(), Plugin.class).addBinding().to(MyPlugin.class)\n</code></pre>"},{"location":"guide/diagnostic/guice-report/#overrides","title":"Overrides","text":"<p>Report explicitly marks overridden bindings (by overriding modules). For example, in the report above, module binding</p> <pre><code>\u251c\u2500\u2500 linkedkey            [@Prototype]     BindService                                     at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:37) *OVERRIDDEN\n</code></pre> <p>is overridden by</p> <pre><code>\u251c\u2500\u2500 linkedkey            [@Prototype]     BindService                                     at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.OverrideModule.configure(OverrideModule.java:16) *OVERRIDE\n</code></pre> <p>Important</p> <p>Report lines are long so you'll have to scroll report blocks to the right to see markers.</p>"},{"location":"guide/diagnostic/guice-report/#aop","title":"Aop","text":"<p>Report shows all beans affected with aop:</p> <pre><code>\u251c\u2500\u2500 untargetted          [@Singleton]     AopedService                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.CasesModule.configure(CasesModule.java:36) *AOP\n</code></pre> <p>Tip</p> <p>Use AOP report to see what exact handlers were applied and with what order.</p>"},{"location":"guide/diagnostic/guice-report/#private-modules","title":"Private modules","text":"<p>For private guice modules report will show all internal bindings:</p> <pre><code>INFO  [2019-10-13 09:21:21,080] ru.vyarus.dropwizard.guice.debug.GuiceBindingsDiagnostic: Guice bindings = \n\n    4 MODULES with 4 bindings\n    \u2502   \n    \u2514\u2500\u2500 OuterModule                  (r.v.d.g.d.r.g.s.privt)    \n        \u2502   \n        \u2514\u2500\u2500 InnerModule                  (r.v.d.g.d.r.g.s.privt)    *PRIVATE\n            \u251c\u2500\u2500 untargetted          [@Prototype]     InnerService                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:14)\n            \u251c\u2500\u2500 untargetted          [@Prototype]     OuterService                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:15) *EXPOSED\n            \u251c\u2500\u2500 exposed              [@Prototype]     OuterService                                    at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.InnerModule.configure(InnerModule.java:17)\n            \u2502   \n            \u2514\u2500\u2500 Inner2Module                 (r.v.d.g.d.r.g.s.privt)    \n                \u251c\u2500\u2500 untargetted          [@Prototype]     InnerService2                                   at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.Inner2Module.configure(Inner2Module.java:14)\n                \u2502   \n                \u2514\u2500\u2500 Inner3Module                 (r.v.d.g.d.r.g.s.privt)    *PRIVATE\n                    \u2514\u2500\u2500 untargetted          [@Prototype]     OutServ                                         at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.privt.Inner3Module.configure(Inner3Module.java:13) *EXPOSED\n</code></pre> <p>where</p> <pre><code>public class OuterModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        install(new InnerModule());\n    }\n}\n\npublic class InnerModule extends PrivateModule {\n    @Override\n    protected void configure() {\n        install(new Inner2Module());\n        bind(InnerService.class);\n        bind(OuterService.class);\n\n        expose(OuterService.class);\n    }   \n}      \n\npublic class Inner2Module extends AbstractModule {\n    @Override\n    protected void configure() {\n        install(new Inner3Module());\n        bind(InnerService2.class);\n    }                                             \n}\n\npublic class Inner3Module extends PrivateModule {\n\n    @Override\n    protected void configure() {\n        bind(OutServ.class);\n        expose(OutServ.class);\n    }\n}\n</code></pre> <p>Warning</p> <p>Exposed service from inner private module <code>expose(OutServ.class);</code> is not shown in report! It is hidden intentionally to clarify which bindings are visible by application (only exposed  bindings after the top-most private module).</p>"},{"location":"guide/diagnostic/guice-report/#removed-bindings","title":"Removed bindings","text":"<p>For recognized extensions and transitive modules guicey can apply disable rules: so when you disable extension (<code>.disableExtensions</code>) or guice module (<code>.disableModules</code>) it will physically remove relative bindings. All removed are indicated on report.</p> <p>For example:</p> <pre><code>INFO  [2019-10-13 09:26:59,502] ru.vyarus.dropwizard.guice.debug.GuiceBindingsDiagnostic: Guice bindings = \n\n    2 MODULES with 2 bindings\n    \u2502   \n    \u2514\u2500\u2500 TransitiveModule             (r.v.d.g.d.r.g.support)    \n        \u251c\u2500\u2500 untargetted          [@Prototype]     Res1                                            at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:15) *EXTENSION\n        \u251c\u2500\u2500 untargetted          [@Prototype]     Res2                                            at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:16) *EXTENSION, REMOVED\n        \u2514\u2500\u2500 Inner                        (r.v.d.g.d.r.g.s.TransitiveModule) *REMOVED\n</code></pre> <p>where:</p> <pre><code>public class TransitiveModule extends AbstractModule {\n\n    @Override\n    protected void configure() {\n        bind(Res1.class);\n        bind(Res2.class);\n        install(new Inner());\n    }\n\n    public static class Inner extends AbstractModule {\n        @Override\n        protected void configure() {\n            ...\n        }\n    }\n}      \n\n\nGuiceBundle.builder()\n        .modules(new TransitiveModule())\n        .disableExtensions(TransitiveModule.Res2)\n        .disableModules(TransitiveModule.Inner)\n        .printGuiceBindings()\n        .build()\n</code></pre>"},{"location":"guide/diagnostic/guice-report/#report-customization","title":"Report customization","text":"<p>Report is implemented as guicey event listener and provide additional customization  options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration.</p> <p>For example, guice bindings report without library bindings is configured like this:</p> <pre><code>listen(new GuiceBindingsDiagnostic(new GuiceConfig()\n                    .hideGuiceBindings()\n                    .hideGuiceyBindings())\n</code></pre> <p>Report rendering logic may also be used directly as report provide separate renderer object implementing <code>ReportRenderer</code>. Renderer not bound to guice context and assume direct instantiation. </p> <p>For examples of direct renderer usage see events implementation:</p> <ul> <li><code>InjectorPhaseEvent.ReportRenderer</code> </li> </ul>"},{"location":"guide/diagnostic/installers-report/","title":"Installers report","text":"<p>Installers report is intended to show what extensions could be used and share some light on how installers work.</p> <p>Activation:</p> <pre><code>GuiceBundle.builder() \n    ...\n    .printAvailableInstallers()\n    .build());\n</code></pre> <p>Example output:</p> <pre><code>INFO  [2019-10-11 06:09:06,085] ru.vyarus.dropwizard.guice.debug.ConfigurationDiagnostic: Available installers report\n\n---------------------------------------------------------------------------[CONFIGURATION]\n\n    INSTALLERS in processing order = \n        OBJECT, ORDER                  lifecycle            (r.v.d.g.m.i.f.LifeCycleInstaller)     \n        OBJECT, ORDER                  managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n        OBJECT                         jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) \n        JERSEY, BIND, OPTIONS          jerseyprovider       (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) \n        TYPE, JERSEY, BIND, OPTIONS    resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n        BIND                           eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller) \n        OBJECT                         healthcheck          (r.v.d.g.m.i.f.h.HealthCheckInstaller) \n        OBJECT                         task                 (r.v.d.g.m.i.feature.TaskInstaller)    \n        BIND                           plugin               (r.v.d.g.m.i.f.plugin.PluginInstaller) \n        OBJECT, OPTIONS, ORDER         webservlet           (r.v.d.g.m.i.f.w.WebServletInstaller)  \n        OBJECT, ORDER                  webfilter            (r.v.d.g.m.i.f.web.WebFilterInstaller) \n        OBJECT, OPTIONS, ORDER         weblistener          (r.v.d.g.m.i.f.w.l.WebListenerInstaller) \n\n\n---------------------------------------------------------------------------[CONFIGURATION TREE]\n\n    APPLICATION\n    \u2502   \n    \u2514\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n        \u251c\u2500\u2500 installer  LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  ManagedInstaller             (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  JerseyProviderInstaller      (r.v.d.g.m.i.f.j.provider) \n        \u251c\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  EagerSingletonInstaller      (r.v.d.g.m.i.f.eager)      \n        \u251c\u2500\u2500 installer  HealthCheckInstaller         (r.v.d.g.m.i.f.health)     \n        \u251c\u2500\u2500 installer  TaskInstaller                (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  PluginInstaller              (r.v.d.g.m.i.f.plugin)     \n        \u2502   \n        \u2514\u2500\u2500 WebInstallersBundle          (r.v.d.g.m.installer)      \n            \u251c\u2500\u2500 installer  WebFilterInstaller           (r.v.d.g.m.i.f.web)        \n            \u251c\u2500\u2500 installer  WebServletInstaller          (r.v.d.g.m.i.f.web)        \n            \u2514\u2500\u2500 installer  WebListenerInstaller         (r.v.d.g.m.i.f.w.listener)      \n</code></pre> <p>Note</p> <p>This is actually re-configured configuration report. But, in contrast to configuration report, it shows all installers (even not used). </p> <p>Also, it indicated used installer features. For example, looking at</p> <pre><code>OBJECT, ORDER                  managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n</code></pre> <p>You could see that managed installer (responsible for <code>Managed</code> objects installation) use objects for installation (obtains extension instance from guice and registers it). Also it supports ordering (so extensions could use <code>@Order</code> annotation). </p> <p>By looking  at <code>@EagerSingleton</code> installer:</p> <pre><code>BIND                           eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller)\n</code></pre> <p>You can see that it only applies guice binding and nothing more.</p>"},{"location":"guide/diagnostic/installers-report/#installer-features","title":"Installer features","text":"Feature Description <code>OBJECT</code> Installer use object instances for extensions registration (obtain instance from guice context) <code>TYPE</code> Installer use extension class for extension registration. Usually it's jersey installers which has to register extension in jersey context <code>JERSEY</code> Installer installs jersey features (in time of jersey start and not after injector creation as \"pure\" installers) <code>BIND</code> Installer perform manual guice binding. For such installers, automatic untargeted binding for extension is not created (assuming installer require some custom binding). Such installers also verify manual guice bindings, when they are recognized as extension binding. <code>OPTIONS</code> Installer requires access for options. Most likely it means it supports additional configuration options (but it cold just read core options value). <code>ORDER</code> Installer supports extensions ordering. Use <code>@Order</code> annotation to declare order."},{"location":"guide/diagnostic/jersey-report/","title":"Jersey config report","text":"<p>Report shows all registered jersey extensions, including registered by dropwizard and all manual registrations.</p> <pre><code>GuiceBundle.builder()\n    ...\n    .printJerseyConfig() \n    .build()\n</code></pre> <p>Example report:</p> <pre><code>INFO  [2019-10-28 06:16:44,068] ru.vyarus.dropwizard.guice.debug.JerseyConfigDiagnostic: Jersey configuration = \n\n    Exception mappers\n        Throwable                      ExceptionMapperBinder$1      (io.dropwizard.setup)      \n        EofException                   EarlyEofExceptionMapper      (i.d.jersey.errors)        \n        EmptyOptionalException         EmptyOptionalExceptionMapper (i.d.jersey.optional)      \n        IOException                    GuiceExceptionMapper         (r.v.d.g.c.h.support)      \n        IOException                    HKExceptionMapper            (r.v.d.g.c.h.s.hk)         *jersey managed\n        IllegalStateException          IllegalStateExceptionMapper  (i.d.jersey.errors)        \n        JerseyViolationException       JerseyViolationExceptionMapper (i.d.j.validation)         \n        JsonProcessingException        JsonProcessingExceptionMapper (i.d.jersey.jackson)       \n        ValidationException            ValidationExceptionMapper    (o.g.j.s.v.internal)       \n\n    Param converters\n        AbstractParamConverterProvider (i.d.jersey.params)        \n        FuzzyEnumParamConverterProvider (i.d.j.validation)         \n        GuiceParamConverterProvider  (r.v.d.g.c.h.support)      \n        HKParamConverterProvider     (r.v.d.g.c.h.s.hk)         *jersey managed\n        RootElementProvider          (o.g.j.j.i.JaxbStringReaderProvider) \n        OptionalDoubleParamConverterProvider (i.d.jersey.optional)      \n        OptionalIntParamConverterProvider (i.d.jersey.optional)      \n        OptionalLongParamConverterProvider (i.d.jersey.optional)      \n        OptionalParamConverterProvider (i.d.jersey.guava)         \n        OptionalParamConverterProvider (i.d.jersey.optional)      \n        AggregatedProvider           (o.g.j.i.i.ParamConverters) \n\n    Context resolvers\n        Context                        GuiceContextResolver         (r.v.d.g.c.h.support)      \n        Context                        HKContextResolver            (r.v.d.g.c.h.s.hk)         *jersey managed\n\n    Message body readers\n        Object                         BasicTypesMessageProvider    (o.g.j.m.internal)                       [text/plain]\n        byte[]                         ByteArrayProvider            (o.g.j.m.internal)                       [application/octet-stream, */*]\n        DataSource                     DataSourceProvider           (o.g.j.m.internal)                       [application/octet-stream, */*]\n        Document                       DocumentProvider             (o.g.j.jaxb.internal)                    [application/xml, text/xml, */*]\n        File                           FileProvider                 (o.g.j.m.internal)                       [application/octet-stream, */*]\n        MultivaluedMap&lt;String, String&gt; FormMultivaluedMapProvider   (o.g.j.m.internal)                       [application/x-www-form-urlencoded]\n        Form                           FormProvider                 (o.g.j.m.internal)                       [application/x-www-form-urlencoded, */*]\n        Type                           GuiceMessageBodyReader       (r.v.d.g.c.h.support)                    \n        Type                           HKMessageBodyReader          (r.v.d.g.c.h.s.hk)         *jersey managed \n        InputStream                    InputStreamProvider          (o.g.j.m.internal)                       [application/octet-stream, */*]\n        Object                         JacksonJsonProvider          (c.f.j.jaxrs.json)                       [*/*]\n        Object                         JacksonMessageBodyProvider   (i.d.jersey.jackson)                     [*/*]\n        Reader                         ReaderProvider               (o.g.j.m.internal)                       [text/plain, */*]\n        RenderedImage                  RenderedImageProvider        (o.g.j.m.internal)                       [image/*, application/octet-stream]\n        StreamSource                   StreamSourceReader           (o.g.j.m.i.SourceProvider)               [application/xml, text/xml, */*]\n        SAXSource                      SaxSourceReader              (o.g.j.m.i.SourceProvider)               [application/xml, text/xml, */*]\n        DOMSource                      DomSourceReader              (o.g.j.m.i.SourceProvider)               [application/xml, text/xml, */*]\n        String                         StringMessageProvider        (o.g.j.m.internal)                       [text/plain, */*]\n        T[], Collection&lt;T&gt;             App                          (o.g.j.j.i.XmlCollectionJaxbProvider)    [application/xml]\n        T[], Collection&lt;T&gt;             Text                         (o.g.j.j.i.XmlCollectionJaxbProvider)    [text/xml]\n        T[], Collection&lt;T&gt;             General                      (o.g.j.j.i.XmlCollectionJaxbProvider)    [*/*]\n        JAXBElement&lt;Object&gt;            App                          (o.g.j.j.i.XmlJaxbElementProvider)       [application/xml]\n        JAXBElement&lt;Object&gt;            Text                         (o.g.j.j.i.XmlJaxbElementProvider)       [text/xml]\n        JAXBElement&lt;Object&gt;            General                      (o.g.j.j.i.XmlJaxbElementProvider)       [*/*,*/*+xml]\n        Object                         App                          (o.g.j.j.i.XmlRootElementJaxbProvider)   [application/xml]\n        Object                         Text                         (o.g.j.j.i.XmlRootElementJaxbProvider)   [text/xml]\n        Object                         General                      (o.g.j.j.i.XmlRootElementJaxbProvider)   [*/*]\n        Object                         App                          (o.g.j.j.i.XmlRootObjectJaxbProvider)    [application/xml]\n        Object                         Text                         (o.g.j.j.i.XmlRootObjectJaxbProvider)    [text/xml]\n        Object                         General                      (o.g.j.j.i.XmlRootObjectJaxbProvider)    [*/*]\n\n    Message body writers\n        Object                         BasicTypesMessageProvider    (o.g.j.m.internal)                       [text/plain]\n        byte[]                         ByteArrayProvider            (o.g.j.m.internal)                       [application/octet-stream, */*]\n        ChunkedOutput&lt;Object&gt;          ChunkedResponseWriter        (o.g.jersey.server)                      \n        DataSource                     DataSourceProvider           (o.g.j.m.internal)                       [application/octet-stream, */*]\n        Document                       DocumentProvider             (o.g.j.jaxb.internal)                    [application/xml, text/xml, */*]\n        File                           FileProvider                 (o.g.j.m.internal)                       [application/octet-stream, */*]\n        MultivaluedMap&lt;String, String&gt; FormMultivaluedMapProvider   (o.g.j.m.internal)                       [application/x-www-form-urlencoded]\n        Form                           FormProvider                 (o.g.j.m.internal)                       [application/x-www-form-urlencoded, */*]\n        Type                           GuiceMessageBodyWriter       (r.v.d.g.c.h.support)                    \n        Type                           HKMessageBodyWriter          (r.v.d.g.c.h.s.hk)         *jersey managed \n        InputStream                    InputStreamProvider          (o.g.j.m.internal)                       [application/octet-stream, */*]\n        Object                         JacksonJsonProvider          (c.f.j.jaxrs.json)                       [*/*]\n        Object                         JacksonMessageBodyProvider   (i.d.jersey.jackson)                     [*/*]\n        OptionalDouble                 OptionalDoubleMessageBodyWriter (i.d.jersey.optional)                 [*/*]\n        OptionalInt                    OptionalIntMessageBodyWriter (i.d.jersey.optional)                    [*/*]\n        OptionalLong                   OptionalLongMessageBodyWriter (i.d.jersey.optional)                   [*/*]\n        Optional&lt;Object&gt;               OptionalMessageBodyWriter    (i.d.jersey.guava)                       [*/*]\n        Optional&lt;Object&gt;               OptionalMessageBodyWriter    (i.d.jersey.optional)                    [*/*]\n        Reader                         ReaderProvider               (o.g.j.m.internal)                       [text/plain, */*]\n        RenderedImage                  RenderedImageProvider        (o.g.j.m.internal)                       [image/*]\n        Source                         SourceWriter                 (o.g.j.m.i.SourceProvider)               [application/xml, text/xml, */*]\n        StreamingOutput                StreamingOutputProvider      (o.g.j.m.internal)                       [application/octet-stream, */*]\n        String                         StringMessageProvider        (o.g.j.m.internal)                       [text/plain, */*]\n        Object                         ValidationErrorMessageBodyWriter (o.g.j.s.v.internal)                 \n        T[], Collection&lt;T&gt;             App                          (o.g.j.j.i.XmlCollectionJaxbProvider)    [application/xml]\n        T[], Collection&lt;T&gt;             Text                         (o.g.j.j.i.XmlCollectionJaxbProvider)    [text/xml]\n        T[], Collection&lt;T&gt;             General                      (o.g.j.j.i.XmlCollectionJaxbProvider)    [*/*]\n        JAXBElement&lt;Object&gt;            App                          (o.g.j.j.i.XmlJaxbElementProvider)       [application/xml]\n        JAXBElement&lt;Object&gt;            Text                         (o.g.j.j.i.XmlJaxbElementProvider)       [text/xml]\n        JAXBElement&lt;Object&gt;            General                      (o.g.j.j.i.XmlJaxbElementProvider)       [*/*,*/*+xml]\n        Object                         App                          (o.g.j.j.i.XmlRootElementJaxbProvider)   [application/xml]\n        Object                         Text                         (o.g.j.j.i.XmlRootElementJaxbProvider)   [text/xml]\n        Object                         General                      (o.g.j.j.i.XmlRootElementJaxbProvider)   [*/*]\n\n    Reader interceptors\n        MappableExceptionWrapperInterceptor (o.g.j.s.internal)         \n        GuiceReaderInterceptor       (r.v.d.g.c.h.support)      \n        HKReaderInterceptor          (r.v.d.g.c.h.s.hk)         *jersey managed\n\n    Writer interceptors\n        MappableExceptionWrapperInterceptor (o.g.j.s.internal)         \n        JsonWithPaddingInterceptor   (o.g.j.s.internal)         \n        GuiceWriterInterceptor       (r.v.d.g.c.h.support)      \n        HKWriterInterceptor          (r.v.d.g.c.h.s.hk)         *jersey managed\n\n    Container request filters\n        GuiceContainerRequestFilter  (r.v.d.g.c.h.support)      \n        HKContainerRequestFilter     (r.v.d.g.c.h.s.hk)         *jersey managed\n\n    Container response filters\n        GuiceContainerResponseFilter (r.v.d.g.c.h.support)      \n        HKContainerResponseFilter    (r.v.d.g.c.h.s.hk)         *jersey managed\n\n    Dynamic features\n        CacheControlledResponseFeature (i.d.jersey.caching)       \n        GuiceDynamicFeature          (r.v.d.g.c.h.support)      \n        HKDynamicFeature             (r.v.d.g.c.h.s.hk)         *jersey managed\n\n    Param value providers\n        AsyncResponseValueParamProvider (o.g.j.s.i.inject)         \n        BeanParamValueParamProvider  (o.g.j.s.i.inject)         \n        CookieParamValueParamProvider (o.g.j.s.i.inject)         \n        DelegatedInjectionValueParamProvider (o.g.j.s.i.inject)         \n        EntityParamValueParamProvider (o.g.j.s.i.inject)         \n        FormParamValueParamProvider  (o.g.j.s.i.inject)         \n        GuiceValueParamProvider      (r.v.d.g.c.h.support)      \n        HKValueParamProvider         (r.v.d.g.c.h.s.hk)         *jersey managed\n        HeaderParamValueParamProvider (o.g.j.s.i.inject)         \n        MatrixParamValueParamProvider (o.g.j.s.i.inject)         \n        PathParamValueParamProvider  (o.g.j.s.i.inject)         \n        QueryParamValueParamProvider (o.g.j.s.i.inject)         \n        SessionFactoryProvider       (i.d.jersey.sessions)      \n        WebTargetValueParamProvider  (o.g.j.s.i.inject)         \n\n    Injection resolvers\n        @Context                        ContextInjectionResolverImpl (o.g.j.inject.hk2)         \n        @Ann                            GuiceInjectionResolver       (r.v.d.g.c.h.support)      \n        @Ann                            HKInjectionResolver          (r.v.d.g.c.h.s.hk)         *jersey managed\n        @Suspended                      ParamInjectionResolver       (o.g.j.s.i.inject)          using AsyncResponseValueParamProvider \n        @CookieParam                    ParamInjectionResolver       (o.g.j.s.i.inject)          using CookieParamValueParamProvider \n        @FormParam                      ParamInjectionResolver       (o.g.j.s.i.inject)          using FormParamValueParamProvider \n        @HeaderParam                    ParamInjectionResolver       (o.g.j.s.i.inject)          using HeaderParamValueParamProvider \n        @MatrixParam                    ParamInjectionResolver       (o.g.j.s.i.inject)          using MatrixParamValueParamProvider \n        @PathParam                      ParamInjectionResolver       (o.g.j.s.i.inject)          using PathParamValueParamProvider \n        @QueryParam                     ParamInjectionResolver       (o.g.j.s.i.inject)          using QueryParamValueParamProvider \n        @Uri                            ParamInjectionResolver       (o.g.j.s.i.inject)          using WebTargetValueParamProvider \n        @BeanParam                      ParamInjectionResolver       (o.g.j.s.i.inject)          using BeanParamValueParamProvider \n</code></pre> <p>Warning</p> <p>Items order does not represent actual priority order! Items in each section are sorted according to <code>@Priority</code> annotation and then by name, but <code>@Custom</code> qualification priority is ignored (and so user extensions and default one may be shown in incorrect order). Report sorting applied only for consistency (always show the same order) - it's a trade off.</p>"},{"location":"guide/diagnostic/jersey-report/#common-markers","title":"Common markers","text":"<p>Markers are shown at the end of extension line. The following markers are common for all extension types.</p>"},{"location":"guide/diagnostic/jersey-report/#filter","title":"Filter","text":"<p>Jersey extension scope may be reduced with <code>@NameBinding</code> annotation. Custom annotation may  be created (declared as <code>@NameBinding</code>):</p> <pre><code>@NameBinding\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface FilterAnn {}\n</code></pre> <p>Now if extension will be annotated with it:</p> <pre><code>@Provider\n@FilterAnn\npublic class ExMapper implements ExceptionMapper&lt;IOException&gt; {}\n</code></pre> <p>Will be applied only to resources, annotated with <code>@FilterAnn</code>.</p> <p>Report will identify scoped extensions with marker:</p> <pre><code>IOException                    ExMapper                     (r.v.d.g.d.r.j.FilterMarkerRenderTest) *only @FilterAnn\n</code></pre>"},{"location":"guide/diagnostic/jersey-report/#lazy","title":"Lazy","text":"<p>Extensions annotated with <code>@LazyBinding</code> are identified with marker:</p> <pre><code>IOException                    ExMapper                     (r.v.d.g.d.r.j.LazyRenderTest) *lazy\n</code></pre>"},{"location":"guide/diagnostic/jersey-report/#jersey-managed","title":"Jersey managed","text":"<p>Extensions, managed by HK2 are also identified with marker:</p> <pre><code>@Ann                            HKInjectionResolver          (r.v.d.g.c.h.s.hk)         *jersey managed\n</code></pre>"},{"location":"guide/diagnostic/jersey-report/#exception-mappers","title":"Exception mappers","text":"<p>Extended exception mappers (these mappers may decide if they accept exception handling):</p> <pre><code>@Provider\npublic class ExtMapper implements ExtendedExceptionMapper&lt;IOException&gt; {\n    @Override\n    public boolean isMappable(IOException exception) {\n        return false;\n    }\n\n    @Override\n    public Response toResponse(IOException exception) {\n        return null;\n    }\n}\n</code></pre> <p>Are identified in report:</p> <pre><code>OException                    ExtMapper                    (r.v.d.g.d.r.j.ExtendedExceptionMapperRenderTest) *extended\n</code></pre>"},{"location":"guide/diagnostic/jersey-report/#report-customization","title":"Report customization","text":"<p>Report is implemented as guicey event listener and provide additional customization  options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration.</p> <p>For example, to show only exception mappers:</p> <pre><code>listen(new JerseyConfigDiagnostic(new JerseyConfig()\n                    .showExceptionMappers()))\n</code></pre> <p>Report rendering logic may also be used directly as report provide separate renderer object implementing <code>ReportRenderer</code>. Renderer not bound to guice context and assume direct instantiation.</p>"},{"location":"guide/diagnostic/lifecycle-report/","title":"Lifecycle report","text":"<p>In contrast to other reports, this report prints many small messages: 1 message on each meaningful  guicey lifecycle points. This lets you:</p> <ul> <li>See how configuration goes (and so on each stage problem appear)</li> <li>Separate your logs (making entire startup operations order more obvious)</li> <li>Indicate time since application startup making obvious how much time application spent on each phase.</li> </ul> <pre><code>GuiceBundle.builder()\n    ...\n    .printLifecyclePhases()\n     // or printLifecyclePhasesDetailes() to see all confgiruation objects used on logged stage \n    .build()\n</code></pre> <p>Example output:    </p> <pre><code>                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.013 ]____________________________________________________/  1 hooks processed  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.121 ]____________________________________________________/  Initialized 3 (-1) GuiceyBundles  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.136 ]____________________________________________________/  2 commands installed  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.151 ]____________________________________________________/  11 (-1) installers initialized  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.158 ]____________________________________________________/  14 classpath extensions detected  \\____\n\nINFO  [2019-10-13 08:33:33,925] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /\nINFO  [2019-10-13 08:33:33,926] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.869 ]____________________________________________________/  Started 3 GuiceyBundles  \\____\n...\n</code></pre> <p>Important</p> <p>Lifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events.  Anyway, these logs intended to be used for problems resolution and so console only output should not be a problem.</p> <p>Note</p> <p><code>(-1)</code> in some events in report means disabled items and actual displayed count did not count disabled items. You can see all disabled items on detailed output.</p>"},{"location":"guide/diagnostic/lifecycle-report/#detailed-output","title":"Detailed output","text":"<p>Detailed report (<code>.printLifecyclePhasesDetailed()</code>) shows all configuration objects used at current stage. </p> <p>Example detailed output:</p> <pre><code>                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.013 ]____________________________________________________/  1 hooks processed  \\____\n\n    hooks = \n        GuiceyTestHook               (r.v.d.g.AbstractTest)     \n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.118 ]____________________________________________________/  Initialized 3 (-1) GuiceyBundles  \\____\n\n    bundles = \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        WebInstallersBundle          (r.v.d.g.m.installer)      \n\n    disabled = \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        \n\n    ignored duplicate instances = \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        \n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.131 ]____________________________________________________/  2 commands installed  \\____\n\n    commands = \n        DummyCommand                 (r.v.d.g.s.feature)        \n        NonInjactableCommand         (r.v.d.g.s.feature)        \n\n...    \n</code></pre>"},{"location":"guide/diagnostic/lifecycle-report/#timer","title":"Timer","text":"<p>Each log contains time marker:</p> <pre><code>__[ 00:00:00.131 ]___\n</code></pre> <p>Timer starts on <code>GuiceBundle</code> creation (it is physically impossible to start it earlier).</p> <p>Note that timer also measure shutdown time (starting from initial shutdown start event):</p> <pre><code>                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.000 ]____________________________________________________/  Stopping Jetty...  \\____\n\nINFO  [2019-10-13 08:36:02,882] org.eclipse.jetty.server.AbstractConnector: Stopped application@36cc9385{HTTP/1.1,[http/1.1]}{0.0.0.0:8080}\nINFO  [2019-10-13 08:36:02,883] org.eclipse.jetty.server.AbstractConnector: Stopped admin@cf518cf{HTTP/1.1,[http/1.1]}{0.0.0.0:8081}\nINFO  [2019-10-13 08:36:02,886] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@5a484ce1{Admin context,/,null,UNAVAILABLE}\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.000 ]____________________________________________________/  Jersey app destroyed  \\____\n\nINFO  [2019-10-13 08:36:02,892] org.eclipse.jetty.server.handler.ContextHandler: Stopped i.d.j.MutableServletContextHandler@3cc30dee{Application context,/,null,UNAVAILABLE}\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.000 ]____________________________________________________/  Jetty stopped  \\____\n</code></pre> <p>This may help you to spot slow shutdown logic.</p>"},{"location":"guide/diagnostic/shared-state-report/","title":"Shared state usage","text":"<p>Guicey shared state is a bundle communication mechanism and safe \"static\" access for the important objects (quite rarely required). Before, it was not clear the real sequence of state population and access, and now there is a special report showing all state manipulations:</p> <pre><code>GuiceBundle.builder()\n    .printSharedStateUsage()\n</code></pre> <pre><code>INFO  [2025-03-27 09:49:35,219] ru.vyarus.dropwizard.guice.debug.SharedStateDiagnostic: Shared configuration state usage: \n\n    SET Options (ru.vyarus.dropwizard.guice.module.context.option)                           at r.v.d.g.m.context.(ConfigurationContext.java:167)\n\n    SET List (java.util)                                                                     at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:60)\n        MISS at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:56)\n        GET at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:57)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:60)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:61)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:62)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:73)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:74)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:82)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:84)\n\n    SET Bootstrap (io.dropwizard.core.setup)                                                 at r.v.d.g.m.context.(ConfigurationContext.java:806)\n\n    SET Map (java.util)                                                                      at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:97)\n        MISS at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:93)\n        GET at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:94)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:97)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:98)\n        GET  at r.v.d.g.d.SharedStateDiagnosticTest.(SharedStateDiagnosticTest.java:101)\n    ...     \n</code></pre>"},{"location":"guide/diagnostic/startup-report/","title":"Startup times","text":"<p>The report intended to show the entire application startup time information to simplify searching for bottlenecks. It's hard to measure everything exactly from a bundle, but the report will try to show the time spent in each phase (init, run, web) and time of each registered dropwizard bundle.</p> <pre><code>GuiceBundle.builder()\n    .printStartupTime()\n</code></pre> <p>Sample output:</p> <pre><code>INFO  [2025-03-27 09:12:27,435] ru.vyarus.dropwizard.guice.debug.StartupTimeDiagnostic: Application startup time: \n\n    JVM time before                    : 1055 ms\n\n    Application startup                : 807 ms\n        Dropwizard initialization          : 127 ms\n            GuiceBundle                        : 123 ms (finished since start at 127 ms)\n                Bundle builder time                : 38 ms\n                Hooks processing                   : 3.23 ms\n                    StartupDiagnosticTest$Test1$$Lambda/0x0000711de72a1d70: 2.37 ms\n                Classpath scan                     : 44 ms\n                Commands processing                : 4.41 ms\n                    DummyCommand                       : 0.42 ms\n                    NonInjactableCommand               : 3.16 ms\n                Bundles lookup                     : 1.15 ms\n                Guicey bundles init                : 3.24 ms\n                    WebInstallersBundle                : 0.52 ms\n                    CoreInstallersBundle               : 1.83 ms\n                Installers time                    : 21 ms\n                    Installers resolution              : 15 ms\n                    Scanned extensions recognition     : 6.13 ms\n                Listeners time                     : 1.35 ms\n                    ConfigurationHooksProcessedEvent   : 0.23 ms\n                    BeforeInitEvent                    : 0.59 ms\n                    BundlesResolvedEvent               : 0.009 ms\n                    BundlesInitializedEvent            : 0.43 ms\n                    CommandsResolvedEvent              : 0.006 ms\n                    InstallersResolvedEvent            : 0.01 ms\n                    ClasspathExtensionsResolvedEvent   : 0.009 ms\n                    InitializedEvent                   : 0.007 ms\n\n        Dropwizard run                     : 679 ms\n            Configuration and Environment      : 483 ms\n            GuiceBundle                        : 196 ms\n                Configuration analysis             : 20 ms\n        ...     \n</code></pre> <p>Limitations</p> <ul> <li>Can't show init time of dropwizard bundles, registered before the guice bundle (obviously)</li> <li><code>Applicaion#run</code> method time measured as part of \"web\" (the bundle can't see this point, but should not be a problem)</li> </ul> <p>The report could be also enabled for compiled application: <code>-Dguicey.hooks=startup-time</code> </p>"},{"location":"guide/diagnostic/startup-report/#before-time","title":"Before time","text":"<p>The report can't know what was happening before application initialization (jvm startup time), but this is usually a meaningful time (while real person waits for application startup).</p> <p>So all time before application is indicated with (value obtained from MX bean): </p> <p><code>JVM time before                    : 1055 ms</code></p>"},{"location":"guide/diagnostic/web-report/","title":"Web mappings report","text":"<p>Report shows all registered servlets and filters (including declared in guice <code>ServletModule</code>).</p> <pre><code>GuiceBundle.builder()\n    ...\n    .printWebMappings() \n    .build()\n</code></pre> <p>Example report:</p> <pre><code>INFO  [2019-10-24 07:48:32,601] ru.vyarus.dropwizard.guice.debug.WebMappingsDiagnostic: Web mappings: \n\n    MAIN /\n    \u251c\u2500\u2500 filter     /custom/*                    CustomMappingFilter          (r.v.d.g.d.r.w.s.UserServletsBundle)                    [ERROR]         .custommapping\n    \u251c\u2500\u2500 filter     /async/*             async   AsyncFilter                  (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .async\n    \u251c\u2500\u2500 filter     /both/*                      BothFilter                   (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .both\n    \u251c\u2500\u2500 filter     /1/*                         MainFilter                   (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .main\n    \u251c\u2500\u2500 filter     /2/*                         --\"--                                                                                                \n    \u2502   \n    \u251c\u2500\u2500 filter     /*                   async   GuiceFilter                  (c.g.inject.servlet)                                    [REQUEST]       Guice Filter\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/*                         GFilter                        r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/abc?/.*           regex   GRegexFilter                   r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/foo                       instance of GFilterInstance    r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guiceservlet    /2/*                         GServlet                       r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guiceservlet    /2/abc?/             regex   GRegexServlet                  r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u2514\u2500\u2500 guiceservlet    /2/foo                       instance of GServletInstance   r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \n    \u251c\u2500\u2500 filter     /*                   async   AllowedMethodsFilter         (i.d.jersey.filter)                                     [REQUEST]       io.dropwizard.jersey.filter.AllowedMethodsFilter-5d51e129\n    \u251c\u2500\u2500 filter     /*                   async   ThreadNameFilter             (i.d.servlets)                                          [REQUEST]       io.dropwizard.servlets.ThreadNameFilter-21c815e4\n    \u2502   \n    \u251c\u2500\u2500 servlet    /foo                         MainServlet                  (r.v.d.g.d.r.w.s.UserServletsBundle)                                    target\n    \u2502   \u2514\u2500\u2500 filter                                  TargetServletFilter          (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .targetservlet\n    \u2502   \n    \u251c\u2500\u2500 servlet    /bar                         --\"--                                                                                                \n    \u251c\u2500\u2500 servlet    /both                        BothServlet                  (r.v.d.g.d.r.w.s.UserServletsBundle)                                    .both\n    \u251c\u2500\u2500 servlet    /async               async   AsyncServlet                 (r.v.d.g.d.r.w.s.UserServletsBundle)                                    .async\n    \u251c\u2500\u2500 servlet    /*                   async   JerseyServletContainer       (i.d.jersey.setup)                                                      io.dropwizard.jersey.setup.JerseyServletContainer-cf518cf\n    \u2514\u2500\u2500 servlet    /                    async   Default404Servlet            (o.e.j.s.ServletHandler)                                                org.eclipse.jetty.servlet.ServletHandler$Default404Servlet-5a6fa56e\n\n\n    ADMIN /\n    \u251c\u2500\u2500 filter     /both/*                      BothFilter                   (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .both\n    \u251c\u2500\u2500 filter     /1/*                         AdminFilter                  (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .admin\n    \u251c\u2500\u2500 filter     /2/*                         --\"--                                                                                                \n    \u2502   \n    \u251c\u2500\u2500 filter     /*                   async   AdminGuiceFilter             (r.v.d.g.m.i.internal)                                  [REQUEST]       Guice Filter\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/*                         GFilter                        r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/abc?/.*           regex   GRegexFilter                   r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/foo                       instance of GFilterInstance    r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guiceservlet    /2/*                         GServlet                       r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guiceservlet    /2/abc?/             regex   GRegexServlet                  r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u2514\u2500\u2500 guiceservlet    /2/foo                       instance of GServletInstance   r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \n    \u251c\u2500\u2500 filter     /*                   async   AllowedMethodsFilter         (i.d.jersey.filter)                                     [REQUEST]       io.dropwizard.jersey.filter.AllowedMethodsFilter-5c080ef3\n    \u251c\u2500\u2500 servlet    /tasks/*             async   TaskServlet                  (i.d.servlets.tasks)                                                    tasks\n    \u251c\u2500\u2500 servlet    /fooadmin                    AdminServlet                 (r.v.d.g.d.r.w.s.UserServletsBundle)                                    .admin\n    \u251c\u2500\u2500 servlet    /baradmin                    --\"--                                                                                                \n    \u251c\u2500\u2500 servlet    /both                        BothServlet                  (r.v.d.g.d.r.w.s.UserServletsBundle)                                    .both\n    \u251c\u2500\u2500 servlet    /*                   async   AdminServlet                 (c.c.metrics.servlets)                                                  com.codahale.metrics.servlets.AdminServlet-24e83d19\n    \u2514\u2500\u2500 servlet    /                    async   Default404Servlet            (o.e.j.s.ServletHandler)                                                org.eclipse.jetty.servlet.ServletHandler$Default404Servlet-1200458e     \n</code></pre> <p>Report shows both main and admin contexts.</p> <p>Note</p> <p>Filter and servlet names are shown list at each line because they are often  autogenerated and hardly readable. Still name is required if you will need to  map filter to exact servlet (or to disable/stop exact servlet) </p> <p>For both filters and servlets async filters and  servlets are explicitly marked with <code>async</code>.</p> <p>Filters dispatch types are shown at the end of filter line:</p> <pre><code>\u251c\u2500\u2500 filter     /custom/*                    CustomMappingFilter          (r.v.d.g.d.r.w.s.UserServletsBundle)                    [ERROR]         .custommapping\n\u251c\u2500\u2500 filter     /async/*             async   AsyncFilter                  (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .async\n</code></pre> <p>If filter is applied by servlet name then it would be rendered below target servlet:</p> <pre><code>\u251c\u2500\u2500 servlet    /foo                         MainServlet                  (r.v.d.g.d.r.w.s.UserServletsBundle)                                    target\n\u2502   \u2514\u2500\u2500 filter                                  TargetServletFilter          (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .targetservlet\n</code></pre> <p>Warning</p> <p>Filters, applied by servlet name are not shown at all if target servlets are not registered.</p> <p>If filter or servlet is applied with multiple target urls then each pattern will start on new line and only on first line complete information will be shown (idem <code>--\"--</code> string will be used to identify same filter):</p> <pre><code>\u251c\u2500\u2500 filter     /1/*                         MainFilter                   (r.v.d.g.d.r.w.s.UserServletsBundle)                    [REQUEST]       .main\n\u251c\u2500\u2500 filter     /2/*                         --\"--                                                                                                  \n</code></pre>"},{"location":"guide/diagnostic/web-report/#guice","title":"Guice","text":"<p>Guice servlets and filters (declared in <code>ServletModule</code>s) are shown below guice <code>GuiceFilter</code> (guice filter actually intercept requests and then manually redirect to matching guice bean):</p> <pre><code>\u251c\u2500\u2500 filter     /*                   async   GuiceFilter                  (c.g.inject.servlet)                                    [REQUEST]       Guice Filter\n\u2502   \u251c\u2500\u2500 guicefilter     /1/*                         GFilter                        r.v.d.g.d.r.w.support.GuiceWebModule\n\u2502   \u251c\u2500\u2500 guicefilter     /1/abc?/.*           regex   GRegexFilter                   r.v.d.g.d.r.w.support.GuiceWebModule\n\u2502   \u251c\u2500\u2500 guicefilter     /1/foo                       instance of GFilterInstance    r.v.d.g.d.r.w.support.GuiceWebModule\n</code></pre> <p>Attention</p> <p>Guice servlets and filters are shown in both admin and main contexts, because <code>GuiceFilter</code> is applied on both contexts and so all urls will work in both contexts.</p> <p>Note that regex registrations are explicitly marked with <code>reges</code></p> <pre><code>filterRegex(\"/1/abc?/.*\").through(GRegexFilter.class)\n</code></pre>"},{"location":"guide/diagnostic/web-report/#state","title":"State","text":"<p>Report also indicate all stopped and disabled items (report below executed under lightweight guicey test, when jetty is not started):</p> <pre><code>    MAIN /\n    \u251c\u2500\u2500 filter     /custom/*                    CustomMappingFilter          (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED       [ERROR]         .custommapping\n    \u251c\u2500\u2500 filter     /async/*             async   AsyncFilter                  (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED       [REQUEST]       .async\n    \u251c\u2500\u2500 filter     /both/*                      BothFilter                   (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED       [REQUEST]       .both\n    \u251c\u2500\u2500 filter     /1/*                         MainFilter                   (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED       [REQUEST]       .main\n    \u251c\u2500\u2500 filter     /2/*                         --\"--\n    \u2502\n    \u251c\u2500\u2500 filter     /*                   async   GuiceFilter                  (c.g.inject.servlet)                      STOPPED       [REQUEST]       Guice Filter\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/*                         GFilter                        r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/abc?/.*           regex   GRegexFilter                   r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guicefilter     /1/foo                       instance of GFilterInstance    r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guiceservlet    /2/*                         GServlet                       r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u251c\u2500\u2500 guiceservlet    /2/abc?/             regex   GRegexServlet                  r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502   \u2514\u2500\u2500 guiceservlet    /2/foo                       instance of GServletInstance   r.v.d.g.d.r.w.support.GuiceWebModule\n    \u2502\n    \u251c\u2500\u2500 servlet    /foo                         MainServlet                  (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED                       target\n    \u2502   \u2514\u2500\u2500 filter                                  TargetServletFilter          (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED       [REQUEST]       .targetservlet\n    \u2502\n    \u251c\u2500\u2500 servlet    /bar                         --\"--\n    \u251c\u2500\u2500 servlet    /both                        BothServlet                  (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED                       .both\n    \u2514\u2500\u2500 servlet    /async               async   AsyncServlet                 (r.v.d.g.d.r.w.s.UserServletsBundle)      STOPPED                       .async\n</code></pre> <p>Here <code>MainServlet</code> is disabled (and stopped) and <code>BothServlet</code> is just stopped.</p> <p>Tip</p> <p>Servlet could be disabled like this:</p> <pre><code>environment.getApplicationContext().getServletHandler()\n        .getServlet(\"target\").setEnabled(false)\n</code></pre>"},{"location":"guide/diagnostic/web-report/#report-customization","title":"Report customization","text":"<p>Report is implemented as guicey event listener and provide additional customization  options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration.</p> <p>For example, same report by for main context only:</p> <pre><code>listen(new WebMappingsDiagnostic(new MappingsConfig()\n                    .showMainContext()\n                    .showDropwizardMappings()\n                    .showGuiceMappings()))\n</code></pre> <p>Report rendering logic may also be used directly as report provide separate renderer object implementing <code>ReportRenderer</code>. Renderer not bound to guice context and assume direct instantiation.    </p>"},{"location":"guide/diagnostic/yaml-values-report/","title":"Yaml values report","text":"<p>Prints all available direct yaml values:</p> <pre><code>GuiceBundle.builder()\n    ...\n    .printConfigurationBindings()\n     // or printCustomConfigurationBindings() to avoid dropwizard bindings \n    .build()\n</code></pre> <p>Note</p> <p>Even if custom binding report selected (<code>printCustomConfigurationBindings()</code>), guicey will always bind all bindings, including dropwizard <code>Configuration</code> class. Custom config report could just shows  less for simplicity.  </p> <p>Will print:</p> <pre><code>INFO  [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = \n\n    ComplexGenericCase (visible paths)\n    \u2502   \n    \u251c\u2500\u2500 sub: ComplexGenericCase.Sub&lt;String&gt;\n    \u2502   \u2514\u2500\u2500 smth: String = null\n    \u2502   \n    \u251c\u2500\u2500 logging: DefaultLoggingFactory\n    \u2502   \u251c\u2500\u2500 level: String = \"INFO\"\n    \u2502   \u251c\u2500\u2500 loggers: RegularImmutableMap&lt;String, JsonNode&gt; = {}\n    \u2502   \u2514\u2500\u2500 appenders: SingletonImmutableList&lt;AppenderFactory&lt;ILoggingEvent&gt;&gt; = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]\n    \u2502   \n    \u251c\u2500\u2500 metrics: MetricsFactory\n    \u2502   \u251c\u2500\u2500 frequency: Duration = 1 minute\n    \u2502   \u2514\u2500\u2500 reporters: RegularImmutableList&lt;ReporterFactory&gt; = []\n    \u2502   \n    \u2514\u2500\u2500 server: DefaultServerFactory\n        \u251c\u2500\u2500 maxThreads: Integer = 1024\n        \u251c\u2500\u2500 minThreads: Integer = 8\n        \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024\n        \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute\n        \u251c\u2500\u2500 nofileSoftLimit: Integer = null\n        \u251c\u2500\u2500 nofileHardLimit: Integer = null\n        \u251c\u2500\u2500 gid: Integer = null\n        \u251c\u2500\u2500 uid: Integer = null\n        \u251c\u2500\u2500 user: String = null\n        \u251c\u2500\u2500 group: String = null\n        \u251c\u2500\u2500 umask: String = null\n        \u251c\u2500\u2500 startsAsRoot: Boolean = null\n        \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true\n        \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false\n        \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds\n        \u251c\u2500\u2500 allowedMethods: HashSet&lt;String&gt; = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH]\n        \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true\n        \u251c\u2500\u2500 applicationConnectors: ArrayList&lt;ConnectorFactory&gt; = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b]\n        \u251c\u2500\u2500 adminConnectors: ArrayList&lt;ConnectorFactory&gt; = [io.dropwizard.jetty.HttpConnectorFactory@227a47]\n        \u251c\u2500\u2500 adminMaxThreads: Integer = 64\n        \u251c\u2500\u2500 adminMinThreads: Integer = 1\n        \u251c\u2500\u2500 applicationContextPath: String = \"/\"\n        \u251c\u2500\u2500 adminContextPath: String = \"/\"\n        \u2502   \n        \u251c\u2500\u2500 serverPush: ServerPushFilterFactory\n        \u2502   \u251c\u2500\u2500 enabled: Boolean = false\n        \u2502   \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds\n        \u2502   \u251c\u2500\u2500 maxAssociations: Integer = 16\n        \u2502   \u251c\u2500\u2500 refererHosts: List&lt;String&gt; = null\n        \u2502   \u2514\u2500\u2500 refererPorts: List&lt;Integer&gt; = null\n        \u2502   \n        \u251c\u2500\u2500 rootPath: Optional&lt;String&gt; = Optional.empty\n        \u2502   \n        \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory\n        \u2502   \u2514\u2500\u2500 appenders: SingletonImmutableList&lt;AppenderFactory&lt;IAccessEvent&gt;&gt; = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c]\n        \u2502   \n        \u2514\u2500\u2500 gzip: GzipHandlerFactory\n            \u251c\u2500\u2500 enabled: Boolean = true\n            \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes\n            \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes\n            \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet&lt;String&gt; = []\n            \u251c\u2500\u2500 compressedMimeTypes: Set&lt;String&gt; = null\n            \u251c\u2500\u2500 includedMethods: Set&lt;String&gt; = null\n            \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1\n            \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true\n            \u2514\u2500\u2500 syncFlush: Boolean = false\n\n\n    Configuration object bindings:\n        @Config ComplexGenericCase\n        @Config Configuration\n\n\n    Unique sub configuration objects bindings:\n\n        ComplexGenericCase.sub\n            @Config ComplexGenericCase.Sub&lt;String&gt; = null\n\n        Configuration.logging\n            @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n\n        Configuration.metrics\n            @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]}\n\n        Configuration.server\n            @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/}\n\n        Configuration.server.gzip\n            @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6\n\n        Configuration.server.requestLog\n            @Config RequestLogFactory&lt;RequestLog&gt; (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571\n\n        Configuration.server.serverPush\n            @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4\n\n\n    Configuration paths bindings:\n\n        ComplexGenericCase:\n            @Config(\"sub\") ComplexGenericCase.Sub&lt;String&gt; = null\n            @Config(\"sub.smth\") String = null\n\n        Configuration:\n            @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n            @Config(\"logging.appenders\") List&lt;AppenderFactory&lt;ILoggingEvent&gt;&gt; (with actual type SingletonImmutableList&lt;AppenderFactory&lt;ILoggingEvent&gt;&gt;) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]\n            @Config(\"logging.level\") String = \"INFO\"\n            @Config(\"logging.loggers\") Map&lt;String, JsonNode&gt; (with actual type RegularImmutableMap&lt;String, JsonNode&gt;) = {}\n            @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]}\n            @Config(\"metrics.frequency\") Duration = 1 minute\n            @Config(\"metrics.reporters\") List&lt;ReporterFactory&gt; (with actual type RegularImmutableList&lt;ReporterFactory&gt;) = []\n            @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/}\n            @Config(\"server.adminConnectors\") List&lt;ConnectorFactory&gt; (with actual type ArrayList&lt;ConnectorFactory&gt;) = [io.dropwizard.jetty.HttpConnectorFactory@227a47]\n            @Config(\"server.adminContextPath\") String = \"/\"\n            @Config(\"server.adminMaxThreads\") Integer = 64\n            @Config(\"server.adminMinThreads\") Integer = 1\n            @Config(\"server.allowedMethods\") Set&lt;String&gt; (with actual type HashSet&lt;String&gt;) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH]\n            @Config(\"server.applicationConnectors\") List&lt;ConnectorFactory&gt; (with actual type ArrayList&lt;ConnectorFactory&gt;) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b]\n            @Config(\"server.applicationContextPath\") String = \"/\"\n            @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false\n            @Config(\"server.enableThreadNameFilter\") Boolean = true\n            @Config(\"server.gid\") Integer = null\n            @Config(\"server.group\") String = null\n            @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6\n            @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes\n            @Config(\"server.gzip.compressedMimeTypes\") Set&lt;String&gt; = null\n            @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1\n            @Config(\"server.gzip.enabled\") Boolean = true\n            @Config(\"server.gzip.excludedUserAgentPatterns\") Set&lt;String&gt; (with actual type HashSet&lt;String&gt;) = []\n            @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true\n            @Config(\"server.gzip.includedMethods\") Set&lt;String&gt; = null\n            @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes\n            @Config(\"server.gzip.syncFlush\") Boolean = false\n            @Config(\"server.idleThreadTimeout\") Duration = 1 minute\n            @Config(\"server.maxQueuedRequests\") Integer = 1024\n            @Config(\"server.maxThreads\") Integer = 1024\n            @Config(\"server.minThreads\") Integer = 8\n            @Config(\"server.nofileHardLimit\") Integer = null\n            @Config(\"server.nofileSoftLimit\") Integer = null\n            @Config(\"server.registerDefaultExceptionMappers\") Boolean = true\n            @Config(\"server.requestLog\") RequestLogFactory&lt;RequestLog&gt; (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571\n            @Config(\"server.requestLog.appenders\") List&lt;AppenderFactory&lt;IAccessEvent&gt;&gt; (with actual type SingletonImmutableList&lt;AppenderFactory&lt;IAccessEvent&gt;&gt;) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c]\n            @Config(\"server.rootPath\") Optional&lt;String&gt; = Optional.empty\n            @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4\n            @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds\n            @Config(\"server.serverPush.enabled\") Boolean = false\n            @Config(\"server.serverPush.maxAssociations\") Integer = 16\n            @Config(\"server.serverPush.refererHosts\") List&lt;String&gt; = null\n            @Config(\"server.serverPush.refererPorts\") List&lt;Integer&gt; = null\n            @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds\n            @Config(\"server.startsAsRoot\") Boolean = null\n            @Config(\"server.uid\") Integer = null\n            @Config(\"server.umask\") String = null\n            @Config(\"server.user\") String = null\n</code></pre> <p>Here you can see:</p> <ul> <li>All visible configuration values (as tree).</li> <li>Types and interfaces for configuration object</li> <li>Unique sub configuration objects</li> <li>Values bound to guice context</li> </ul> <p>Also, if manual qualification is used, all annotated properties would also be shown:</p> <pre><code>    Qualified bindings:\n        @Named(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[], reportOnStop=false} (metrics)\n        @CustomQualifier SubObj = ru.vyarus.dropwizard.guice.yaml.qualifier.QualifierSampleTest$SubObj@19e0dffe (obj1)\n        @Named(\"sub-prop\") Set&lt;String&gt; = (aggregated values)\n            String = \"2\" (obj1.prop2)\n            String = \"3\" (obj1.prop3)\n        @Named(\"custom\") String = \"1\" (prop1)\n</code></pre>"},{"location":"guide/diagnostic/yaml-values-report/#guice","title":"Guice","text":"<p>Report is mostly intended to be used to see available guice bindings and that's why  <code>@Config</code> annotation is shown almost everywhere. For example, </p> <pre><code>@Config(\"server.serverPush.enabled\") Boolean = false\n</code></pre> <p>means that the following injection will work:</p> <pre><code>@Inject @Config(\"server.serverPush.enabled\") Boolean pushEnabled;\n</code></pre> <p>And it will be set to \"false\". </p> <p>Tip</p> <p>Report is printed before guice injector creation to let you review all available bindings when injector creation fails due to incorrect configuration value binding. </p> <p>The same for unique objects:</p> <pre><code>Configuration.logging\n            @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n</code></pre> <p>Means available injection:</p> <pre><code>@Inject @Config LoggingFactory logginFactory;\n</code></pre> <p>Note</p> <p>Declaration type is always used (<code>LoggingFactory</code>) even when runtype type is known (<code>(with actual type DefaultLoggingFactory)</code>). This is important to keep  bindings consistent (otherwise they would always change, depending on actual config value).</p>"},{"location":"guide/diagnostic/yaml-values-report/#direct-values-access","title":"Direct values access","text":"<p>But report is also handful for direct values access (through <code>ConfigurationTree</code> object).</p> <p>For example, accessing value by path:</p> <pre><code>tree.valueByPath(\"logging.level\") == INFO\n</code></pre> <p>Or unique object access:</p> <pre><code>tree.valueByUniqueDeclaredType(MetricsFactory.class) == &lt;factory instance&gt;\n</code></pre>"},{"location":"guide/diagnostic/yaml-values-report/#report-customization","title":"Report customization","text":"<p>Report is implemented as guicey event listener and provide additional customization  options, so if default configuration (from shortcut methods above) does not fit your needs you can register listener directly with required configuration.</p> <p>For example, custom bindings report is configured like this:</p> <pre><code>listen(new YamlBindingsDiagnostic(\n            new BindingsConfig()\n                    .showConfigurationTree()\n                    .showNullValues()\n                    .showCustomConfigOnly()));\n</code></pre> <p>Report rendering logic may also be used directly as report provide separate renderer object implementing <code>ReportRenderer</code>. Renderer not bound to guice context and assume direct instantiation. </p> <p>For examples of direct renderer usage see events implementation:</p> <ul> <li><code>RunPhaseEvent.renderConfigurationBindings()</code> </li> </ul>"},{"location":"guide/guice/bindings/","title":"Bindings","text":"<p>Guicey always installs <code>GuiceBootstrapModule</code> which registers the following bindings:</p> <ul> <li>Dropwizard objects:<ul> <li><code>io.dropwizard.setup.Bootstrap</code> </li> <li><code>io.dropwizard.Configuration</code> </li> <li><code>io.dropwizard.setup.Environment</code></li> </ul> </li> <li>Detailed configuration bindings (by root classes, interfaces, yaml path or unique subtype)</li> <li>Jersey objects (including request scoped) </li> <li>Guicey special objects</li> <li>All installed extensions </li> </ul> <p>Tip</p> <p>All registered bindings could be seen with guice report.</p>"},{"location":"guide/guice/bindings/#configuration","title":"Configuration","text":"<p><code>Configuration</code> bound to guice as: </p> <ul> <li><code>io.dropwizard.Configuration</code></li> <li>Your configuration class (<code>MyConfiguration extends Configuration</code>)</li> <li>All classes between them</li> </ul> <p>For example, if</p> <pre><code>MyConfiguration extends MyAbstractConfiguration extends Configuration\n</code></pre> <p>Then <code>MyAbstractConfiguration</code> will be also bound and the following injection will work:</p> <pre><code>@Inject MyAbstractConfiguration conf\n</code></pre> <p>Note</p> <p>Configuration object bindings could be declared with or without qualifier <code>@Config</code>. So <code>@Inject @Config MyAbstractConfiguration conf</code> will also work. It is suggested to always use qualifier (to get in common with direct value bindings), but it's up to you.</p> <p>If root configuration classes implement interfaces then configuration could be bound by interface. This may be used to support common <code>Has&lt;Something&gt;</code> configuration interfaces convention used to recognize your extension configuration in configuration object.</p> <pre><code>public interface HasFeatureX {\n    FeatureXConfig getFetureXConfig();\n}\n\npublic class MyConfiguration extends Configuration implements HasFeatureXConfig {...}\n\npublic class MyBean {\n    @Inject @Config HasFeatureX conf;\n    ...\n}\n</code></pre> <p>Interface binding will ignore interfaces in <code>java.*</code> or <code>groovy.*</code> packages (to avoid unnecessary bindings).</p> <p>Tip</p> <p>Consider using direct sub configuration object binding instead of marker interface if object uniqueness is guaranteed in user configuration.</p>"},{"location":"guide/guice/bindings/#yaml-config-introspection","title":"Yaml config introspection","text":"<p>Guicey performs <code>Configuration</code> object introspection to provide access for  configured yaml values by path or through sub-objects.</p> <p>Warning</p> <p>Additional configuration objects are not bound when yaml introspection is disabled</p> <p>Raw introspection result could be injected directly (for reporting or analysis):</p> <pre><code>@Inject ConfigurationTree tree;\n</code></pre> <p>Tip</p> <p>All available configuration bindings could be seen with <code>.printConfigurationBindings()</code> report (use <code>.printAllConfigurationBindings()</code> to see also core dropwizard configuration values).</p> <p>This report is executed before injector creation so use it in cases when injector fail to inject configration value to validate binsinds correctness.   </p>"},{"location":"guide/guice/bindings/#unique-objects","title":"Unique objects","text":"<p>Unique sub-object (sub configuration classes appeared once) could be injected directly.</p> <p>For example, the following config contains two (custom) unique sub objects: <pre><code>public class MyConfig extends Configuration {\n    @JsonProperty AuthConfig auth;\n    @JsonProperty DbConfig db;\n}\n</code></pre></p> <p>Which could be injected directly:</p> <pre><code>@Inject @Config AuthConfig auth;\n@Inject @Config DbConfig db;\n</code></pre> <p>Tip</p> <p>This is very useful for re-usable modules, which are not aware of your configuration  object structure, but require only one sub configuration object:</p> <pre><code>public class MyConfig extends Configuration {\n    @JsonProperty FeatureXConfig featureX;\n}\n</code></pre> <p>Somewhere in module service:</p> <pre><code>public class FeatureXService {\n    @Inject @Config FeatureXConfig featureX; \n}\n</code></pre>"},{"location":"guide/guice/bindings/#value-by-path","title":"Value by path","text":"<p>All visible configuration paths values can be directly bound:</p> <pre><code>public class MyConfig extends Configuration {\n    SubConf sub;\n}\n\npublic class SubConf {\n    String smth;\n    List&lt;String&gt; values;\n}\n</code></pre> <pre><code>@Inject @Config(\"sub\") SubConf sub;\n@Inject @Config(\"sub.smth\") String smth;\n@Inject @Config(\"sub.values\") List&lt;String&gt; values;\n</code></pre> <p>Note</p> <p>Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations).  The only exception is conditional mapping like dropwizard <code>server</code> when available paths could change, depending on configuration (what configuration type will be used)</p> <p>Note</p> <p>Generified types are bound only with generics (with all available type information). If you have <code>SubConf&lt;T&gt; sub</code> in config, then it will be bound with correct generic <code>SubConfig&lt;String&gt;</code> (suppose generic T is declared as String).</p> <p>Value type, declared in configuration class is used for binding, but there are two exceptions.</p> <p>First, if declared type is declared as collection (<code>Set</code>, <code>List</code>, <code>Map</code>) implementation then binding will use base collection interface:</p> <pre><code>ArrayList&lt;String&gt; value\n\n@Inject @Config(\"value\") List&lt;String&gt; vlaue;\n</code></pre> <p>Second, if, for some (unforgivable) reason, property is declared as <code>Object</code> in configuration, then binding type will depend on value presence:</p> <ul> <li><code>@Config(\"path\") Object val</code> - when value is null</li> <li><code>@Config(\"path\") ValueType val</code> - actual value type, when value is not null       </li> </ul> <p>It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard <code>server</code>).</p> <p>Tip</p> <p>If provided value bindings are not enough for your case, you can declare your own value bindings:</p> <p>Get introspcetion result object (<code>ConfigurationTree</code>) in guice module and bind values the way you need it: <pre><code>public class MyConfigBindingsModule extends DropwizardAwareModule {\n    @Override\n    public void configure() {\n        bind(String.class).annotatedWith(Names.named(\"db.url\"), configuration(\"db.url));\n    }\n}\n</code></pre></p>"},{"location":"guide/guice/bindings/#environment-binding","title":"Environment binding","text":"<p>Dropwizard <code>io.dropwizard.setup.Environment</code> is bound to guice context.</p> <p>It is mostly useful to perform additional configurations in guice bean for features not covered with installers.  For example:</p> <pre><code>public class MyBean {\n\n    @Inject\n    public MyBean(Environment environment) {\n        environment.lifecycle().addServerLifecycleListener(new ServerLifecycleListener {\n            public void serverStarted(Server server) {\n                callSomeMethod();\n            }\n        })\n    }\n}\n</code></pre> <p>It's not the best example, but it illustrates usage (and such things usually helps to quick-test something). </p> <p>See also authentication configuration example.</p>"},{"location":"guide/guice/bindings/#jersey-specific-bindings","title":"Jersey specific bindings","text":"<p>Jersey bindings are not immediately available, because HK2 context starts after guice,  so use <code>Provider</code> to inject these bindings.</p> <p>These bindings available after HK2 context start:</p> <ul> <li><code>jakarta.ws.rs.core.Application</code></li> <li><code>jakarta.ws.rs.ext.Providers</code></li> <li><code>org.glassfish.hk2.api.ServiceLocator</code></li> <li><code>org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider</code></li> </ul> <p>Request-scoped bindings:</p> <ul> <li><code>jakarta.ws.rs.core.UriInfo</code></li> <li><code>jakarta.ws.rs.container.ResourceInfo</code></li> <li><code>jakarta.ws.rs.core.HttpHeaders</code></li> <li><code>jakarta.ws.rs.core.SecurityContext</code></li> <li><code>jakarta.ws.rs.core.Request</code></li> <li><code>org.glassfish.jersey.server.ContainerRequest</code></li> <li><code>org.glassfish.jersey.server.AsyncContext</code></li> </ul> <p>Tip</p> <p>Read about jersey bindings implementation in lifecycle section.</p>"},{"location":"guide/guice/bindings/#request-and-response","title":"Request and response","text":"<p>By default, <code>GuiceFilter</code> is enabled on both contexts (admin and main). So you can inject request and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions).</p> <p>If you disable guice filter with .noGuiceFilter() then guicey will bridge objects from HK2 context:</p> <ul> <li><code>jakarta.servlet.http.HttpServletRequest</code></li> <li><code>jakarta.servlet.http.HttpServletResponse</code></li> </ul> <p>This means you can still inject them, but request and response will only be available under resource calls (the only part managed by jersey).</p> <p>Example usage:</p> <pre><code>@Inject Provider&lt;HttpServletRequest&gt; requestProvider;\n</code></pre> <p>Note</p> <p>Pay attention, that in guice-managed resources <code>@Context</code> field bindings  must be replaced with providers.</p>"},{"location":"guide/guice/bindings/#options","title":"Options","text":"<p><code>ru.vyarus.dropwizard.guice.module.context.option.Options</code> binding provides access to guicey options: <pre><code>@Inject Options options;\n</code></pre></p> <p>Example usage:</p> <pre><code>Preconditions.checkState(options.get(GuiceyOptions.UseHkBridge), \n                                 \"HK2 guice bridge is required!\")\n</code></pre>"},{"location":"guide/guice/bindings/#guicey-configuration","title":"Guicey configuration","text":"<p><code>ru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo</code> binding provides access to guicey configuration details:</p> <pre><code>@Inject GuiceyConfigurationInfo info\n</code></pre>"},{"location":"guide/guice/bindings/#extension-bindings","title":"Extension bindings","text":"<p>Summary</p> <p>Normally, you don't need to know about extension bindings because they are mostly useless  for application, but this section is important in case of problems. </p> <p>In order to support guice <code>binder().requireExplicitBindings()</code> option guicey binds all extensions with untargeted binding: <code>binder().bind(YourExtension.class)</code>.</p> <p>But there are three exceptions:</p> <ul> <li>Installers with custom binding logic (like a plugins installer)</li> <li>If extension was detected from binding (obviously binding already exists)</li> <li>If extension is annotated with<code>@LazyBinding</code></li> </ul> <p>As injector is created in <code>Stage.PRODUCTION</code>, all singleton extensions will be instantiated in time of injector startup (injector stage could be changed in main bundle).</p>"},{"location":"guide/guice/injector/","title":"Injector instance","text":""},{"location":"guide/guice/injector/#restrictive-options","title":"Restrictive options","text":"<p>Guicey is compatible with the following guice restrictive options:</p> <pre><code>public class MyModule extends AbstractModule {\n        @Override\n        protected void configure() {\n            binder().disableCircularProxies();\n            binder().requireExactBindingAnnotations();\n            binder().requireExplicitBindings();\n        }\n    }\n</code></pre>"},{"location":"guide/guice/injector/#access-injector","title":"Access injector","text":"<p>In some cases it may be important to get injector instance outside of guice context.</p> <p>Warning</p> <p>Injector is created on dropwizard run phase. Attempt to obtain injector before it will lead to exception.</p> <p>Injector instance could be resolved with:</p> <ul> <li><code>GuiceBundle#getInjector()</code> method on instance (exception thrown if not yet started)</li> <li><code>InjectorLookup.getInjector(app).get()</code> static call using application instance (lookup returns <code>Optional</code> for null safety).</li> </ul> <p>If you need lazy injector reference, you can use <code>InjectorProvider</code> class (<code>Provider&lt;Injector&gt;</code>):</p> <pre><code>Provider&lt;Injector&gt; provider = new InjectorProvider(app);\n// somewhere after run phase\nInjector injector = provider.get();\n</code></pre> <p>Bean instance may be obtained with <code>getInstance</code> shortcut:</p> <pre><code>public class MyApplication extends Application&lt;Configuration&gt; {\n\n    @Override\n    public void run(TestConfiguration configuration, Environment environment) throws Exception {\n        InjectorLookup.getInstance(this, SomeService.class).get().doSomething();\n    }\n}\n</code></pre> <p>Injector could also be referenced by <code>Environment</code> object:</p> <pre><code>InjectorLookup.getInstance(environment, SomeService.class).get().doSomething();\n</code></pre> <p>Tip</p> <p>Most likely, requirement for injector instance means integration with some third party library. Consider writing custom installer in such cases (it will eliminate need for injector instance).</p> <p>Inside guice context you can simply inject Injector instance:</p> <pre><code>@Inject Injector injector;\n</code></pre>"},{"location":"guide/guice/injector/#injector-stage","title":"Injector stage","text":"<p>By default injector is created at <code>PRODICTION</code> stage, which means that all registered singletons are instantiated in time of injector creation.</p> <p>You can change stage at main bundle:</p> <pre><code>GuiceBundle.builder()\n    ...\n    .build(Stage.DEVELOPMENT)\n</code></pre>"},{"location":"guide/guice/injector/#injector-factory","title":"Injector factory","text":"<p>You can control guice injector creation through <code>ru.vyarus.dropwizard.guice.injector.InjectorFactory</code>. </p> <p>Default implementation is very simple:</p> <pre><code>public class DefaultInjectorFactory implements InjectorFactory {\n\n    @Override\n    public Injector createInjector(final Stage stage, final Iterable&lt;? extends Module&gt; modules) {\n        return Guice.createInjector(stage, modules);\n    }\n}\n</code></pre> <p>Injector creation customization may be required by some 3<sup>rd</sup> party library. For example, netflix governator  owns injector creation (see example).</p> <p>Custom injector factory could be registered in guice bundle builder:</p> <pre><code>bootstrap.addBundle(GuiceBundle.builder()\n            .injectorFactory(new CustomInjectorFactory())\n            ...\n</code></pre>"},{"location":"guide/guice/module-analysis/","title":"Modules analysis","text":"<p>Before injector start, guicey parse registered modules with guice SPI in order to:</p> <ul> <li>Recognize extensions from bindings</li> <li>Remove disabled extensions bindings</li> <li>Remove bindings of disabled modules</li> </ul> <p>Tip</p> <p>Use guice report to see all available bindings</p> <p>Warning</p> <p>Only direct modules (<code>.modules()</code>) are analyzed! Overriding modules (<code>.modulesOverride()</code>) are ignored (intentionally).  </p> <p>Then all not removed bindings are composed to special module (even when no bindings removed, this avoid duplicate modules parsing on injector creation). That means that injector factory  receive not user registered modules, but synthetic (with pre-parsed bindings) module instead. </p> <p>Note</p> <p>The most time-consuming operation in analysis is modules parsing, which is actually performed in any case during guice injector creation. You can see this on  statistics report: if you switch off analysis injector time will grow. </p>"},{"location":"guide/guice/module-analysis/#extensions-recognition","title":"Extensions recognition","text":"<p>Guicey can recognize extensions in guice bindings (from configured guice modules).  For example,</p> <pre><code>public class MyModule extends AbstractModule {\n    public void configure () {\n        // right parts just for example \n        bind(MyResource.class).to(MyResourceImpl.class);\n        bind(MyManaged.class).toProvider(MyManagedProvider.class);\n    }\n}\n</code></pre> <p>Guicey will detect <code>MyResource</code> as jersey resource and <code>MyManaged</code> as managed extension.</p> <p>Tip</p> <p>Extensions annotated with <code>@InvisibleForScanner</code> are not recognized, like in classpath scanner. But note that annotated extensions should not be registered manually! Because it will lead to default extension binding registration by guicey, which will most likely conflict with existing binding (as a workaround <code>@LazyBinding</code> annotation may be used).</p> <p>Alternatively, you can simply qualify bean and it would not be recognized as extension. </p> <p>This is completely equivalent to</p> <pre><code>GuiceBundle.builder()\n    .extensions(MyResource.class, MyManaged.class)\n</code></pre> <p>Note</p> <p>Internally, the same installers are used for extensions recognition and installation. The only difference is that guicey would not create default bindings for such extensions (because bindings already exists).</p>"},{"location":"guide/guice/module-analysis/#restrictions","title":"Restrictions","text":"<ul> <li>Only direct bindings (<code>bind(..)</code>) and linked keys (<code>bind(..).to(..)</code>) are checked.</li> <li>Instances are not analyzed (<code>bind(Something.class).toInstance(new Extension())</code>) because extensions supposed to be guice-managed      (not strictly required, but will allow to avoid aop-related problems). But, still     it is possible to declare not guice managed extension with instance mapping to extension class or provider. </li> <li>Generified (<code>bind(new TypeLiteral&lt;MyResource&lt;String&gt;(){})</code>) and      qualified (<code>bind(MyResource.class).annotatedWith(Qualify.class)</code>) bindings are ignored     (simply because it's not obvious what to do with them).</li> <li>Overriding modules are not checked  as they supposed to be used for quick fixes and test mocking.     </li> </ul> <p>Will be recognized</p> <pre><code>// untargeted binding\nbind(Extension.class)\n\n// left side of the link\nbind(Extension.class).to(Something.class)\n\n// right side of the link\nbind(Something.class).to(Extension.class)\n\n// left side of instance or provider mapping\nbind(Extension.class).toInstance(new Extension())\nbind(Extension.class).toProvider(SomeProvider.class)    \n</code></pre> <p>Will NOT be recognized</p> <pre><code>// instances not analysed\nbind(Something.class).toInstance(new Extension())    \n\n// extension-recignizable type must be strictly declared \nbind(Something.class).toProvider(ExtensionProvider.class)\n\n// generified declaration    \nbind(new TypeLiteral&lt;Extension&lt;Somthing&gt;(){})\n\n// qualified declaration    \nbind(Extension.class).annotatedWith(Qualify.class)\n</code></pre> <p>Side note</p> <p>Qualified and generified cases are not supported because they imply that multiple instances of one class may be declared. This rise problems with direct manual declaration: for example, if user declare <code>.extensions(Extension.class)</code> and in module we have <code>bind(Extension.class).annotatedWith(Qualify.class)</code> how can we be sure if it is the same declaration or not? </p> <p>Current implementation will not revognize qualified extension and automatically create direct binding (<code>bind(Extension.class)</code>).</p> <p>For sure someone will face generified or qualified extensions case, but it would be  simplier to workaraund it in exact case, rather then trying to handle all posible cases in general, making everything more complex.     </p>"},{"location":"guide/guice/module-analysis/#disabled-extensions","title":"Disabled extensions","text":"<p>In order to disable extension, recognized from binding, guicey will simply remove this binding.</p> <p>If extension was a part of longer links chain then entire chain would be removed too!</p> <p>For example, </p> <pre><code>bind(One.class).to(Two.class)\nbind(Two.class).to(Extension.class)\n</code></pre> <p>When <code>Extension</code> disabled <code>One--&gt;Two</code> link is also removed.</p> <p>Motivation: </p> <ul> <li>First of all, this avoids error cases when remaining chain part contains  only abstract types (e.g. only interfaces remains)</li> <li>Removes possible inconsistencies as long chains may appear due to some class overrides and so  removing only top (overriding) class will just to \"before override\" state.  </li> </ul> <p>Removed chains are visible on guice report.</p>"},{"location":"guide/guice/module-analysis/#private-modules","title":"Private modules","text":"<p>Guicey will also search extensions in private modules (of course, only in exposed beans).</p> <pre><code>public class PModule extends PrivateModule {\n    @Override\n    protected void configure() {\n        // ExtImpl is extension (recognition sign absent in interface) \n        bind(IExt.class).to(ExtImpl.class);\n        // extension exposed by interface \n        expose(IExt.class);\n    }\n}\n\npublic interface IExt {... }\npublic class Ext implements IExt, Managed { ... }\n</code></pre> <p>Guicey would detect that <code>ExtImpl</code> is an extension, and it is available (through exposed interface) and so register it as an extension.</p> <p>Important</p> <p>Guicey rely on extension classes and so it would need direct extension access (to be able to call <code>Injector.getInstance(ExtImpl.class)</code>). By default, it is not possible (exposed only interface), but guicey would change private module: it would add an additional <code>expose</code> for <code>ExtImpl</code>.</p> <p>Also, as any guicey extension could be disabled, then <code>.disable(ExtImpl.class)</code> would remove binding inside private module (works only for top-level private modules).</p> <p>If you'll face any problems with private modules behavior, please report it.</p> <p>Private modules analysis could be disabled with:</p> <pre><code>GuiceBundle.builder()\n    .option(GuiceyOptions.AnalyzePrivateGuiceModules, false)\n</code></pre>"},{"location":"guide/guice/module-analysis/#transitive-modules","title":"Transitive modules","text":"<p>During bindings analysis guicey can see binding module's hierarchy (module \"A\" installs module \"B\", which registers binding C). Using this guicey can remove all bindings relative to exact module class - the result is the same as if such module was never registered.</p> <p>This is transitive modules disable implementation.</p>"},{"location":"guide/guice/module-analysis/#disabling-analysis","title":"Disabling analysis","text":"<p>To completely switch off analysis use option:</p> <pre><code>.option(GuiceyOptions.AnalyzeModules, false)\n</code></pre> <p>Warning</p> <p>When analysis is disabled, extensions recognition and  transitive modules disables will not work anymore!    </p> <p>With disabled analysis injector factory will receive user provided modules directly (instead of pre-parsed synthetic module).</p> <p>Important</p> <p>Enabled analysis completely prevent situations when default binding, created by guicey, conflict with manual binding existing in module. In such case startup will fail. Before modules analysis it was only possible to solve such issue with <code>@LazyBinding</code> annotation.  </p>"},{"location":"guide/guice/module-analysis/#reporting","title":"Reporting","text":"<p>You can see analysis information under diagnostic report:</p> <pre><code>    ...\n\n    \u251c\u2500\u2500 [9.3%] MODULES processed in 40.14 ms\n    \u2502   \u251c\u2500\u2500 7 modules autowired\n    \u2502   \u251c\u2500\u2500 8 elements found in 5 user modules in 36.53 ms\n    \u2502   \u2514\u2500\u2500 1 extensions detected from 3 acceptable bindings  \n\n    ...\n\n    \u251c\u2500\u2500 [0.70%] EXTENSIONS installed in 3.594 ms\n    \u2502   \u251c\u2500\u2500 4 extensions installed\n    \u2502   \u2514\u2500\u2500 declared as: 2 manual, 1 scan, 1 binding\n\n    ...\n\n    \u251c\u2500\u2500 GUICE BINDINGS\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 ModuleWithExtensions         (r.v.d.g.d.s.module)       \n    \u2502       \u2514\u2500\u2500 extension  ModuleFeature                (r.v.d.g.d.s.m.ModuleWithExtensions) \n\n    ...     \n</code></pre> <p>Here you can see that <code>5 user modules</code> were analyzed out ot 7 overall modules. 2 avoided modules are <code>GuiceBootstrapModule</code> and some overriding module.  </p> <p>Modules contains <code>8 elements</code>: this includes not only bindings, but also type listeners, aop handlers, etc (all declarations).</p> <p><code>1 extensions detected from 3 acceptable bindings</code> - only 3 bindings were acceptable for analysis  (not generified and not qualified bindings) and 1 extension was recognized. Recognition could also be seen under <code>EXTENSIONS</code> section: <code>declared as: 2 manual, 1 scan, 1 binding</code> (note that numbers show detections, but single extension may be detected in multiple sources).</p> <p>And, finally, configuration tree shows extension binding module. But it's always top-most registered module (binding could be actually declared in some transitive module)!</p>"},{"location":"guide/guice/module-analysis/#removed-bindings","title":"Removed bindings","text":"<p>If any bindings were removed, this would be also shown in report:</p> <pre><code>    ...\n\n    \u251c\u2500\u2500 [11%] MODULES processed in 37.54 ms\n    \u2502   \u251c\u2500\u2500 2 modules autowired\n    \u2502   \u251c\u2500\u2500 4 elements found in 1 user modules in 32.43 ms\n    \u2502   \u251c\u2500\u2500 2 extensions detected from 2 acceptable bindings\n    \u2502   \u251c\u2500\u2500 3 elements removed\n    \u2502   \u2514\u2500\u2500 1 inner modules removed (types)\n\n    ...\n</code></pre> <p>(removed links are also counted)</p> <p>Guice bindings report shows exact removed items:</p> <pre><code>2 MODULES with 2 bindings\n    \u2502   \n    \u2514\u2500\u2500 TransitiveModule             (r.v.d.g.d.r.g.support)    \n        \u251c\u2500\u2500 untargetted          [@Prototype]     Res1                                            at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:15) *EXTENSION\n        \u251c\u2500\u2500 untargetted          [@Prototype]     Res2                                            at ru.vyarus.dropwizard.guice.debug.renderer.guice.support.TransitiveModule.configure(TransitiveModule.java:16) *EXTENSION, REMOVED\n        \u2514\u2500\u2500 Inner                        (r.v.d.g.d.r.g.s.TransitiveModule) *REMOVED\n</code></pre> <p>Here entire module <code>Inner</code> and <code>Res2</code> extension binding removed.</p> <p>Removed chains are shown as:</p> <pre><code>    BINDING CHAINS\n    \u2514\u2500\u2500 Base  --[linked]--&gt;  Ext  --[linked]--&gt;  ExtImpl       *CHAIN REMOVED\n</code></pre>"},{"location":"guide/guice/module-autowiring/","title":"Module autowiring","text":"<p>Because guice modules are registered in dropwizard init section only <code>Bootstrap</code> instance is available. Often <code>Environment</code> and <code>Configuration</code> objects are also required.</p>"},{"location":"guide/guice/module-autowiring/#autowiring-interfaces","title":"Autowiring interfaces","text":"<p>Guicey can automatically inject environment objects into your module if  it implements any of (or all of them): </p> <ul> <li><code>BootstrapAwareModule</code> - access bootstrap instance </li> <li><code>EnvironmentAwareModule</code> - access environment instance </li> <li><code>ConfigurationAwareModule</code> - access configuration instance</li> <li><code>ConfigurationTreeAwareModule</code> - access to configuration values by path</li> <li><code>OptionsAwareModule</code> - access guicey options</li> </ul> <p>Reference object will be set to module just before injector creation, so you can use it inside your  module logic (<code>configuration</code> method).</p> <p>Warning</p> <p>Module autowiring will only work for modules directly set to <code>modules()</code> (of main bundle or any guicey bundle).</p> <pre><code>public class MyModule implements EnvironmentAwareModule {\n    private Environemnt environment;\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        this.environment = environment;\n    }\n\n    @Override\n    protected void configure() {\n        // use environment here\n    }\n}\n</code></pre>"},{"location":"guide/guice/module-autowiring/#autowiring-base-class","title":"Autowiring base class","text":"<p>To avoid manually implementing interfaces (avoid boilerplate) you can use <code>DropwizardAwareModule</code> as  base class which already implements all autowiring interfaces:</p> <pre><code>public class MyModule extends DropwizardAwareModule&lt;MyConfiguration&gt; {\n    @Override\n    protected void configure() {\n        bootstrap()     // Bootstrap instance\n        environment()   // Environment instance\n        configuration() // MyConfiguration instance\n        appPackage()    // application class package \n        configuratonTree() // configuration as tree of values\n        confuguration(Class) // unique sub configuration\n        configuration(String) // configuration value by yaml path\n        configurations(Class) // sub configuration objects by type (including subtypes)\n        annotatedConfiguration(ann) // annotaed configuration value by instance\n        annotatedConfiguration(Class) // annotaed configuration value by annotation type\n        options() // access guicey options   \n        sharedState(Class) // shared sctate access\n    }\n} \n</code></pre>"},{"location":"guide/guice/module-autowiring/#options","title":"Options","text":"<p>Options could be used in guice module to access guicey configurations:</p> <pre><code>public class MyModule extends DropwizardAwareModule&lt;MyConfiguration&gt; {\n    @Override\n    protected void configure() {\n        // empty when guicey servlet support is dasabled\n        if (options.&lt;EnumSet&gt;get(GuiceyOptions.GuiceFilterRegistration).isEmtpy()) {\n            // do nothing\n        } else {\n            // register servlet module\n        }\n    }\n}\n</code></pre> <p>Or it could be some custom options usage.</p> <p>Tip</p> <p>If you are going to register module inside guicey bundle, you can simply resolve option value inside guicey bundle and pass it to module directly.</p>"},{"location":"guide/guice/module-autowiring/#configuration-access","title":"Configuration access","text":"<p>Tip</p> <p>If you are going to register module inside guicey bundle, you can simply resolve configuration object inside guicey bundle and pass it to module directly (bundle has  absolutely the same configuration access methods)</p>"},{"location":"guide/guice/module-autowiring/#unique-feature-config","title":"Unique feature config","text":"<p>When working with re-usable modules, it could be handy to rely on unique configuration  object:</p> <pre><code>public class XFeatureModule extends DropwizardAwareModule&lt;Configuration&gt; {\n    @Override\n    protected void configure() {\n        XFeatureConfig conf = configuration(XFeatureConfig.class);\n        ...\n    }\n}\n</code></pre> <p>Note that this module doesn't known exact type of user configuration, it just  assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example:</p> <pre><code>public class MyConfig extends Configuration {\n\n    @JsonProperty\n    private XFeatureConfig xfeature;\n\n    ...\n}\n</code></pre> <p>Important</p> <p>Object uniqueness checked by exact type match, so if configuration also  contains some extending class (<code>XFeatureConfigExt</code>) it will be different unique config. </p>"},{"location":"guide/guice/module-autowiring/#access-by-path","title":"Access by path","text":"<p>When you are not sure that configuration is unique, you can rely on exact path definition:</p> <pre><code>public class XFeatureModule extends DropwizardAwareModule&lt;Configuration&gt; {\n\n    private String path;\n\n    public XFeatureModule(String path) {\n        this.path = path;\n    } \n\n    @Override\n    protected void configure() {\n        XFeatureConfig conf = configuration(path);\n        ...\n    }\n}\n</code></pre> <p>Path is declared by module user, who knows required configuration location:</p> <pre><code>GuiceBundle.builder()\n    .modules(new XFeatureModule(\"sub.feature\"))\n    ...\n    .build()\n</code></pre> <p>Where </p> <pre><code>public class MyConfig extends Configuration {\n\n    @JsonProperty\n    private SubConfig sub = { // pseudo code to combine class declarations\n         @JsonProperty\n         private XFeatureConfig feature;   \n    }\n\n    ...\n}\n</code></pre>"},{"location":"guide/guice/module-autowiring/#multiple-configs","title":"Multiple configs","text":"<p>In case, when multiple config objects could be declared in user configuration, you can access all of them: </p> <pre><code>public class XFeatureModule extends DropwizardAwareModule&lt;Configuration&gt; {\n    @Override\n    protected void configure() {\n        List&lt;XFeatureConfig&gt; confs = configurations(XFeatureConfig.class);\n        ...\n    }\n}\n</code></pre> <p>For configuration</p> <pre><code>public class MyConfig extends Configuration {\n\n    @JsonProperty\n    private XFeatureConfig xfeature;\n    @JsonProperty\n    private XFeatureConfig xfeature2;\n\n    ...\n}\n</code></pre> <p>It wil return both objects: <code>[xfeature, xfeature2]</code></p> <p>Important</p> <p>In contrast to unique configurations, this method returns all subclasses too. So if there are <code>XFeatureConfigExt</code> declared somewhere it will also be returned.</p>"},{"location":"guide/guice/module-autowiring/#custom-configuration-analysis","title":"Custom configuration analysis","text":"<p>In all other cases (with more complex requirements) you can use <code>ConfigurationTree</code> object which represents introspected configuration paths.  </p> <pre><code>public class XFeatureModule extends DropwizardAwareModule&lt;Configuration&gt; {\n    @Override\n    protected void configure() {\n        // get all properties of custom configuration (ignoring properties from base classes)\n        List&lt;ConfigPath&gt; paths = configurationTree().findAllRootPathsFrom(MyConfig.class);\n\n        List markedTypes = paths.stream()\n            .filter(it -&gt; it.getValue() != null \n                    &amp;&amp; it.getType().getValueType().hasAnnotation(MyMarker.class))\n            .map(it -&gt; it.getValue())\n            .collect(Collectors.toList());\n        ...\n    }\n}\n</code></pre> <p>In this example, module search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker (<code>@MyMarker</code>).  </p> <p>See introspected configuration structure description</p>"},{"location":"guide/guice/module-autowiring/#shared-state","title":"Shared state","text":"<p>Special shortcuts provided to simplify access to shared state (if required).</p> <pre><code>public class XFeatureModule extends DropwizardAwareModule&lt;Configuration&gt; {\n    @Override\n    protected void configure() {\n        SharedConfigObject config = sharedStateOrFail(SomeBundle.class, \n            \"Bundle %s is not registered\", SomeBundle.class.getSimpleName());           \n    }\n}\n</code></pre> <p>Shared state supposed to be declared in bundles and if required state is not available in time of injector creation then required bundle was not registered for sure.</p> <p>Be careful with shared state as it is intended to be used only in rare cases when really complex integrations required.</p>"},{"location":"guide/guice/override/","title":"Override guice bindings","text":"<p>Guice natively support bindings override with <code>Modules.override()</code> api. This is mostly  useful in tests, when some bindings could be overridden with mocks. But it could also  be used in real application in order to \"workaround\" some 3<sup>rd</sup> party module behaviour. </p> <p>Guicey provides special support for overridings registration.</p> <p>You need 2 modules: one with original binding and another with  binding override.</p> <p>For example, suppose you want to replace <code>ServiceX</code> binding from:</p> <pre><code>public class MyModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        bind(ServiceX.class).to(ServiceXImpl.class);        \n    }\n}\n</code></pre> <p>Generally have few options:</p> <ul> <li>If it implements an interface, implement your own service and bind as  <code>bind(ServiceX.class).to(MyServiceXImpl.class)</code></li> <li>If service is a class, you can modify its behaviour with extended class <code>bind(ServiceX.class).to(MyServiceXExt.class)</code></li> <li>Or you can simply register some mock instance <code>bind(ServiceX.class).toInstance(myMockInstance)</code></li> </ul> <p>Here assume that <code>ServiceX</code> is interface, so simply register different implementation:</p> <pre><code>public class MyOverridingModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        bind(ServiceX.class).to(CustomServiceXImpl.class);        \n    }\n}\n</code></pre> <p>Now register overriding:</p> <pre><code>GuiceBundle.builder()\n    .modules(new MyModule())\n    .modulesOverride(new MyOverridingModule())  \n    .build()  \n</code></pre> <p>And everywhere in code <code>@Inject ServiceX service;</code> will receive <code>CustomServiceXImpl</code> (instead of <code>ServiceXImpl</code>)</p> <p>Tip</p> <p>Sometimes it may be simpler to disable existing module and register new module with modified bindings instead of overrides (for example with a hooks)</p> <p>Note</p> <p>Overriding module could contain additional bindings - they would be also available in the resulted injector. (binding from overriding module either overrides existing binding or simply added as new binding)    </p>"},{"location":"guide/guice/scopes/","title":"Scopes","text":"<p>Reminder</p> <p>By default, all guice beans are created in prototype scope. Guicey only force singleton scope for jersey extensions (resources and extensions))</p> <p>Available scopes:</p> <ul> <li><code>@Singleton</code> - single instance per context</li> <li><code>@RequestScoped</code> - object per request (if guice filter support is not disabled)</li> <li><code>@Prototype</code> - prototype scope annotation (useful to override forced singleton scope for jersey services)</li> </ul> <p>Session scope (<code>@SessionScoped</code>) is usually useless, because sessions are not enabled by default in dropwizard (but it is possible to enable them).</p> <p>Tip</p> <p>Scopes of registered beans could be checked in guice report</p>"},{"location":"guide/guice/scopes/#prototype","title":"Prototype","text":"<p>Normally, prototype scope (new instance on each new injection) is the default - no need to explicitly specify it.</p> <p>The only possible usage is overriding default forced singleton scope for jersey extensions. For example, resource declared like this:</p> <pre><code>@Path(\"/my\")\npublic class MyResource {}\n</code></pre> <p>Will be singleton. Prototype scope must be explicitly declared (if required):</p> <pre><code>@Path(\"/my\")\n@Prototype\npublic class MyResource {}\n</code></pre> <p>Note</p> <p><code>@Prototype</code> scope annotation support is registered by guicey</p>"},{"location":"guide/guice/scopes/#singleton","title":"Singleton","text":"<p>Both <code>com.google.inject.Singleton</code> and <code>jakarta.inject.Singleton</code> annotations could be used.</p> <p>Tip</p> <p>Prefer declaring <code>@Singleton</code> scope on all beans, except cases when different scope is required.     </p>"},{"location":"guide/guice/scopes/#request","title":"Request","text":"<p>By default, <code>GuiceFilter</code> is registered for both application and admin contexts.  And so request (and session) scopes will be available in both contexts.</p> <pre><code>@RequestScoped\npublic class MyRequestScopedBean { ... }\n</code></pre> <p>In order to access request scoped beans in other beans you'll need to use provider:</p> <pre><code>Provider&lt;MyRequestScopedBean&gt; myBeanProvider;\n</code></pre> <p>Some jersey objects are already bound in request scope  </p> <p>Context request and response objects are also available through request scope:</p> <pre><code>Provider&lt;HttpServletRequest&gt; requestProvider\nProvider&lt;HttpServletResponse&gt; responseProvider\n</code></pre>"},{"location":"guide/guice/scopes/#request-scope-transition","title":"Request scope transition","text":"<p>This is guice feature, it is just mentioned here.</p> <p>Guice could access request scoped bindings only in current thread. If you need to access  request scoped binding in different thread, you need to transfer request scope into that thread:</p> <pre><code>@Singleton \npublic class RequestBean {\n\n    // provider will not work in other thread because of request scope\n    @Inject\n    Provider&lt;UriInfo&gt; uri;\n\n    public void doSomethingInRequestScope() {\n            // jersey object must be resolved inside hk request scope (to store it in guice request scope)\n            // so guice could see its instance later in another thread\n            uri.get();\n\n            // wrap logic that require request scope \n            Callable&lt;String&gt; action = ServletScopes.transferRequest(() -&gt; {\n                // access request scoped binding in different thread \n                return uri.get().getQueryParameters().getFirst(\"q\");\n            });            \n            CompletableFuture.runAsync(() -&gt; {\n                try {\n                    // execute action in different thread\n                    action.call();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n    }\n}            \n</code></pre> <p>Warning</p> <p>Pay attention that for jersey scope objects provider must be called first in the current thread! Guice would be able to propagate to another thread only objects already present in guice request scope. Without it, <code>provider.get()</code>, called under different thread would be delegated to jersey, which is not aware of this thread and so fail to provide its request scope object.</p> <p>Such additional call is not required for pure guice-managed request scope objects.  </p>"},{"location":"guide/guice/scopes/#request-scope-simulation","title":"Request scope simulation","text":"<p>Sometimes, request scoped beans may need to be used somewhere without request (for example, inside scheduled job). Of course, this is not correct situation, and the best way is to re-design services, but not always possible.</p> <p>As a workaround, request scope could be simulated:</p> <pre><code>@Inject\nProvider&lt;RScopedService&gt; service;\n...\nfinal RequestScoper scope = ServletScopes.scopeRequest(Collections.emptyMap());\ntry (final RequestScoper.CloseableScope ignored = scope.open()) {\n  // work with request-scoped bean\n  service.get().doSomething();\n}\n</code></pre>"},{"location":"guide/guice/scopes/#eager-singleton","title":"Eager singleton","text":"<p>By default, guicey create injector in <code>PRODUCTION</code> stage, so all registered singletons will be instantiated immediately.</p> <p>But if you rely on guice JIT (instantiation by injection) it may defer bean creation  (until it will be requested first time).</p> <p>To always start beans (even in <code>DEVELOPMENT</code> stage) guice provide eager singleton option: <code>bind(MyService.class).asEagerSingleton()</code>.</p> <p>For cases when you don't want to manually declare bean, but require it to start with guice context you can either implement Managed or mark bean  as @EagerSingleton (the latter will simply bind annotated bean as guice eager singleton instead of you).</p>"},{"location":"guide/guice/servletmodule/","title":"ServletModule","text":"<p>By default, GuiceFilter is registered for both application and admin contexts:</p> <ul> <li>ServletModule can be used for filters and servlets declaration </li> <li>Request (and session) scope is available in both contexts</li> </ul> <p>Note</p> <p>Actually, the same <code>GuiceFilter</code> instance is used for both contexts. This way request scope works properly on both contexts, and registrations through <code>ServeletModule</code> are available both context. See web mappings report.</p> <p>Example of servlet and filter registration through guice module:</p> <pre><code>public class WebModule extends ServletModule {\n\n    @Override\n    protected void configureServlets() {\n        filter(\"/*\").through(MyFilter.class);\n        serve(\"/myservlet\").with(MyServlet.class);\n    }\n}    \n\nGuiceBundle.builder()\n    .modules(new WebModule())\n    .build()\n</code></pre> <p>Warning</p> <p>Rest context is mapped to root by default. To change it use configuration file:</p> <pre><code>server:\n    rootPath: '/rest/*'\n</code></pre> <p>Note</p> <p>With guice you can map servlets and filters using regexps </p> <p>Tip</p> <p>It may be more handy to use web extensions instead of direct registrations. For example, it is the only way to bind servlets in admin context.    </p>"},{"location":"guide/guice/servletmodule/#limitations","title":"Limitations","text":"<p>By default, <code>GuiceFilter</code> is registered with <code>REQUEST</code> dispatcher type. If you need to use other types use option:</p> <pre><code>    .option(GuiceyOptions.GuiceFilterRegistration, EnumSet.of(REQUEST, FORWARD))\n</code></pre> <p>Warning</p> <p>Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register <code>GuiceFilter</code> for <code>ASYNC</code> type).  Use web installers for such cases. </p> <p>Warning</p> <p><code>GuiceFilter</code> dispatch all requests for filters and servlets registered by <code>ServletModule</code> internally and there may be problems combining servlets from <code>ServletModule</code> and filters in main scope.</p>"},{"location":"guide/guice/servletmodule/#disable-servletmodule-support","title":"Disable ServletModule support","text":"<p>Danger</p> <p>Option is deprecated because request scope will become mandatory for the next guicey version (due to HK2 remove).    </p> <p>If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support:</p> <pre><code>GuiceBundle.builder()\n    .noGuiceFilter()\n</code></pre> <p>It will:</p> <ul> <li>Avoid registration of <code>GuiceFilter</code> in both contexts</li> <li>Remove request and session guice scopes support (because no ServletModule registered)</li> <li>Prevent installation of any <code>ServletModule</code> (error will be thrown indicating duplicate binding)</li> <li><code>HttpServletRequest</code> and <code>HttpServletResponse</code> still may be injected in resources with <code>Provider</code>  (but it will not be possible to use such injections in servlets, filters or any other place)</li> </ul> <p>Disabling saves about ~50ms of startup time. </p>"},{"location":"guide/test/assertj/","title":"AssertJ","text":"<p>It is highly recommended to use AssertJ instead of JUnit assertions (dropwizard team use for testing dropwizard).</p> <p>AssertJ version is already managed by dropwizard BOM:</p> <pre><code>testImplementation 'org.assertj:assertj-core'\n</code></pre> <p>AssertJ assertions are reversed, which might be cumbersome for simple assertions:</p> <pre><code>// Junit\nAssertions.assertEquals(12, something);\n\n// AssertJ\nAssertions.assertThat(something).isEqualTo(12);\n</code></pre> <p>But, with AssertJ you can combine assertions:</p> <pre><code>assertThat(frodo.getName()).startsWith(\"Fro\")\n                           .endsWith(\"do\")\n                           .isEqualToIgnoringCase(\"frodo\");\n</code></pre> <p>Tip</p> <p>See assertions guide</p> <p>Important</p> <p>In many cases, assertj assertion fail messages would be much more informative, which speeds up tests development and regressions investigation.</p>"},{"location":"guide/test/assertj/#text-assertions","title":"Text assertions","text":"<p>AssertJ greatly simplifies large text comparisons (e.g. console output). In Junit, to check if output contains some part you'll have to do:</p> <pre><code>Assertions.assertTrue(output.contains(\"some large string chunk here\"))\n</code></pre> <p>If assertion fails, you'll only:</p> <pre><code>org.opentest4j.AssertionFailedError: \nExpected :true\nActual   :false\n</code></pre> <p>For AssertJ assertion:</p> <pre><code>Assertions.assertThat(output).contains(\"some large string chunk here\");\n</code></pre> <p>You'll have all required info in the console:</p> <pre><code>java.lang.AssertionError: \nExpecting actual:\n  \"\n  original text here\n\n\"\nto contain:\n  \"some large string chunk here\" \n</code></pre> <p>This is extremely helpful because often output is pre-processed with regexps (to remove windows \"\\r\", to replace varying part (e.g. times), etc.) and AssertJ error shows the processed text which greatly simplifies understanding the problem.</p>"},{"location":"guide/test/assertj/#asserting-collections","title":"Asserting collections","text":"<pre><code>List&lt;TolkienCharacter&gt; hobbits = list(frodo, sam, pippin);\n\n// all elements must satisfy the given assertions\nassertThat(hobbits).allSatisfy(character -&gt; {\n  assertThat(character.getRace()).isEqualTo(HOBBIT);\n  assertThat(character.getName()).isNotEqualTo(\"Sauron\");\n});\n\n// at least one element must satisfy the given assertions\nassertThat(hobbits).anySatisfy(character -&gt; {\n  assertThat(character.getRace()).isEqualTo(HOBBIT);\n  assertThat(character.getName()).isEqualTo(\"Sam\");\n});\n</code></pre> <p>Accessing elements:</p> <pre><code>Iterable&lt;TolkienCharacter&gt; hobbits = list(frodo, sam, pippin);\nassertThat(hobbits).first().isEqualTo(frodo);\nassertThat(hobbits).element(1).isEqualTo(sam);\nassertThat(hobbits).last().isEqualTo(pippin);\n</code></pre>"},{"location":"guide/test/assertj/#exception-assertions","title":"Exception assertions","text":"<pre><code>assertThatExceptionOfType(RuntimeException.class)\n         .isThrownBy(() -&gt; { throw new RuntimeException(new IllegalArgumentException(\"boom!\")); })\n         .havingCause()\n         .withMessage(\"boom!\");\n</code></pre> <p>Or</p> <pre><code>assertThatThrownBy(() -&gt; throw new RuntimeException(\"boom!\"))\n        .hasMessage(\"boom!\");\n</code></pre>"},{"location":"guide/test/assertj/#objects-comparison","title":"Objects comparison","text":"<p>For data objects, not implementing equals simple comparison would not work:</p> <pre><code>Object first = new Something();\nObject second = new Something();\n\n// different objects because equals not implemented\nassertThat(first).isEqualTo(second);\n</code></pre> <p>AssertJ provides recursive comparison to compare object fields (instead of using object equals):</p> <pre><code>assertThat(first)\n    .usingRecursiveComparison()\n    .isEqualTo(second);\n</code></pre> <p>You can also exclude some fields from comparison:</p> <pre><code>assertThat(first)\n  .usingRecursiveComparison()\n  .ignoringFields(\"birthdDate\")\n  .isEqualTo(second);\n</code></pre> <p>Tip</p> <p>Assert object does not contain null fields:  <pre><code>assertThat(object).usingRecursiveAssertion().hasNoNullFields()\n</code></pre></p>"},{"location":"guide/test/assertj/#assumptions","title":"Assumptions","text":"<p>Assumption mechanism allows ignoring test if some  condition does not met:</p> <pre><code>@Test\npublic void when_an_assumption_is_not_met_the_test_is_ignored() {\n  // since this assumption is obviously false ...\n  Assumptions.assumeThat(frodo.getRace()).isEqualTo(ORC);\n  // ... this assertion is not performed\n  assertThat(fellowshipOfTheRing).contains(sauron);\n}\n</code></pre>"},{"location":"guide/test/assertj/#soft-assertions","title":"Soft assertions","text":"<p>Soft assertions allows showing all errors at once, instead of only the first one.</p> <p>This might be useful for speeding up debugging long-running tests (avoid many run-fix-run cycles):</p> <pre><code>SoftAssertions.assertSoftly(softly -&gt; {\n    softly.assertThat(frodo.name).isEqualTo(\"Samwise\");\n    softly.assertThat(sam.name).isEqualTo(\"Frodo\");\n});\n</code></pre> <pre><code>Multiple Failures (2 failures)\n -- failure 1 --\n Expecting:\n  &lt;\"Frodo\"&gt;\n to be equal to:\n  &lt;\"Samwise\"&gt;\n but was not.\n -- failure 2 --\n Expecting:\n  &lt;\"Samwise\"&gt;\n to be equal to:\n  &lt;\"Frodo\"&gt;\n but was not.\n</code></pre>"},{"location":"guide/test/assertj/#db-assertions","title":"DB assertions","text":"<p>There is also an assertj-db extension which greatly simplifies testing logic affecting JDBC database.</p> <p>To use assertj-db add dependency:</p> <pre><code>testImplementation 'org.assertj:assertj-db:3.0.0'\n</code></pre> <p>Assuming database is configured in application configuration:</p> <pre><code>AssertDbConnection connection;\n\n@BeforeAll\n// here AppConfig would be injected as guice bean (assume junit extension used) \nstatic void beforeAll(AppConfig config) {\n    final DataSourceFactory db = config.getDatabase();\n    connection = AssertDbConnectionFactory\n            .of(db.getUrl(), db.getUser(), db.getPassword())\n            .create();\n}\n</code></pre> <p>Now you can access any table:</p> <pre><code>Table table = connection.table(\"table_name\").build();\n</code></pre> <p>Important</p> <p><code>Table</code> represents current database \"snapshot\" - it will not show modifications performed after table creation! So always create new table before assertions.</p> <p>To output it to console (useful for modifications on empty or small tables):</p> <pre><code>Outputs.output(table).toConsole();\n</code></pre> <p>Will print the entire table in console:</p> <pre><code>[MEMBERS table]\n|-----------|---------|-----------|-----------|--------------|-----------|-----------|-----------|\n|           |         | *         |           |              |           |           |           |\n|           | PRIMARY | ID        | NAME      | FIRSTNAME    | SURNAME   | BIRTHDATE | SIZE      |\n|           | KEY     | (NUMBER)  | (TEXT)    | (TEXT)       | (TEXT)    | (DATE)    | (NUMBER)  |\n|           |         | Index : 0 | Index : 1 | Index : 2    | Index : 3 | Index : 4 | Index : 5 |\n|-----------|---------|-----------|-----------|--------------|-----------|-----------|-----------|\n| Index : 0 | 1       | 1         | Hewson    | Paul David   | Bono      | 05-10-60  | 1.75      |\n| Index : 1 | 2       | 2         | Evans     | David Howell | The Edge  | 08-08-61  | 1.77      |\n| Index : 2 | 3       | 3         | Clayton   | Adam         |           | 03-13-60  | 1.78      |\n| Index : 4 | 4       | 4         | Mullen    | Larry        |           | 10-31-61  | 1.70      |\n|-----------|---------|-----------|-----------|--------------|-----------|-----------|-----------|\n</code></pre> <p>Assert table data:</p> <pre><code>org.assertj.db.api.Assertions.assertThat(table).hasNumberOfRows(1);\n\norg.assertj.db.api.Assertions.assertThat(table).column(\"name\")\n        .value().isEqualTo(\"Hewson\")\n</code></pre> <p>Do direct sql requests:</p> <pre><code>Request request1 = connection.request(\"select name, firstname from members where id = 2 or id = 3\").build();\n</code></pre> <p>Tip</p> <p>Read more in concepts doc</p>"},{"location":"guide/test/junit4/","title":"Junit 4","text":"<p>Warning</p> <p>Since guicey 5.5 junit 4 support was extracted from guicey to external module:</p> <ul> <li>Package remains the same to simplify migration (only additional dependency would be required)</li> <li>Deprecation marks removed from rules to reduce warnings. </li> </ul> <p>DEPRECATED because dropwizard deprecated its junit4 rules. Consider migration to JUnit 5</p>"},{"location":"guide/test/junit4/#setup","title":"Setup","text":"<p>Required dependencies (assuming BOM used for versions management):</p> <pre><code>testImplementation 'ru.vyarus.guicey:guicey-test-junit4'\n</code></pre>"},{"location":"guide/test/junit4/#with-junit-5","title":"With Junit 5","text":"<p>OR you can use it with junit 5 vintage engine:</p> <pre><code>testImplementation 'ru.vyarus.guicey:guicey-test-junit4'\ntestImplementation 'org.junit.jupiter:junit-jupiter-api'\ntestRuntimeOnly 'org.junit.jupiter:junit-jupiter'\ntestRuntimeOnly 'org.junit.vintage:junit-vintage-engine'\n</code></pre> <p>This way all existing junit 4 tests would work and new tests could use junit 5 extensions.</p>"},{"location":"guide/test/junit4/#rules","title":"Rules","text":"<p>Provided rules:</p> <ul> <li><code>GuiceyAppRule</code> - lightweight integration tests (guice only)</li> <li><code>GuiceyHooksRule</code> - test-specific application modifications</li> <li><code>StartupErrorRule</code> - helper for testing failed application startup</li> </ul>"},{"location":"guide/test/junit4/#testing-core-logic","title":"Testing core logic","text":"<p>For integration testing of guice specific logic you can use <code>GuiceyAppRule</code>. It works almost like  DropwizardAppRule, but doesn't start jetty (and so jersey and guice web modules will not be initialized).  Managed and lifecycle objects supported.</p> <pre><code>public class MyTest {\n\n    @Rule\n    GuiceyAppRule&lt;MyConfiguration&gt; RULE = new GuiceyAppRule&lt;&gt;(MyApplication.class, \"path/to/configuration.yaml\");\n\n    public void testSomething() {\n        RULE.getBean(MyService.class).doSomething();\n        ...\n    }\n}\n</code></pre> <p>As with dropwizard rule, configuration is optional</p> <pre><code>new GuiceyAppRule&lt;&gt;(MyApplication.class, null)\n</code></pre>"},{"location":"guide/test/junit4/#testing-web-logic","title":"Testing web logic","text":"<p>For web component tests (servlets, filters, resources) use  DropwizardAppRule.</p> <p>To access guice beans use injector lookup:</p> <pre><code>InjectorLookup.getInstance(RULE.getApplication(), MyService.class).get();\n</code></pre>"},{"location":"guide/test/junit4/#customizing-guicey-configuration","title":"Customizing guicey configuration","text":"<p>Guicey provides a way to modify its configuration in tests. You can apply configuration hook using rule:</p> <pre><code>// there may be exact class instead of lambda\nnew GuiceyHooksRule((builder) -&gt; builder.modules(...))\n</code></pre> <p>To use it with <code>DropwizardAppRule</code> or <code>GuiceyAppRule</code> you will have to apply explicit order:</p> <pre><code>static GuiceyAppRule RULE = new GuiceyAppRule(App.class, null);\n@ClassRule\npublic static RuleChain chain = RuleChain\n       .outerRule(new GuiceyHooksRule((builder) -&gt; builder.modules(...)))\n       .around(RULE);\n</code></pre> <p>Attention</p> <p>RuleChain is required because rules execution order is not guaranteed and configuration rule must obviously be executed before application rule. </p> <p>If you need to declare configurations common for all tests then declare rule instance in base test class and use it in chain (at each test):</p> <pre><code>public class BaseTest {\n    // IMPORTANT no @ClassRule annotation here!\n     static GuiceyHooksRule BASE = new GuiceyHooksRule((builder) -&gt; builder.modules(...))\n }\n\n public class SomeTest extends BaseTest {\n     static GuiceyAppRule RULE = new GuiceyAppRule(App.class, null);\n     @ClassRule\n     public static RuleChain chain = RuleChain\n        .outerRule(BASE)\n        // optional test-specific staff\n        .around(new GuiceyHooksRule((builder) -&gt; builder.modules(...)) \n        .around(RULE);\n }\n</code></pre> <p>Warning</p> <p>Don't use configuration rule with spock because it will not work. Use special spock extension instead.</p>"},{"location":"guide/test/junit4/#access-guice-beans","title":"Access guice beans","text":"<p>When using <code>DropwizardAppRule</code> the only way to obtain guice managed beans is through:</p> <pre><code>InjectorLookup.getInjector(RULE.getApplication()).getBean(MyService.class);\n</code></pre> <p>Also, the following trick may be used to inject test fields:</p> <pre><code>public class MyTest {\n\n    @ClassRule\n    static DropwizardAppRule&lt;TestConfiguration&gt; RULE = ...\n\n    @Inject MyService service;\n    @Inject MyOtherService otherService;\n\n    @Before\n    public void setUp() {\n        InjectorLookup.get(RULE.getApplication()).get().injectMemebers(this)\n    }                    \n}\n</code></pre>"},{"location":"guide/test/junit4/#testing-startup-errors","title":"Testing startup errors","text":"<p>If exception occur on startup dropwizard will call <code>System.exit(1)</code> instead of throwing exception (as it was before 1.1.0). System exit could be intercepted with system rules.</p> <p>Note</p> <p>If you are going to move to junit 5 soon then better use system stubs library. It is a successor of system rules and provides both junit 4 and 5 extensions.</p> <p>Special rule provided to simplify work with system rules: <code>StartupErrorRule</code>. It's a combination of exit and out/err outputs interception rules.</p> <pre><code>public class MyErrTest {\n\n    @Rule\n    public StartupErrorRule RULE = StartupErrorRule.create();\n\n    public void testSomething() {\n        new MyErrApp().main('server');\n    }\n}\n</code></pre> <p>This test will pass only if application will throw exception during startup.</p> <p>In junit it is impossible to apply checks after exit statement, so such checks must be registered as a special callback:</p> <pre><code>public class MyErrTest {\n\n    @Rule\n    public StartupErrorRule RULE = StartupErrorRule.create((out, err) -&gt; {\n        Assert.assertTrue(out.contains(\"some log line\"));\n        Assert.assertTrue(err.contains(\"expected exception message\"));\n    });\n\n    public void testSomething() {\n        new MyErrApp().main('server');\n    }\n}\n</code></pre> <p>Note that err will contain full exception stack trace and so you can check exception type too by using contains statement like above.</p> <p>Check callback(s) may be added after rule creation:</p> <pre><code>@Rule\npublic StartupErrorRule RULE = StartupErrorRule.create();\n\npublic void testSomething() throws Exception {\n    RULE.checkAfterExit((out, err) -&gt; {\n            Assert.assertTrue(err.contains(\"expected exception message\"));\n        });\n    ...\n}\n</code></pre> <p>Multiple check callbacks may be registered (even if the first one was registered in rule's  create call).</p> <p>Rule works a bit differently with spock 1.</p>"},{"location":"guide/test/junit4/#migrating-to-junit-5","title":"Migrating to JUnit 5","text":"<ul> <li>Instead of <code>GuiceyAppRule</code> use @TestGuiceyApp extension.</li> <li>Instead of <code>DropwizardAppRule</code> use @TestDropwizardApp extension.</li> <li><code>GuiceyHooksRule</code> can be substituted with hooks declaration in extensions or as test fields</li> <li>Instead of <code>StartupErrorRule</code> use system-stubs - the successor of system rules</li> </ul> <p>In essence:</p> <ul> <li>Use annotations instead of rules (and forget about RuleChain difficulties)</li> <li>Test fields injection will work out of the box, so no need for additional hacks</li> <li>JUnit 5 propose parameter injection, which may be not common at first, but it's actually very handy</li> </ul> <p>Also, there is a pre-configured http client suitable for calling test application urls (or any other general url).  </p>"},{"location":"guide/test/openapi-server/","title":"Openapi fake server","text":"<p>See example source</p> <p>If you generate external API client using OpenAPI declaration, you can also generate a fake server implementation from the same file.</p> <p>Sample client and server build:</p> <pre><code>mport org.openapitools.generator.gradle.plugin.tasks.GenerateTask\n\nplugins {\n    id 'org.openapi.generator'\n}\n\njava {\n    withSourcesJar()\n}\n\ndependencies {\n    implementation 'io.dropwizard:dropwizard-forms'\n    implementation 'com.github.scribejava:scribejava-core:8.3.3'\n\n    // OPENAPI CODEGEN\n    // additional dependency required for codegen, but conflicts with dropwizard (need to disable feature)\n    implementation 'org.glassfish.jersey.media:jersey-media-json-jackson'\n\n    compileOnly 'io.swagger.core.v3:swagger-annotations:2.2.30'\n}\n\n// https://openapi-generator.tech/docs/generators/java\nopenApiGenerate {\n    generatorName = \"java\"\n    inputSpec = \"$projectDir/src/main/openapi/petStore.yaml\"\n    outputDir = \"$buildDir/petstore/client\"\n    apiPackage = \"com.petstore.api\"\n    invokerPackage = \"com.petstore\"\n    modelPackage = \"com.petstore.api.model\"\n    configOptions = [\n            library: \"jersey3\",\n            dateLibrary: \"java8\",\n            openApiNullable: \"false\",\n            hideGenerationTimestamp: \"true\"\n    ]\n}\n\n\n// https://openapi-generator.tech/docs/generators/jaxrs-jersey\ntasks.register('openApiGenerateServer', GenerateTask) {\n    group = 'openapi tools'\n    generatorName = \"jaxrs-jersey\"\n    inputSpec = \"$projectDir/src/main/openapi/petStore.yaml\"\n    outputDir = \"$buildDir/petstore/server\"\n    apiPackage = \"com.petstore.server.api\"\n    invokerPackage = \"com.petstore.server\"\n    modelPackage = \"com.petstore.server.api.model\"\n    configOptions = [\n            library    : \"jersey3\",\n            dateLibrary: \"java8\",\n            openApiNullable: \"false\",\n            hideGenerationTimestamp: \"true\"\n    ]\n}\n\ncompileJava.dependsOn 'openApiGenerate', 'openApiGenerateServer'\ntasks.sourcesJar.dependsOn 'openApiGenerate', 'openApiGenerateServer'\nsourceSets.main.java.srcDir \"${openApiGenerate.outputDir.get()}/src/main/java\"\n// note main folder not attached! (sources were copied manually)\nsourceSets.main.java.srcDir \"${openApiGenerateServer.outputDir.get()}/src/gen/java\"\n</code></pre> <p><code>openApiGenerate</code> creates client in build/petstore/client <code>openApiGenerateServer</code> creates server stub in build/petstore/server</p>"},{"location":"guide/test/openapi-server/#client","title":"Client","text":"<p>Actual client interfaces are generated in:</p> <pre><code>/build/petstore/client/src/main/java/com/petstore/api\n</code></pre> <p>These are the main client classes:</p> <ul> <li><code>PetApi</code></li> <li><code>StoreApi</code></li> <li><code>UserApi</code></li> </ul> <p>Guice bindings:</p> <pre><code>public class PetStoreApiModule extends DropwizardAwareModule&lt;ExampleConfig&gt; {\n\n    @Override\n    protected void configure() {\n        ApiClient apiClient = new ApiClient();\n        apiClient.setBasePath(configuration().getPetStoreUrl());\n        // optional\n        apiClient.setDebugging(true);\n\n        bind(ApiClient.class).toInstance(apiClient);\n        bind(PetApi.class).toInstance(new PetApi(apiClient));\n        bind(StoreApi.class).toInstance(new StoreApi(apiClient));\n        bind(UserApi.class).toInstance(new UserApi(apiClient));\n    }\n}\n</code></pre> <p>(target url is in configuration)</p>"},{"location":"guide/test/openapi-server/#server","title":"Server","text":"<p>Generated server stub:</p> <pre><code>/build/petstore/server/src/main/java/com/petstore/server\n</code></pre> <p>NOTE: server will also generate its own model, but this part will be attached directly (from <code>gen</code> folder).</p> <p>Now copy server files into the main sources (preserving package):</p> <pre><code>/build/petstore/server/src/main/java/com/petstore/server --&gt;  /src/main/java/com/petstore/server\n</code></pre> <p>(except <code>Bootstrap</code> class)</p> <p>Implement fakes in <code>impl</code>. For example, to implement getPetById, change <code>PetApiServiceImpl</code> :</p> <pre><code>@Override\npublic Response getPetById(Long petId, SecurityContext securityContext) throws NotFoundException {\n    final Pet pet = new Pet();\n    pet.setId(petId);\n    pet.setName(\"Jack\");\n    final Tag tag = new Tag();\n    tag.setName(\"puppy\");\n    pet.getTags().add(tag);\n    return Response.ok().entity(pet).build();\n}\n</code></pre> <p>Now implement root fake resource:</p> <pre><code>@Path(\"/fake/petstore/\")\npublic class FakePetStoreServer {\n\n    // IMPORTANT: paths in console would contain /pet/pet duplicate, but ACTUAL path matching would IGNORE\n    // @Path(\"/pet\") declared on ApiApi class, so such declaration is correct for runtime\n\n    @Path(\"/pet\")\n    public Class&lt;PetApi&gt; getPetApi() {\n        return PetApi.class;\n    }\n\n    @Path(\"/store\")\n    public Class&lt;StoreApi&gt; getStoreApi() {\n        return StoreApi.class;\n    }\n\n    @Path(\"/user\")\n    public Class&lt;UserApi&gt; getUserApi() {\n        return UserApi.class;\n    }\n}\n</code></pre>"},{"location":"guide/test/openapi-server/#bundle","title":"Bundle","text":"<p>Use GuiceyBundle for activation:</p> <pre><code>public class PetStoreBundle implements GuiceyBundle {\n\n    @Override\n    public void run(GuiceyEnvironment environment) throws Exception {\n        // because of required conflicting dependency jersey-media-json-jackson\n        // https://github.com/dropwizard/dropwizard/issues/1341#issuecomment-251503011\n        environment.environment().jersey()\n                .property(CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE, Boolean.TRUE);\n\n        // register client api\n        environment.modules(new PetStoreApiModule());\n\n        // optional fake server start\n        if (environment.&lt;ExampleConfig&gt;configuration().isStartFakeStore()) {\n            environment.register(FakePetStoreServer.class);\n        }\n    }\n}\n</code></pre> <p>Registration in app:</p> <pre><code>@Override\npublic void initialize(Bootstrap&lt;ExampleConfig&gt; bootstrap) {\n    bootstrap.addBundle(GuiceBundle.builder()\n            .bundles(new PetStoreBundle())\n            .build());\n}\n</code></pre>"},{"location":"guide/test/openapi-server/#usage","title":"Usage","text":"<pre><code>@TestDropwizardApp(value = ExampleApp.class,\n        configOverride = {\n                \"petStoreUrl: http://localhost:8080/fake/petstore\",\n                \"startFakeStore: true\"})\npublic class FakeServerTest {\n\n    @Inject\n    SampleService sampleService;\n\n    @Test\n    void testServer() {\n\n        final Pet pet = sampleService.findPet(1);\n        Assertions.assertNotNull(pet);\n        Assertions.assertEquals(\"Jack\", pet.getName());\n    }\n}\n</code></pre>"},{"location":"guide/test/overview/","title":"Testing","text":"<p>Guicey provides test extensions for: </p> <ul> <li>JUnit 5</li> <li>Spock 2 </li> <li>Framework-agnostic utilities</li> </ul> <p>Spock 2</p> <p>There are no special Spock 2 extensions: junit 5 extensions used directly (with a special library), so all junit 5 features are available for spock 2.</p> <p>Deprecated (because they use a deprecated dropwizard rule):</p> <ul> <li>Spock 1 </li> <li>JUnit 4</li> </ul> <p>Almost all extensions implemented with DropwizardTestSupport.</p> <p>Tip</p> <p>Test framework-agnostic utilities could be also used with junit 5 or spock extensions in cases when assertions required after application shutdown or to test application startup errors.</p>"},{"location":"guide/test/overview/#test-concepts","title":"Test concepts","text":"<p>Dropwziard proposes atomic testing approach (separate testing of each element). </p> <p>With DI (guice) we have to move towards integration testing because:</p> <ol> <li>It is now harder to mock classes \"manually\" (because of DI \"black box\")</li> <li>We have a core (guice injector, without web services), starting much faster than  complete application.</li> </ol> <p>The following kinds of tests should be used:</p> <ol> <li>Unit tests for atomic parts (usually, utility classes)</li> <li>Business logic (core integration tests): lightweight application starts (without web) to test services    (some services could be mocked or stubbed)</li> <li>Lightweight REST tests: same as 2, but also some rest services simulated (same as     dropwizard resource testing) </li> <li>Web integration tests: full application startup to test web endpoints (full workflow to check transport layer)</li> <li>Custom command tests</li> <li>Application startup fail test (done with command runner) to check self-validations</li> </ol>"},{"location":"guide/test/overview/#configuration-hooks","title":"Configuration hooks","text":"<p>Guicey provides a hooks mechanism for modifying configuration of the existing application.</p> <p>Hook receives builder instance used for <code>GuiceBundle</code> configuration and so with hook you can do everything that could be done is the main bundle configuration: </p> <ul> <li>Register new guice modules</li> <li>Register new bundles (dropwizard or guicey)</li> <li>Disable extensions/modules/bundles</li> <li>Activate guicey reports</li> <li>Override guice bindings</li> <li>Register some additional extensions (could be useful for validation or to replace existing extension with    a stub implementation)</li> <li>Change application options</li> </ul> <p>Example hook:</p> <pre><code>public class MyHook implements GuiceyConfigurationHook {\n\n    public void configure(GuiceBundle.Builder builder) throws Exception {\n        builder\n            .disableModules(FeatureXModule.class)\n            .disable(inPackage(\"com.foo.feature\"))\n            .modulesOverride(new MockDaoModule())\n            .option(Myoptions.DebugOption, true);\n    }\n}\n</code></pre> <p>Tip</p> <p>You can modify options in hook and so could enable some custom debug/monitoring options specifically for test.</p>"},{"location":"guide/test/overview/#disables","title":"Disables","text":"<p>Every extension, installed by guicey, could be disabled. When you register extension manually:</p> <pre><code>GuiceBundle.builder()\n    .extensions(MyExceptionMapper.class)\n    ...\n</code></pre> <p>(or extension detected from classpath scan or from guice binding), guicey controls its installation and so could avoid registering it (disable).</p> <p>Note</p> <p>Guicey can't disable extensions registered directly: <pre><code>environment.jersey().register(MyExceptionMapper.class)    \n</code></pre></p> <p>You can use hooks to disable all unnecessary features in test:</p> <ul> <li>installers</li> <li>extensions</li> <li>guice modules</li> <li>guicey bundles</li> <li>dropwizard bundles</li> </ul> <p>This way, you can isolate (as much as possible) some feature for testing.</p> <p>The most helpful should be bundles disable (if you use bundles for features grouping) and guice modules.</p> <p>Using disable predicates multiple extensions could be disabled at once (e.g., extensions from some package or only annotated extensions). But pay attention that predicates applied for all types of extensions!</p>"},{"location":"guide/test/overview/#guice-bindings-override","title":"Guice bindings override","text":"<p>It is a quite common requirement to replace some service with a stub or mock.  That's where guice overriding bindings come into play (<code>Modules.override()</code>).  With it, you don't need to modify existing guice modules to replace any guice bean for tests (no matter how original binding was declared: it would override anything, including providers and provider methods).</p> <p>For example, we have some service binding declared as: <pre><code>public class MyModule extends AbstractModule {\n\n    protected configure() {\n        // assumed @Inject ServiceX used everywhere \n        bind(ServiceX.class).to(MyServiceX.class);        \n    }\n}\n</code></pre></p> <p>To replace it with <code>MyServiceXExt</code>, preparing overriding module:</p> <pre><code>public class MyOverridingModule extends AbstractModule {\n\n    protected configure() {\n        bind(ServiceX.class).to(MyServiceXExt.class);        \n    }\n}\n</code></pre> <p>It could be overridden with a hook:</p> <pre><code>public class MyHook implements GuiceyConfigurationHook {\n    public void configure(GuiceBundle.Builder builder) throws Exception {\n        builder\n            // the main module is still registered in application:\n            // .modules(new MyModule())        \n            .modulesOverride(new MyOverridingModule());\n    }\n}\n</code></pre> <p>Now all service injections (<code>@Inject ServiceX</code>) would receive <code>MyServiceXExt</code> instead of <code>MyServiceX</code></p>"},{"location":"guide/test/overview/#debug-bundles","title":"Debug bundles","text":"<p>You can also use special guicey bundles, which modify application behavior. Bundles could contain additional listeners or services to gather additional metrics during tests or validate behavior.</p> <p>For example, guicey tests use a custom bundle to enable restricted guice options like  <code>disableCircularProxies</code>:</p> <pre><code>public class GuiceRestrictedConfigBundle implements GuiceyBundle {\n\n    @Override\n    void initialize(GuiceyBootstrap bootstrap) throws Exception {\n        bootstrap.modules(new GRestrictModule());\n    }\n\n    public static class GRestrictModule extends AbstractModule {\n        @Override\n        protected void configure() {\n            binder().disableCircularProxies();\n            binder().requireExactBindingAnnotations();\n            binder().requireExplicitBindings();\n        }\n    }\n}\n\n// Here bundle is registered with a system property, but\n// also could be registered with a hook\nPropertyBundleLookup.enableBundles(GuiceRestrictedConfigBundle.class);\n</code></pre> <p>Bundles are less powerful than hooks, but in many cases it is enough, for example to:</p> <ul> <li>disable installers, extensions, guice modules</li> <li>register custom extensions, modules or bundles</li> <li>override guice bindings</li> </ul> <p>You can also use the lookup mechanism to load bundles in tests (like system properties lookup used above). </p>"},{"location":"guide/test/overview/#overriding-overridden-beans","title":"Overriding overridden beans","text":"<p>Guicey provides direct support for overriding guice bindings, but this might be already used by application itself (e.g. to \"hack\" or \"patch\" some service  in 3<sup>rd</sup> party module).</p> <p>In this case, it would be impossible to override such (already overridden) services and you should use the provided custom injector factory:  </p> <p>Register factory in guice bundle:</p> <pre><code>GuiceBundle.builder()\n    .injectorFactory(new BindingsOverrideInjectorFactory())\n</code></pre> <p>After that you can register overriding bindings (which will override even modules registered in <code>modulesOverride</code>) with:</p> <pre><code>BindingsOverrideInjectorFactory.override(new MyOverridingModule())\n</code></pre> <p>Important</p> <p>It is assumed that overriding modules registration and application initialization will be at the same thread (<code>ThreadLocal</code> used for holding registered modules to allow parallel tests usage). </p> <p>For example, suppose we have some service <code>CustomerService</code> and it's implementation <code>CustomerServiceImpl</code>,  defined in some 3<sup>rd</sup> party module. For some reason, we need to override this binding in the application:</p> <pre><code>public class OverridingModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        bind(CustomerService.class).to(CustomCustomerServiceImpl.class);\n    }\n}\n</code></pre> <p>If we need to override this binding in test (again):</p> <pre><code>public class TestOverridingModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        bind(CustomerService.class).to(CustomServiceStub.class);\n    }\n}\n</code></pre> <p>Registration would look like this:</p> <pre><code>GuiceBundle.builder()\n    .injectorFactory(new BindingsOverrideInjectorFactory())\n    .modules(new ThirdPatyModule())\n    // override binding for application needs\n    .modulesOverride(new OverridingModule())\n    ...\n    .build()\n\n// register overriding somewhere in test\nBindingsOverrideInjectorFactory.override(new TestOverridingModule())    \n</code></pre> <p>Tip</p> <p>Configuration hook may be used for static call (as a good integration point)</p> <p>After test startup, application will use customer service binding from <code>TestOverridingModule</code>.</p>"},{"location":"guide/test/overview/#test-commands","title":"Test commands","text":"<p>Dropwizard commands could be tested with commands test support</p> <p>For example:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .run(\"simple\", \"-u\", \"user\");\n\nAssertions.assertTrue(result.isSuccessful());\n</code></pre> <p>There are no special junit 5 extensions for command tests because direct run method is  already the best way.</p> <p>Warning</p> <p>Commands support override <code>System.in/out/err</code> to collect all output (and control input) which makes such tests impossible to run in parallel.</p>"},{"location":"guide/test/overview/#test-application-startup-fail","title":"Test application startup fail","text":"<p>To verify application self-validation mechanisms (make sure application would fail with incomplete configuration,  or whatever another reason) use commands runner.</p> <p>For example: </p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .runApp();\n\nAssertions.assertEquals();\n</code></pre> <p>Why not run directly?</p> <p>You can run command directly: <code>new App().run(\"simple\", \"-u\", \"user\")</code> But, if application throws exception in run phase, <code>System.exit(1)</code> would be called:</p> <p><pre><code>public abstract class Application&lt;T extends Configuration&gt; {\n    ...\n    protected void onFatalError(Throwable t) {\n        System.exit(1);\n    }\n}\n</code></pre> Commands runner runs commands directly so exit would not be called. </p>"},{"location":"guide/test/overview/#configuration","title":"Configuration","text":"<p>In tests, you can either use a custom configuration file with config overrides or create configuration instance manually.</p> <p>For modifying configuration, there are two mechanisms:</p> <ul> <li>Configuration overrides: dropwizard mechanism works only with file-based configuration.   Works through system properties and may not work in some cases (for example, for collection   properties)</li> <li>Configuration modifiers: guicey mechanism allowing direct configuration modification before    application startup (works with file-based configuration and manually created configuration    instance)</li> </ul>"},{"location":"guide/test/overview/#web-client","title":"Web client","text":"<p>Guicey provides a ClientSupport instance which provides basic methods for calling web endpoints. The most helpful part of it is that it will self-configure automatically, according to the provided configuration, so you don't need to modify tests when rest or admin mapping changes.</p>"},{"location":"guide/test/spock/","title":"Spock 1","text":"<p>Spock framework allows you to write much clearer tests (comparing to junit) thanks to  groovy language.</p> <p>Warning</p> <p>Since guicey 5.5 spock 1 support was extracted from guicey to external module. Package remains the same to simplify migration (only additional dependency would be required)</p> <p>This was required because spock 1 does not work on JDK 16 and above.</p> <p>DEPRECATED because Implementation relies on deprecated junit 4 rules. Consider migration to spock 2 (junit 5)</p>"},{"location":"guide/test/spock/#setup","title":"Setup","text":"<p>You will need the following dependencies (assuming BOM used for versions management):</p> <pre><code>testImplementation 'ru.vyarus.guicey:guicey-test-spock'\n</code></pre>"},{"location":"guide/test/spock/#with-junit-5","title":"With Junit 5","text":"<p>OR you can use it with junit 5 vintage engine:</p> <pre><code>testImplementation 'ru.vyarus.guicey:guicey-test-spock'\ntestImplementation 'org.junit.jupiter:junit-jupiter-api'\ntestRuntimeOnly 'org.junit.jupiter:junit-jupiter'\ntestRuntimeOnly 'org.junit.vintage:junit-vintage-engine'\n</code></pre> <p>This way you can write both spock (groovy) and junit 5 (java or groovy) tests.</p>"},{"location":"guide/test/spock/#extensions","title":"Extensions","text":"<p>Provided extensions:</p> <ul> <li><code>@UseGuiceyApp</code> - for lightweight tests (without starting web part, only guice context)</li> <li><code>@UseDropwizardApp</code> - for complete integration tests</li> </ul> <p>Both extensions allow using injections directly in specifications (like spock-guice).</p> <p><code>@UseGuiceyHooks</code> extension could be used to apply configuration hook  common for all tests. But, it is deprecated in favor of native hooks support in main extensions.</p>"},{"location":"guide/test/spock/#testing-core-logic","title":"Testing core logic","text":"<p><code>@UseGuiceyApp</code> runs all guice logic without starting jetty (so resources, servlets and filters will not be available). <code>Managed</code> objects will still be handled correctly.</p> <pre><code>@UseGuiceyApp(MyApplication)\nclass AutoScanModeTest extends Specification {\n\n    @Inject MyService service\n\n    def \"My service test\" {\n\n        when: 'calling service'\n        def res = service.getSmth()\n\n        then: 'correct result returned'\n        res == 'hello'\n    }\n</code></pre> <p>Application started before all tests in annotated class and stopped after them.</p>"},{"location":"guide/test/spock/#testing-web-logic","title":"Testing web logic","text":"<p><code>@UseDropwizardApp</code> is useful for complete integration testing (when web part is required):</p> <pre><code>@UseDropwizardApp(MyApplication)\nclass WebModuleTest extends Specification {\n\n    @Inject MyService service\n\n    def \"Check web bindings\"() {\n\n        when: \"calling filter\"\n        def res = new URL(\"http://localhost:8080/dummyFilter\").getText()\n\n        then: \"filter active\"\n        res == 'Sample filter and service called'\n        service.isCalled()\n</code></pre>"},{"location":"guide/test/spock/#random-ports","title":"Random ports","text":"<p>In order to start application on random port you can use configuration shortcut:</p> <pre><code>@UseDropwizardApp(value = MyApplication, randomPorts = true)\n</code></pre> <p>Note</p> <p>Random ports will be applied even if configuration with exact ports provided: <pre><code>@UseDropwizardApp(value = MyApplication, \n          config = 'path/to/my/config.yml', \n          randomPorts = true)\n</code></pre> Also, random ports support both server types (default and simple)</p> <p>Real ports could be resolved with ClientSupport object.</p>"},{"location":"guide/test/spock/#rest-mapping","title":"Rest mapping","text":"<p>Normally, rest mapping configured with <code>server.rootMapping=/something/*</code> configuration, but if you don't use custom configuration class, but still want to re-map rest, shortcut could be used:</p> <pre><code>@UseDropwizardApp(value = MyApplication, restMapping=\"something\")\n</code></pre> <p>In contrast to config declaration, attribute value may not start with '/' and end with '/*' - it would be appended automatically. </p> <p>This option is only intended to simplify cases when custom configuration file is not yet used in tests (usually early PoC phase). It allows you to map servlet into application root in test (because rest is no more resides in root). When used with existing configuration file, this parameter will override file definition.</p>"},{"location":"guide/test/spock/#guice-injections","title":"Guice injections","text":"<p>Any guice bean may be injected directly into test field:</p> <pre><code>@Inject\nSomeBean bean\n</code></pre> <p>This may be even bean not declared in guice modules (JIT injection will occur).</p> <p>To better understand injection scopes look the following test:</p> <pre><code>@UseGuiceyApp(AutoScanApplication)\nclass InjectionTest extends Specification {\n\n    // instance remain the same between tests\n    @Shared @Inject TestBean sharedBean\n\n    // new instance injected on each test\n    @Inject TestBean bean\n\n    // the same context used for all tests (in class), so the same bean instance inserted before each test\n    @Inject TestSingletonBean singletonBean\n\n    def \"Check injection types\"() {\n        when: \"changing state of injected beans\"\n        sharedBean.value = 10\n        bean.value = 5\n        singletonBean.value = 15\n\n        then: \"instances are different\"\n        sharedBean.value == 10\n        bean.value == 5\n        singletonBean.value == 15\n\n    }\n\n    def \"Check shared state\"() {\n\n        expect: \"shared bean instance is the same, whereas other one re-injected\"\n        sharedBean.value == 10\n        bean.value == 0\n        singletonBean.value == 15 // the same instance was set before second test\n    }\n\n    // bean is in prototype scope\n    static class TestBean {\n        int value\n    }\n\n    @Singleton\n    static class TestSingletonBean {\n        int value\n    }\n}\n</code></pre> <p>Note</p> <p>Guice AOP will not work on test methods (because test instances not created by guice).</p>"},{"location":"guide/test/spock/#client","title":"Client","text":"<p>Both extensions prepare special jersey client instance which could be used for web calls. It is mostly useful for complete web tests to call rest services and servlets.</p> <pre><code>@InjectClient\nClientSupport client\n</code></pre> <p>It will also work in static fields or <code>@Shared</code> fields.</p> <p>Client object provides:</p> <ul> <li>Access to JerseyClient object (for raw calls)</li> <li>Shortcuts for querying main, admin or rest contexts (it will count the current configuration automatically)</li> <li>Shortcuts for base main, admin or rest contexts base urls (and application ports)</li> </ul> <p>Example usages:</p> <pre><code>// GET {rest path}/some\nclient.targetRest(\"some\").request().buildGet().invoke()\n\n// GET {main context path}/servlet\nclient.targetMain(\"servlet\").request().buildGet().invoke()\n\n// GET {admin context path}/adminServlet\nclient.targetAdmin(\"adminServlet\").request().buildGet().invoke()\n</code></pre> <p>Tip</p> <p>All methods above accepts any number of strings which would be automatically combined into correct path: <pre><code>client.targetRest(\"some\", \"other/\", \"/part\")\n</code></pre> would be correctly combined as \"/some/other/part/\"</p> <p>As you can see test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct.</p> <pre><code>when: \"calling rest service\"\ndef res = client.targetRest(\"some\").request().buildGet().invoke()\n\nthen: \"response is correct\"\nres.status == 200\nres.readEntity(String) == \"response text\"\n</code></pre> <p>Also, if you want to use other client, client object can simply provide required info:</p> <pre><code>client.getPort()        // app port (8080)\nclient.getAdminPort()   // app admin port (8081)\nclient.basePathMain()   // main context path (http://localhost:8080/)\nclient.basePathAdmin()  // admin context path (http://localhost:8081/)\nclient.basePathRest()   // rest context path (http://localhost:8080/)\n</code></pre> <p>Raw client usage:</p> <pre><code>// call completely external url\nclient.target(\"http://somedomain:8080/dummy/\").request().buildGet().invoke()\n</code></pre> <p>Warning</p> <p>Client object could be injected with both dropwizard and guicey extensions, but in case of guicey extension, only raw client could be used (because web part not started all other methods will throw NPE)</p>"},{"location":"guide/test/spock/#configuration","title":"Configuration","text":"<p>For both extensions you can configure application with external configuration file:</p> <pre><code>@UseGuiceyApp(value = MyApplication,\n    config = 'path/to/my/config.yml'\nclass ConfigOverrideTest extends Specification {\n</code></pre> <p>Or just declare required values:</p> <pre><code>@UseGuiceyApp(value = MyApplication,\n    configOverride = [\n            @ConfigOverride(key = \"foo\", value = \"2\"),\n            @ConfigOverride(key = \"bar\", value = \"12\")\n    ])\nclass ConfigOverrideTest extends Specification {\n</code></pre> <p>Or use both at once (here overrides will override file values):</p> <pre><code>@UseGuiceyApp(value = MyApplication,\n    config = 'path/to/my/config.yml',\n    configOverride = [\n            @ConfigOverride(key = \"foo\", value = \"2\"),\n            @ConfigOverride(key = \"bar\", value = \"12\")\n    ])\nclass ConfigOverrideTest extends Specification {\n</code></pre>"},{"location":"guide/test/spock/#application-test-modification","title":"Application test modification","text":"<p>You can use hooks to customize application.</p> <p>In both extensions annotation hooks could be declared with attribute:</p> <pre><code>@UseDropwizardApp(value = MyApplication, hooks = MyHook)\n</code></pre> <p>or</p> <pre><code>@UseGuiceyApp(value = MyApplication, hooks = MyHook)\n</code></pre> <p>Where MyHook is:</p> <pre><code>class MyHook implements GuiceyConfigurationHook {}\n</code></pre>"},{"location":"guide/test/spock/#hook-fields","title":"Hook fields","text":"<p>Alternatively, you can declare hook directly in test static field:</p> <pre><code>@EnableHook\nstatic GuiceyConfigurationHook HOOK = { it.modules(new DebugModule()) }\n</code></pre> <p>Any number of fields could be declared. The same way hook could be declared in base test class:</p> <pre><code>class BaseTest extends Specification {\n\n    // hook in base class\n    @EnableHook\n    static GuiceyConfigurationHook BASE_HOOK = { it.modules(new DebugModule()) }\n}\n\n@UseGuiceyApp(value = App, hooks = SomeOtherHook)\nclass SomeTest extends BaseTest {\n\n    // Another hook\n    @EnableHook\n    static GuiceyConfigurationHook HOOK = { it.modules(new DebugModule2()) }\n}\n</code></pre> <p>All 3 hooks will work.</p>"},{"location":"guide/test/spock/#hooks-extension","title":"Hooks extension","text":"<p>Warning</p> <p>This extension is deprecated in favour of field hooks declarations. </p> <pre><code>@UseGuiceyHooks(MyBaseHook)\nclass BaseTest extends Specification {\n\n}\n\n@UseGuiceyApp(App)\nclass SomeTest extends BaseTest {}\n</code></pre> <p>Note</p> <p>You can still use test specific hooks together with declared base hook (to apply some more test-specific configuration).</p> <p>Warning</p> <p>Only one <code>@UseGuiceyHooks</code> declaration may be used in test hierarchy: for example, you can't declare it in base class and then another one on extended class - base for a group of tests. This is spock limitation (only one extension will actually work) but should not be an issue for most cases.</p>"},{"location":"guide/test/spock/#extension-configuration-unification","title":"Extension configuration unification","text":"<p>It is a common need to run multiple tests with the same test application configuration (same config overrides, same hooks etc.). Do not configure it in each test, instead move extension configuration into base test class:</p> <pre><code>@UsetGuiceyApp(...)\nabstract class AbstractTest extends Specification {\n    // here might be helper methods\n}\n</code></pre> <p>And now all test classes should simply extend it:</p> <pre><code>class Test1 extends AbstractTest {\n\n    @Inject\n    MyService service\n\n    def \"Check something\"() { ... }\n}\n</code></pre>"},{"location":"guide/test/spock/#dropwizard-startup-error","title":"Dropwizard startup error","text":"<p><code>StartupErrorRule</code> may be used to intercept dropwizard <code>System.exit(1)</code> call. But it will work different then for junit: <code>then</code> section is always called with exception (<code>CheckExitCalled</code>).  Also, <code>then</code> section may be used for assertion after exit calls and so there is  no need to add custom assertion callbacks (required by junit tests).</p> <pre><code>class ErrorTest extends Specification {\n\n    @Rule StartupErrorRule RULE = StartupErrorRule.create()\n\n    def \"Check startup error\"() {\n\n        when: \"starting app with error\"\n        new MyErrApp().main(['server'])\n\n        then: \"startup failed\"\n        thrown(RULE.indicatorExceptionType)\n        RULE.output.contains('stating application')\n        RULE.error.contains('some error occur')\n</code></pre>"},{"location":"guide/test/spock/#spock-lifecycle-hooks","title":"Spock lifecycle hooks","text":"<pre><code>class MyTest extends Specification {\n\n    @ClassRule @Shared\n    JunitRule sharedRule = new JunitRule()\n\n    @Rule\n    JunitRule2 rule = new JunitRule2()\n\n    def setupSpec() {\n    }\n\n    def setup() {\n    }\n\n    def \"Test method body\" () {\n        setup:\n    }\n}\n</code></pre> <p>Class rules are applied once per test class (same as <code>setupSpec</code>). Rules are applied per test method (same as <code>setup</code>).</p> <p>Setup order:</p> <ul> <li>Class rule</li> <li>Setup spec method</li> <li>Rule</li> <li>Setup method</li> <li>Test method's setup section</li> </ul>"},{"location":"guide/test/spock/#migration-to-spock-2","title":"Migration to Spock 2","text":"<p>There is no special extensions for Spock 2, instead junit 5 integrations must be used with it, using special library</p> <p>Current spock extensions are almost equivalent to junit5 extensions (in features and behaviour):</p> <ul> <li>Instead of <code>@UseGuiceyApp</code> use <code>@TestGuiceyApp</code></li> <li>Instead of <code>@UseDropwizardApp</code> use <code>@TestDropwizardApp</code></li> <li>Hooks can be specified with hooks declaration in extensions or as test fields</li> <li>Instead of <code>StartupErrorRule</code> use system-stubs - the successor of system rules</li> </ul>"},{"location":"guide/test/spock/#client_1","title":"Client","text":"<p>For <code>ClientSupport</code> object, INSTEAD of </p> <pre><code>@Inject ClientSupport client\n</code></pre> <p>use parameter injection (possibly in fixture methods too):</p> <pre><code>def \"Check something\"(ClientSupport client) {}\n</code></pre>"},{"location":"guide/test/spock/#config-overrides","title":"Config overrides","text":"<p>Junit extension does not require an annotation for each override, so INSTEAD of:</p> <pre><code>@UseDropwizardApp(value = App, configOverride = [\n        @ConfigOverride(key = \"server.rootPath\", value = \"/rest/*\"),\n        @ConfigOverride(key = \"server.applicationContextPath\", value = \"/prefix\"),\n        @ConfigOverride(key = \"server.adminContextPath\", value = \"/admin\")\n</code></pre> <p>Use:</p> <pre><code>@TestDropwizardApp(value = App, restMapping = \"/rest/*\",\n        configOverride = [\n                \"server.applicationContextPath: /prefix\",\n                \"server.adminContextPath: /admin\"])\n</code></pre> <p>Note that <code>server.rootPath</code> could be configured with <code>restMapping</code> annotation property.</p>"},{"location":"guide/test/spock/#alternative-declaration","title":"Alternative declaration","text":"<p>You may also use alternative declaration:</p> <pre><code>class MyTest extends Specification {\n\n    @RegisterExtension\n    static TestDropwizardAppExtension app = TestDropwizardAppExtension.forApp(App)\n            .config(\"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\")\n            .configOverrides(\"foo: 2\", \"bar: 12\")\n            .randomPorts()\n            .hooks(Hook)\n            .hooks(builder -&gt; builder.disableExtensions(DummyManaged))\n            .create()\n}\n</code></pre> <p>This is an alternative to previous rules declaration in fields. It is useful when you need dynamic hook (as lambda) or configuration overrides  require some other extensions.</p> <p>Note that config override may be registered with <code>Supplier</code>:</p> <pre><code>.configOverride(\"key\", () -&gt; { Somewhere.getValue()})\n</code></pre> <p>Warning</p> <p>Don't use <code>@Shared</code> fields instead of static - it wouldn't work! Also non-static field declaration is not supported by junit extension.</p>"},{"location":"guide/test/spock2/","title":"Spock 2","text":"<p>Migration from spock 1</p> <p>There are no special extensions for Spock 2 (like it was for spock 1), instead I did an extra integration library, so you can use existing Junit 5 extensions with spock.</p> <p>Note</p> <p>You are not limited to guicey junit 5 extensions, you can use (almost) any junit 5 extensions. And you can use any other spock extensions together with junit extensions.</p>"},{"location":"guide/test/spock2/#setup","title":"Setup","text":"<p>You will need the following dependencies (assuming BOM used for versions management):</p> <pre><code>testImplementation 'ru.vyarus:spock-junit5'\ntestImplementation 'org.spockframework:spock-core:2.3-groovy-4.0'\ntestImplementation 'io.dropwizard:dropwizard-testing'\ntestImplementation 'org.junit.jupiter:junit-jupiter-api'\n</code></pre> <p>Note</p> <p>In gradle you need to explicitly activate junit 5 support with <pre><code>test {\n    useJUnitPlatform()\n    ...\n}                    \n</code></pre></p>"},{"location":"guide/test/spock2/#usage","title":"Usage","text":"<p>See junit 5 extensions docs for usage details (it's all used the same).</p> <p>Warning</p> <p>Junit 5 extensions would not work with <code>@Shared</code> spock fields! You can still use such fields directly, but don't expect junit 5 extensions to be able to work with such fields (they can't \"see\" it).</p> <p>Here is a simple example:</p> <pre><code>@TestDropwizardApp(App)\nclass MyTest extends Specification {\n\n    @Inject MyService service\n\n    def \"Check something\" (ClientSupport client) {\n\n        when: \"calling rest endpoint\"\n        def res = client.targetRest(\"foo/bar\").request()\n                .buildGet().invoke().readEntity(String)\n\n        then: \"result correct\"\n        res == \"something\"\n\n        and: \"service called\"\n        service.isCalled()\n    }\n}\n</code></pre> <p>Tip</p> <p>Note that parameter injection will also work in test and fixture (setup/cleanup) methods</p> <p>Overall, you get best of both worlds: same extensions as in junit 5 (and ability to use all other junit extensions) and spock expressiveness for writing tests.</p>"},{"location":"guide/test/spock2/#testing-commands","title":"Testing commands","text":"<p>Warning</p> <p>Commands execution overrides System IO and so can't run in parallel with other tests!</p> <p>Use <code>@Isolated</code>  on such tests to prevent parallel execution with other tests</p> <p>Command execution is usually a short-lived action, so it is not possible to write an extension for it. Command could be tested only with generic utility:</p> <pre><code>def \"Test command execution\"() {\n\n    when: \"executing command\"\n    CommandResult result = TestSupport.buildCommandRunner(App)\n            .run(\"cmd\", \"-p\", \"param\")\n\n    then: \"success\"\n    result.successful\n}\n</code></pre> <p>Read more details in junit 5 guide</p> <p>Note</p> <p>The same utility could be used to test application startup fails</p>"},{"location":"guide/test/spock2/#special-cases","title":"Special cases","text":"<p>Junit 5 doc describes system stubs library usage. It is completely valid for spock, I'll just show a few examples here on how to:</p> <ul> <li>Modify (and reset) environment variables</li> <li>Modify (and reset) system properties</li> <li>Validate system output (e.g. testing logs)</li> <li>Intercepting system exit</li> </ul> <pre><code>@ExtendWith(SystemStubsExtension)\nclass StartupErrorTest extends Specification {\n\n    @SystemStub\n    SystemExit exit\n    @SystemStub\n    SystemErr err\n\n    def \"Check app crash\"() {\n\n        when: \"starting app\"\n        exit.execute(() -&gt; {\n            new App().run(['server'] as String[])\n        });\n\n        then: \"error\"\n        exit.exitCode == 1\n        err.text.contains(\"Error message text\")\n    }\n}\n</code></pre> <pre><code>@ExtendWith(SystemStubsExtension)\nclass EnvironmentChangeTest extends Specification {\n\n    @SystemStub\n    EnvironmentVariables ENV\n    @SystemStub\n    SystemOut out\n    @SystemStub\n    SystemProperties propsReset\n\n    def \"Check variables mapping\"() {\n\n        setup:\n        ENV.set(\"VAR\", \"1\")\n        System.setProperty(\"foo\", \"bar\") // OR propsReset.set(\"foo\", \"bar\") - both works the same\n\n        when: \n        // something requiring custom env or property values\n\n        then:\n        // validate system output (e.g. logs correctness)\n        out.text.contains(\"Some message assumed to be logged\")\n</code></pre> <p>Note</p> <p>Use test framework-agnostic utilities to run application with configuration or to run application without web part (for faster test).</p>"},{"location":"guide/test/general/client/","title":"Testing web (HTTP client)","text":"<p><code>ClientSupport</code> is a JerseyClient aware of dropwizard configuration, so you can easily call admin/main/rest urls.</p> <p>Creation:</p> <pre><code>ClientSupport client = TestSupport.webClient(support);\n</code></pre> <p>where support is <code>DropwizardTestSupport</code> or <code>GuiceyTestSupport</code> (in later case it could be used only as generic client for calling external urls).</p> <p>Example usage:</p> <pre><code>// GET {rest path}/some\nclient.targetRest(\"some\").request().buildGet().invoke()\n\n// GET {main context path}/servlet\nclient.targetMain(\"servlet\").request().buildGet().invoke()\n\n// GET {admin context path}/adminServlet\nclient.targetAdmin(\"adminServlet\").request().buildGet().invoke()\n\n// General external url call\nclient.target(\"https://google.com\").request().buildGet().invoke()\n</code></pre> <p>Tip</p> <p>All methods above accepts any number of strings which would be automatically combined into correct path: <pre><code>client.targetRest(\"some\", \"other/\", \"/part\")\n</code></pre> would be correctly combined as \"/some/other/part/\"</p> <p>As you can see, test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct.</p> <pre><code>Response res = client.targetRest(\"some\").request().buildGet().invoke()\n\nAssertions.assertEquals(200, res.getStatus())\nAssertions.assertEquals(\"response text\", res.readEntity(String)) \n</code></pre> <p>Also, if you want to use other client, client object can simply provide required info:</p> <pre><code>client.getPort()        // app port (8080)\nclient.getAdminPort()   // app admin port (8081)\nclient.basePathRoot()   // root server path (http://localhost:8080/)\nclient.basePathMain()   // main context path (http://localhost:8080/)\nclient.basePathAdmin()  // admin context path (http://localhost:8081/)\nclient.basePathRest()   // rest context path (http://localhost:8080/)\n</code></pre>"},{"location":"guide/test/general/client/#simple-rest-methods","title":"Simple REST methods","text":"<p>The client also contains simplified GET/POST/PUT/DELETE methods for path, relative to server root (everything after port):</p> <pre><code>@Test\npublic void testWeb(ClientSupport client) {\n    // get with result\n    Result res = client.get(\"rest/sample\", Result.class);\n\n    // post without result (void)\n    client.post(\"rest/action\", new PostObject(), null);\n\n   // post with result \n   Result res = client.post(\"rest/action\", new PostObject(), Result.class);\n}\n</code></pre> <p>All methods:</p> <ol> <li>Methods accept paths relative to server root. In the example above: \"http://localhost:8080/rest/sample\"</li> <li>Could return mapped response.</li> <li>For void calls, use null instead of the result type. In this case, only 200 and 204 (no content) responses    would be considered successful</li> </ol> <p>POST and PUT also accept (body) object to send. But methods does not allow multipart execution.</p> <p>Tip</p> <p>These methods could be used as examples for jersey client usage.</p>"},{"location":"guide/test/general/client/#customization","title":"Customization","text":"<p><code>JerseyClient</code> used in <code>ClientSupport</code> could be customized using <code>TestClientFactory</code> implementation.</p> <p>Simple factory example:</p> <pre><code>public class SimpleTestClientFactory implements TestClientFactory {\n\n    @Override\n    public JerseyClient create(final DropwizardTestSupport&lt;?&gt; support) {\n        return new JerseyClientBuilder()\n                .register(new JacksonFeature(support.getEnvironment().getObjectMapper()))\n                .property(ClientProperties.CONNECT_TIMEOUT, 1000)\n                .property(ClientProperties.READ_TIMEOUT, 5000)\n                .property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)\n                .build();\n    }\n}\n</code></pre> <p>Default implementation (<code>DefaultTestClientFactory</code>) applies timeouts and auto-registers multipart support if <code>dropwizard-forms</code> module if available in classpath.</p> <p>All builders support <code>.clientFactory()</code> method for optional customization.</p>"},{"location":"guide/test/general/client/#default-client","title":"Default client","text":"<p><code>JerseyClient</code> used inside <code>ClientSupport</code> is created by <code>DefaultTestClientFactory</code>.</p> <p>Default implementation:</p> <ol> <li>Enables multipart feature if <code>dropwizard-forms</code> is in classpath (so the client could be used    for sending multipart data).</li> <li>Enables request and response logging to simplify writing (and debugging) tests.</li> </ol> <p>By default, all request and response messages are written directly into console to guarantee client actions visibility (logging might not be configured in tests).</p> <p>Example output:</p> <pre><code>[Client action]---------------------------------------------{\n1 * Sending client request on thread main\n1 &gt; GET http://localhost:8080/sample/get\n\n}----------------------------------------------------------\n\n\n[Client action]---------------------------------------------{\n1 * Client response received on thread main\n1 &lt; 200\n1 &lt; Content-Length: 13\n1 &lt; Content-Type: application/json\n1 &lt; Date: Mon, 27 Nov 2023 10:00:40 GMT\n1 &lt; Vary: Accept-Encoding\n{\"foo\":\"get\"}\n\n}----------------------------------------------------------\n</code></pre> <p>Console output might be disabled with a system proprty:</p> <pre><code>// shortcut sets DefaultTestClientFactory.USE_LOGGER property\nDefaultTestClientFactory.disableConsoleLog()\n</code></pre> <p>With it, everything would be logged into <code>ClientSupport</code> logger (java.util) under INFO (most likely, would be invisible in the most logger configurations, but could be enabled).</p> <p>To reset property (and get logs back into console) use:</p> <pre><code>DefaultTestClientFactory.enableConsoleLog()\n</code></pre> <p>Note</p> <p>Static methods added not directly into <code>ClientSupport</code> because this is the default client factory feature. You might use a completely different factory.</p>"},{"location":"guide/test/general/command/","title":"Testing commands","text":"<p><code>CommandTestSupport</code> object is a commands test utility equivalent to <code>DropwizardTestSupport</code>. It uses dropwizard <code>Cli</code> for arguments recognition and command selection.</p> <p>The main difference with <code>DropwizardTestSupport</code> is that command execution is a short-lived process and all assertions are possible only after the execution. That's why command runner would include in the result all possible dropwizard objects, created during execution (because it would be impossible to reference them after execution).</p> <p>New builder (almost the same as application execution builder) simplify commands execution:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .run(\"simple\", \"-u\", \"user\")\n\nAssertions.assertTrue(result.isSuccessful());\n</code></pre> <p>This runner could be used to run any command type (simple, configured, environment). The type of command would define what objects would be present ofter the command execution (for example, <code>Injector</code> would be available only for <code>EnvironmentCommand</code>).</p> <p>Run command arguments are the same as real command arguments (the same <code>Cli</code> used for commands parsing). You can only omit configuration path and use builder instead:</p> <pre><code>    CommandResult result = TestSupport.buildCommandRunner(App.class)\n            .config(\"path/to/config.yml\")\n            .configOverride(\"prop: 1\")\n            .run(\"cmd\", \"-p\", \"param\");\n</code></pre> <p>Important</p> <p>Such run never fails with an exception: any appeared exception would be stored inside the response:</p> <pre><code>Assertions.assertFalse(result.isSuccessful());  \nAssertions.assertEquals(\"Error message\", result.getException().getMessage());\n</code></pre>"},{"location":"guide/test/general/command/#io","title":"IO","text":"<p>Runner use System.in/err/out replacement. All output is intercepted and could be asserted:</p> <pre><code>Assertions.assertTrue(result.getOutput().contains(\"some text\"))\n</code></pre> <p><code>result.getOutput()</code> contains both <code>out</code> and <code>err</code> streams together (the same way as user would see it in console). Error output is also available separately with <code>result.getErrorOutput()</code>.</p> <p>Note</p> <p>All output is always printed to console, so you could always see it after test execution (without additional actions)</p> <p>Commands requiring user input could also be tested (with mocked input):</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .consoleInputs(\"1\", \"two\", \"something else\")\n        .run(\"quiz\")\n</code></pre> <p>At least, the required number of answers must be provided (otherwise error would be thrown, indicating not enough inputs)</p> <p>Warning</p> <p>Due to IO overrides, command tests could not run in parallel.  For junit 5, such tests could be annotated with <code>@Isolated</code> (to prevent execution in parallel with other tests)</p>"},{"location":"guide/test/general/command/#configuration","title":"Configuration","text":"<p>Configuration options are the same as in run builder. For example:</p> <pre><code>// override only\nTestSupport.buildCommandRunner(App.class)\n        .configOverride(\"foo: 12\")\n        .run(\"cfg\");\n\n// file with overrides\nTestSupport.buildCommandRunner(App.class)\n        .config(\"src/test/resources/path/to/config.yml\")\n        .configOverride(\"foo: 12\")\n        .run(\"cfg\");\n\n// direct config object\nMyConfig config = new MyConfig();         \nTestSupport.buildCommandRunner(App.class)\n        .config(config)\n        .run(\"cfg\");\n</code></pre> <p>Note</p> <p>Config file should not be specified in command itself - builder would add it, if required. But still, it would not be a mistake to use config file directly in command:</p> <pre><code>TestSupport.buildCommandRunner(App.class)\n    // note .config(\"...\") was not used (otherwise two files would appear)!\n    .run(\"cfg\", \"path/to/config.yml\");\n</code></pre> <p>Using builder for config file configuration assumed to be a preferred way.</p>"},{"location":"guide/test/general/command/#listener","title":"Listener","text":"<p>There is a simple listener support (like in application run builder) for setup-cleanup actions:</p> <pre><code>TestSupport.buildCommandRunner(App.class)\n        .listen(new CommandRunBuilder.CommandListener&lt;&gt;() {\n            public void setup(String[] args) { ... }\n            public void cleanup(CommandResult&lt;TestConfiguration&gt; result) { ... }\n        })\n        .run(\"cmd\")\n</code></pre>"},{"location":"guide/test/general/general/","title":"General test tools","text":"<p>Junit 5</p> <p>If you're going to use junit 5, go straight to junit 5 section: all required general tools usage scenarios are described there.</p> <p>Test framework-agnostic tools.  Useful when:</p> <ul> <li>There are no extensions for your test framework</li> <li>Assertions must be performed after test app shutdown (or before startup)</li> <li>Commands testing</li> </ul> <p>Test utils:</p> <ul> <li><code>TestSupport</code> - root utilities class, providing easy access to other helpers</li> <li><code>DropwizardTestSupport</code> - dropwizard native support for full integration tests</li> <li><code>GuiceyTestSupport</code> - guice context-only integration tests (without starting web part)</li> <li><code>CommandTestSupport</code> - general commands tests </li> <li><code>ClientSupport</code> - web client helper (useful for calling application urls)</li> </ul> <p>Important</p> <p><code>TestSupport</code> assumed to be used as a universal shortcut: everything could be created/executed through it so just type <code>TestSupport.</code> and look available methods - no need to remember other classes. </p> <p>Additional features implemented with hooks:</p> <ul> <li>StubsHook - stubs support</li> <li>MocksHook - mocks support</li> <li>SpiesHook - spies support</li> <li>RestStubsHook - lightweight REST testing</li> <li>RecordLogsHook - logs testing</li> <li>TrackersHook - guice bean calls recording and performance testing</li> </ul>"},{"location":"guide/test/general/logs/","title":"Testing logs","text":"<p>Guicey provide <code>RecordLogsHook</code> for capturing logged messages.</p> <p>Important</p> <p>Works only with logback (default dropwizard logger).</p> <p>For example, suppose some service logs some technical hint at some condition:</p> <pre><code>public class Service {\n    private final Logger logger = LoggerFactory.getLogger(Service.class);\n\n    public void foo() {\n        ...\n        if (someCondition) {\n            logger.info(\"Some technical note\");\n        }\n    }\n}\n</code></pre> <p>Testing that technical note actually logged:</p> <pre><code>public class LogsTest {\n\n    @Test\n    public void testLog() {\n        RecordedLogHook hook = new RecordedLogHook();\n        // start recorder registration\n        RecordedLogs logs = hook.record()\n                // listen only for one logger\n                .logger(Service.class)\n                // start recording all logger messages of level INFO and above\n                .start(Level.INFO);\n\n        // run application with hook\n        TestsSupport.build(MyApp.class)\n                .hooks(hook)\n                .runCore(injector -&gt; {\n                    // run method foo (assume log message must appear)\n                    injector.getInstance(Service.class).foo();\n                });\n\n        // one log recorded\n        Assertions.assertEquals(1, logs.count());\n        // log message appears\n        Assertions.assertEquals(1, logs.containing(\"Some technical note\").count());\n        // alternative: last message was a technical hint\n        Assertions.assertEquals(\"Some technical note\", logs.lastMessage());\n    }\n}\n</code></pre> <p>Warning</p> <p>Such tests could not be run in parallel because logger configuration is global</p>"},{"location":"guide/test/general/logs/#registration","title":"Registration","text":"<p>You can register as many recorders as you like. Each recorder could listen one or more loggers.</p> <p>To listen all warnings (root logger):</p> <pre><code>hook.register().start(Level.WARN);\n</code></pre> <p>To listen all loggers in package:</p> <pre><code>hook.register().loggers(\"com.my.package\").start(Level.WARN);\n</code></pre> <p>To listen exact class and package:</p> <pre><code>hook.register()\n        .loggers(SomeClass.class)\n        .loggers(\"com.my.package\")\n        .start(Level.INFO);\n</code></pre>"},{"location":"guide/test/general/logs/#implementation-details","title":"Implementation details","text":"<p>Each recorder registration leads to logging appender registration for a target logger (or multiple loggers).</p> <p>If the current logger configuration is higher than required, then logger would be  re-configured. For example, if default logger level is <code>INFO</code> and recorder requires <code>TRACE</code> messages, then it would change logger configuration to receive required messages.</p> <p>Tip</p> <p>Recorder might be used just to enable required logs, without application  logging configuration. This is very useful in tests (to enable <code>DEBUG</code> or <code>TRACE</code>  messages for exact service (or package)): <code>hook.register().loggers(MyClass.class).start(Level.TRACE)</code></p> <p>During application startup dropwizard resets loggers two times and hook would re-attach appenders to compensate it. You should be able to record all messages from application startup, except logs from dropwizard bundles, registered BEFORE <code>GuiceBundle</code>.</p> <p>If required, actual recorder object is accessible with <code>RecordedLog#getRecorder()</code>: it provides <code>attach()</code> and <code>destroy()</code> methods (for attaching and detaching appender). The hook would call these methods automatically.</p>"},{"location":"guide/test/general/logs/#querying","title":"Querying","text":"<p><code>RecordedLogs</code> used to query recorded logs. Root object always contains all recorded events (for configured loggers).</p> <p>Recorded logs are accessible in form of raw event (<code>ILoggingEvent</code>) or pure string message  (formatted messages with arguments).</p> Method Description Example <code>count()</code> Recorded logs count <code>assertEquals(1, logs.count())</code> <code>empty()</code> Events recorded <code>assertFalse(logs.empty())</code> <code>events()</code> All recorded events <code>List&lt;ILoggingEvent&gt; events = logs.events()</code> <code>messages()</code> Messages of all recorded messages <code>List&lt;String&gt; messages = logs.messages()</code> <code>has(loggerName)</code> Checks if messages from target logger available <code>assertTrue(logs.has(Service.class))</code>, <code>assertTrue(logs.has(\"com.some\"))</code> <code>has(level)</code> Checks if messages of level available <code>assertTrue(logs.has(Level.WARN))</code> <code>lastEvent()</code> Last recorded event or null <code>assertEquals(Level.WARN, logs.lastEvent().getLevel())</code> <code>lastMessage()</code> Message of the last recorded event or null <code>assertEquals(\"Something\", logs.lastMessage())</code> <p>Also, logs could be filtered:</p> Filter Description Example <code>level(level)</code> Select events with level <code>logs.level(Level.WARN)</code> <code>logger(loggerName)</code> Select events of required loggers <code>logs.logger(Service.class)</code>, <code>logs.logger(\"com.some\")</code> <code>containing(String)</code> Events where messages contains provided string <code>logs.containing(\"Substring\")</code> <code>matching(regex)</code> Events where messages match provided regex <code>logs.matching(\"something \\\\d+\")</code> <code>select(predicate)</code> General events matching predicate <code>logs.select(event -&gt; event.getLevel().equals(Level.TRACE))</code> <p>Filters return another matcher object where all verification and filter methods above could be called (multiple filters could be applied consequently).</p> <p>For example, verify count of all messages containing string:</p> <pre><code>assertEquals(1, logs.containing(\"Something\").count());\n</code></pre> <p>Or filtering by logger and level (if recorder records multiple loggers):</p> <pre><code>assertEquals(12, logs.logger(\"com.some.package\").level(Level.WARN).count())\n</code></pre>"},{"location":"guide/test/general/logs/#clear-recordings","title":"Clear recordings","text":"<p>Recorded logs could be cleared at any time (to simplify exact method logs matching):</p> <pre><code>// clear logs, recorded during application startup\nlogs.clear();\n// call method\nservice.foo();\n// verify logs appeared during method call\nassertEquals(1, logs.containing(\"Something\").count());\n\n// clear again to check logs of another method\nlogs.clear();\nservice.boo();\n...\n</code></pre>"},{"location":"guide/test/general/logs/#hook-methods","title":"Hook methods","text":"<p>Logs from all recorders could be cleared with hook:</p> <pre><code>hook.clearLogs()\n</code></pre> <p>To detach all registered appenders:</p> <pre><code>hook.destroy()\n</code></pre> <p>Note</p> <p>Dropwizard resets loggers during startup so manual detach should not be required (to avoid keeping stale appenders between tests).</p>"},{"location":"guide/test/general/mocks/","title":"Testing with mocks","text":"<p>Mockito mocks are essentially an automatic stubs: with the ability to dynamically declare method behavior (by default, all mock methods  return default value: often null). </p> <p>Guicey provides <code>MocksHook</code> for overriding guice beans with mockito mocks.</p> <p>Warning</p> <p>Stubs will not work for HK2 beans     </p> <p>Mockito documentation is written in the <code>Mockito</code> class javadoc. Additional docs could be found in mockito wiki Also, see official mockito refcard and baeldung guides.</p>"},{"location":"guide/test/general/mocks/#setup","title":"Setup","text":"<p>Requires mockito dependency (version may be omitted if dropwizard BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre>"},{"location":"guide/test/general/mocks/#usage","title":"Usage","text":"<p>Remember</p> <ul> <li>Do not mock types you don\u2019t own</li> <li>Don\u2019t mock value objects</li> <li>Don\u2019t mock everything</li> <li>Show love with your tests!</li> </ul> <p>source, explanations</p> <p>For example, suppose we have a service:</p> <pre><code>public class Service {\n    public String foo() {\n        ...\n    }\n}\n</code></pre> <p>where method foo implements some complex logic, not required in test.</p> <p>To override service with a mock:</p> <pre><code>MocksHook hook = new MocksHook();\n// register mock (mock would be created automatically using Mockito.mock(Service.class)\nService mock = hook.mock(Service.class);\n// define method result\nwhen(mock.foo()).thenReturn(\"static value\");\n\nTestsSupport.build(App.class)\n        .hooks(hook)\n        .runCore(injector -&gt; {\n            Service service = injector.getInstance(Service.class);\n\n            // mock instance instead of service\n            Assertions.assertEquals(mock, service);\n            // method overridden            \n            Assertions.assertEquals(\"static value\", service.foo());\n        });\n</code></pre> <p>Here <code>when</code> refer to <code>Mockito.when()</code> used with static import.</p> <p>Important</p> <p>Guice AOP would not be applied to mocks (only guice-managed beans support AOP)</p> <p>You can also provide a pre-created mock instance (this does not make much sence, but possible):</p> <pre><code>hook.mock(Service.class, mockInstance);\n</code></pre>"},{"location":"guide/test/general/mocks/#mocking-examples","title":"Mocking examples","text":"<p>Mocking answers for different arguments:</p> <pre><code>when(mock.foo(10)).thenReturn(100);\nwhen(mock.foo(20)).thenReturn(200);\nwhen(mock.foo(30)).thenReturn(300);\n</code></pre> <p>Different method answers (for consequent calls):</p> <pre><code>when(mock.foo(anyInt())).thenReturn(10, 20, 30);\n</code></pre> <p>Using actual argument in mock:</p> <pre><code> when(mock.getValue(anyInt())).thenAnswer(invocation -&gt; {\n        int argument = (int) invocation.getArguments()[0];\n        int result;\n        switch (argument) {\n        case 10:\n            result = 100;\n            break;\n        case 20:\n            result = 200;\n            break;\n        case 30:\n            result = 300;\n            break;\n        default:\n            result = 0;\n        }\n        return result;\n    });\n</code></pre>"},{"location":"guide/test/general/mocks/#asserting-calls","title":"Asserting calls","text":"<p>Mock could also be used for calls verification:</p> <pre><code>// method Service.foo() called on mock just once\nverify(mock, times(1)).foo();\n// method Service.bar(12) called just once (with exact argument value)\nverify(mock, times(1)).bar(12);\n</code></pre> <p>These assertions would fail if method was called more times or using different arguments.</p>"},{"location":"guide/test/general/mocks/#mock-reset","title":"Mock reset","text":"<p>If you run multiple tests with the same application, then it makes sense to re-configure mocks for each test and so the previous mock state must be reset.</p> <p>Use <code>hook.resetMocks()</code> to reset all registered mocks</p>"},{"location":"guide/test/general/mocks/#partial-mocks","title":"Partial mocks","text":"<p>If mock is applied for a class with implemented methods, these methods would still be overridden with fake implementations. If you want to preserve this logic, then use spies:</p> <pre><code>public class AbstractService implements IService {\n    public abstract String bar();\n\n    public String foo() {\n        return \"value\";\n    }\n}\n\nAbstractService mock = Mockito.spy(AbstractService.class);\nhook.mock(IService.class, mock);\n\n\nIService service = injector.getInstance(IService.class);\n// default mock implementation for abstract method\nAssertions.assertNull(service.bar());\n// implemented method preserved\nAssertions.assertEquals(\"value\", service.foo());\n</code></pre> <p>Note</p> <p>The spies section covers only spies, spying on real guice bean instance. Using spies for partial mocks is more related to pure mocking and so it's described here.</p>"},{"location":"guide/test/general/mocks/#accessing-mock","title":"Accessing mock","text":"<p>Mock instance (used to configure methods behavior) could be obtained:</p> <ol> <li>On registration (<code>Service mock = hook.mock(Service.class)</code>)</li> <li>From guice injector: <code>Service mock = injector.getInstance(Service.class)</code>    (as hook is registered by instance, guice AOP could not be applied for it and so it     would always be a raw mock)</li> <li>From hook: <code>Service mock = hook.getMock(Service.class)</code></li> </ol>"},{"location":"guide/test/general/mocks/#mocking-openapi-client","title":"Mocking OpenAPI client","text":"<p>If you use some external API with a client, generated from openapi (swagger) declaration, then you should be using it in code like this:</p> <pre><code>@Inject\nSomeApi api;\n\npublic void foo() {\n    Some response = api.someGetCall(...)\n}\n</code></pre> <p>Where <code>SomeApi</code> is a generated client class.</p> <p>Usually, the simplest way is to record real service response (using swagger UI or other generated documentation) or simply enabling client debug in the application (so all requests and responses would be logged).</p> <p>Store such responses as json files in test resources: e.g. <code>src/test/resources/responses/someGet.json</code></p> <p>Now mocking <code>SomeApi</code> and configure it to return object, mapped from json file content, instead of the real call:</p> <pre><code>MocksHook hook = new MocksHook();\nService mock = hook.mock(SomeApi.class);\nObjectMapper mapper = new ObjectMapper();\n// define method result\nwhen(mock.someGetCall(...)).thenReturn(mapper.readValue(\n        new File(\"src/test/resources/responses/someGet.json\"), Some.class));\n</code></pre> <p>With it, object, mapped from json file, would be returned on service call, instead of the real api.</p> <p>Note</p> <p>In the example, direct file access used instead of classpath lookup because IDEA by default does not copy <code>.json</code> resources (it must be additionally configured) and so direct file access is more universal.</p>"},{"location":"guide/test/general/output/","title":"Testing console output","text":"<p>There is a utility to capture console output:</p> <pre><code>String out = TestSupport.captureOutput(() -&gt; {\n\n    // run application inside\n    TestSupport.runWebApp(App.class, injector -&gt; {\n        ClientSupport client = TestSupport.getContextClient();\n\n        // call application api endpoint\n        client.get(\"sample/get\", null);\n\n        return null;\n    });\n});\n\n// uses assert4j, test that client was called (just an example) \nAssertions.assertThat(out)\n    .contains(\"[Client action]---------------------------------------------{\");\n</code></pre> <p>Returned output contains both <code>System.out</code> and <code>System.err</code> - same as it would be seen in console.</p> <p>All output is also printed into console to simplify visual validation</p> <p>Warning</p> <p>Such tests could not be run in parallel (due to system io overrides)</p>"},{"location":"guide/test/general/rest/","title":"Testing REST","text":"<p>Guicey provides lightweight REST testing support: same as dropwizard resource testing support, but with guicey-specific features.</p> <p>Such tests would not start web container: all rest calls are simulated (but still, it tests every part of resource execution).</p> <p>Important</p> <p>Rest stubs work only with lightweight guicey run (they are simply useless when web container started)</p> <p>Lightweight REST could be started with <code>RestStubsRunner</code> hook:</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .disableDropwizardExceptionMappers(true)\n        .build();\n\nTestSupport.build(App.class)\n        .hooks(restHook)\n        .runCore(injector -&gt; {\n            // pre-configured client to call resources with relative paths\n            RestClient rest = restHook.getRestClient();\n\n            String res = rest.get(\"/foo\", String.class);\n            Assertions.assertEquals(\"something\", res);\n\n            WebApplicationException ex = Assertions.assertThrows(WebApplicationException.class,\n                () -&gt; rest.get(\"/error\", String.class));\n                Assertions.assertEquals(\"error message\", ex.getResponse().readEntity(String.class));\n        });\n</code></pre> <p>Note</p> <p>Extension naming is not quite correct: it is not a stub, but real application resources are used. The word \"stub\" used to highlight the fact of incomplete startup: only rest without web.</p> <p>By default, all declared resources would be started with all existing jersey extensions (filters, exception mappers, etc.). Servlets and http filters are not started (guicey disables all web extensions to avoid their (confusing) appearance in console)</p>"},{"location":"guide/test/general/rest/#selecting-resources","title":"Selecting resources","text":"<p>Real tests usually require just one resource (to be tested):</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .resources(MyResource.class)\n        .build();\n</code></pre> <p>This way only one resource would be started (and all resources directly registered in application, not as guicey extension). All jersey extensions will remain.</p> <p>Or a couple of resources:</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .resources(MyResource.class, MyResource2.class)\n        .build();\n</code></pre> <p>Or you may disable some resources:</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .disableResources(MyResource2.class, MyResource3.class)\n        .build();\n</code></pre>"},{"location":"guide/test/general/rest/#disabling-jersey-extensions","title":"Disabling jersey extensions","text":"<p>Often jersey extensions, required for the final application, make complications for testing.</p> <p>For example, exception mapper: dropwizard register default exception mapper which returns only the error message, instead of actual exception (and so sometimes we can't check the real cause).</p> <p><code>.disableDropwizardExceptionMappers(true)</code> disables extensions, registered by dropwizard.</p> <p>When default exception mapper enabled, resource throwing runtime error would return just error code:</p> <pre><code>@Path(\"/some/\")\n@Produces(\"application/json\")\npublic class ErrorResource {\n\n    @GET\n    @Path(\"/error\")\n    public String get() {\n        throw new IllegalStateException(\"error\");\n    }\n}    \n</code></pre> <pre><code>WebApplicationException ex = Assertions.assertThrows(WebApplicationException.class,\n        () -&gt; rest.get(\"/some/error\", String.class));\n\n// exception hidden, only generic error code\nAssertions.assertTrue(ex.getResponse().readEntity(String.class)\n        .startsWith(\"{\\\"code\\\":500,\\\"message\\\":\\\"There was an error processing your request. It has been logged\"));\n</code></pre> <p>Without dropwizard exception mapper, we can verify exact exception:</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .disableDropwizardExceptionMappers(true)\n        .build();\n\n...\n\nProcessingException ex = Assertions.assertThrows(ProcessingException.class,\n        () -&gt; rest.get(\"/error\", String.class));\n// exception available\nAssertions.assertTrue(ex.getCause() instanceof IllegalStateException);\n</code></pre> <p>It might be useful to disable application extensions also with <code>.disableAllJerseyExtensions(true)</code>:</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .disableDropwizardExceptionMappers(true)\n        .disableAllJerseyExtensions(true)\n        .build();\n</code></pre> <p>This way raw resource would be called without any additional logic.</p> <p>Note</p> <p>Only extensions, managed by guicey could be disabled: extensions directly registered in dropwizard would remain.</p> <p>Also, you can select exact extensions to use (e.g., to test it):</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .jerseyExtensions(CustomExceptionMapper.class)\n        .build();\n</code></pre> <p>Or disable only some extensions (for example, disabling extension implementing security):</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .disableJerseyExtensions(CustomSecurityFilter.class)\n        .build();\n</code></pre>"},{"location":"guide/test/general/rest/#requests-logging","title":"Requests logging","text":"<p>By default, rest client would log requests and responses, </p> <pre><code>String res = rest.get(\"/foo\", String.class);\nAssertions.assertEquals(\"something\", res);\n</code></pre> <pre><code>[Client action]---------------------------------------------{\n1 * Sending client request on thread main\n1 &gt; GET http://localhost:0/foo\n\n}----------------------------------------------------------\n\n\n[Client action]---------------------------------------------{\n1 * Client response received on thread main\n1 &lt; 200\n1 &lt; Content-Length: 3\n1 &lt; Content-Type: application/json\nsomething\n\n}----------------------------------------------------------\n</code></pre> <p>Logging could be disabled with <code>.logRequests(false)</code>:</p> <pre><code>final RestStubsRunner restHook = RestStubsRunner.builder()\n        .logRequests(false)\n        .build();\n</code></pre>"},{"location":"guide/test/general/rest/#container","title":"Container","text":"<p>By default, InMemoryTestContainerFactory used.</p> <pre><code>In-Memory container is not a real container. It starts Jersey application and \ndirectly calls internal APIs to handle request created by client provided by \ntest framework. There is no network communication involved. This containers \ndoes not support servlet and other container dependent features, but it is a \nperfect choice for simple unit tests.\n</code></pre> <p>If it is not enough (in-memory container does not support all functions), then use <code>GrizzlyTestContainerFactory</code></p> <pre><code>The GrizzlyTestContainerFactory creates a container that can run as a light-weight, \nplain HTTP container. Almost all Jersey tests are using Grizzly HTTP test container \nfactory.\n</code></pre> <p>To activate grizzly container add dependency (version managed by dropwizard BOM):</p> <pre><code>testImplementation 'org.glassfish.jersey.test-framework.providers:jersey-test-framework-provider-grizzly2'\n</code></pre> <p>By default, grizzly would be used if it's available on classpath, otherwise in-memory used. If you need to force any container type use:</p> <pre><code>// use in-memory container, even if grizly available in classpath\n// (use to force more lightweight container, even if some tests require grizzly)\n.container(TestContainerPolicy.IN_MEMORY)\n</code></pre> <pre><code>// throw error if grizzly container not available in classpath\n// (use to avoid accidental in-memory use)\n.container(TestContainerPolicy.GRIZZLY)\n</code></pre>"},{"location":"guide/test/general/rest/#rest-client","title":"Rest client","text":"<p><code>RestClient</code> is almost the same as ClientSupport, available for guicey extensions. It is just limited only for rest (and so simpler to use).</p> <p>Note</p> <p>Just in case: <code>ClientSupport</code> would not work with rest stubs (because web container is actually  not started and so <code>ClientSupport</code> can't recognize a correct rest mapping path). Of course, it could be used with a full URLs.</p> <p>Client provides base methods with response mapping:</p> <pre><code>RestClient rest = restHook.getRestClient();\n</code></pre> <ul> <li><code>rest.get(path, Class)</code></li> <li><code>rest.post(path, Object/Entity, Class)</code></li> <li><code>rest.put(path, Object/Entity, Class)</code></li> <li><code>rest.delete(path, Class)</code></li> </ul> <p>To not overload default methods with parameters, additional data could be set with defaults:</p> <ul> <li><code>rest.defaultHeader(String, String)</code></li> <li><code>rest.defaultQueryParam(String, String)</code></li> <li><code>rest.defaultAccept(String...)</code></li> <li><code>rest.defaultOk(Integer...)</code></li> </ul> <p><code>defaultOk</code> used for void responses (response class == null) to check correct response status (default 200 (OK) and 204 (NO_CONTENT)).</p> <p>So if we need to perform a post request with query param and custom header:</p> <pre><code>rest.defaultHeader(\"Secret\", \"unreadable\")\n    .defaultQueryParam(\"foo\", \"bar\");\nOtherModel res = rest.post(\"/somehere\", new SomeModel(), OtherModel.class);\n</code></pre> <p>Note</p> <p>Multipart support is enabled automatically when dropwizard-forms available in classpath</p> <pre><code>FormDataMultiPart multiPart = new FormDataMultiPart();\nmultiPart.setMediaType(MediaType.MULTIPART_FORM_DATA_TYPE);\n\nFileDataBodyPart fileDataBodyPart = new FileDataBodyPart(\"file\",\n        file.toFile(),\n        MediaType.APPLICATION_OCTET_STREAM_TYPE);\nmultiPart.bodyPart(fileDataBodyPart);\n\nrest.post(path, Entity.entity(multiPart, multiPart.getMediaType()), Something.class);\n</code></pre> <p>To clear defaults:</p> <pre><code>rest.reset() \n</code></pre> <p>Might be a part of call chain:</p> <pre><code>rest.reset().post(...) \n</code></pre> <p>When test needs to verify cookies, response headers, etc. use <code>.request(path)</code>:</p> <pre><code>Response response = rest.request(path).get() // .post(), .put(), .delete();\n</code></pre> <p>All defaults are also applied in this case.</p> <p>To avoid applying configured defaults, raw <code>rest.target(path)...</code> could be used.</p>"},{"location":"guide/test/general/run/","title":"Testing application","text":"<p>Application could be started in 2 ways:</p> <ol> <li>Core - create only guice injector (without starting web services) - ideal for business logic testing (pretty fast)</li> <li>Web - full application start to test web endpoints (and complete flows)</li> </ol> <p>The second case is handled by DropwizardTestSupport and the first one by <code>GuiceyTestSupport</code> object (extending <code>DropwizardTestSupport</code>).</p> <p>There is a generic builder to simplify work with these objects (provides all possible configuration options):</p> <pre><code>RunResult result = TestSupport.build(App.class)\n        .config(\"src/test/resources/path/to/test/config.yml\")\n        .configOverrides(\"foo: 2\", \"bar: 12\")\n        .hooks(new MyHook())\n        // run lightweight application (without web services)\n        .runCore()\n</code></pre> <p>Tip</p> <p><code>RunResult</code> contains both <code>DropwizardTestSupport</code> used for execution and <code>Injector</code> instance. In other words, everything required for performing assertions.</p> <p>or with action:</p> <pre><code>Object serviceValue = TestSupport.build(App.class)\n        .config(\"src/test/resources/path/to/test/config.yml\")\n        .configOverrides(\"foo: 2\", \"bar: 12\")\n        .hooks(new MyHook())\n        // run full application\n        .runWeb(injector -&gt; {\n            return injector.getInstance(FooService.class).getSomething();\n        })\n</code></pre> <p>Note</p> <p>Builder methods are almost equal to junit 5 extension builder</p> <p>Important</p> <p>All run methods declared as <code>throws Exception</code>. This was done to bypass original exceptions instead of wrapping them inside runtime exceptions.</p> <p>This should not be a problem: just add <code>throws Exception</code> into test method signature </p>"},{"location":"guide/test/general/run/#configuration","title":"Configuration","text":"<p>Configuration could be applied in a different ways:</p> <pre><code>// with override values only\nTestSupport.build(App.class)\n        .configOverride(\"foo: 12\")\n\n// file with overrides\nTestSupport.build(App.class)\n        .config(\"src/test/resources/path/to/config.yml\")\n        .configOverride(\"foo: 12\")\n\n// file with config modifier\nTestSupport.build(App.class)\n        .config(\"src/test/resources/path/to/config.yml\")\n        .configModifiers(config -&gt; config.setFoo(12))    \n\n// direct config object \nMyConfig config = new MyConfig();         \nTestSupport.build(App.class)\n        .config(config)\n</code></pre> <p>Note</p> <p>Config override (<code>.configOverride()</code>) mechanism is provided by dropwizard: values are stored as system properties and applied in time of configuration parsing. It might not work for some properties (like collections) and it can't be used with manual configuration (last example).</p> <p>Config modifier (<code>.configModifiers()</code>) is a guicey concept: it could be used with either  configuration file or manual configuration object. It was added to simplify config modifications and overcome limitations of config override. The only downside: when configuration is parsed from file, modifier called after logging configuration, so to modify logging only config overrides could be used.</p> <p>Also, configuration source provider could be modified:</p> <pre><code>TestSupport.build(App.class)\n        .config(\"path/in/classpath/config.yml\")\n        .configSourceProvider(new ResourceConfigurationSourceProvider())\n</code></pre> <p>There are also configuration shortcuts:</p> <pre><code>TestSupport.build(App.class)\n        .randomPorts()\n        .restMapping(\"api\")\n</code></pre> <p>To randomize used application ports (overrides config file values) and apply a different rest mapping path.</p> <p>When config overrides are used, they are always stored as system properties. This could be a problem for parallel tests execution. To overcome this, test-unique prefixes could be used:</p> <pre><code>TestSupport.build(App.class)\n        .configOverride(\"foo\", \"1\")\n        .propertyPrefix(\"something\")\n</code></pre> <p>Junit 5 extensions use test class (and sometimes method) name to generate unique prefixes.</p>"},{"location":"guide/test/general/run/#lifecycle-listeners","title":"Lifecycle listeners","text":"<p>Builder also support listeners registration in order to simulate setup/cleanup lifecycle methods, common for test frameworks:</p> <pre><code>TestSupport.build(App.class)\n        .listen(new TestSupportBuilder.TestListener&lt;&gt;() {\n            public void setup(final DropwizardTestSupport&lt;C&gt; support) throws Exception {\n                // do before test\n            }\n            ...\n        })\n        .runCore();\n</code></pre> <p>All listener methods are default so only required methods could be overridden.</p> <p>Warning</p> <p>Builder could be used for support objects creation (<code>buildCore()</code>, <code>buildWeb()</code>) - in this case listeners could not be used (only builder runner could properly process listeners).</p>"},{"location":"guide/test/general/run/#shortcuts","title":"Shortcuts","text":"<p>For simple cases, there are many builder shortcuts in <code>TestSupport</code> class.</p> <p>Support object construction:</p> <pre><code>DropTestSupport support = TestSupport.webApp(App.class, \n        \"path/to/config.yml\", \"prop: 1\", \"prop2: 2\");\n\nGuiceyTestSupport support = TestSupport.coreApp(App.class,\n        \"path/to/config.yml\", \"prop: 1\", \"prop2: 2\"); \n</code></pre> <p>Run:</p> <pre><code>RunResult result = TestSupport.runWebApp(App.class);\n\nRunResult result = TestSupport.runWebApp(App.class,\n        \"path/to/config.yml\", \"prop: 1\", \"prop2: 2\");\n\nObject value = TestSupport.runWebApp(App.class, injector - &gt; {\n            return injector.getInstance(Service.class).getSmth();\n        });\n\nObject value = TestSupport.runWebApp(App.class,\n        \"path/to/config.yml\", injector - &gt; {\n        return injector.getInstance(Service.class).getSmth();\n        }, \"prop: 1\", \"prop2: 2\");\n\n// ... and same methods for \"coreApp\"\n</code></pre> <p>All these methods are builder shortcuts (suitable for simple cases).</p> <p>Tip</p> <p>Context <code>DropwizardTestSupport</code> and <code>ClientSupport</code> objects could be statically referenced inside callback:</p> <pre><code>TestSupport.runWebApp(App.class, injector - &gt; {\n    DropwizardTestSupport support = TestSupport.getContext();\n    ClientSupport client = TestSupport.getContextClient();\n    return null;\n});\n</code></pre>"},{"location":"guide/test/general/run/#asserting-execution","title":"Asserting execution","text":"<p>To assert configuration or any guicey bean it would be enough to use run without callback:</p> <pre><code>RunResult&lt;CfgType&gt; result = TestSupport.build(App.class).runCore();\n\n// direct configuratio instance\nAssertions.assertEquals(12, result.getConfiguration().getProp1());\n// any guice bean \nAssertions.assertEquals(12, result.getBean(Configuration.class).getProp1());\nAssertions.assertNotNull(result.getEnvironment());\nAssertions.assertNotNull(result.getApplication());\n</code></pre> <p>Web-related assertions could be done inside callback:</p> <pre><code>SomeRsponseObject res = TestSupport.build(App.class).runWeb(injecor -&gt; {\n            ClientSupport client = TestSupport.getContextClient()\n            return client.get(\"some\", SomeRsponseObject.class);\n        });\n\nAssertions.assertEquals(\"something\", res.getField1())\n</code></pre> <p>Or multiple assertions could be done directly inside callback.</p>"},{"location":"guide/test/general/run/#managed-lifecycle","title":"Managed lifecycle","text":"<p>Core tests (without web part) simulate <code>Managed</code> objects lifecycle (because often core logic rely on pre-initializations).</p> <p>If managed lifecycle is note required for test, it could be disabled with alternative run method:</p> <pre><code>TestSupport.build(App.class).runCoreWithoutManaged(..)\n</code></pre> <p>On raw test support object: <code>new GuiceyTestSupport().disableManagedLifecycle()</code></p>"},{"location":"guide/test/general/run/#raw-test-support-objects","title":"Raw test support objects","text":"<p>It may be required to use <code>DropwizardTestSupport</code> objects directly: for example, when before() and after() calls must be performed in different methods (some test framework integration).</p> <p>Objects could be created with builder:</p> <pre><code>GuiceyTestSupport core = TestSupport.build(App.class)\n        .buildCore();\n\nDropwizardTestSupport web = TestSupport.build(App.class)\n        .buildWeb();\n</code></pre> <p>Note</p> <p><code>GuiceyTestSupport extends DropwizardTestSupport</code>, so in both cases <code>DropwizardTestSupport</code> could be used as type.</p> <p>There are also shortcut methods:</p> <pre><code>DropwizardTestSupport supportCore = TestSupport.coreApp(App.class,\n        \"path/to/config.yml\", \n        \"prop: 1\", \"prop2: 2\");\n\nDropwizardTestSupport supportWeb = TestSupport.webApp(App.class,\n        \"path/to/config.yml\",\n        \"prop: 1\", \"prop2: 2\");\n</code></pre> <p>Support object usage:</p> <pre><code>support.before()\n\n// test\n\nsupport.after()\n</code></pre> <p>This is equivalent to:</p> <pre><code>TestSupport.run(support, injector -&gt; {\n    // test\n});\n</code></pre> <p>Other helper methods for support object (executed while the support object is active):</p> <ul> <li><code>TestSupport.getInjector(support)</code> - obtain application injector</li> <li><code>TestSupport.getBean(support, Key/Class)</code> - get guice bean</li> <li><code>TestSupport.injectBeans(support, target)</code> - inject annotated object fields</li> <li><code>TestSupport.webClient(support)</code> - construct <code>ClientSupport</code> object</li> </ul> <p>Support object provides references for dropwizard objects:</p> <pre><code>support.getEnvironment();\nsupport.getConfiguration();\nsupport.getApplication();\n</code></pre> <p>Complete example using junit:</p> <pre><code>public class RawTest {\n\n    static DropwizardTestSupport support;\n\n    @Inject MyService service;\n\n    @BeforeAll\n    public static void setup() {\n        support = TestSupport.coreApp(App.class);\n        // support = TestSupport.webApp(App.class);\n        // start app\n        support.before();\n    }\n\n    @BeforeEach\n    public void before() {\n        // inject services in test\n        TestSupport.injectBeans(support, this);\n    }\n\n    @AfterAll\n    public static void cleanup() {\n        if (support != null) {\n            support.after();\n        }\n    }\n\n    @Test\n    public void test() {\n        Assertions.assertEquals(\"10\", service.computeValue());\n    }\n}\n</code></pre> <p>Note</p> <p><code>support.before()</code> would automatically call <code>after()</code> in case of startup error</p>"},{"location":"guide/test/general/spies/","title":"Testing with spies","text":"<p>Mockito spies allows dynamic modification of real objects behavior (configured same as mocks, but, by default, all methods work as in raw bean).</p> <p>Guicey provides <code>SpiesHook</code> for overriding guice beans with mockito spies.</p> <p>Important</p> <p>Spy creation requires real bean instance and so guicey use AOP to intercept real bean access and redirecting all calls through a dynamically created (on first access) spy object. This means that spies would only work with guice-managed beans.</p> <p>If you need to spy for a manual instance - use partial mocks</p> <p>Warning</p> <p>Spies will not work for HK2 beans</p> <p>Mockito documentation is written in the <code>Mockito</code> class javadoc. Additional docs could be found in mockito wiki Also, see official mockito refcard and baeldung guides.</p>"},{"location":"guide/test/general/spies/#setup","title":"Setup","text":"<p>Requires mockito dependency (version may be omitted if dropwizard BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre>"},{"location":"guide/test/general/spies/#usage","title":"Usage","text":"<p>Suppose we have a service:</p> <pre><code>public static class Service {\n\n    public String get(int id) {\n        return \"Hello \" + id;\n    }\n}\n</code></pre> <p>Spying it:</p> <pre><code>SpiesHook hook = new SpiesHook();\n// real spy could be created ONLY after injector startup\nfinal SpyProxy proxy = hook.spy(Service.class);\n// SpyProxy implements provider and so could be also used as: \n// Provider&lt;Service&gt; provider = hook.spy(Service.class)\n\nTestSupport.build(App.class)\n        .hooks(hook)\n        .runCore(injector -&gt; {\n            // get spy object for configuration\n            Service spy = proxy.getSpy();\n            // IMPORTANT: spies configured in reverse order to avoid accidental method call            \n            doReturn(\"bar1\").when(spy).get(11);\n\n            // real instance, injected everywhere in application (AOP proxy)\n            Service service = injector.getInstance(Service.class);\n            // stubbed result\n            Assertions.assertEquals(\"bar1\", s1.get(11));\n            // real method result (because argument is different)\n            Assertions.assertEquals(\"Hello 10\", s1.get(10));\n        })\n</code></pre> <p>Here <code>doReturn</code> refer to <code>Mockito.doReturn</code> used with static import.</p> <p>Note</p> <p>As real guice bean used under the hood, all AOP, applied to the original bean, will work.</p> <p>Tip</p> <p>Calling guice proxy <code>injector.getInstance(Service.class).get(11)</code> and spy object directly <code>spy.get(11)</code> is equivalent (because guice returns AOP proxy which redirects call to the spy)</p> <p>See other examples in mocks section.</p>"},{"location":"guide/test/general/spies/#asserting-calls","title":"Asserting calls","text":"<p>Tip</p> <p>If you want to use spies to track bean access (verify arguments and response) then try trackers which are better match for this case.</p> <p>As mocks, spies could be used to assert calls:</p> <pre><code>// method Service.get(11) called on mock just once\nverify(spy, times(1)).get(11);\n</code></pre> <p>These assertions would fail if method was called more times or using different arguments.</p>"},{"location":"guide/test/general/spies/#method-result-capture","title":"Method result capture","text":"<p>Verifying method return value with spies is a bit clumsy:</p> <pre><code>public static class ResultCaptor&lt;T&gt; implements Answer {\n    private T result = null;\n    public T getResult() {\n        return result;\n    }\n\n    @Override\n    public T answer(InvocationOnMock invocationOnMock) throws Throwable {\n        result = (T) invocationOnMock.callRealMethod();\n        return result;\n    }\n}\n\nResultCaptor&lt;String&gt; resultCaptor = new ResultCaptor&lt;&gt;();\n// capture actual argument value (just to show how to do it)\nArgumentCaptor&lt;Integer&gt; argumentCaptor = ArgumentCaptor.forClass(Integer.class);\nMockito.doAnswer(resultCaptor).when(spy).get(argumentCaptor.capture());\n\n// call method\nAssertions.assertThat(spy.get(11)).isEqualTo(\"bar\");\n// result captured\nAssertions.assertThat(resultCaptor.getResult()).isEqualTo(\"bar\");\nAssertions.assertThat(argumentCaptor.getValue()).isEqualTo(11);\n\nMockito.verify(spy, Mockito.times(1)).get(11);\n</code></pre> <p>Why would you need that? It is often useful when verifying indirect bean call. For example, if we have <code>SuperService</code> which internally calls <code>Service</code> and so  there is no other way to verify service call result correctness other than spying it (or use tracker).</p>"},{"location":"guide/test/general/spies/#pre-initialization","title":"Pre initialization","text":"<p>As spy object creation is delayed until application startup, it is impossible to configure spy before application startup (as with mocks). Usually it is not a problem, if target bean is not called during startup.</p> <p>If you need to modify behavior of spy, used during application startup (e.g. by some <code>Managed</code>), then there is a delayed initialization mechanism:</p> <pre><code>SpiesHook hook = new SpiesHook();\n// real spy could be created ONLY after injector startup\nfinal SpyProxy proxy = hook.spy(Service.class)\n        .withInitializer(service -&gt; doReturn(\"spied\").when(service).get(11));\n...\n</code></pre> <p>Here, configuration from <code>withInitializer</code> block would be called just after  spy creation (on first access).</p> <p>And so any <code>Managed</code>, calling it during startup would use completely configured spy:</p> <pre><code>@Singleton\npublic static class Mng implements Managed {\n    @Inject\n    Service service;\n\n    @Override\n    public void start() throws Exception {\n        // \"spied\" result\n        service1.get(11);\n    }\n}\n</code></pre>"},{"location":"guide/test/general/spies/#spies-reset","title":"Spies reset","text":"<p>If you run multiple tests with the same application, then it makes sense to re-configure spies for each test and so the previous spy state must be reset.</p> <p>Use <code>hook.resetSpies()</code> to reset all registered mocks</p>"},{"location":"guide/test/general/spies/#accessing-spy","title":"Accessing spy","text":"<p>Spy instance (used to configure methods behavior) could be obtained:</p> <ol> <li>After application startup:     <pre><code>SpyProxy proxy = hook.spy(Service.class);\n// after app startup  \nService spy = proxy.getSpy();\n</code></pre></li> <li>From hook: <code>Service spy = hook.getSpy(Service.class)</code></li> </ol>"},{"location":"guide/test/general/startup/","title":"Testing startup fails","text":"<p>Command runner could also be used for application startup fail tests:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .run(\"server\")\n</code></pre> <p>or with the shortcut:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .runApp()\n</code></pre> <p>Important</p> <p>In case of application successful start, special check would immediately stop it by throwing exception (resulting object would contain it), so such test would never freeze.</p> <p>Why not run directly?</p> <p>You can run command directly: <code>new App().run(\"server\")</code> But, if application throws exception in run phase, <code>System.exit(1)</code> would be called:</p> <p><pre><code>public abstract class Application&lt;T extends Configuration&gt; {\n    ...\n    protected void onFatalError(Throwable t) {\n        System.exit(1);\n    }\n}\n</code></pre> Commands runner runs commands directly so exit would not be called. </p>"},{"location":"guide/test/general/stubs/","title":"Testing with stubs","text":"<p>Stubs are hand-made replacements of real application services (\"manual\" or \"lazy\" mocks).</p> <p>Guicey provides <code>StubsHook</code> for overriding guice beans with stub implementations.</p> <p>Warning</p> <p>Stubs will not work for HK2 beans </p> <p>There are two main cases:</p> <ol> <li>Stub class extends existing service: <code>class ServiceStub extends Service</code></li> <li>Stub implements service interface: <code>class ServiceStub implements IService</code></li> </ol> <p>Stubs replace real application services (using guice overriding modules), so stub would be injected in all services instead of the real service.</p> <p>For example, suppose we have a service:</p> <pre><code>public class Service {\n    public String foo() {\n        ...\n    }\n}\n</code></pre> <p>where method foo implements some complex logic, not required in test.</p> <p>Writing stub:</p> <pre><code>public class ServiceStub extends Service {\n    @Override\n    public String foo() {\n        return \"static value\";\n    }\n}\n</code></pre> <p>Using stub in test:</p> <pre><code>StubsHook hook = new StubsHook();\n// register stub (stub instance managed with guice)\nhook.stub(Service.class, ServiceStub.class);\n\nTestsSupport.build(App.class)\n        .hooks(hook)\n        .runCore(injector -&gt; {\n            Service service = injector.getInstance(Service.class);\n            // service is a stub\n            Assertions.assertInstanceOf(ServiceStub.class, service);\n            Assertions.assertEquals(\"static value\", service.foo());\n        });\n</code></pre> <p>Info</p> <p>In many cases, mockito mocks and spies could be more useful, but stubs are simpler (easier to understand, especially comparing to spies).</p> <p>In the example above, stub instance is created by guice. Stub could also be registered by instance:</p> <pre><code>hook.stub(Service.class, new ServiceStub());\n</code></pre> <p>In this case, stub's <code>@Inject</code> fields would be processed (<code>requestInjection(stub)</code> would be called).</p> <p>Note</p> <p>Guice AOP would apply only for stubs registered with class. So stub instance could be used (instead of class) exactly to avoid additional AOP logic for service.</p>"},{"location":"guide/test/general/stubs/#stub-lifecycle","title":"Stub lifecycle","text":"<p>More complex stubs may contain a test-related internal state, which must be cleared between tests.</p> <p>In this case, stub could implement <code>StubLifecycle</code>:</p> <pre><code>public class ServiceStub extends Service implements StubLifecycle {\n    int calls;\n\n    @Override \n    public void before() {\n        calls = 0; \n    }\n\n    @Override\n    public void after() {\n        calls = 0;\n    }\n}\n</code></pre> <p>(both methods optional)</p> <p>Then we can call these methods with hook:</p> <pre><code>// call before() on all stubs\nhook.before();\n// test staff here\n// call after after test\nhook.after();\n</code></pre>"},{"location":"guide/test/general/stubs/#stub-instance","title":"Stub instance","text":"<p>Stub instance could be obtained either from injector (using overridden service as a key):</p> <pre><code>ServiceStub stub = (ServiceStub) injector.getInstance(Service.class);\n</code></pre> <p>or directly from hook:</p> <pre><code>ServiceStub stub = hook.getStub(Service.class);\n</code></pre>"},{"location":"guide/test/general/tracks/","title":"Testing performance (bean tracking)","text":"<p>Tracker records guice bean methods execution:</p> <ol> <li>Collect method call arguments and result for each call</li> <li>Log slow methods execution</li> <li>Collect metrics to show overall methods performance (stats)</li> </ol> <p>Warning</p> <p>Trackers will not work for HK2 beans and for non guice-managed beans (bound by instance)</p> <p>Note</p> <p>Initially, trackers were added as a simpler alternative for mockito spy's clumsy result capturing. But, eventually, it evolved into a simple performance tracking tool (very raw, of course, but in many cases it would be enough).</p>"},{"location":"guide/test/general/tracks/#setup","title":"Setup","text":"<p>Not strictly required, but trackers provide type-safe search api using mockito, and so you'll need mockito dependency only if you wish to use this api (version may be omitted if dropwizard BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre>"},{"location":"guide/test/general/tracks/#usage","title":"Usage","text":"<p>Suppose we have a service:</p> <pre><code>public static class Service {\n\n    public String get(int id) {\n        return \"Hello \" + id;\n    }\n}\n</code></pre> <p>And we want to very indirect service call (when service called by some other service):</p> <pre><code>TrackersHook hook = TrackersHook();\nfinal Tracker&lt;Service&gt; tracker = hook.track(Service.class)\n        .trace(true)\n        .add();\nTestSupport.build(DefaultTestApp .class)\n        .hooks(hook)\n        .runCore(injector -&gt;{\n            Service service = injector.getInstance(Service.class);\n\n            // call service\n            Assertions.assertEquals(\"Hello 11\",service.get(11));\n\n            MethodTrack track = tracker.getLastTrack();\n            Assertions.assertTrue(track.toString().contains(\"get(11) = \\\"Hello 11\\\"\"));\n            // object arguments\n            Assertions.assertArrayEquals(new Object[] {11},track.getRawArguments());\n            // arguments in string form\n            Assertions.assertArrayEquals(new String[] {\"11\"},track.getArguments());\n            // raw result\n            Assertions.assertEquals(\"1 call\",track.getRawResult());\n            // result in string form\n            Assertions.assertEquals(\"1 call\",track.getResult());\n        });\n</code></pre> <p>In this example, trace was enabled (optional) and so each method call would be logged like this:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.41 ms      &lt;@1b0e9707&gt; .get(11) = \"Hello 11\"\n</code></pre>"},{"location":"guide/test/general/tracks/#configuration","title":"Configuration","text":"<p>Tracker registration call <code>final Tracker&lt;Service&gt; tracker = hook.track(Service.class)</code> returns a configuration builder. Final registration appears only after <code>.add()</code> method call.</p> Option Description Default trace When enabled, all method calls are printed false slowMethods Print warnings about methods executing longer than the specified threshold. Set to 0 to disable warnings. 5 seconds disableSlowMethodsLogging Shortcut to disable tracking for slow methods (same as set 0). keepRawObjects Keep method call arguments and result objects (potentially mutable) true maxStringLength Max length for a <code>String</code> argument or result (cut long strings) 30"},{"location":"guide/test/general/tracks/#tracing","title":"Tracing","text":"<p>Tracing might be useful to see each tracked method call in console with parameters and execution time:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.41 ms      &lt;@1b0e9707&gt; .foo(1) = \"1 call\"\n\\\\\\---[Tracker&lt;Service&gt;] 0.02 ms      &lt;@1b0e9707&gt; .foo(2) = \"2 call\"\n\\\\\\---[Tracker&lt;Service&gt;] 0.12 ms      &lt;@1b0e9707&gt; .bar(1) = \"1 bar\"\n</code></pre> <p>It also prints service instance hash, to make obvious method calls on different instances. Different instances could appear on prototype-scoped beans (default scope).</p> <p>Enabled with:</p> <pre><code>hook.track(Service .class)\n        .trace(true)\n</code></pre> <p>Note</p> <p>Traces are logged with <code>System.out</code> to make sure messages are always visible in console.</p>"},{"location":"guide/test/general/tracks/#slow-methods","title":"Slow methods","text":"<p>By default, tracker would log methods, executed longer than 5 seconds:</p> <pre><code>WARN  [2025-05-09 08:30:38,458] ru.vyarus.dropwizard.guice.test.track.Tracker: \n\\\\\\---[Tracker&lt;Service&gt;] 7.07 ms      &lt;@7634f2b&gt; .foo() = \"foo\"\n</code></pre> <p>Note</p> <p>Slow methods are logged with logger, and not <code>System.out</code> as traces.</p> <p>For example, to set slow method for 1 minute:</p> <pre><code>hook.track(Service .class)\n        .slowMethods(1, ChronoUnit.MINUTES)\n</code></pre> <p>To avoid logging slow methods (shortcut for setting 0 value):</p> <pre><code>hook.track(Service .class)\n        .disableSlowMethodsLogging()\n</code></pre>"},{"location":"guide/test/general/tracks/#keeping-raw-objects","title":"Keeping raw objects","text":"<p>By default, tracker stores all arguments and returned result objects.</p> <p>Raw arguments could be used to examine complex objects just after the method call. But, in case of multiple method calls, raw objects might not be actual. For example:</p> <pre><code>public Service {\n    public void foo(List&lt;String&gt; list) {\n        list.add(\"foo\" + list.size());\n    }\n}\n</code></pre> <p>Here method changes argument state and so, if we call method multiple times, stored arguments would be useless (as all calls would reference the same list instance):</p> <pre><code>List&lt;String&gt; test = new ArrayList&lt;&gt;();\nservice.foo(test);\nservice.foo(test);\n\n// stored list useless as object was changed after the initial call\nList&lt;String&gt; firstCallArg = tracker.getLastTracks(2).get(0).getRawArguments().get(0);\nAssertions.assertEquals(2, firstCallArg.size());\n\n// but string representation would still be useful:\nString firstCallArgString = tracker.getLastTracks(2).get(0).getArguments().get(0);\nAssertions.assertEquals(\"0[]\", firstCallArg.size());\n\n// second call argument string\nString firstCallArgString = tracker.getLastTracks(2).get(1).getArguments().get(0);\nAssertions.assertEquals(\"1['foo1']\", firstCallArg.size());\n</code></pre> <p>In case of complex objects (pojo, for example), string representation would only contain the type and instance hash: <code>Type@hash</code> (which is not informative, but the only universal short  way to describe object).</p> <p>If tracker used only for performance testing (to accumulate execution time from many runs), it might make sense to avoid holding raw arguments:</p> <pre><code>hook.track(Service .class)\n        .keepRawObjects(false)\n</code></pre>"},{"location":"guide/test/general/tracks/#max-length","title":"Max length","text":"<p>Methods could consume or return large string, but using large stings for console  output is not desired. All strings larger then configured size would be cut with \"...\" suffix:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.08 ms      &lt;@66fb45e5&gt; .baz(\"largelargelargelargelargelarge...\")\n</code></pre> <p>Changing default:</p> <pre><code>hook.track(Service .class)\n        .maxStringLength(10)\n</code></pre>"},{"location":"guide/test/general/tracks/#tracked-data","title":"Tracked data","text":"<p>Each call stored as <code>MethodTrack</code> and contains raw arguments <code>getRawArguments()</code> (which might change over time if mutable objects used) and string version <code>getArguments()</code> (can't change) and same for the result object. Raw objects are mostly useful in case of immediate check after the method call.</p> <p>Same for result: <code>getRawResult()</code> for raw object and <code>getResult()</code> for string version.</p> <p>Also, there are quoted string versions: <code>getQuatedResult()</code> and <code>getQuatedArguments()</code>. These methods are the same as string methods, but all strings are in quotes to clearly see string bounds (quoted versions useful for console reporting)</p> <p>Obtaining tracked data:</p> <pre><code>// all recordings\nList&lt;MethodTrack&gt; tracks = tracker.getTracks();\n// last 2 calls (in execution order)\nList&lt;MethodTrack&gt; tracks = tracker.getLastTracks(2);\n// last call\nMethodTrack track = tracker.getLastTrack();\n</code></pre>"},{"location":"guide/test/general/tracks/#searching","title":"Searching","text":"<p>In the case of many recorded executions (for multiple methods), search could be used:</p> <pre><code>// search by method (any argument value)\ntracks = tracker.findTracks(mock -&gt; when(\n               mock.foo(Mockito.anyInt()))\n         );\n\n// search methods with argument condition ( &gt; 1) \ntracks = tracker.findTracks(mock -&gt; when(\n        mock.foo(Mockito.intThat(argument -&gt; argument &gt; 1)))\n        );\n\n// search for methods with exact argument value  \ntracks = tracker.findTracks(mock -&gt; when(\n        mock.foo(11))\n        );\n</code></pre> <p>This method uses Mockito stubbing abilities for search criteria declaration: easy to use and type-safe search.</p>"},{"location":"guide/test/general/tracks/#reset-data","title":"Reset data","text":"<p>Tracked data could be cleared at any time either on tracker: <code>tracker.clear()</code> or using hook (for all trackers): <code>hook.resetTrackers()</code></p>"},{"location":"guide/test/general/tracks/#stats","title":"Stats","text":"<p>Tracker could aggregate all executions of the same method:</p> <pre><code>TrackerStats stats = tracker.getStats();\nAssertions.assertEquals(1, stats.getMethods().size());\n\nMethodSummary summary = stats.getMethods().get(0);\nAssertions.assertEquals(\"foo\", summary.getMethod().getName());\nAssertions.assertEquals(Service.class, summary.getService());\nAssertions.assertEquals(1, summary.getTracks());\nAssertions.assertEquals(0, summary.getErrors());\nAssertions.assertEquals(1, summary.getMetrics().getValues().length);\nAssertions.assertTrue(summary.getMetrics().getMin() &lt; 1000);\n</code></pre> <p>Tracker use dropwizard metrics, so stats provide common values like mean time, median time, 95 percentile, etc.</p> <p>There is a default statistics report implementation, which might be used for console reporting:</p> <pre><code>System.out.println(tracker.getStats().render());\n</code></pre> <pre><code>    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    Service                                  foo(int)                                           2 (2)      0          0.009 ms   0.352 ms   0.352 ms   0.352 ms   0.352 ms\n</code></pre> <p>Here you can see that 2 instances were used for 2 success calls. Of course max time would be too large (cold jvm), but with min value you can see more realistic time. With a high number of executions percentile and mean values would become more realistic.</p> <p>Here is an example of tracking <code>GuiceyConfigurationInfo</code> with activated <code>.printAllGuiceBindings()</code> report:</p> <pre><code>    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    GuiceyConfigurationInfo                  getNormalModuleIds()                               1          0          1.076 ms   1.076 ms   1.076 ms   1.076 ms   1.076 ms  \n    GuiceyConfigurationInfo                  getModulesDisabled()                               1          0          0.038 ms   0.038 ms   0.038 ms   0.038 ms   0.038 ms  \n    GuiceyConfigurationInfo                  getOverridingModuleIds()                           1          0          0.034 ms   0.034 ms   0.034 ms   0.034 ms   0.034 ms  \n    GuiceyConfigurationInfo                  getExtensionsDisabled()                            1          0          0.020 ms   0.020 ms   0.020 ms   0.020 ms   0.020 ms  \n    GuiceyConfigurationInfo                  getOptions()                                       1          0          0.005 ms   0.005 ms   0.005 ms   0.005 ms   0.005 ms  \n    GuiceyConfigurationInfo                  getData()                                          3          0          0.003 ms   0.006 ms   0.004 ms   0.006 ms   0.006 ms  \n</code></pre> <p>Note</p> <p>Methods sorted by slowness </p> <p>You can also collect stats for multiple trackers:</p> <pre><code>TrackerStats overall = new TrackerStats(tracker1, tracker2);\nSystem.out.println(overall.render());\n</code></pre>"},{"location":"guide/test/general/tracks/#tracker-object-access","title":"Tracker object access","text":"<p>If required, existing tracker object could be obtained directly from hook:</p> <pre><code>Tracker&lt;Service&gt; tracker = hook.getTracker(Service.class);\n</code></pre> <p>This might be useful, for example, to obtain multiple trackers and print overall stats. But, in the majority of cases, tracker instance, created on registration would be enough.</p>"},{"location":"guide/test/junit5/client/","title":"Testing web (HTTP client)","text":"<p>Both extensions prepare special jersey client instance which could be used for web calls. It is mostly useful for complete web tests to call rest services and servlets.</p> <pre><code>@Test\nvoid checkRandomPorts(ClientSupport client) {\n    Assertions.assertNotEquals(8080, client.getPort());\n    Assertions.assertNotEquals(8081, client.getAdminPort());\n}\n</code></pre> <p><code>ClientSupport</code> could only be injected as test/setup method parameter.</p> <p>Client object provides:</p> <ul> <li>Access to JerseyClient object (for raw calls)</li> <li>Shortcuts for querying main, admin or rest contexts (it will count the current configuration automatically)</li> <li>Shortcuts for base main, admin or rest contexts base urls (and application ports)</li> </ul> <p>Example usages:</p> <pre><code>// GET {rest path}/some\nclient.targetRest(\"some\").request().buildGet().invoke()\n\n// GET {main context path}/servlet\nclient.targetMain(\"servlet\").request().buildGet().invoke()\n\n// GET {admin context path}/adminServlet\nclient.targetAdmin(\"adminServlet\").request().buildGet().invoke()\n\n// General external url call\nclient.target(\"https://google.com\").request().buildGet().invoke()\n</code></pre> <p>Tip</p> <p>All methods above accepts any number of strings which would be automatically combined into correct path: <pre><code>client.targetRest(\"some\", \"other/\", \"/part\")\n</code></pre> would be correctly combined as \"/some/other/part/\"</p> <p>As you can see test code is abstracted from actual configuration: it may be default or simple server with any contexts mapping on any ports - target urls will always be correct.</p> <pre><code>Response res = client.targetRest(\"some\").request().buildGet().invoke()\n\nAssertions.assertEquals(200, res.getStatus())\nAssertions.assertEquals(\"response text\", res.readEntity(String)) \n</code></pre> <p>Also, if you want to use other client, client object can simply provide required info:</p> <pre><code>client.getPort()        // app port (8080)\nclient.getAdminPort()   // app admin port (8081)\nclient.basePathRoot()   // root server path (http://localhost:8080/)\nclient.basePathMain()   // main context path (http://localhost:8080/)\nclient.basePathAdmin()  // admin context path (http://localhost:8081/)\nclient.basePathRest()   // rest context path (http://localhost:8080/)\n</code></pre> <p>Raw client usage:</p> <pre><code>// call completely external url\nclient.target(\"http://somedomain:8080/dummy/\").request().buildGet().invoke()\n</code></pre> <p>Warning</p> <p>Client object could be injected with both dropwizard and guicey extensions, but in case of guicey extension, only raw client could be used (because web part not started all other methods will throw NPE)</p>"},{"location":"guide/test/junit5/client/#simple-rest-methods","title":"Simple REST methods","text":"<p>The client also contains simplified GET/POST/PUT/DELETE methods for path, relative to server root (everything after port):</p> <p>Tip</p> <p>For simple rest testing prefer lightweight rest where rest client is simpler (because it does not need to be universal).</p> <pre><code>@Test\npublic void testWeb(ClientSupport client) {\n    // get with result\n    Result res = client.get(\"rest/sample\", Result.class);\n\n    // post without result (void)\n    client.post(\"rest/action\", new PostObject(), null);\n\n   // post with result \n   Result res = client.post(\"rest/action\", new PostObject(), Result.class);\n}\n</code></pre> <p>All methods:</p> <ol> <li>Methods accept paths relative to server root. In the example above: \"http://localhost:8080/rest/sample\"</li> <li>Could return mapped response.</li> <li>For void calls, use null instead of the result type. In this case, only 200 and 204 (no content) responses    would be considered successful</li> </ol> <p>POST and PUT also accept (body) object to send. But methods does not allow multipart execution.</p> <p>Tip</p> <p>These methods could be used as examples for jersey client usage.</p>"},{"location":"guide/test/junit5/client/#client-factory","title":"Client factory","text":"<p><code>JerseyClient</code> used in <code>ClientSupport</code> could be customized using <code>TestClientFactory</code> implementation.</p> <p>Simple factory example:</p> <pre><code>public class SimpleTestClientFactory implements TestClientFactory {\n\n    @Override\n    public JerseyClient create(final DropwizardTestSupport&lt;?&gt; support) {\n        return new JerseyClientBuilder()\n                .register(new JacksonFeature(support.getEnvironment().getObjectMapper()))\n                .property(ClientProperties.CONNECT_TIMEOUT, 1000)\n                .property(ClientProperties.READ_TIMEOUT, 5000)\n                .property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)\n                .build();\n    }\n}\n</code></pre> <p>Default implementation (<code>DefaultTestClientFactory</code>) applies timeouts and auto-registers multipart support if <code>dropwizard-forms</code> module if available in classpath.</p> <p>Custom implementation could be specified directly in the test annotation:</p> <pre><code>@TestDropwizardApp(value = MyApp.class, clientFactory = CustomTestClientFactory.class)\n</code></pre> <p>(or <code>.clientFactory()</code> method in builder)</p>"},{"location":"guide/test/junit5/client/#default-client","title":"Default client","text":"<p><code>JerseyClient</code> used inside <code>ClientSupport</code> is created by <code>DefaultTestClientFactory</code>.</p> <p>Default implementation:</p> <ol> <li>Enables multipart feature if <code>dropwizard-forms</code> is in classpath (so the client could be used    for sending multipart data).</li> <li>Enables request and response logging to simplify writing (and debugging) tests.</li> </ol> <p>By default, all request and response messages are written directly into console to guarantee client actions visibility (logging might not be configured in tests).</p> <p>Example output:</p> <pre><code>[Client action]---------------------------------------------{\n1 * Sending client request on thread main\n1 &gt; GET http://localhost:8080/sample/get\n\n}----------------------------------------------------------\n\n\n[Client action]---------------------------------------------{\n1 * Client response received on thread main\n1 &lt; 200\n1 &lt; Content-Length: 13\n1 &lt; Content-Type: application/json\n1 &lt; Date: Mon, 27 Nov 2023 10:00:40 GMT\n1 &lt; Vary: Accept-Encoding\n{\"foo\":\"get\"}\n\n}----------------------------------------------------------\n</code></pre> <p>Console output might be disabled with a system proprty:</p> <pre><code>// shortcut sets DefaultTestClientFactory.USE_LOGGER property\nDefaultTestClientFactory.disableConsoleLog()\n</code></pre> <p>With it, everything would be logged into <code>ClientSupport</code> logger (java.util) under INFO (most likely, would be invisible in the most logger configurations, but could be enabled).</p> <p>To reset property (and get logs back into console) use:</p> <pre><code>DefaultTestClientFactory.enableConsoleLog()\n</code></pre> <p>Note</p> <p>Static methods added not directly into <code>ClientSupport</code> because this is the default client factory feature. You might use a completely different factory.</p>"},{"location":"guide/test/junit5/command/","title":"Testing commands","text":"<p>Warning</p> <p>Commands execution overrides System IO and so can't run in parallel with other tests!</p> <p>Use <code>@Isolated</code>  on such tests to prevent parallel execution with other tests</p> <p>Command execution is usually a short-lived action, so it is not possible to write an extension for it. Command could be tested only with generic utility:</p> <pre><code>@Test\npublic class testCommand() {\n    CommandResult result = TestSupport.buildCommandRunner(App.class)\n            .run(\"cmd\", \"-p\", \"param\");\n\n    Assertions.assertTrue(result.isSuccessful());\n}\n</code></pre> <p>This runner could be used to run any command type (simple, configured, environment). The type of command would define what objects would be present ofter the command execution (for example, <code>Injector</code> would be available only for <code>EnvironmentCommand</code>).</p> <p>Run command arguments are the same as real command arguments (the same <code>Cli</code> used for commands parsing). You can only omit configuration path and use builder instead:</p> <pre><code>    CommandResult result = TestSupport.buildCommandRunner(App.class)\n            .config(\"path/to/config.yml\")\n            .configOverride(\"prop: 1\")\n            .run(\"cmd\", \"-p\", \"param\");\n</code></pre> <p>Important</p> <p>Command execution never throws an exception - any appeared exception would be inside resulted object:</p> <pre><code>Assertions.assertFalse(result.isSuccessful());  \nAssertions.assertEquals(\"Error message\", result.getException().getMessage());\n</code></pre> <p>Output is intercepted and could be used for assertions: <pre><code>Assertions.assertTrue(result.getOutput().contains(\"some text\"))\n</code></pre></p> <p>All special objects (like configuration, environment etc), created during command execution are all stored inside the result object (this is the only way to access them). </p>"},{"location":"guide/test/junit5/command/#io","title":"IO","text":"<p>Runner use System.in/err/out replacement. All output is intercepted and could be asserted:</p> <pre><code>Assertions.assertTrue(result.getOutput().contains(\"some text\"))\n</code></pre> <p><code>result.getOutput()</code> contains both <code>out</code> and <code>err</code> streams together (the same way as user would see it in console). Error output is also available separately with <code>result.getErrorOutput()</code>.</p> <p>Note</p> <p>All output is always printed to console, so you could always see it after test execution (without additional actions)</p> <p>Commands requiring user input could also be tested (with mocked input):</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .consoleInputs(\"1\", \"two\", \"something else\")\n        .run(\"quiz\")\n</code></pre> <p>At least, the required number of answers must be provided (otherwise error would be thrown, indicating not enough inputs)</p> <p>Warning</p> <p>Due to IO overrides, command tests could not run in parallel.  For junit 5, such tests could be annotated with <code>@Isolated</code> (to prevent execution in parallel with other tests)</p>"},{"location":"guide/test/junit5/command/#configuration","title":"Configuration","text":"<p>Configuration options are the same as in run builder. For example:</p> <pre><code>// override only\nTestSupport.buildCommandRunner(App.class)\n        .configOverride(\"foo: 12\")\n        .run(\"cfg\");\n\n// file with overrides\nTestSupport.buildCommandRunner(App.class)\n        .config(\"src/test/resources/path/to/config.yml\")\n        .configOverride(\"foo: 12\")\n        .run(\"cfg\");\n\n// direct config object\nMyConfig config = new MyConfig();         \nTestSupport.buildCommandRunner(App.class)\n        .config(config)\n        .run(\"cfg\");\n</code></pre> <p>Note</p> <p>Config file should not be specified in command itself - builder would add it, if required. But still, it would not be a mistake to use config file directly in command:</p> <pre><code>TestSupport.buildCommandRunner(App.class)\n    // note .config(\"...\") was not used (otherwise two files would appear)!\n    .run(\"cfg\", \"path/to/config.yml\");\n</code></pre> <p>Using builder for config file configuration assumed to be a preferred way.</p>"},{"location":"guide/test/junit5/command/#listener","title":"Listener","text":"<p>There is a simple listener support (like in application run builder) for setup-cleanup actions:</p> <pre><code>TestSupport.buildCommandRunner(App.class)\n        .listen(new CommandRunBuilder.CommandListener&lt;&gt;() {\n            public void setup(String[] args) { ... }\n            public void cleanup(CommandResult&lt;TestConfiguration&gt; result) { ... }\n        })\n        .run(\"cmd\")\n</code></pre>"},{"location":"guide/test/junit5/config/","title":"Application configuration","text":"<p>Note</p> <p>In terms of configuration, both extensions (<code>@TestGuiceyApp</code> and <code>@TestDropwizardApp</code>)  are equal, so all examples would show just one of them.</p> <p>Also, annotation provides the same options as field-based extension declaration, so if something is shown for annotation - the same could be done with builder.</p> <p>Application could be started with an external configuration file:</p> <pre><code>@TestGuiceyApp(value = MyApplication.class,\n    config = \"path/to/my/test-config.yml\"\npublic class MyTest {\n</code></pre> <p>Or just declare required values:</p> <pre><code>@TestGuiceyApp(value = MyApplication.class,\n    configOverride = {\n            \"foo: 2\",\n            \"bar: 12\"\n    })\npublic class ConfigOverrideTest {\n</code></pre> <p>(note that overriding declaration follows yaml format \"key: value\")</p> <p>Or use both at once (here overrides will override file values):</p> <pre><code>@TestGuiceyApp(value = MyApplication.class,\n    config = 'path/to/my/config.yml',\n    configOverride = {\n            \"foo: 2\",\n            \"bar: 12\"\n    })\nclass ConfigOverrideTest {\n</code></pre>"},{"location":"guide/test/junit5/config/#manual-configuration-object","title":"Manual configuration object","text":"<p>Normally, either empty configuration object created (if a configuration file not provided)  or it created from a specified file.</p> <p>It is also possible to manually construct configuration object instance in junit5 extension (for both lightweight and full app tests):</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        .config(() -&gt; new MyConfig())\n        ...\n</code></pre> <p>Or in setup object:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt; ext.config(() -&gt; new MyConfig())\n</code></pre> <p>Tip</p> <p>Pay attention to how setup objects could be used for configuration modification: it is often easier to declare test extension in base class and use setup objects for test-specific modifications.</p> <p>Important</p> <p>Configuration overrides would not work with manually created configuration objects. Use configuration modifiers with manual configs.</p>"},{"location":"guide/test/junit5/config/#configuration-modifiers","title":"Configuration modifiers","text":"<p>Dropwizard configuration overrides mechanism is limited (for example, it would not work for a collection property).</p> <p>Configuration modifier is an alternative mechanism when all changes are performed on configuration instance.</p> <p>Modifier could be used as lambda:</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        .configModifiers(config -&gt; config.getSomething().setFoo(12))\n        ...\n</code></pre> <p>Or in setup object:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt; \n        ext.configModifiers(config -&gt; config.getSomething().setFoo(12))\n</code></pre> <p>Modifier could be declared in class:</p> <pre><code>public class MyModifier implements ConfigModifier&lt;MyConfig&gt; {\n    @Override\n    public void modify(MyConfig config) throws Exception {\n        config.getSomething().setFoo(12);\n    }\n}\n\n@TestGuiceyApp(.., configModifiers = MyModifier.class)\n</code></pre> <p>Tip</p> <p>Modifier could be used with both manual configuration or usual (yaml) configuration. Configuration modifiers also could be used together with configuration overrides.</p> <p>Limitation</p> <p>Configuration modifiers are called after dropwizard logging configuration, so logging is the only thing that can't be configured (use configuration overrides for logging)</p>"},{"location":"guide/test/junit5/config/#deferred-configuration","title":"Deferred configuration","text":"<p>If you need to configure value, supplied by some other extension, or value may be resolved only after test start, then static overrides declaration is not an option. In this case use alternative extensions declaration which provides additional  config override methods:</p> <pre><code>@RegisterExtension\n@Order(1)\nstatic FooExtension ext = new FooExtension();\n\n@RegisterExtension\n@Order(2)\nstatic TestGuiceyAppExtension app = TestGuiceyAppExtension.forApp(AutoScanApplication.class)\n        .config(\"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\")\n        .configOverrides(\"foo: 1\")\n        .configOverride(\"bar\", () -&gt; ext.getValue())\n        .configOverrides(new ConfigOverrideValue(\"baa\", () -&gt; \"44\"))\n        .create();\n</code></pre> <p>In most cases <code>configOverride(\"bar\", () -&gt; ext.getValue())</code> would be enough to configure a supplier instead of static value.</p> <p>In more complex cases, you can use custom implementations of <code>ConfigOverride</code>. </p> <p>Guicey have to accept only <code>ConfigOverride</code> objects implementing custom  <code>ru.vyarus.dropwizard.guice.test.util.ConfigurablePrefix</code> interface.  In order to support parallel tests guicey generates unique config prefix for each test (because all overrides eventually stored to system properties) and so it needs a way to set this prefix into custom <code>ConfigOverride</code> objects.</p>"},{"location":"guide/test/junit5/config/#configuration-from-3rd-party-extensions","title":"Configuration from 3<sup>rd</sup> party extensions","text":"<p>If you have junit extension (e.g. which starts db for test) and you need  to apply configuration overrides from that extension, then you should simply store required values inside junit storage:</p> <pre><code>public class ConfigExtension implements BeforeAllCallback {\n\n    @Override\n    public void beforeAll(ExtensionContext context) throws Exception {\n        // do something and then store value\n        context.getStore(ExtensionContext.Namespace.GLOBAL).put(\"ext1\", 10);\n    }\n}\n</code></pre> <p>And map overrides directly from store using <code>configOverrideByExtension</code> method:</p> <pre><code>@ExtendWith(ConfigExtension.class)\npublic class SampleTest {\n\n    @RegisterExtension\n    static TestGuiceyAppExtension app = TestGuiceyAppExtension.forApp(App.class)\n            .configOverrideByExtension(ExtensionContext.Namespace.GLOBAL, \"ext1\")\n            .create();\n}\n</code></pre> <p>Here, value applied by extension under key <code>ext1</code> would be applied to configuration <code>ext1</code> path. If you need to use different configuration key:</p> <pre><code>.configOverrideByExtension(ExtensionContext.Namespace.GLOBAL, \"ext1\", \"key\")\n</code></pre> <p>Tip</p> <p>You can use setup objects instead of custom junit extensions for test environment setup</p>"},{"location":"guide/test/junit5/debug/","title":"Debug","text":"<p>All declared setup objects and hooks could be listed with a (declaration) source reference (where possible) in initialization order.</p> <pre><code>public static class Test2 extends Base {\n\n    @RegisterExtension\n    static TestGuiceyAppExtension app = TestGuiceyAppExtension.forApp(App.class)\n            .setup(Ext1.class, Ext2.class)\n            .setup(it -&gt; null, new Ext3())\n            .debug()\n            .create();\n\n    @EnableSetup\n    static TestEnvironmentSetup ext1 = it -&gt; null;\n    @EnableSetup\n    static TestEnvironmentSetup ext2 = it -&gt; null;\n</code></pre> <pre><code>Guicey test extensions (Test2.):\n\n    Setup objects = \n        Ext1                            @RegisterExtension.setup(class)                    at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:102)\n        Ext2                            @RegisterExtension.setup(class)                    at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:102)\n        &lt;lambda&gt;                        @RegisterExtension.setup(obj)                      at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:103)\n        Ext3                            @RegisterExtension.setup(obj)                      at r.v.d.g.t.j.d.SetupObjectsLogTest.(SetupObjectsLogTest.java:103)\n        &lt;lambda&gt;                        @EnableSetup Base#base1                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Base#base1\n        &lt;lambda&gt;                        @EnableSetup Base#base2                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Base#base2\n        &lt;lambda&gt;                        @EnableSetup Test2#ext1                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Test2#ext1\n        &lt;lambda&gt;                        @EnableSetup Test2#ext2                            at r.v.d.g.t.j.d.SetupObjectsLogTest$Test2#ext2\n</code></pre> <p>Also, applied configuration overrides and modifiers would be shown:</p> <pre><code>Configuration overrides (Test2.):\n                      foo = 2\n                      bar = 11\n\nConfiguration modifiers:\n        &lt;lambda&gt;                        @RegisterExtension.configModifiers(obj)            at r.v.d.g.t.j.d.ConfigOverrideLogTest.(ConfigOverrideLogTest.java:100)\n        CfgModify1                      @RegisterExtension.configModifiers(class)          at r.v.d.g.t.j.d.ConfigOverrideLogTest.(ConfigOverrideLogTest.java:101)\n        &lt;lambda&gt;                        @EnableSetup Test2#setup.configModifiers(obj)      at r.v.d.g.t.j.d.ConfigOverrideLogTest.(ConfigOverrideLogTest.java:107)\n        CfgModify2                      @EnableSetup Test2#setup.configModifiers(class)    at r.v.d.g.t.j.d.ConfigOverrideLogTest.(ConfigOverrideLogTest.java:108)\n</code></pre> <p>Important</p> <p>Configuration overrides printed after application startup because they are extracted from system properties (to guarantee exact used value), which is possible to analyze only after <code>DropwizardTestSupport#before()</code> call.</p> <p>Note</p> <p>Configuration prefix for system properties is shown in brackets: <code>(Test1.)</code>. It simplifies investigation in case of concurrent tests.</p> <p>Debug could be activated by annotation:</p> <pre><code>@TestGuiceyApp(value = App.class, debug = true)\n</code></pre> <p>By builder:</p> <pre><code>@RegisterExtension\nTestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(App)\n        .debug()\n        .create()\n</code></pre> <p>By setup object:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup db = ext -&gt; {\n            ext.debug();\n        };\n</code></pre> <p>And using system property:</p> <pre><code>-Dguicey.extensions.debug=true\n</code></pre> <p>There is also a shortcut for enabling system property:</p> <pre><code>TestSupport.debugExtensions()\n</code></pre>"},{"location":"guide/test/junit5/debug/#startup-performance","title":"Startup performance","text":"<p>To simplify slow tests (slowness) investigations, guicey measures and prints extensions time.</p> <p>For example, test with application started in beforeAll, with two test methods (same app for both tests):</p> <pre><code>@TestGuiceyApp(value = App.class, debug = true)\npublic class PerformanceLogTest {\n    @Test\n    public void test1() { ... }\n    @Test\n    public void test2() { ... }\n}\n</code></pre> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 1595d2b2 /\nGuicey time after [Before each] of PerformanceLogTest#test1(): 1204 ms\n\n    [Before all]                       : 1204 ms\n        Guicey fields search               : 2.03 ms\n        Guicey hooks registration          : 0.02 ms\n        Guicey setup objects execution     : 1.92 ms\n        DropwizardTestSupport creation     : 1.47 ms\n        Application start                  : 1172 ms\n\n    [Before each]                      : 0.46 ms\n        Guice fields injection             : 0.19 ms\n\n\n\\\\\\------------------------------------------------------------/ test instance = 45554613 /\nGuicey time after [Before each] of PerformanceLogTest#test2(): 1205 ms ( + 0.33 ms)\n\n    [Before each]                      : 0.69 ms ( + 0.23 ms)\n        Guice fields injection             : 0.36 ms ( + 0.17 ms)\n\n    [After each]                       : 0.10 ms\n\n\n\\\\\\---------------------------------------------------------------------------------------------\nGuicey time after [After all] of PerformanceLogTest: 1207 ms ( + 2.15 ms)\n\n    [After each]                       : 0.11 ms ( + 0.01 ms)\n\n    [After all]                        : 2.14 ms\n        Application stop                   : 1.72 ms\n</code></pre> <p>There are three reports:</p> <ol> <li>Before first test method (see guicey extension startup time)</li> <li>Before the second test method (see guicey time for the second method only)</li> <li>After all (cleanup time)</li> </ol> <p>Only the first report shows all recorded times, next reports only mention time increase. For example, the second report mentions only <code>Guice fields injection             : 0.36 ms ( + 0.17 ms)</code> Meaning guicey perform fields injection just before the second test, spent 0.17 ms on it (overall injection time for two injections is 0.36 ms)</p>"},{"location":"guide/test/junit5/debug/#extensions","title":"Extensions","text":"<p>It is recommended to use root extension debug option value in the extensions. Current field-bases extensions print recognized fields report when debug is enabled.</p> <pre><code>@TestGuiceyApp(value = App.class, stup = MySetup.class, debug = true)\n\npublic class MySetup implements TestEnvironmentSetup, TestExecutionListener {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        extension.listen(this);\n\n        if (extension.isDebug()) {\n            System.out.println(\"Debug info: ...\");\n        }\n    }\n\n    @Override\n    public void started(final EventContext context) throws Exception {\n        if (context.isDebug()) {\n            System.out.println(\"Debug info: ...\");\n        }\n    }\n</code></pre>"},{"location":"guide/test/junit5/env/","title":"Environment variables","text":"<p>Warning</p> <p>Such modifications are not suitable for parallel tests execution!</p> <p>Use <code>@Isolated</code>  on such tests to prevent parallel execution with other tests</p> <p>To modify environment variables for test use system stubs library</p> <pre><code>testImplementation 'uk.org.webcompere:system-stubs-jupiter:2.1.3'\ntestImplementation 'org.objenesis:objenesis:3.3'\n</code></pre> <pre><code>@ExtendWith(SystemStubsExtension.class)\npublic class MyTest {\n    @SystemStub\n    EnvironmentVariables ENV;\n    @SystemStub\n    SystemOut out;\n    @SystemStub\n    SystemProperties propsReset;\n\n    @BeforeAll\n    public void setup() {\n        ENV.set(\"VAR\", \"1\");\n        System.setProperty(\"foo\", \"bar\"); // OR propsReset.set(\"foo\", \"bar\") - both works the same\n    } \n\n    @Test\n    public void test() {\n        // here goes some test that requires custom environment and system property values\n\n        // validating output\n        Assertions.assertTrue(out.getTest().contains(\"some log message\"));\n    }\n}\n</code></pre> <p>Pay attention that there is no need for cleanup: system properties and environment variables would be re-set automatically!</p>"},{"location":"guide/test/junit5/hooks/","title":"Application modification","text":"<p>You can use hooks to customize application.</p> <p>Note</p> <p>Hook provides the same methods as the main <code>GuiceBundle.builder()</code> and so it could easily re-configure application (change options, add or disable modules,  enable reports, etc.)</p> <p>In both extension annotations, hooks could be declared with attribute:</p> <pre><code>@TestDropwizardApp(value = MyApplication.class, hooks = MyHook.class)\n</code></pre> <p>or</p> <pre><code>@TestGuiceyApp(value = MyApplication.class, hooks = MyHook.class)\n</code></pre> <p>Where MyHook is:</p> <pre><code>public class MyHook implements GuiceyConfigurationHook {\n    @Override\n    public void configure(GuiceBundle.Builder builder) throws Exception {\n\n    }\n}\n</code></pre> <p>Many test extensions could be written with hooks. For example, to implement deep mocks support we can write hook like this:</p> <pre><code>public class MockApiHook implements GuiceyConfigurationHook {\n    private final Class&lt;?&gt;[] classes;\n\n    public MockApiHook(final Class&lt;?&gt;... classes) {\n        this.classes = classes;\n    }\n\n    @Override\n    public void configure(final GuiceBundle.Builder builder) {\n        builder.modulesOverride(binder -&gt; {\n            for (Class&lt;?&gt; clazz : classes) {\n                bind(binder, clazz, Mockito.mock(clazz));\n            }\n        });\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>// mocks created and registered as overriding original services \n@EnableHook\nstatic MockApiHook mocks = new MockApiHook(SomeService.class, SomeOtherService.class);\n\n@Inject\nSomeService service;\n\n@BeforeEach\npublic void setUp() {\n    // In case of multiple test methods  Mockito.reset(service) required\n    // Would work correctly only if AOP not used for service\n    Mockito.when(service.getFoo()).thenReturn(\"12\");\n}\n\n@test\npublic void test() {\n     Assertions.assertEquals(\"12\", service.getFoo());\n}\n</code></pre> <p>Important</p> <p>This is just a simple example (not counting possible AOP usage) - just to show how hooks  could be used. Mocks support is already implemented: see <code>@MockBean</code> extension.</p>"},{"location":"guide/test/junit5/hooks/#hook-fields","title":"Hook fields","text":"<p>Alternatively, you can declare hook directly in test field:</p> <pre><code>@EnableHook\nstatic GuiceyConfigurationHook HOOK = builder -&gt; builder.modules(new DebugModule());\n</code></pre> <p>Tip</p> <p>Hook field could be used for guicey report activation in test: <pre><code>@EnableHook\nstatic GuiceyConfigurationHook hook = GuiceBundle.Builder::printStartupTime;\n</code></pre></p> <p>Any number of hook fields could be declared.  Hook fields could be also declared in base test class:</p> <pre><code>public abstract class BaseTest {\n\n    // hook in base class\n    @EnableHook\n    static GuiceyConfigurationHook BASE_HOOK = builder -&gt; builder.modules(new DebugModule());\n}\n\n@TestGuiceyApp(value = App.class, hooks = SomeOtherHook.class)\npublic class SomeTest extends BaseTest {\n\n    // Another hook\n    @EnableHook\n    static GuiceyConfigurationHook HOOK = builder -&gt; builder.modules(new DebugModule2());\n}\n</code></pre> <p>All 3 hooks will work (two in fields, one in annotation).</p>"},{"location":"guide/test/junit5/inject/","title":"Guice injections","text":"<p>Any guice bean could be injected directly into a test field:</p> <pre><code>@Inject\nSomeBean bean\n</code></pre> <p>This will work even for not declared (in guice modules) beans (JIT injection will occur).</p> <p>To better understand injection scopes look the following test:</p> <pre><code>// one application instance started for all test methods\n@TestGuiceyApp(AutoScanApplication.class)\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class InjectionScopeTest {\n\n    // new instance injected on each test\n    @Inject\n    TestBean bean;\n\n    // the same context used for all tests (in class), so the same bean instance inserted before each test\n    @Inject\n    TestSingletonBean singletonBean;\n\n    @Test\n    @Order(1)\n    public void testInjection() {\n        bean.value = 5;\n        singletonBean.value = 15;\n\n        Assertions.assertEquals(5, bean.value);\n        Assertions.assertEquals(15, singletonBean.value);\n\n    }\n\n    @Test\n    @Order(2)\n    public void testSharedState() {\n\n        Assertions.assertEquals(0, bean.value);\n        Assertions.assertEquals(15, singletonBean.value);\n    }\n\n    // bean is in prototype scope\n    public static class TestBean {\n        int value;\n    }\n\n    @Singleton\n    public static class TestSingletonBean {\n        int value;\n    }\n}\n</code></pre> <p>Note</p> <p>Guice AOP will not work on test methods (because test instances are not created by guice).</p>"},{"location":"guide/test/junit5/inject/#parameter-injection","title":"Parameter injection","text":"<p>Any declared guice bean may be injected as test method parameter:</p> <pre><code>@Test\npublic void testSomthing(DummyBean bean) \n</code></pre> <p>(where <code>DummyBean</code> is manually declared in some module or requested as a dependency  (JIT-instantiated) during injector creation).</p> <p>For unknown beans injection (not declared and not used during startup) special annotation must be used:</p> <pre><code>@Test\npublic void testSomthing(@Jit TestBean bean) \n</code></pre> <p>Info</p> <p>Additional annotation required because you may use other junit extensions providing their own parameters, which guicey extension should not try to handle. That's why not annotated parameters verified with existing injector bindings.</p> <p>Qualified and generified injections will also work:</p> <pre><code>@Test\npublic void testSomthing(@Named(\"qual\") SomeBean bean,\n                         TestBean&lt;String&gt; generifiedBean,\n                         Provider&lt;OtherBean&gt; provider) \n</code></pre> <p>Also, there are special objects available as parameters:</p> <ul> <li><code>Application</code> or exact application class (<code>MyApplication</code>)</li> <li><code>ObjectMapper</code></li> <li><code>ClientSupport</code> application web client helper</li> <li><code>DropwizardTestSupport</code> test support object used internally</li> <li><code>ExtensionContext</code> junit extension context</li> </ul> <p>Note</p> <p>Parameter injection will work on test methods as well as lifecyle methods (beforeAll, afterEach etc.) </p> <p>Example:</p> <pre><code>@TestDropwizardApp(AutoScanApplication.class)\npublic class ParametersInjectionDwTest {\n\n    public ParametersInjectionDwTest(Environment env, DummyService service) {\n        Preconditions.checkNotNull(env);\n        Preconditions.checkNotNull(service);\n    }\n\n    @BeforeAll\n    static void before(Application app, DummyService service) {\n        Preconditions.checkNotNull(app);\n        Preconditions.checkNotNull(service);\n    }\n\n    @BeforeEach\n    void setUp(Application app, DummyService service) {\n        Preconditions.checkNotNull(app);\n        Preconditions.checkNotNull(service);\n    }\n\n    @AfterEach\n    void tearDown(Application app, DummyService service) {\n        Preconditions.checkNotNull(app);\n        Preconditions.checkNotNull(service);\n    }\n\n    @AfterAll\n    static void after(Application app, DummyService service) {\n        Preconditions.checkNotNull(app);\n        Preconditions.checkNotNull(service);\n    }\n\n    @Test\n    void checkAllPossibleParams(Application app,\n                                AutoScanApplication app2,\n                                Configuration conf,\n                                TestConfiguration conf2,\n                                Environment env,\n                                ObjectMapper mapper,\n                                Injector injector,\n                                ClientSupport client,\n                                DropwizardTestSupport support,\n                                DummyService service,\n                                @Jit JitService jit) {\n        assertNotNull(app);\n        assertNotNull(app2);\n        assertNotNull(conf);\n        assertNotNull(conf2);\n        assertNotNull(env);\n        assertNotNull(mapper);\n        assertNotNull(injector);\n        assertNotNull(client);\n        assertNotNull(support);\n        assertNotNull(service);\n        assertNotNull(jit);\n        assertEquals(client.getPort(), 8080);\n        assertEquals(client.getAdminPort(), 8081);\n    }\n\n    public static class JitService {\n\n        private final DummyService service;\n\n        @Inject\n        public JitService(DummyService service) {\n            this.service = service;\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p><code>DropwizardTestSupport</code> and <code>ClientSupport</code> objects are also available with a static calls (in the same thread):</p> <pre><code>DropwizardTestSupport support = TestSupport.getContext();\nClientSupport client = TestSupport.getContextClient();\n</code></pre>"},{"location":"guide/test/junit5/junit-ext/","title":"3<sup>rd</sup> party extensions integration","text":"<p>It is extremely simple in JUnit 5 to write extensions. If you do your own extension, you can easily integrate with guicey or dropwizard extensions.</p> <p>Tip</p> <p>In many cases, it would be easier to write a custom guicey setup object  which provides almost the same abilities as junit extensions plus guicey awareness. All field-based extensions in guicey are implemented with setup objects.</p>"},{"location":"guide/test/junit5/junit-ext/#guicey-side","title":"Guicey side","text":"<p>If you already have a junit extension that stores something in <code>ExtensionContext</code> then you can:</p> <ol> <li>Bind value into configuration directly:      <code>.configOverrideByExtension(ExtensionContext.Namespace.GLOBAL, \"ext-key\", \"config.key\")</code> </li> <li>Bind junit <code>ExtensionContext</code> as test method parameter (and access storage manually): <pre><code>@BeforeAll\npublic static void beforeAll(ExtensionContext junitContext) {\n    ...\n}\n</code></pre></li> <li>Inside setup object access junit context:  <pre><code>public class MyExt implements GuiceyEnvironmentSetup {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        ExtensionContext context = extension.getJunitContext();\n    }\n}\n</code></pre></li> </ol>"},{"location":"guide/test/junit5/junit-ext/#extension-side","title":"Extension side","text":"<p>There are special static methods allowing you to obtain main test objects:</p> <ul> <li><code>GuiceyExtensionsSupport.lookupSupport(extensionContext)</code> -&gt; <code>Optional&lt;DropwizardTestSupport&gt;</code></li> <li><code>GuiceyExtensionsSupport.lookupInjector(extensionContext)</code> -&gt; <code>Optional&lt;Injector&gt;</code></li> <li><code>GuiceyExtensionsSupport.lookupClient(extensionContext)</code> -&gt; <code>Optional&lt;ClientSupport&gt;</code></li> </ul> <p>For example:</p> <pre><code>public class MyExtension implements BeforeEachCallback {\n\n    @Override\n    public void beforeEach(ExtensionContext context) throws Exception {\n        Injector injector = GuiceyExtensionsSupport.lookupInjector(context).get();\n        ...\n    }\n}\n</code></pre> <p>(guicey holds test state in junit test-specific storages and that's why test context is required)</p> <p>Warning</p> <p>There is no way in junit to order extensions, so you will have to make sure that your extension will be declared after guicey extension (<code>@TestGuiceyApp</code> or <code>@TestDropwizardApp</code>).</p> <p>There is intentionally no direct api for applying configuration overrides from 3<sup>rd</sup> party extensions because it would be not obvious. Instead, you should always declare overridden value in extension declaration. Either use instance getter:</p> <pre><code>@RegisterExtension\nstatic MyExtension ext = new MyExtension()\n\n@RegisterExtension\nstatic TestGuiceyAppExtension dw = TestGuiceyAppExtension.forApp(App.class)\n        .configOverride(\"some.key\", ()-&gt; ext.getValue())\n        .create()\n</code></pre> <p>Or store value inside junit store and then reference it:</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension app = TestGuiceyAppExtension.forApp(App.class)\n        .configOverrideByExtension(ExtensionContext.Namespace.GLOBAL, \"ext1\")\n        .create();\n</code></pre>"},{"location":"guide/test/junit5/logs/","title":"Testing logs","text":"<p>Important</p> <p>Works only with logback (default dropwizard logger).</p> <p><code>@RecordLogs</code> extension could record log messages for one or multiple classes.</p> <p>For example, for service:</p> <pre><code>public class Service {\n    private final Logger logger = LoggerFactory.getLogger(Service.class);\n\n    public void foo() {\n        ...\n        if (someCondition) {\n            logger.debug(\"Some technical note\");\n        }\n    }\n}\n</code></pre> <p>Testing log appears: </p> <pre><code>@Isolated\n@TestGucieyApp(App.class)\npublic class Test {\n\n    @RecordLogs(value = Service.class, level = Level.DEBUG)\n    RecordedLogs logs;\n\n    @Inject\n    Service service;\n\n    @Test\n    public void test() {\n        // here some actions with service, involving logging\n        service.foo();\n\n        Assertions.assertEquals(1, logs.count());\n        Assertions.assertTrue(logs.has(Level.DEBUG));\n        Assertions.assertEquals(1, logs.containing(\"Some technical note\").count());\n        // alternative: last message was a technical hint\n        Assertions.assertEquals(\"Some technical note\", logs.lastMessage());\n    }\n}\n</code></pre> <p>Logs could be collected for any custom logger name or entire package:</p> <pre><code>@RecordLogs(loggers = \"ru.vyarus.dropwizard.guice.test\", level = Level.TRACE)\nRecordedLogs logs;\n</code></pre> <p>Warning</p> <p>Such tests could not be run in parallel because logger configuration is global  (use <code>@Isolated</code> to prevent parallel execution)</p>"},{"location":"guide/test/junit5/logs/#registration","title":"Registration","text":"<p>You can register as many recorders as you like. Each recorder could listen one or more loggers.</p> <p>To listen all warnings (root logger):</p> <pre><code>@RecordLogs(level = Level.WARN)\nRecordedLogs logs;\n</code></pre> <p>To listen all loggers in package:</p> <pre><code>@RecordLogs(loggers = \"com.my.package\", level = Level.WARN)\nRecordedLogs logs;\n</code></pre> <p>To listen exact class and package:</p> <pre><code>@RecordLogs(value = SomeClass.class, loggers = \"com.my.package\", level = Level.INFO)\nRecordedLogs logs;\n</code></pre>"},{"location":"guide/test/junit5/logs/#implementation-details","title":"Implementation details","text":"<p>Each recorder registration leads to logging appender registration for a target logger (or multiple loggers).</p> <p>If the current logger configuration is higher than required, then logger would be re-configured. For example, if default logger level is <code>INFO</code> and recorder requires <code>TRACE</code> messages, then it would change logger configuration to receive required messages.</p> <p>Tip</p> <p>Recorder might be used just to enable required logs, without application logging configuration. This is very useful in tests (to enable <code>DEBUG</code> or <code>TRACE</code> messages for exact service (or package)):  <pre><code>@RecordLogs(value = MyClass.class, level = Level.TRACE) \nRecordedLogs logs;\n</code></pre></p> <p>During application startup dropwizard resets loggers two times and hook would re-attach appenders to compensate it. You should be able to record all messages from application startup, except logs from dropwizard bundles, registered BEFORE <code>GuiceBundle</code>.</p>"},{"location":"guide/test/junit5/logs/#querying","title":"Querying","text":"<p><code>RecordedLogs</code> used to query recorded logs. Root object always contains all recorded events (for configured loggers).</p> <p>Recorded logs are accessible in form of raw event (<code>ILoggingEvent</code>) or pure string message (formatted messages with arguments).</p> Method Description Example <code>count()</code> Recorded logs count <code>assertEquals(1, logs.count())</code> <code>empty()</code> Events recorded <code>assertFalse(logs.empty())</code> <code>events()</code> All recorded events <code>List&lt;ILoggingEvent&gt; events = logs.events()</code> <code>messages()</code> Messages of all recorded messages <code>List&lt;String&gt; messages = logs.messages()</code> <code>has(loggerName)</code> Checks if messages from target logger available <code>assertTrue(logs.has(Service.class))</code>, <code>assertTrue(logs.has(\"com.some\"))</code> <code>has(level)</code> Checks if messages of level available <code>assertTrue(logs.has(Level.WARN))</code> <code>lastEvent()</code> Last recorded event or null <code>assertEquals(Level.WARN, logs.lastEvent().getLevel())</code> <code>lastMessage()</code> Message of the last recorded event or null <code>assertEquals(\"Something\", logs.lastMessage())</code> <p>Also, logs could be filtered:</p> Filter Description Example <code>level(level)</code> Select events with level <code>logs.level(Level.WARN)</code> <code>logger(loggerName)</code> Select events of required loggers <code>logs.logger(Service.class)</code>, <code>logs.logger(\"com.some\")</code> <code>containing(String)</code> Events where messages contains provided string <code>logs.containing(\"Substring\")</code> <code>matching(regex)</code> Events where messages match provided regex <code>logs.matching(\"something \\\\d+\")</code> <code>select(predicate)</code> General events matching predicate <code>logs.select(event -&gt; event.getLevel().equals(Level.TRACE))</code> <p>Filters return another matcher object where all verification and filter methods above could be called (multiple filters could be applied consequently).</p> <p>For example, verify count of all messages containing string:</p> <pre><code>assertEquals(1, logs.containing(\"Something\").count());\n</code></pre> <p>Or filtering by logger and level (if recorder records multiple loggers):</p> <pre><code>assertEquals(12, logs.logger(\"com.some.package\").level(Level.WARN).count())\n</code></pre>"},{"location":"guide/test/junit5/logs/#clear-recordings","title":"Clear recordings","text":"<p>Recorded logs could be cleared at any time (to simplify exact method logs matching):</p> <pre><code>// clear logs, recorded during application startup\nlogs.clear();\n// call method\nservice.foo();\n// verify logs appeared during method call\nassertEquals(1, logs.containing(\"Something\").count());\n\n// clear again to check logs of another method\nlogs.clear();\nservice.boo();\n...\n</code></pre> <p>By default, recorded logs cleared after each test method.  This could be disabled with <code>autoReset</code> option:</p> <pre><code>@RecordLogs(value = MyClass.class, level = Level.INFO, autoReset = false) \nRecordedLogs logs;\n</code></pre>"},{"location":"guide/test/junit5/logs/#debug","title":"Debug","text":"<p>When extension debug is active:</p> <pre><code>@TestGucieyApp(value = App.class, debug = true)\npublic class Test \n</code></pre> <p>All recognized log recorder fields would be logged:</p> <pre><code>Applied log recorders (@RecordLogs) on Test\n\n    #logs                          DEBUG  Service\n</code></pre>"},{"location":"guide/test/junit5/mocks/","title":"Testing with mocks","text":"<p>Mockito mocks are essentially an automatic stubs: with the ability to dynamically declare method behavior (by default, all mock methods  return default value: often null). </p> <p>Mocks declared with a <code>@MockBean</code> annotation.</p> <p>Warning</p> <p>Stubs will not work for HK2 beans     </p> <p>Mockito documentation is written in the <code>Mockito</code> class javadoc. Additional docs could be found in mockito wiki Also, see official mockito refcard and baeldung guides.</p>"},{"location":"guide/test/junit5/mocks/#setup","title":"Setup","text":"<p>Requires mockito dependency (version may be omitted if dropwizard BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre>"},{"location":"guide/test/junit5/mocks/#usage","title":"Usage","text":"<p>Remember</p> <ul> <li>Do not mock types you don\u2019t own</li> <li>Don\u2019t mock value objects</li> <li>Don\u2019t mock everything</li> <li>Show love with your tests!</li> </ul> <p>source, explanations</p> <p>For example, suppose we have a service:</p> <pre><code>public class Service {\n    public String foo() {\n        ...\n    }\n}\n</code></pre> <p>where method foo implements some complex logic, not required in test.</p> <p>To override service with a mock:</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n\n    // register mock (mock would be created automatically using Mockito.mock(Service.class)\n    @MockBean\n    Service mock;\n\n    // injecting here to show that mock replaced real service\n    @Inject\n    Service service;\n\n    @BeforeEach\n    public void setUp() {\n        // declaring behaviour\n        when(mock.foo()).thenReturn(\"static value\");\n    }\n\n    @Test\n    public void test() {\n        // mock instance instead of service\n        Assertions.assertEquals(mock, service);\n        // method overridden            \n        Assertions.assertEquals(\"static value\", service.foo());\n    }\n}\n</code></pre> <p>Here <code>when</code> refer to <code>Mockito.when()</code> used with static import.</p> <p>Important</p> <p>Guice AOP would not be applied to mocks (only guice-managed beans support AOP)</p> <p>You can also provide a pre-created mock instance (useful if mock used during application startup or partial mocks):</p> <pre><code>@MockBean\nstatic Service mock = createMock();\n</code></pre> <p>Note</p> <p>When mock is registered with instance, mock field must be static for per-test application run (default annotation). It may not be static for per-method application startup (with <code>@RegisterExtension</code>).</p>"},{"location":"guide/test/junit5/mocks/#mocking-examples","title":"Mocking examples","text":"<p>Mocking answers for different arguments:</p> <pre><code>when(mock.foo(10)).thenReturn(100);\nwhen(mock.foo(20)).thenReturn(200);\nwhen(mock.foo(30)).thenReturn(300);\n</code></pre> <p>Different method answers (for consequent calls):</p> <pre><code>when(mock.foo(anyInt())).thenReturn(10, 20, 30);\n</code></pre> <p>Using actual argument in mock:</p> <pre><code> when(mock.getValue(anyInt())).thenAnswer(invocation -&gt; {\n        int argument = (int) invocation.getArguments()[0];\n        int result;\n        switch (argument) {\n        case 10:\n            result = 100;\n            break;\n        case 20:\n            result = 200;\n            break;\n        case 30:\n            result = 300;\n            break;\n        default:\n            result = 0;\n        }\n        return result;\n    });\n</code></pre>"},{"location":"guide/test/junit5/mocks/#asserting-calls","title":"Asserting calls","text":"<p>Mock could also be used for calls verification:</p> <pre><code>// method Service.foo() called on mock just once\nverify(mock, times(1)).foo();\n// method Service.bar(12) called just once (with exact argument value)\nverify(mock, times(1)).bar(12);\n</code></pre> <p>These assertions would fail if method was called more times or using different arguments.</p>"},{"location":"guide/test/junit5/mocks/#mock-reset","title":"Mock reset","text":"<p>Mocks are re-set automatically after each test method (and that's why it makes  sense to declare mock behavior in test setup method - execured before each test method).</p> <p>Note</p> <p>Mock could be reset manually at any time with <code>Mockito.reset(mock)</code> </p> <p>Mocks automatic reset could be disabled with <code>autoReset</code> option:</p> <pre><code>@MockBean(autoReset = false)\nService mock;\n</code></pre>"},{"location":"guide/test/junit5/mocks/#partial-mocks","title":"Partial mocks","text":"<p>If mock is applied for a class with implemented methods, these methods would still be overridden with fake implementations. If you want to preserve this logic, then use spies:</p> <pre><code>public class AbstractService implements IService {\n    public abstract String bar();\n\n    public String foo() {\n        return \"value\";\n    }\n}\n\n@TestGuiceyApp(App.class)\npublic class Test {\n\n    @MockBean\n    static IService mock = Mockito.spy(AbstractService.class);\n\n    @Inject \n    IService service;\n\n    @Test\n    public void test() {\n        // default mock implementation for abstract method\n        Assertions.assertNull(service.bar());\n        // implemented method preserved\n        Assertions.assertEquals(\"value\", service.foo());\n    }\n}\n</code></pre> <p>Note</p> <p>The spies section covers only spies, spying on real guice bean instance. Using spies for partial mocks is more related to pure mocking and so it's described here.</p>"},{"location":"guide/test/junit5/mocks/#mocks-report","title":"Mocks report","text":"<p>Mockito provides a mock usage report (<code>Mockito.mockingDetails(value).printInvocations()</code>), which could be enabled with <code>@MockBean(printSummary = true)</code> (report shown after each test method):</p> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 6d420cdd /\n@MockBean stats on [After each] for MockSummaryTest$Test1#test():\n\n    [Mockito] Interactions of: Mock for Service, hashCode: 1340267778\n     1. service.foo(1);\n      -&gt; at ru.vyarus.dropwizard.guice.test.jupiter.setup.mock.MockSummaryTest$Test1.test(MockSummaryTest.java:55)\n       - stubbed -&gt; at ru.vyarus.dropwizard.guice.test.jupiter.setup.mock.MockSummaryTest$Test1.setUp(MockSummaryTest.java:50)\n</code></pre>"},{"location":"guide/test/junit5/mocks/#debug","title":"Debug","text":"<p>When extension debug is active:</p> <pre><code>@TestGucieyApp(value = App.class, debug = true)\npublic class Test \n</code></pre> <p>All recognized mock fields would be logged:</p> <pre><code>Applied mocks (@MockBean) on MockSimpleTest:\n\n    #mock2                         Service2                     (r.v.d.g.t.j.s.m.MockSimpleTest)  AUTO\n    #mock1                         Service1                     (r.v.d.g.t.j.s.m.MockSimpleTest)  AUTO\n</code></pre>"},{"location":"guide/test/junit5/mocks/#mocking-openapi-client","title":"Mocking OpenAPI client","text":"<p>If you use some external API with a client, generated from openapi (swagger) declaration, then you should be using it in code like this:</p> <pre><code>@Inject\nSomeApi api;\n\npublic void foo() {\n    Some response = api.someGetCall(...)\n}\n</code></pre> <p>Where <code>SomeApi</code> is a generated client class.</p> <p>Usually, the simplest way is to record real service response (using swagger UI or other generated documentation) or simply enabling client debug in the application (so all requests and responses would be logged).</p> <p>Store such responses as json files in test resources: e.g. <code>src/test/resources/responses/someGet.json</code></p> <p>Now mocking <code>SomeApi</code> and configure it to return object, mapped from json file content, instead of the real call:</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n    @MockBean\n    SomeApi mock;\n\n    // injecting here to show that mock replaced real service\n    @Inject\n    SomeService service;\n\n    @Inject\n    Environment environment;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        // usually better than new ObjectMapper() (already pre-configured with extensions)\n        ObjectMapper mapper = environment.getObjectMapper();\n        when(mock.someGetCall(...)).thenReturn(mapper.readValue(\n                new File(\"src/test/resources/responses/someGet.json\"), Some.class));\n    }\n\n    @Test\n    public void test() {\n        // call some service using api internally (mock removes external call)\n        service.doSomething();\n    }\n}\n</code></pre> <p>With it, object, mapped from json file, would be returned on service call, instead of the real api.</p> <p>Note</p> <p>In the example, direct file access used instead of classpath lookup because IDEA by default does not copy <code>.json</code> resources (it must be additionally configured) and so direct file access is more universal.</p>"},{"location":"guide/test/junit5/nested/","title":"Junit nested tests","text":"<p>Junit natively supports nested tests.</p> <p>Guicey extensions affects all nested tests below declaration (nesting level is not limited):</p> <pre><code>@TestGuiceyApp(AutoScanApplication.class)\npublic class NestedPropagationTest {\n\n    @Inject\n    Environment environment;\n\n    @Test\n    void checkInjection() {\n        Assertions.assertNotNull(environment);\n    }\n\n    @Nested\n    class Inner {\n\n        @Inject\n        Environment env; // intentionally different name\n\n        @Test\n        void checkInjection() {\n            Assertions.assertNotNull(env);\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>Nested tests will use exactly the same guice context as root test (application started only once).</p> <p>Extension declared on nested test will affect all sub-tests:</p> <pre><code>public class NestedTreeTest {\n\n    @TestGuiceyApp(AutoScanApplication.class)\n    @Nested\n    class Level1 {\n\n        @Inject\n        Environment environment;\n\n        @Test\n        void checkExtensionApplied() {\n            Assertions.assertNotNull(environment);\n        }\n\n        @Nested\n        class Level2 {\n            @Inject\n            Environment env;\n\n            @Test\n            void checkExtensionApplied() {\n                Assertions.assertNotNull(env);\n            }\n\n            @Nested\n            class Level3 {\n\n                @Inject\n                Environment envr;\n\n                @Test\n                void checkExtensionApplied() {\n                    Assertions.assertNotNull(envr);\n                }\n            }\n        }\n    }\n\n    @Nested\n    class NotAffected {\n        @Inject\n        Environment environment;\n\n        @Test\n        void extensionNotApplied() {\n            Assertions.assertNull(environment);\n        }\n    }\n}\n</code></pre> <p>This way nested tests allows you to use different extension configurations in one (root) class.</p> <p>Note that extension declaration with <code>@RegisterExtension</code> on the root class field would also be applied to nested tests. Even declaration in non-static field (start application for each method) would also work.</p>"},{"location":"guide/test/junit5/nested/#use-interfaces-to-share-tests","title":"Use interfaces to share tests","text":"<p>This is just a tip on how to execute same test method in different environments.</p> <pre><code>public class ClientSupportDwTest {\n\n    interface ClientCallTest {\n        // test to apply for multiple environments\n        @Test\n        default void callClient(ClientSupport client) {\n            Assertions.assertEquals(\"main\", client.targetMain(\"servlet\")\n                    .request().buildGet().invoke().readEntity(String.class));\n        }\n    }\n\n    @TestDropwizardApp(App.class)\n    @Nested\n    class DefaultConfig implements ClientCallTest {\n\n        @Test\n        void testClient(ClientSupport client) {\n            Assertions.assertEquals(\"http://localhost:8080/\", client.basePathMain());\n        }\n    }\n\n    @TestDropwizardApp(value = App.class, configOverride = {\n            \"server.applicationContextPath: /app\",\n            \"server.adminContextPath: /admin\",\n    }, restMapping = \"api\")\n    @Nested\n    class ChangedDefaultConfig implements ClientCallTest {\n\n        @Test\n        void testClient(ClientSupport client) {\n            Assertions.assertEquals(\"http://localhost:8080/app/\", client.basePathMain());\n        }\n    }\n}\n</code></pre> <p>Here test declared in <code>ClientCallTest</code> interface will be called for each nested test  (one declaration - two executions in different environments).</p>"},{"location":"guide/test/junit5/output/","title":"Testing console output","text":"<p>There is a utility to capture console output:</p> <pre><code>@Isolated\n@TestWebApp(App.class)\npublic class Test {\n\n    @Test\n    public void testRestCall(ClientSupport client) {\n        String out = TestSupport.captureOutput(() -&gt; {\n            // call application api endpoint\n            client.get(\"sample/get\", null);\n        });\n\n        // uses assert4j, test that client was called (just an example) \n        Assertions.assertThat(out)\n                .contains(\"[Client action]---------------------------------------------{\");\n    }\n}\n</code></pre> <p>Returned output contains both <code>System.out</code> and <code>System.err</code> - same as it would be seen in console.</p> <p>All output is also printed into console to simplify visual validation</p> <p>Warning</p> <p>Such tests could not be run in parallel (due to system io overrides) and so should be  annotated with <code>@Isolated</code></p>"},{"location":"guide/test/junit5/parallel/","title":"Parallel execution","text":""},{"location":"guide/test/junit5/parallel/#parallel-execution","title":"Parallel execution","text":"<p>Junit parallel tests execution could be activated with properties file <code>junit-platform.properties</code> located at test resources root:</p> <pre><code>junit.jupiter.execution.parallel.enabled = true\njunit.jupiter.execution.parallel.mode.default = concurrent\n</code></pre> <p>Note</p> <p>In order to avoid config overriding collisions (because all overrides eventually stored to system properties) guicey generates unique property prefixes in each test.</p> <p>To avoid port collisions in dropwizard tests use randomPorts option.</p>"},{"location":"guide/test/junit5/rest/","title":"Testing rest","text":"<p>Guicey provides lightweight REST testing support: same as dropwizard resource testing support, but with guicey-specific features.</p> <p>Such tests would not start web container: all rest calls are simulated (but still, it tests every part of resource execution).</p> <p>Important</p> <p>Rest stubs work only with lightweight guicey run (they are simply useless when web container started)</p> <p>Lightweight REST could be declared with <code>@StubRest</code> annotation.</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n\n    @StubRest\n    RestClient rest;\n\n    @Test\n    public void test() {\n        String res = rest.get(\"/foo\", String.class);\n        Assertions.assertEquals(\"something\", res);\n\n        WebApplicationException ex = Assertions.assertThrows(WebApplicationException.class,\n                () -&gt; rest.get(\"/error\", String.class));\n        Assertions.assertEquals(\"error message\", ex.getResponse().readEntity(String.class));\n    }\n}\n</code></pre> <p>Note</p> <p>Extension naming is not quite correct: it is not a stub, but real application resources are used. The word \"stub\" used to highlight the fact of incomplete startup: only rest without web.</p> <p>By default, all declared resources would be started with all existing jersey extensions (filters, exception mappers, etc.). Servlets and http filters are not started (guicey disables all web extensions to avoid their (confusing) appearance in console)</p>"},{"location":"guide/test/junit5/rest/#selecting-resources","title":"Selecting resources","text":"<p>Real tests usually require just one resource (to be tested):</p> <pre><code>@StubRest(MyResource.class)\nRestClient rest;\n</code></pre> <p>This way only one resource would be started (and all resources directly registered in application, not as guicey extension). All jersey extensions will remain.</p> <p>Or a couple of resources:</p> <pre><code>@StubRest({MyResource.class, MyResource2.class})\nRestClient rest;\n</code></pre> <p>Or you may disable some resources:</p> <pre><code>@StubRest(disableResources = {MyResource2.class, MyResource3.class})\nRestClient rest;\n</code></pre>"},{"location":"guide/test/junit5/rest/#disabling-jersey-extensions","title":"Disabling jersey extensions","text":"<p>Often jersey extensions, required for the final application, make complications for testing.</p> <p>For example, exception mapper: dropwizard register default exception mapper which returns only the error message, instead of actual exception (and so sometimes we can't check the real cause).</p> <p><code>disableDropwizardExceptionMappers = true</code> disables extensions, registered by dropwizard.</p> <p>When default exception mapper enabled, resource throwing runtime error would return just error code:</p> <pre><code>@Path(\"/some/\")\n@Produces(\"application/json\")\npublic class ErrorResource {\n\n    @GET\n    @Path(\"/error\")\n    public String get() {\n        throw new IllegalStateException(\"error\");\n    }\n}    \n</code></pre> <pre><code>@TestGuiceyApp\npublic class Test {\n\n    @StubRest\n    RestClient rest;\n\n    public void test() {\n        WebApplicationException ex = Assertions.assertThrows(WebApplicationException.class,\n                () -&gt; rest.get(\"/some/error\", String.class));\n\n        // exception hidden, only generic error code\n        Assertions.assertTrue(ex.getResponse().readEntity(String.class)\n                .startsWith(\"{\\\"code\\\":500,\\\"message\\\":\\\"There was an error processing your request. It has been logged\"));\n    }\n}\n</code></pre> <p>Without dropwizard exception mapper, we can verify exact exception:</p> <pre><code>public class Test {\n\n    @StubRest(disableDropwizardExceptionMappers = true)\n    RestClient rest;\n\n    public void test() {\n        ProcessingException ex = Assertions.assertThrows(ProcessingException.class,\n                () -&gt; rest.get(\"/error\", String.class));\n        // exception available\n        Assertions.assertTrue(ex.getCause() instanceof IllegalStateException);\n    }\n}\n</code></pre> <p>It might be useful to disable application extensions also with <code>disableAllJerseyExtensions</code>:</p> <pre><code>```java\n@StubRest(disableDropwizardExceptionMappers = true,\n        disableAllJerseyExtensions = true)\nRestClient rest;\n</code></pre> <p>This way raw resource would be called without any additional logic.</p> <p>Note</p> <p>Only extensions, managed by guicey could be disabled: extensions directly registered in dropwizard would remain.</p> <p>Also, you can select exact extensions to use (e.g., to test it):</p> <pre><code>@StubRest(jerseyExtensions = CustomExceptionMapper.class)\nRestClient rest;\n</code></pre> <p>Or disable only some extensions (for example, disabling extension implementing security):</p> <pre><code>@StubRest(disableJerseyExtensions = CustomSecurityFilter.class)\nRestClient rest;\n</code></pre>"},{"location":"guide/test/junit5/rest/#debug","title":"Debug","text":"<p>Use debug output to see what extensions were actually included and what disabled:</p> <pre><code>@TestGuiceyApp(.., debug = true)\npublic class Test {\n    @StubRest(disableDropwizardExceptionMappers = true,\n            disableResources = Resource2.class,\n            disableJerseyExtensions = RestFilter2.class)\n    RestClient rest;\n}\n</code></pre> <pre><code>REST stub (@StubRest) started on DebugReportTest$Test1:\n\n    Jersey test container factory: org.glassfish.jersey.test.inmemory.InMemoryTestContainerFactory\n    Dropwizard exception mappers: DISABLED\n\n    2 resources (disabled 1):\n        ErrorResource                (r.v.d.g.t.j.s.r.support)  \n        Resource1                    (r.v.d.g.t.j.s.r.support)  \n\n    2 jersey extensions (disabled 1):\n        RestExceptionMapper          (r.v.d.g.t.j.s.r.support)  \n        RestFilter1                  (r.v.d.g.t.j.s.r.support)  \n\n    Use .printJerseyConfig() report to see ALL registered jersey extensions (including dropwizard)\n</code></pre>"},{"location":"guide/test/junit5/rest/#requests-logging","title":"Requests logging","text":"<p>By default, rest client would log requests and responses:</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n\n    @StubRest\n    RestClient rest;\n\n    @Test\n    public void test() {\n        String res = rest.get(\"/foo\", String.class);\n        Assertions.assertEquals(\"something\", res);\n    }\n}\n</code></pre> <pre><code>[Client action]---------------------------------------------{\n1 * Sending client request on thread main\n1 &gt; GET http://localhost:0/foo\n\n}----------------------------------------------------------\n\n\n[Client action]---------------------------------------------{\n1 * Client response received on thread main\n1 &lt; 200\n1 &lt; Content-Length: 3\n1 &lt; Content-Type: application/json\nsomething\n\n}----------------------------------------------------------\n</code></pre> <p>Logging could be disabled with <code>logRequests</code> option: <code>@StubRest(logRequests = false)</code></p>"},{"location":"guide/test/junit5/rest/#container","title":"Container","text":"<p>By default, InMemoryTestContainerFactory used.</p> <pre><code>In-Memory container is not a real container. It starts Jersey application and \ndirectly calls internal APIs to handle request created by client provided by \ntest framework. There is no network communication involved. This containers \ndoes not support servlet and other container dependent features, but it is a \nperfect choice for simple unit tests.\n</code></pre> <p>If it is not enough (in-memory container does not support all functions), then use <code>GrizzlyTestContainerFactory</code></p> <pre><code>The GrizzlyTestContainerFactory creates a container that can run as a light-weight, \nplain HTTP container. Almost all Jersey tests are using Grizzly HTTP test container \nfactory.\n</code></pre> <p>To activate grizzly container add dependency (version managed by dropwizard BOM):</p> <pre><code>testImplementation 'org.glassfish.jersey.test-framework.providers:jersey-test-framework-provider-grizzly2'\n</code></pre> <p>By default, grizzly would be used if it's available on classpath, otherwise in-memory used. If you need to force any container type use:</p> <pre><code>// use in-memory container, even if grizly available in classpath\n// (use to force more lightweight container, even if some tests require grizzly)\n@StubRest(container = TestContainerPolicy.IN_MEMORY)\n</code></pre> <pre><code>// throw error if grizzly container not available in classpath\n// (use to avoid accidental in-memory use)\n@StubRest(container = TestContainerPolicy.GRIZZLY)\n</code></pre>"},{"location":"guide/test/junit5/rest/#rest-client","title":"Rest client","text":"<p><code>RestClient</code> is almost the same as ClientSupport, available for guicey extensions. It is just limited only for rest (and so simpler to use).</p> <p>Note</p> <p>Just in case: <code>ClientSupport</code> would not work with rest stubs (because web container is actually  not started and so <code>ClientSupport</code> can't recognize a correct rest mapping path). Of course, it could be used with a full URLs.</p> <p>Client provides base methods with response mapping:</p> <pre><code>@StubRest\nRestClient rest;\n</code></pre> <ul> <li><code>rest.get(path, Class)</code></li> <li><code>rest.post(path, Object/Entity, Class)</code></li> <li><code>rest.put(path, Object/Entity, Class)</code></li> <li><code>rest.delete(path, Class)</code></li> </ul> <p>To not overload default methods with parameters, additional data could be set with defaults:</p> <ul> <li><code>rest.defaultHeader(String, String)</code></li> <li><code>rest.defaultQueryParam(String, String)</code></li> <li><code>rest.defaultAccept(String...)</code></li> <li><code>rest.defaultOk(Integer...)</code></li> </ul> <p><code>defaultOk</code> used for void responses (response class == null) to check correct response status (default 200 (OK) and 204 (NO_CONTENT)).</p> <p>So if we need to perform a post request with query param and custom header:</p> <pre><code>rest.defaultHeader(\"Secret\", \"unreadable\")\n    .defaultQueryParam(\"foo\", \"bar\");\nOtherModel res = rest.post(\"/somehere\", new SomeModel(), OtherModel.class);\n</code></pre> <p>Note</p> <p>Multipart support is enabled automatically when dropwizard-forms available in classpath</p> <pre><code>FormDataMultiPart multiPart = new FormDataMultiPart();\nmultiPart.setMediaType(MediaType.MULTIPART_FORM_DATA_TYPE);\n\nFileDataBodyPart fileDataBodyPart = new FileDataBodyPart(\"file\",\n        file.toFile(),\n        MediaType.APPLICATION_OCTET_STREAM_TYPE);\nmultiPart.bodyPart(fileDataBodyPart);\n\nrest.post(path, Entity.entity(multiPart, multiPart.getMediaType()), Something.class);\n</code></pre> <p>To clear defaults:</p> <pre><code>rest.reset() \n</code></pre> <p>Might be a part of call chain:</p> <pre><code>rest.reset().post(...) \n</code></pre> <p>When test needs to verify cookies, response headers, etc. use <code>.request(path)</code>:</p> <pre><code>Response response = rest.request(path).get() // .post(), .put(), .delete();\n</code></pre> <p>All defaults are also applied in this case.</p> <p>To avoid applying configured defaults, raw <code>rest.target(path)...</code> could be used.</p>"},{"location":"guide/test/junit5/run/","title":"Testing application","text":"<p>Guicey provides two junit extensions:</p> <ul> <li>@TestGuiceyApp - for lightweight tests (without starting web part, only guice context)</li> <li>@TestDropwizardApp - for complete integration tests</li> </ul> <p><code>@TestGuiceyApp</code> assumed to be used for the majority of tests as it only starts guice injector (which is much faster than complete application startup). Such tests are ideal for testing    business logic (services).</p> <p><code>@TestDropwizardApp</code> (full integration test) used only to check web endpoints and full workflow (assuming all business logic was already tested with lightweight tests)</p> <p>Both extensions:</p> <ul> <li>Inject guice beans directly in test fields.</li> <li>Support method parameters injection</li> <li>Support hooks and setup objects for test configuration</li> <li>Support alternative declaration for deferred configuration   or starting application for each test method. </li> <li>Provide pre-configured http client might be used for calling test application endpoints (or external).</li> <li>Support junit parallel execution (no side effects).</li> </ul> <p>Field annotations:</p> <ul> <li><code>@EnableHook</code> - hooks registration</li> <li><code>@EnableSetup</code> - setup objects registration</li> <li><code>@StubBean</code> - guice bean stubs registration</li> <li><code>@MockBean</code> - guice bean mocks registration (mockito)</li> <li><code>@SpyBean</code> - guice bean spies registration (mockito)</li> <li><code>@TrackBean</code> - guice beans execution tracking (simpler then mockito spies; suitable for performance testing) </li> <li><code>@StubRest</code> - lightweight REST testing</li> <li><code>@RecordLogs</code> - logs testing</li> </ul> <p>Method parameter annotations:</p> <ul> <li><code>@Jit</code> - for not declared guice beans injection</li> </ul>"},{"location":"guide/test/junit5/run/#testing-core-logic","title":"Testing core logic","text":"<p><code>@TestGuiceyApp</code> creates guice injector (runs all application services) without starting jetty (so resources, servlets and filters will not be available). <code>Managed</code> objects will still be handled correctly.</p> <pre><code>@TestGuiceyApp(MyApplication.class)\npublic class AutoScanModeTest {\n\n    @Inject \n    MyService service;\n\n    @Test\n    public void testMyService() {        \n        Assertions.assertEquals(\"hello\", service.getSmth());     \n    }\n</code></pre> <p>Also, injections work as method parameters:</p> <pre><code>@TestGuiceyApp(MyApplication.class)\npublic class AutoScanModeTest {\n\n    public void testMyService(MyService service) {        \n        Assertions.assertEquals(\"hello\", service.getSmth());     \n    }\n</code></pre> <p>Application started before all tests in annotated class and stopped after them.</p>"},{"location":"guide/test/junit5/run/#annotation-options","title":"Annotation options","text":"Option Description Default config Configuration file path \"\" configOverride Configuration file overriding values {} configModifiers Configuration object modifier {} hooks Hooks to apply {} setup Setup objects to apply {} injectOnce Inject test fields just one for multiple test methods with one test instance false debug Enable extension debug output false reuseApplication Use the same application instance for multiple tests false useDefaultExtensions Use default guicey field extensions true clientFactory Custom client factory to use <code>DefaultTestClientFactory</code> managedLifecycle Managed beans lifecycle simulation true"},{"location":"guide/test/junit5/run/#managed-lifecycle","title":"Managed lifecycle","text":"<p>Core application tests (<code>@TestGuiceyApp</code>) does not start web part and so lifecycle should not work, but <code>Managed</code> objects often used to initialize core services.   </p> <p>Guicey core test simulate <code>Managed</code> lifecycle (call start and stop methods). For tests, not requiring lifecycle at all, it might be disabled with:</p> <pre><code>@TestGuiceyApp(value = App.class, managedLifecycle = false)\n</code></pre> <p>or</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        ...\n        .disableManagedLifecycle()\n</code></pre> <p>Note</p> <p>Application lifecycle will remain: events like <code>onApplicationStartup</code> would still be working (and all registered <code>LifeCycle</code> objects would work). Only managed objects ignored.</p>"},{"location":"guide/test/junit5/run/#testing-web-logic","title":"Testing web logic","text":"<p><code>@TestDropwizardApp</code> is useful for complete integration testing (when web part is required):</p> <pre><code>@TestDropwizardApp(MyApplication.class)\nclass WebModuleTest {\n\n    @Inject \n    MyService service\n\n    @Test\n    public void checkWebBindings(ClientSupport client) {\n\n        Assertions.assertEquals(\"Sample filter and service called\", \n            client.targetMain(\"servlet\").request().buildGet().invoke().readEntity(String.class));\n\n        Assertions.assertTrur(service.isCalled());\n</code></pre> <p><code>@TestDropwizardApp</code> contains the same annotation options as core test, but without lifecycle simulation (lifecycle managed by started server).</p>"},{"location":"guide/test/junit5/run/#random-ports","title":"Random ports","text":"<p>In order to start application on random port you can use configuration shortcut:</p> <pre><code>@TestDropwizardApp(value = MyApplication.class, randomPorts = true)\n</code></pre> <p>Note</p> <p>Random ports setting override exact ports in configuration: <pre><code>@TestDropwizardApp(value = MyApplication, \n                  config = 'path/to/my/config.yml', \n                  randomPorts = true)\n</code></pre> Also, random ports support both server types (default and simple)</p> <p>Real ports could be resolved with ClientSupport object.</p>"},{"location":"guide/test/junit5/run/#rest-mapping","title":"Rest mapping","text":"<p>Normally, rest mapping configured with <code>server.rootMapping=/something/*</code> configuration, but if you don't use custom configuration class, but still want to re-map rest, shortcut could be used:</p> <pre><code>@TestDropwizardApp(value = MyApplication.class, restMapping=\"something\")\n</code></pre> <p>In contrast to config declaration, attribute value may not start with '/' and end with '/*' - it would be appended automatically. </p> <p>This option is only intended to simplify cases when custom configuration file is not yet used in tests (usually early PoC phase). It allows you to map servlet into application root in test (because rest is no more resides in root). When used with existing configuration file, this parameter will override file definition.</p>"},{"location":"guide/test/junit5/run/#alternative-declaration","title":"Alternative declaration","text":"<p>Both extensions could be declared in fields:</p> <pre><code>@RegisterExtension\nstatic TestDropwizardAppExtension app = TestDropwizardAppExtension.forApp(AutoScanApplication.class)\n        .config(\"src/test/resources/ru/vyarus/dropwizard/guice/config.yml\")\n        .configOverrides(\"foo: 2\", \"bar: 12\")\n        .randomPorts()\n        .hooks(Hook.class)\n        .hooks(builder -&gt; builder.disableExtensions(DummyManaged.class))\n        .create();\n</code></pre> <p>The only difference with annotations is that you can declare hooks and setup objects as lambdas directly  (still hooks in static fields will also work).</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension app = TestGuiceyAppExtension.forApp(AutoScanApplication.class)\n        ...\n</code></pre> <p>This alternative declaration is intended to be used in cases when guicey extensions need to be aligned with other 3<sup>rd</sup> party extensions: in junit you can order extensions declared with annotations (by annotation order) and extensions declared with <code>@RegisterExtension</code> (by declaration order). But there is no way to order extension registered with <code>@RegisterExtension</code> before annotation extension.</p> <p>So if you have 3<sup>rd</sup> party extension which needs to be executed BEFORE guicey extensions, you can use field declaration.</p> <p>Note</p> <p>Junit 5 intentionally shuffle <code>@RegisterExtension</code> extensions order, but you can always order them with <code>@Order</code> annotation.</p>"},{"location":"guide/test/junit5/run/#start-application-per-test-method","title":"Start application per test method","text":"<p>When you declare extensions with annotations or with <code>@RegisterExtension</code> in static fields, application would be started before all test methods and shut down after last test method.</p> <p>If you want to start application for each test method then declare extension in non-static field:</p> <pre><code>@RegisterExtension\nTestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(App.class).create()\n\n// injection would be re-newed for each test method\n@Inject Bean bean;\n\n@Test\npublic void test1() {\n    Assertions.assertEquals(0, bean.value);\n    // changing value to show that bean was reset between tests\n    bean.value = 10    \n}\n\n@Test\npublic void test2() {\n    Assertions.assertEquals(0, bean.value);\n    bean.value = 10\n}\n</code></pre> <p>Also, <code>@EnableHook</code> and <code>@EnableSetup</code> fields might also be not static (but static fields would also work) in this case:</p> <pre><code>@RegisterExtension\nTestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(App.class).create()\n\n@EnableSetup\nMySetup setup = new MySetup()\n</code></pre>"},{"location":"guide/test/junit5/setup-object/","title":"Test environment setup","text":"<p>It is often required to prepare test environment before starting dropwizard application. Normally, such cases require writing custom junit extensions. In order to simplify environment setup, guicey provides <code>TestEnviromentSetup</code> interface.</p> <p>Setup objects are called before application startup and could directly apply (through parameter) configuration overrides and hooks.</p> <p>Info</p> <p>As hooks could modify application configuration, setup object modifies test extension configuration (hook - extra application functionality, setup object - extra test functionality).</p> <p>For example, suppose you need to set up a database before test:</p> <pre><code>public class TestDbSetup implements TestEnvironmentSetup {\n\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        // pseudo code\n        Db db = DbFactory.startTestDb();\n        // register required configuration\n        extension\n                .configOverride(\"database.url\", ()-&gt; db.getUrl())\n                .configOverride(\"database.user\", ()-&gt; db.getUser())\n                .configOverride(\"database.password\", ()-&gt; db.getPassword);\n        // assuming object implements Closable\n        return db;\n    }\n}\n</code></pre> <p>It is not required to return anything, only if something needs to be closed after application shutdown: objects other than <code>Closable</code> (<code>AutoClosable</code>) or <code>org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource</code> simply ignored. This approach (only one method) simplifies interface usage with lambdas.</p> <p>Setup object might be declared in extension annotation: </p> <pre><code>@TestGuiceyApp(value=App.class, setup=TestDbSetup.class)\n</code></pre> <p>Or in manual registration:</p> <pre><code>@RegisterExtension\nTestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(App.class)\n        // as class\n        .setup(TestDbSetup.class)\n        // or as instance\n        .setup(new TestDbSetup())\n</code></pre> <p>Or with lambda:</p> <pre><code>.setup(ext -&gt; {\n        Db db = new Db();\n        ext.configOverride(\"db.url\", ()-&gt;db.getUrl())\n        return db;\n})\n</code></pre>"},{"location":"guide/test/junit5/setup-object/#setup-fields","title":"Setup fields","text":"<p>Alternatively, setup objects might be declared simply in test fields:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup db = ext -&gt; {\n            Db db = new Db();\n            ext.configOverride(\"db.url\", ()-&gt;db.getUrl())\n            return db;\n        };\n</code></pre> <p>or</p> <pre><code>@EnableSetup\nstatic TestDbSetup db = new TestDbSetup()\n</code></pre> <p>This could be extremely useful if you need to unify setup logic for multiple tests, but use different extension declarations in test. In this case simply move field declaration into base test class:</p> <pre><code>public abstract class BaseTest {\n\n    @EnableSetup\n    static TestDbSetup db = new TestDbSetup();\n}\n</code></pre> <p>Note</p> <p>To avoid confusion with guicey hooks: setup object required to prepare test environment before test (and apply required configurations) whereas hooks is a general mechanism for application customization (not only in tests). Setup objects are executed before application startup (before <code>DropwizardTestSupport</code> object creation) and hooks are executed by started application.</p>"},{"location":"guide/test/junit5/setup-object/#custom-configuration-block","title":"Custom configuration block","text":"<p>To simplify field-based declarations, custom (free) block added (<code>.with()</code>):</p> <pre><code>@RegisterExtension\nstatic TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(..)\n        ...\n        .with(builder -&gt; {\n            if (...) {\n               builder.configOverrides(\"foo.bar\", 12); \n            }\n        }) \n</code></pre> <p>And the same for setup objects:</p> <pre><code>@EnableSetup\nstatic TestEnvironmentSetup setup = ext -&gt;\n        ...\n        .with(builder -&gt; {\n            ...\n        }) \n</code></pre>"},{"location":"guide/test/junit5/setup-object/#builder-configuration","title":"Builder configuration","text":"<p><code>TestExtension</code> builder provides almost the same options as the main guice extension builder (when declared in field) </p> Method Description Example <code>.config(ThrowingSupplier)</code> Manual configuration object creation (config overrides will not work) <code>.config(()-&gt; new MyConfig())</code> <code>.configOverrides(String...)</code> Multiple configuration override values in \"key: value\" form. <code>.configOverrides(\"foo: 10\", \"bar: 12\")</code> <code>.configOverrides(ConfigOverride &amp; ConfigurablePrefix)</code> Config override object (used for deferred values) <code>.configOverrides(new ConfigOverrideValue(\"baa\", () -&gt; \"44\"))</code> <code>.configOverride(String, String)</code> Single config path override <code>.configOverride(\"some.foo\", \"12\")</code> <code>.configOverride(String, Supplier&lt;String&gt;)</code> Deferred config override value <code>.configOverride(\"foo\", () -&gt; \"1\")</code> <code>.configOverrideByExtension(ExtensionContext.Namespace, String)</code> 3<sup>rd</sup> party junit extension integration <code>.configOverrideByExtension(ExtensionContext.Namespace.GLOBAL, \"foo\")</code> <code>.configOverrideByExtension(ExtensionContext.Namespace, String, String)</code> 3<sup>rd</sup> party junit extension integration <code>.configOverrideByExtension(ExtensionContext.Namespace.create(\"sample\"), \"storKey\", \"foo\")</code> <code>.hooks(GuiceyConfigurationHook)</code> Hooks registration <code>.hooks(builder -&gt; builder.disableExtensions(Something.class))</code> <code>.configModifiers(ConfigModifier...)</code> Config modifier registration <code>.&lt;MyConfig&gt;configModifiers(config -&gt; config.bar = 11)</code> <code>.injectOnce()</code> Process test fields injection only once (for same test instance) <code>.debug()</code> Enable debug output <code>.reuseApplication()</code> Use the same application instance for multiple tests <code>.disableDefaultExtensions()</code> Disable setup objects loading with service lookup (and so default extensions) <code>.clientFactory(TestClientFactory)</code> Custom web client client factory (used in <code>ClientSupport</code>) <p>Specific options:</p> Method Description <code>.isDebug()</code> Identifies activated debug mode <code>.isApplicationStartedForClass()</code> Shortcut to differentiate application started for test calss or every method <code>.getJunitContext()</code> Access junit <code>ExtensionContext</code>"},{"location":"guide/test/junit5/setup-object/#lifecycle","title":"Lifecycle","text":"<p>Setup object could react on test lifecycle events: <code>.listen(TestExecutionListener)</code>:</p> <pre><code>public interface TestExecutionListener {\n    default void starting(final EventContext context) throws Exception {}\n    default void started(final EventContext context) throws Exception {}\n    default void beforeAll(final EventContext context) throws Exception {}\n    default void beforeEach(final EventContext context) throws Exception {}\n    default void afterEach(final EventContext context) throws Exception {}\n    default void afterAll(final EventContext context) throws Exception {}\n    default void stopping(final EventContext context) throws Exception {}\n    default void stopped(final EventContext context) throws Exception {}\n}\n</code></pre> <p>Complex setup objects might simply <code>implement TestExecutionListener</code> and register self: </p> <pre><code>public class MySetup implements TestEnvironmentSetup, TestExecutionListener {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n        extension.listen(this);\n    }\n\n    @Override\n    public void started(final EventContext context) throws Exception {\n        // something\n    }\n}\n</code></pre> <p>To simplify usage with setup fields, separate listener methods available to use with lambdas:</p> <pre><code>public class Test {\n\n    @EnableSetup\n    static TestDbSetup db = ext - &gt; ext\n            .onApplicationStarting(event -&gt; ...)\n            .onApplicationStart(event -&gt; ...)\n            .onBeforeAll(event -&gt; ...)\n            .onBeforeEach(event -&gt; ...)\n            .onAfterEach(event -&gt; ...)\n            .onAfterAll(event -&gt; ...)\n            .onApplicationStopping(event -&gt; ...)\n            .onApplicationStop(event -&gt; ...)\n}\n</code></pre> <p>Events:</p> Listener Shortcut method Description Junit phase <code>starting</code> <code>onApplicationStarting</code> Just before application starting BeforeAll or BeforeEach <code>started</code> <code>onApplicationStart</code> Application started BeforeAll or BeforeEach <code>beforeAll</code> <code>onBeforeAll</code> Before all test methods (might not be called if extension registered per method) BeforeAll or not called <code>beforeEach</code> <code>onBeforeEach</code> Before each test method BeforeEach <code>afterEach</code> <code>onAfterEach</code> After each test method AfterEach <code>afterAll</code> <code>onAfterAll</code> After all test methods (might not be called if extension registered per method) AfterAll or not called <code>stopping</code> <code>onApplicationStopping</code> Just before application stopping AfterAll or AfterEach <code>stopped</code> <code>onApplicationStop</code> Application stopped AfterAll or AfterEach <p><code>EventContext</code> parameter provides access for guice injector, DropwizardTestSupport object and junit 5 context.</p> <p>As you can see, events cover all junit lifecycle events together with application specific events. Which makes setup objects a complete alternative to pure junit extensions.</p>"},{"location":"guide/test/junit5/setup-object/#auto-lookup","title":"Auto lookup","text":"<p>Custom <code>TestEnvironmentSetup</code> objects could be loaded automatically with service loader. New default extensions already use service loader.</p> <p>To enable automatic loading of custom extension add: <code>META-INF/services/ru.vyarus.dropwizard.guice.test.jupiter.env.TestEnvironmentSetup</code></p> <p>And put there required setup object classes (one per line), like this:</p> <pre><code>ru.vyarus.dropwizard.guice.test.jupiter.ext.log.RecordedLogsSupport\nru.vyarus.dropwizard.guice.test.jupiter.ext.rest.RestStubSupport\nru.vyarus.dropwizard.guice.test.jupiter.ext.stub.StubsSupport\nru.vyarus.dropwizard.guice.test.jupiter.ext.mock.MocksSupport\n</code></pre> <p>Now, when setup objects have more abilities, more custom test extensions could be implemented (see new filed-based extensions below). Automatic installation for such 3<sup>rd</sup> party extensions (using service loader) should simplify overall usage.</p> <p>Note</p> <p>Service loading for extensions could be disabled (together with new default extensions): <pre><code>@TestGuiceyApp(.., useDefaultExtensions = false)\n</code></pre></p>"},{"location":"guide/test/junit5/setup-object/#annotated-fields-support","title":"Annotated fields support","text":"<p><code>TestExtension</code> builder provides a special method to search annotated test fields: <code>.findAnnotatedFields()</code>.</p> <pre><code>public class Test {\n     @MyAnn\n     Base field;\n}\n</code></pre> <pre><code>public class CustomFieldsSupport implements TestEnvironmentSetup {\n    @Override\n    public Object setup(TestExtension extension) throws Exception {\n\n        List&lt;AnnotatedField&lt;MyAnn, Base&gt;&gt; fields = extension\n                .findAnnotatedFields(MyAnn.class, Base.class);\n    }\n</code></pre> <p>Out of the box, API provides many checks, like required base class (it could be Object to avoid check): if annotated field type is different - error would be thrown.</p> <p>Returned object is also an abstraction: <code>AnnotatedField</code> - it simplifies working with filed value, plus contains additional checks.</p> <p>The main idea is keeping annotation, filed and actual value (that must be injected into test field) in one object (for simplicity - no need to maintain external state).</p>"},{"location":"guide/test/junit5/setup-object/#writing-annotated-field-support","title":"Writing annotated field support","text":"<p>There is a special base class <code>AnnotatedTestFieldSetup</code> which implements base fields workflow (including proper nested tests support).</p> <p>Use this class if you want to implement new field annotation (<code>@MyAnnotation</code>) support:</p> <pre><code>public class MyFieldsSupport extends AnnotatedTestFieldSetup&lt;MyAnnotation, Object&gt;  \n</code></pre> <p>If your field value would always base on some class then specify it to automatically apply related field validations: <code>AnnotatedTestFieldSetup&lt;MyAnnotation, MyBaseClass&gt;</code></p> <p>All current field extensions are using this base class, so you can see usage examples in:</p> <ul> <li><code>StubFieldsSupport</code> - @StubBean</li> <li><code>MockFieldsSupport</code> - @MockBean</li> <li><code>SpyFieldsSupport</code> - @SpyBean</li> <li><code>LogFieldsSupport</code> - @RecordLogs</li> <li><code>TrackerFieldsSupport</code> - @TrackBean</li> <li><code>RestStubFieldsSupport</code> - @StubRest</li> </ul> <p>Base class would search for all annotated fields and call other methods only if  anything was found.</p> <p>Important</p> <p>It is recommended to implement core extension logic inside the hook and use setup object obly to configure that hook. This way setup object would be simpler. (all extensions above use separate hooks).</p> <p>The following methods should be implemented:</p> Method Description Stage fieldDetected Validate resolved field, if required. Anything that could not be checked automatically beforeAll or beforeEach, app not started registerHooks Register hook instance (hook used to apply extensions, override guice bindings etc.). beforeAll or beforeEach, app not started initializeField Here value must be prepared to inject into annotated field. Or user-provided value must be validated beforeAll or beforeEach, app not started beforeValueInjection Called just before injecting value into test field. Good point to apply remaining validations (e.g. requireing started injector) beforeAll and beforeEach (called up to 2 times), app started injectFieldValue Called to provide field value for injection (if pre-initializerd by user - method not called) beforeAll and beforeEach (called up to 2 times), app started report Debug report (list detected fields). Report is called when root extension debug is enabled beforeAll or beforeEach, app started beforeTest Called to call lifecycle method before test (like state clearing) beforeEach, app started afterTest Called to call lifecycle method after test (like state clearing) beforeEach, app started <p>Take a look at <code>MockFieldsSupport</code> - it is a simple and easy to understand implementation.</p>"},{"location":"guide/test/junit5/setup-object/#fielddetected","title":"fieldDetected","text":"<p>Method called as soon as field is detected:</p> <ul> <li>Ideal place for an additional validations (<code>TrackerFieldsSupport</code> validates field type there) </li> <li>This is the earliest point: <code>LogFieldsSupport</code> use it to activate logger immediately</li> </ul>"},{"location":"guide/test/junit5/setup-object/#registerhooks","title":"registerHooks","text":"<p>Usually simple hook registration. Only <code>RestStubFieldsSupport</code> use it to register 2 hooks (second hook validates application scope: in theory could be implemented in one hook but guicey implements generic  hooks which could be used without junit).</p>"},{"location":"guide/test/junit5/setup-object/#initializefield","title":"initializeField","text":"<p>Here we validate user-provided value or create new value.</p> <p>For example, mocks hook (<code>MockFieldsSupport</code>):</p> <pre><code>@Override\n@SuppressWarnings(\"unchecked\")\nprotected &lt;K&gt; void initializeField(final AnnotatedField&lt;MockBean, Object&gt; field, final Object userValue) {\n    final Class&lt;? super K&gt; type = field.getType();\n    if (userValue != null) {\n        Preconditions.checkState(MockUtil.isMock(userValue), getDeclarationErrorPrefix(field)\n                + \"initialized instance is not a mockito mock object. Either provide correct mock or remove value \"\n                + \"and let extension create mock automatically.\");\n        hook.mock(type, (K) userValue);\n    } else {\n        // no need to store custom data for manual value - injectFieldValue not called for manual values \n        field.setCustomData(FIELD_MOCK, hook.mock(type));\n    }\n}\n</code></pre> <p>Note that value is stored inside an <code>AnnotatedField</code> object: <code>field.setCustomData(FIELD_MOCK, hook.mock(type));</code> (for user-provided value, it is stored automatically).</p> <p>This is a not required step: for example, <code>LogFieldsSupport</code> create value object just after field detection (because logger must be appended as soon as possible), and so ignored <code>initializeField</code> method.</p> <p>Another example is <code>StubFieldsSupport</code> - where <code>initializeField</code> method used just for  stub registration in hook. Value for injection into test field is obtained later directly from guice injector (stub could be declared by class - instance is guice managed).</p>"},{"location":"guide/test/junit5/setup-object/#beforevalueinjection","title":"beforeValueInjection","text":"<p>For remaining validation (when injector is required). For example, <code>SpyFieldsSupport</code> use it to validatate if target bean is managed by guice (spy use AOP and can't work with bean bound by instance) Same story for <code>TrackerFieldsSupport</code>.</p> <p>There is even a helper method to validate non-instance bindings: <code>isInstanceBinding(binding)</code></p>"},{"location":"guide/test/junit5/setup-object/#injectfieldvalue","title":"injectFieldValue","text":"<p>Method called only for not pre-initialized fields (no user value). </p> <p>In most cases, it just provides a value, created in <code>initializeField</code>:</p> <pre><code>@Override\nprotected Object injectFieldValue(final EventContext context, final AnnotatedField&lt;MockBean, Object&gt; field) {\n    return Preconditions.checkNotNull(field.getCustomData(FIELD_MOCK), \"Mock not created\");\n}\n</code></pre> <p>Stubs extension rely on guice context (because stub could be guice-meneged):</p> <pre><code>@Override\nprotected Object injectFieldValue(final EventContext context, final AnnotatedField&lt;StubBean, Object&gt; field) {\n    // if not declared, stub value created by guice\n    return context.getBean(field.getAnnotation().value());\n}\n</code></pre>"},{"location":"guide/test/junit5/setup-object/#report","title":"report","text":"<p>Report assumed to show detected fields when root extension debug is enabled. See example report in any extension.</p>"},{"location":"guide/test/junit5/setup-object/#beforetest-and-aftertest","title":"beforeTest and afterTest","text":"<p>Special methods for implementing field value lifecycle.  Almost all values have to be reset after each test method (mocks, spies, stubs etc.). </p> <p>Example from logs extension:</p> <pre><code> @Override\nprotected void afterTest(final EventContext context,\n                         final AnnotatedField&lt;RecordLogs, RecordedLogs&gt; field, final RecordedLogs value) {\n    if (field.getAnnotation().autoReset()) {\n        value.clear();\n    }\n}\n</code></pre> <p>Mocks and speies use this method also to print summary report (if requested in annoation):</p> <pre><code>@Override\n@SuppressWarnings(\"PMD.SystemPrintln\")\nprotected void afterTest(final EventContext context,\n                         final AnnotatedField&lt;MockBean, Object&gt; field, final Object value) {\n    if (field.getAnnotation().printSummary()) {\n        final String res = Mockito.mockingDetails(value).printInvocations();\n        System.out.println(PrintUtils.getPerformanceReportSeparator(context.getJunitContext())\n                + \"@\" + MockBean.class.getSimpleName() + \" stats on [After each] for \"\n                + TestSetupUtils.getContextTestName(context.getJunitContext()) + \":\\n\\n\"\n                + Arrays.stream(res.split(\"\\n\")).map(s -&gt; \"\\t\" + s).collect(Collectors.joining(\"\\n\")));\n    }\n    if (field.getAnnotation().autoReset()) {\n        Mockito.reset(value);\n    }\n}\n</code></pre>"},{"location":"guide/test/junit5/setup/","title":"JUnit 5","text":"<p>Junit 5 user guide | Migration from JUnit 4</p>"},{"location":"guide/test/junit5/setup/#setup","title":"Setup","text":"<p>You will need the following dependencies (assuming BOM used for versions management):</p> <pre><code>testImplementation 'io.dropwizard:dropwizard-testing'\ntestImplementation 'org.junit.jupiter:junit-jupiter-api'\ntestRuntimeOnly 'org.junit.jupiter:junit-jupiter'\n</code></pre> <p>Tip</p> <p>If you already have junit4 or spock tests, you can activate vintage engine  so all tests could work  together with junit 5:  <pre><code>testRuntimeOnly 'org.junit.vintage:junit-vintage-engine'\n</code></pre></p> <p>Note</p> <p>In gradle you need to explicitly activate junit 5 support with <pre><code>test {\n    useJUnitPlatform()\n    ...\n}                    \n</code></pre></p> <p>Warning</p> <p>Junit 5 annotations are different from junit4, so if you have both junit 5 and junit 4 make sure correct classes (annotations) used for junit 5 tests: <pre><code>import org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n</code></pre></p>"},{"location":"guide/test/junit5/setup/#dropwizard-extensions-compatibility","title":"Dropwizard extensions compatibility","text":"<p>Guicey extensions could be used together with dropwizard  extensions. It could be used to start multiple dropwizard applications.</p> <p>For example:</p> <pre><code>// run app (injector only)\n@TestGuiceyApp(App.class)\n// activate dropwizard extensions\n@ExtendWith(DropwizardExtensionsSupport.class)\npublic class ClientSupportGuiceyTest {\n\n    // Use dropwizard extension to start a separate server\n    // It might be the same application or different \n    // (application instances would be different in any case)\n    static DropwizardAppExtension app = new DropwizardAppExtension(App.class);\n\n    @Test\n    void testLimitedClient(ClientSupport client) {\n        Assertions.assertEquals(200, client.target(\"http://localhost:8080/dummy/\")\n                .request().buildGet().invoke().getStatus());\n    }\n}\n</code></pre> <p>Info</p> <p>There is a difference in extensions implementation. </p> <p>Dropwizard extensions work as: junit extension <code>@ExtendWith(DropwizardExtensionsSupport.class)</code> looks for fields  implementing <code>DropwizardExtension</code> (like <code>DropwizardAppExtension</code>) and start/stop them according to test lifecycle.</p> <p>Guicey extensions implemented as separate junit extensions (only some annotated fields are manually searched  (hooks, setup objects, special extensions).  Also, guciey extensions implement junit parameters injection (for test and lifecycle methods). </p>"},{"location":"guide/test/junit5/spies/","title":"Testing with spies","text":"<p>Mockito spies allows dynamic modification of real objects behavior (configured same as mocks, but, by default, all methods work as in raw bean).</p> <p>Spies declared with a <code>@SpyBean</code> annotation.</p> <p>Important</p> <p>Spy creation requires real bean instance and so guicey use AOP to intercept real bean access and redirecting all calls through a dynamically created (on first access) spy object. This means that spies would only work with guice-managed beans.</p> <p>If you need to spy for a manual instance - use partial mocks</p> <p>Warning</p> <p>Spies will not work for HK2 beans</p> <p>Mockito documentation is written in the <code>Mockito</code> class javadoc. Additional docs could be found in mockito wiki Also, see official mockito refcard and baeldung guides.</p>"},{"location":"guide/test/junit5/spies/#setup","title":"Setup","text":"<p>Requires mockito dependency (version may be omitted if dropwizard BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre>"},{"location":"guide/test/junit5/spies/#usage","title":"Usage","text":"<p>Suppose we have a service:</p> <pre><code>public static class Service {\n\n    public String get(int id) {\n        return \"Hello \" + id;\n    }\n}\n</code></pre> <p>Spying it:</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n\n    @SpyBean\n    Service spy;\n\n    // NOT the same instance as spy (but calls on both objects are equivalent)\n    @Inject\n    Service service;\n\n    @BeforeEach\n    public void setUp() {\n        // IMPORTANT: spies configured in reverse order to avoid accidental method call            \n        doReturn(\"bar1\").when(spy).get(11);\n    }\n\n    @Test\n    public void test() {\n        // stubbed result\n        Assertions.assertEquals(\"bar1\", s1.get(11));\n        // real method result (because argument is different)\n        Assertions.assertEquals(\"Hello 10\", s1.get(10)); \n    }\n}\n</code></pre> <p>Here <code>doReturn</code> refer to <code>Mockito.doReturn</code> used with static import.</p> <p>Note</p> <p>As real guice bean used under the hood, all AOP, applied to the original bean, will work.</p> <p>Tip</p> <p>Calling guice proxy <code>service.get(11)</code> and spy object directly <code>spy.get(11)</code> is equivalent (because guice returns AOP proxy which redirects call to the spy)</p> <p>See other examples in mocks section.</p>"},{"location":"guide/test/junit5/spies/#asserting-calls","title":"Asserting calls","text":"<p>Tip</p> <p>If you want to use spies to track bean access (verify arguments and response) then try trackers which are better match for this case.</p> <p>As mocks, spies could be used to assert calls:</p> <pre><code>// method Service.get(11) called on mock just once\nverify(spy, times(1)).get(11);\n</code></pre> <p>These assertions would fail if method was called more times or using different arguments.</p>"},{"location":"guide/test/junit5/spies/#method-result-capture","title":"Method result capture","text":"<p>Verifying method return value with spies is a bit clumsy:</p> <pre><code>public static class ResultCaptor&lt;T&gt; implements Answer {\n    private T result = null;\n    public T getResult() {\n        return result;\n    }\n\n    @Override\n    public T answer(InvocationOnMock invocationOnMock) throws Throwable {\n        result = (T) invocationOnMock.callRealMethod();\n        return result;\n    }\n}\n\n@TestGuiceyApp(App.class)\npublic class Test {\n    ResultCaptor&lt;String&gt; resultCaptor = new ResultCaptor&lt;&gt;();\n    // capture actual argument value (just to show how to do it)\n    ArgumentCaptor&lt;Integer&gt; argumentCaptor = ArgumentCaptor.forClass(Integer.class);\n\n    @SpyBean \n    Service spy;\n\n    @BeforeAll\n    public void setUp() {\n        doAnswer(resultCaptor).when(spy).get(argumentCaptor.capture());\n    }\n\n    public void test() {\n        // call method\n        Assertions.assertThat(spy.get(11)).isEqualTo(\"bar\");\n        // result captured\n        Assertions.assertThat(resultCaptor.getResult()).isEqualTo(\"bar\");\n        Assertions.assertThat(argumentCaptor.getValue()).isEqualTo(11);\n\n        verify(spy, Mockito.times(1)).get(11);\n    }\n}\n</code></pre> <p>Why would you need that? It is often useful when verifying indirect bean call. For example, if we have <code>SuperService</code> which internally calls <code>Service</code> and so  there is no other way to verify service call result correctness other than spying it (or use tracker).</p>"},{"location":"guide/test/junit5/spies/#pre-initialization","title":"Pre initialization","text":"<p>As spy object creation is delayed until application startup, it is impossible to configure spy before application startup (as with mocks). Usually it is not a problem, if target bean is not called during startup.</p> <p>If you need to modify behavior of spy, used during application startup (e.g. by some <code>Managed</code>), then there is a delayed initialization mechanism:</p> <pre><code>// extra class required to overcome annotation limitation\npublic class Initializer implements Consumer&lt;Service&gt; {\n    // real spy could be created ONLY after injector startup\n    @Override\n    public void accept(Service spy) {\n        doReturn(\"spied\").when(service).get(11); \n    }\n\n}\n\n@TestGuiceyApp(App.class)\npublic class Test {\n\n    @SpyBean(initializers = Initializer.class)\n    Service spy;\n\n    ...\n}\n</code></pre> <p>Here, <code>Initializer</code> would be called just after spy creation (on first access).</p> <p>And so any <code>Managed</code>, calling it during startup would use completely configured spy:</p> <pre><code>@Singleton\npublic static class Mng implements Managed {\n    @Inject\n    Service service;\n\n    @Override\n    public void start() throws Exception {\n        // \"spied\" result\n        service1.get(11);\n    }\n}\n</code></pre>"},{"location":"guide/test/junit5/spies/#spies-reset","title":"Spies reset","text":"<p>Spies are re-set automatically after each test method (and that's why it makes sense to declare mock behavior in test setup method - execured before each test method).</p> <p>Note</p> <p>Spy could be reset manually at any time with <code>Mockito.reset(spy)</code></p> <p>Spies automatic reset could be disabled with <code>autoReset</code> option:</p> <pre><code>@SpyBean(autoReset = false)\nService spy;\n</code></pre>"},{"location":"guide/test/junit5/spies/#spies-report","title":"Spies report","text":"<p>Same as for mocks, a usage report could be printed after each test <code>@SpyBean(printSummary = true)</code></p> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 285bf5ac /\n@SpyBean stats on [After each] for SpySummaryTest$Test1#test():\n\n    [Mockito] Interactions of: ru.vyarus.dropwizard.guice.test.jupiter.setup.spy.SpySummaryTest$Service$$EnhancerByGuice$$60e90c@40fe8fd5\n     1. spySummaryTest$Service$$EnhancerByGuice$$60e90c.foo(\n        1\n    );\n      -&gt; at ru.vyarus.dropwizard.guice.test.jupiter.setup.spy.SpySummaryTest$Test1.test(SpySummaryTest.java:50)\n</code></pre>"},{"location":"guide/test/junit5/spies/#debug","title":"Debug","text":"<p>When extension debug is active:</p> <pre><code>@TestGucieyApp(value = App.class, debug = true)\npublic class Test \n</code></pre> <p>All recognized spy fields would be logged:</p> <pre><code>Applied spies (@SpyBean) on SpySimpleTest:\n\n    #spy2                          Service2                     (r.v.d.g.t.j.s.s.SpySimpleTest) \n    #spy1                          Service1                     (r.v.d.g.t.j.s.s.SpySimpleTest) \n</code></pre>"},{"location":"guide/test/junit5/startup/","title":"Testing startup error","text":"<p>Warning</p> <p>Commands execution overrides System IO and so can't run in parallel with other tests!</p> <p>Use <code>@Isolated</code>  on such tests to prevent parallel execution with other tests</p> <p>Tests for application startup fail often required to check some startup conditions. The problem is that it's not enough to simply run the application with \"bad\" configuration file because on error application calls <code>System.exit(1)</code>:</p> <pre><code>    public abstract class Application&lt;T extends Configuration&gt; {\n        ...\n    protected void onFatalError(Throwable t) {\n        System.exit(1);\n    }\n}\n</code></pre> <p>Instead, you can use command run utility:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .runApp()\n</code></pre> <p>or with the shortcut:</p> <pre><code>CommandResult result = TestSupport.buildCommandRunner(App.class)\n        .runApp()\n</code></pre> <p>Tip</p> <p>Test framework-agnostic utilities provides simple utilities to run application (core or web). Could be useful when testing several applications interaction. </p> <p>Important</p> <p>In case of application successful start, special check would immediately stop it by throwing exception (resulting object would contain it), so such test would never freeze.</p>"},{"location":"guide/test/junit5/stubs/","title":"Testing with stubs","text":"<p>Stubs are hand-made replacements of real application services (\"manual\" or \"lazy\" mocks).</p> <p>Stubs declared in test class with a new <code>@StubBean</code> annotation.</p> <p>Warning</p> <p>Stubs will not work for HK2 beans</p> <p>There are two main cases:</p> <ol> <li>Stub class extends existing service: <code>class ServiceStub extends Service</code></li> <li>Stub implements service interface: <code>class ServiceStub implements IService</code></li> </ol> <p>Stubs replace real application services (using guice overriding modules), so stub would be injected in all services instead of the real service.</p> <p>For example, suppose we have a service:</p> <pre><code>public class Service {\n    public String foo() {\n        ...\n    }\n}\n</code></pre> <p>where method foo implements some complex logic, not required in test.</p> <p>Writing stub:</p> <pre><code>public class ServiceStub extends Service {\n    @Override\n    public String foo() {\n        return \"static value\";\n    }\n}\n</code></pre> <p>Using stub in test:</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n\n    @StubBean(Service.class)\n    ServiceStub stub;\n\n    // injecting here to show that stub replaced real service\n    @Inject\n    Service service;\n\n    @Test\n    public void test(){\n        // service is a stub\n        Assertions.assertInstanceOf(ServiceStub.class, service);\n        Assertions.assertEquals(\"static value\", service.foo());\n    }\n}\n</code></pre> <p>Info</p> <p>In many cases, mockito mocks and spies could be more useful, but stubs are simpler (easier to understand, especially comparing to spies).</p> <p>In the example above, stub instance is created by guice.  Stub could also be registered by instance:</p> <pre><code>@StubBean(Service.class)\nServiceStub stub = new ServiceStub();\n</code></pre> <p>In this case, stub's <code>@Inject</code> fields would be processed (<code>requestInjection(stub)</code> would be called).</p> <p>Note</p> <p>When stub is registered with instance, stub field must be static for per-test application run (default annotation). It may not be static for per-method application startup (with <code>@RegisterExtension</code>).</p> <p>Note</p> <p>Guice AOP would apply only for stubs registered with class. So stub instance could be used (instead of class) exactly to avoid additional AOP logic for service.</p>"},{"location":"guide/test/junit5/stubs/#stub-lifecycle","title":"Stub lifecycle","text":"<p>More complex stubs may contain a test-related internal state, which must be cleared between tests.</p> <p>In this case, stub could implement <code>StubLifecycle</code>:</p> <pre><code>public class ServiceStub extends Service implements StubLifecycle {\n    int calls;\n\n    @Override \n    public void before() {\n        calls = 0; \n    }\n\n    @Override\n    public void after() {\n        calls = 0;\n    }\n}\n</code></pre> <p>(both methods optional)</p> <p>Such methods would be called automatically before and after of each test method.</p>"},{"location":"guide/test/junit5/stubs/#debug","title":"Debug","text":"<p>When extension debug is active:</p> <pre><code>@TestGucieyApp(value = App.class, debug = true)\npublic class Test \n</code></pre> <p>All recognized stub fields would be logged:</p> <pre><code>Applied stubs (@StubBean) on StubsSimpleTest:\n\n    StubsSimpleTest.stub2                    GUICE                  Service2 &gt;&gt; Service2Stub        \n    StubsSimpleTest.stub                     GUICE                  Service1 &gt;&gt; Service1Stub \n</code></pre>"},{"location":"guide/test/junit5/test-ext/","title":"Testing extensions","text":"<p>Extensions (like setup objects) often rely on afterEach/afterAll methods and so it is not possible to test extension completely using test extensions (like <code>@TestGuiceyApp</code>).</p> <p>Junit provides a TestKit which could run unit tests inside usual unit test. This way  full extension lifecycle could be tested.</p> <p>Additional dependency required (version managed by dropwizard BOM):</p> <pre><code>testImplementation 'org.junit.platform:junit-platform-testkit'\n</code></pre> <p>Prepare test class, using your extension (better inner class):</p> <pre><code>public class Test {\n\n\n    // IMPORTANT to skip this test for the main junit engine (don't let it run this test)\n    @Disabled\n    public static class TestCase1 {\n\n        // custom extension\n        @MyAnnotation\n        Something field;\n\n    }\n}\n</code></pre> <p>Running test:</p> <pre><code>Throwable th;\nEngineTestKit\n        .engine(\"junit-jupiter\")\n        // ignore @Disable annotation\n        .configurationParameter(\"junit.jupiter.conditions.deactivate\", \"org.junit.*DisabledCondition\")\n        .selectors(DiscoverySelectors.selectClass(TestCase1.class))\n        .execute().allEvents().failed().stream()\n        .forEach(event -&gt; {\n            Throwable err = event.getPayload(TestExecutionResult.class).get().getThrowable().get();\n            err.printStackTrace();\n            th = err;\n        });\n\nif (th != null) {\n    // success case\n} else {\n    // error case\n}\n</code></pre>"},{"location":"guide/test/junit5/test-ext/#testing-console-output","title":"Testing console output","text":"<p>Full console output could be tracked wither with output captor utility or  using <code>system-stubs-jupiter</code> library.</p> <p>For example:</p> <pre><code>public void run(Class test) {\n    EngineTestKit\n            .engine(\"junit-jupiter\")\n            ....\n}\n\n@Test\npublic void test() {\n    String out = TestSupport.captureOutput(() -&gt; {\n        run(TestCase1.class);\n    });\n\n    // windows compatibility\n    out = out.replace(\"\\r\",\"\");\n\n    Assertions.assertThat(out).contains(\"some probably long text\");\n}\n</code></pre> <p>Most likely, logs would contain some changing data (like logger time or performance measures), so output would need to be pre-processed with regexps.</p> <p>For example, to replace string like \"20 ms\", \"112.3 ms\":</p> <pre><code>out.replaceAll(\"\\\\d+(\\\\.\\\\d+)? ms( +)?\", \"111 ms \");\n</code></pre> <p>To replace lambda identity in class name:</p> <pre><code>out.replaceAll(\"\\\\$\\\\$Lambda\\\\$\\\\d+/\\\\d+(x[a-z\\\\d]+)?\", \"\\\\$\\\\$Lambda\\\\$111/1111111\")\n    // jdk 21\n    .replaceAll(\"\\\\$\\\\$Lambda/\\\\d+(x[a-z\\\\d]+)?\", \"\\\\$\\\\$Lambda\\\\$111/1111111\");\n</code></pre> <p>Logger time:</p> <pre><code>out.replaceAll(\"\\\\[\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2},\\\\d+]\", \"[2025-22-22 11:11:11]\")\n</code></pre> <p>And so on. You can see <code>AbstractPlatformTest</code> in guicey tests (dropwizard-guicey module) and all related tests as examples.</p>"},{"location":"guide/test/junit5/tracks/","title":"Testing performance (bean tracking)","text":"<p>Tracker records guice bean methods execution:</p> <ol> <li>Collect method call arguments and result for each call</li> <li>Log slow methods execution</li> <li>Collect metrics to show overall methods performance (stats)</li> </ol> <p>Tracker is declared with <code>@TrackBean</code> annotation.</p> <p>Warning</p> <p>Trackers will not work for HK2 beans and for non guice-managed beans (bound by instance)</p> <p>Note</p> <p>Initially, trackers were added as a simpler alternative for mockito spy's clumsy result capturing. But, eventually, it evolved into a simple performance tracking tool (very raw, of course, but in many cases it would be enough).</p>"},{"location":"guide/test/junit5/tracks/#setup","title":"Setup","text":"<p>Not strictly required, but trackers provide type-safe search api using mockito, and so you'll need mockito dependency only if you wish to use this api (version may be omitted if dropwizard BOM used):</p> <pre><code>testImplementation 'org.mockito:mockito-core'\n</code></pre>"},{"location":"guide/test/junit5/tracks/#usage","title":"Usage","text":"<p>Suppose we have a service:</p> <pre><code>public static class Service {\n\n    public String get(int id) {\n        return \"Hello \" + id;\n    }\n}\n</code></pre> <p>And we want to very indirect service call (when service called by some other service):</p> <pre><code>@TestGuiceyApp(App.class)\npublic class Test {\n    @TrackBean(trace = true)\n    Tracker&lt;Service&gt; tracker;\n\n    @Inject\n    Service service;\n\n    @Test\n    public void test() {\n        // call service\n        Assertions.assertEquals(\"Hello 11\",service.get(11));\n\n        MethodTrack track = tracker.getLastTrack();\n        Assertions.assertTrue(track.toString().contains(\"get(11) = \\\"Hello 11\\\"\"));\n        // object arguments\n        Assertions.assertArrayEquals(new Object[] {11},track.getRawArguments());\n        // arguments in string form\n        Assertions.assertArrayEquals(new String[] {\"11\"},track.getArguments());\n        // raw result\n        Assertions.assertEquals(\"1 call\",track.getRawResult());\n        // result in string form\n        Assertions.assertEquals(\"1 call\",track.getResult());\n    }\n}\n</code></pre> <p>In this example, trace was enabled (optional) and so each method call would be logged like this:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.41 ms      &lt;@1b0e9707&gt; .get(11) = \"Hello 11\"\n</code></pre>"},{"location":"guide/test/junit5/tracks/#configuration","title":"Configuration","text":"<p><code>@TrackBean</code> annotation options:</p> Option Description Default trace When enabled, all method calls are printed false slowMethods Print warnings about methods executing longer than the specified threshold. Set to 0 to disable warnings. 5 seconds slowMethodsUnit Unit for slowMethods value Seconds keepRawObjects Keep method call arguments and result objects (potentially mutable) true maxStringLength Max length for a <code>String</code> argument or result (cut long strings) 30 autoReset Clear trackers after each test method true printSummary Print summary for exact tracker after each test method false"},{"location":"guide/test/junit5/tracks/#tracing","title":"Tracing","text":"<p>Tracing might be useful to see each tracked method call in console with parameters and execution time:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.41 ms      &lt;@1b0e9707&gt; .foo(1) = \"1 call\"\n\\\\\\---[Tracker&lt;Service&gt;] 0.02 ms      &lt;@1b0e9707&gt; .foo(2) = \"2 call\"\n\\\\\\---[Tracker&lt;Service&gt;] 0.12 ms      &lt;@1b0e9707&gt; .bar(1) = \"1 bar\"\n</code></pre> <p>It also prints service instance hash, to make obvious method calls on different instances. Different instances could appear on prototype-scoped beans (default scope).</p> <p>Enabled with:</p> <pre><code>@TrackBean(trace = true)\n</code></pre> <p>Note</p> <p>Traces are logged with <code>System.out</code> to make sure messages are always visible in console.</p>"},{"location":"guide/test/junit5/tracks/#slow-methods","title":"Slow methods","text":"<p>By default, tracker would log methods, executed longer than 5 seconds:</p> <pre><code>WARN  [2025-05-09 08:30:38,458] ru.vyarus.dropwizard.guice.test.track.Tracker: \n\\\\\\---[Tracker&lt;Service&gt;] 7.07 ms      &lt;@7634f2b&gt; .foo() = \"foo\"\n</code></pre> <p>Note</p> <p>Slow methods are logged with logger, and not <code>System.out</code> as traces.</p> <p>For example, to set slow method for 1 minute:</p> <pre><code>@TrackBean(slowMethod = 1, slowMethodsUnit = ChronoUnit.MINUTES)\n</code></pre> <p>To avoid logging slow methods:</p> <pre><code>@TrackBean(slowMethod = 0)\n</code></pre>"},{"location":"guide/test/junit5/tracks/#keeping-raw-objects","title":"Keeping raw objects","text":"<p>By default, tracker stores all arguments and returned result objects.</p> <p>Raw arguments could be used to examine complex objects just after the method call. But, in case of multiple method calls, raw objects might not be actual. For example:</p> <pre><code>public Service {\n    public void foo(List&lt;String&gt; list) {\n        list.add(\"foo\" + list.size());\n    }\n}\n</code></pre> <p>Here method changes argument state and so, if we call method multiple times, stored arguments would be useless (as all calls would reference the same list instance):</p> <pre><code>List&lt;String&gt; test = new ArrayList&lt;&gt;();\nservice.foo(test);\nservice.foo(test);\n\n// stored list useless as object was changed after the initial call\nList&lt;String&gt; firstCallArg = tracker.getLastTracks(2).get(0).getRawArguments().get(0);\nAssertions.assertEquals(2, firstCallArg.size());\n\n// but string representation would still be useful:\nString firstCallArgString = tracker.getLastTracks(2).get(0).getArguments().get(0);\nAssertions.assertEquals(\"0[]\", firstCallArg.size());\n\n// second call argument string\nString firstCallArgString = tracker.getLastTracks(2).get(1).getArguments().get(0);\nAssertions.assertEquals(\"1['foo1']\", firstCallArg.size());\n</code></pre> <p>In case of complex objects (pojo, for example), string representation would only contain the type and instance hash: <code>Type@hash</code> (which is not informative, but the only universal short  way to describe object).</p> <p>If tracker used only for performance testing (to accumulate execution time from many runs), it might make sense to avoid holding raw arguments:</p> <pre><code>@TrackBean(keepRawObjects = false)\n</code></pre>"},{"location":"guide/test/junit5/tracks/#max-length","title":"Max length","text":"<p>Methods could consume or return large string, but using large stings for console  output is not desired. All strings larger then configured size would be cut with \"...\" suffix:</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.08 ms      &lt;@66fb45e5&gt; .baz(\"largelargelargelargelargelarge...\")\n</code></pre> <p>Changing default:</p> <pre><code>@TrackBean(maxStringLength = 10)\n</code></pre>"},{"location":"guide/test/junit5/tracks/#print-summary","title":"Print summary","text":"<p>By default, extension print overall stats report when extension debug enabled.</p> <p>For each tracker, an individual report could be activated with: <code>@TrackBean(printSummary = true)</code> This report does not depend on the extension debug flag.</p> <p>The summary report also shows the number of service instances involved in stats (in the example trace was enabled for clarity):</p> <pre><code>\\\\\\---[Tracker&lt;Service&gt;] 0.28 ms      &lt;@6707a4bf&gt; .foo(1) = \"foo1\"\n\\\\\\---[Tracker&lt;Service&gt;] 0.007 ms     &lt;@79d3473e&gt; .foo(2) = \"foo2\"\n\n\\\\\\------------------------------------------------------------/ test instance = 51f18e31 /\nTracker&lt;Service&gt; stats (sorted by median) for ReportForMultipleInstancesTest$Test1#testTracker():\n\n    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    Service                                  foo(int)                                           2 (2)      0          0.007 ms   0.281 ms   0.281 ms   0.281 ms   0.281 ms  \n</code></pre> <p>Note different instances in trace (<code>&lt;@6707a4bf&gt;</code>, <code>&lt;@79d3473e&gt;</code>) and instances count in calls column: <code>2 (2)</code></p>"},{"location":"guide/test/junit5/tracks/#tracked-data","title":"Tracked data","text":"<p>Each call stored as <code>MethodTrack</code> and contains raw arguments <code>getRawArguments()</code> (which might change over time if mutable objects used) and string version <code>getArguments()</code> (can't change) and same for the result object. Raw objects are mostly useful in case of immediate check after the method call.</p> <p>Same for result: <code>getRawResult()</code> for raw object and <code>getResult()</code> for string version.</p> <p>Also, there are quoted string versions: <code>getQuatedResult()</code> and <code>getQuatedArguments()</code>. These methods are the same as string methods, but all strings are in quotes to clearly see string bounds (quoted versions useful for console reporting)</p> <p>Obtaining tracked data:</p> <pre><code>// all recordings\nList&lt;MethodTrack&gt; tracks = tracker.getTracks();\n// last 2 calls (in execution order)\nList&lt;MethodTrack&gt; tracks = tracker.getLastTracks(2);\n// last call\nMethodTrack track = tracker.getLastTrack();\n</code></pre>"},{"location":"guide/test/junit5/tracks/#searching","title":"Searching","text":"<p>In the case of many recorded executions (for multiple methods), search could be used:</p> <pre><code>// search by method (any argument value)\ntracks = tracker.findTracks(mock -&gt; when(\n               mock.foo(Mockito.anyInt()))\n         );\n\n// search methods with argument condition ( &gt; 1) \ntracks = tracker.findTracks(mock -&gt; when(\n               mock.foo(Mockito.intThat(argument -&gt; argument &gt; 1)))\n        );\n\n// search for methods with exact argument value  \ntracks = tracker.findTracks(mock -&gt; when(\n        mock.foo(11))\n        );\n</code></pre> <p>This method uses Mockito stubbing abilities for search criteria declaration: easy to use and type-safe search.</p>"},{"location":"guide/test/junit5/tracks/#reset-data","title":"Reset data","text":"<p>Tracked data could be cleared at any time either on tracker: <code>tracker.clear()</code>. By default, data is cleared after each test method.</p> <p>To disable automatic cleanup: <code>@TrackBean(autoReset = false)</code></p>"},{"location":"guide/test/junit5/tracks/#debug","title":"Debug","text":"<p>When extension debug is active:</p> <pre><code>@TestGucieyApp(value = App.class, debug = true)\npublic class Test \n</code></pre> <p>All recognized tracker fields would be logged:</p> <pre><code>Applied trackers (@TrackBean) on TrackerSimpleTest:\n\n    #serviceTracker                Service                      (r.v.d.g.t.j.s.t.TrackerSimpleTest) \n</code></pre> <p>Also, a performance report for all registered tracker objects would be printed:</p> <pre><code>\\\\\\------------------------------------------------------------/ test instance = 2bbb44da /\nTrackers stats (sorted by median) for TrackerSimpleTest#testTracker():\n\n    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    Service                                  foo(int)                                           3          0          0.011 ms   0.161 ms   0.151 ms   0.161 ms   0.161 ms  \n    Service                                  bar(int)                                           1          0          0.066 ms   0.066 ms   0.066 ms   0.066 ms   0.066 ms  \n</code></pre>"},{"location":"guide/test/junit5/tracks/#stats","title":"Stats","text":"<p>Tracker could aggregate all executions of the same method:</p> <pre><code>TrackerStats stats = tracker.getStats();\nAssertions.assertEquals(1, stats.getMethods().size());\n\nMethodSummary summary = stats.getMethods().get(0);\nAssertions.assertEquals(\"foo\", summary.getMethod().getName());\nAssertions.assertEquals(Service.class, summary.getService());\nAssertions.assertEquals(1, summary.getTracks());\nAssertions.assertEquals(0, summary.getErrors());\nAssertions.assertEquals(1, summary.getMetrics().getValues().length);\nAssertions.assertTrue(summary.getMetrics().getMin() &lt; 1000);\n</code></pre> <p>Tracker use dropwizard metrics, so stats provide common values like mean time, median time, 95 percentile, etc.</p> <p>There is a default statistics report implementation, which might be used for console reporting:</p> <pre><code>System.out.println(tracker.getStats().render());\n</code></pre> <pre><code>    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    Service                                  foo(int)                                           2 (2)      0          0.009 ms   0.352 ms   0.352 ms   0.352 ms   0.352 ms\n</code></pre> <p>Here you can see that 2 instances were used for 2 success calls. Of course max time would be too large (cold jvm), but with min value you can see more realistic time. With a high number of executions percentile and mean values would become more realistic.</p> <p>Here is an example of tracking <code>GuiceyConfigurationInfo</code> with activated <code>.printAllGuiceBindings()</code> report:</p> <pre><code>    [service]                                [method]                                           [calls]    [fails]    [min]      [max]      [median]   [75%]      [95%]     \n    GuiceyConfigurationInfo                  getNormalModuleIds()                               1          0          1.076 ms   1.076 ms   1.076 ms   1.076 ms   1.076 ms  \n    GuiceyConfigurationInfo                  getModulesDisabled()                               1          0          0.038 ms   0.038 ms   0.038 ms   0.038 ms   0.038 ms  \n    GuiceyConfigurationInfo                  getOverridingModuleIds()                           1          0          0.034 ms   0.034 ms   0.034 ms   0.034 ms   0.034 ms  \n    GuiceyConfigurationInfo                  getExtensionsDisabled()                            1          0          0.020 ms   0.020 ms   0.020 ms   0.020 ms   0.020 ms  \n    GuiceyConfigurationInfo                  getOptions()                                       1          0          0.005 ms   0.005 ms   0.005 ms   0.005 ms   0.005 ms  \n    GuiceyConfigurationInfo                  getData()                                          3          0          0.003 ms   0.006 ms   0.004 ms   0.006 ms   0.006 ms  \n</code></pre> <p>Note</p> <p>Methods sorted by slowness </p> <p>You can also collect stats for multiple trackers:</p> <pre><code>TrackerStats overall = new TrackerStats(tracker1, tracker2);\nSystem.out.println(overall.render());\n</code></pre>"},{"location":"guide/test/junit5/unification/","title":"Extension configuration unification","text":"<p>It is a common need to run multiple tests with the same test application configuration (same config overrides, same hooks etc.). Do not configure it in each test, instead move extension configuration into base test class:</p> <pre><code>@TestGuiceyApp(...)\npublic abstract class AbstractTest {\n    // here might be helper methods\n}\n</code></pre> <p>And now all test classes should simply extend it:</p> <pre><code>public class Test1 extends AbstractTest {\n\n    @Inject\n    MyService service;\n\n    @Test\n    public void testSomething() { ... }\n}\n</code></pre> <p>If you use manual extension configuration (through field), just replace annotation in base class with manual declaration - approach would still work.</p>"},{"location":"guide/test/junit5/unification/#meta-annotation","title":"Meta annotation","text":"<p>You can prepare meta annotation (possibly combining multiple 3<sup>rd</sup> party extensions): </p> <pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@TestDropwizardApp(AutoScanApplication.class)\npublic @interface MyApp {\n}\n\n@MyApp\npublic class MetaAnnotationDwTest {\n\n    @Test\n    void checkAnnotationRecognized(Application app) {\n        Assertions.assertNotNull(app);\n    }   \n}\n</code></pre> <p>OR you can simply use base test class and configure annotation there:</p> <pre><code>@TestDropwizardApp(AutoScanApplication.class)\npublic class BaseTest {}\n\npublic class ActualTest extends BaseTest {} \n</code></pre>"},{"location":"guide/test/junit5/unification/#reuse-application-between-tests","title":"Reuse application between tests","text":"<p>In some cases it is preferable to start application just once and use for all tests (e.g. due to long startup or time-consuming environment preparation).</p> <p>In order to use the same application instance, extension declaration must be performed in  base test class and <code>reuseApplication</code> flag must be enabled:</p> <pre><code>@TestGuiceyApp(value = Application.class, reuseApplication = true)\npublic abstract class BaseTest {}\n</code></pre> <p>or</p> <pre><code>public abstract class BaseTest {\n    @RegisterExtension\n    static TestGuiceyAppExtension ext = TestGuiceyAppExtension.forApp(App.class)\n            .reuseApplication()\n            .create();\n\n}\n</code></pre> <p>The same will work for dropwizard extension (<code>@TestDropwizardApp</code> and <code>TestDropwizardAppExtension</code>).</p> <p>Important</p> <p>Application instance re-use is not enabled by default for backwards compatibility (for cases when base class declaration already used).</p> <p>There might be multiple base test classes declaring reusable applications: different global applications would be started for each declaration (allowing you to group tests requiring different applications) </p> <p>Global application would be closed after all tests execution (with test engine shutdown).</p> <p>In essence, reusable application \"stick\" to declaration in base class, so all tests, extending base class \"inherit\" the same declaration and so the same application (when reuse enabled).</p> <p>Tip</p> <p>Reusable applications may be used together with tests, not extending base class and using guicey extensions. Such tests would simply start a new application instance. Just be sure to avoid port clashes when using reusable dropwizard apps (by using <code>randomPorts</code> option).</p> <p><code>@EnableSetup</code> and <code>@EnableHook</code> fields are also supported for reusable applications. But declare all such fields on base class level (or below) because otherwise only fields declared on first started test would be used. Warning would be printed if such fields used (or ignored because reusable app was already started by different test).</p>"},{"location":"installers/eager/","title":"Eager singleton installer","text":"<p>CoreInstallersBundle / EagerSingletonInstaller</p>"},{"location":"installers/eager/#recognition","title":"Recognition","text":"<p>Detects classes annotated with <code>@EagerSingleton</code> annotation and registers them in guice injector.  It is equivalent of eager singleton registration <code>bind(type).asEagerSingleton()</code>.</p> <p>Useful in cases when you have a bean which is not injected by other beans (so guice can't register it through aot). Normally, you would have to manually register such bean in module.</p> <p>Most likely, such bean will contain initialization logic.  Ideal for cases not directly covered by installers. For example:</p> <pre><code>@EagerSingleton\npublic class MyListener implements LifeCycle.Listener {\n\n    @Inject\n    public MyListener(Environment environment) {\n        environment.lifecicle.addListener(this);\n    }\n}\n</code></pre> <p>Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener.</p> <p>May be used in conjunction with <code>@PostConstruct</code> annotations (e.g. using ext-annotations): installer finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should be used for quick prototyping only.</p>"},{"location":"installers/filter/","title":"Web filter installer","text":"<p>WebInstallersBundle / WebFilterInstaller </p> <p>Register new filter in main or admin contexts.</p>"},{"location":"installers/filter/#recognition","title":"Recognition","text":"<p>Detects classes annotated with <code>@jakarta.servlet.annotation.WebFilter</code> annotation and register them in dropwizard environment.</p> <pre><code>@WebFilter(\"/some/*\")\npublic class MyFilter implements Filter { ... }\n</code></pre> <p>Only the following annotation properties are supported: <code>filterName</code>, <code>urlPatterns</code> (or <code>value</code>), <code>servletNames</code>, <code>dispatcherTypes</code>, <code>initParams</code>, <code>asyncSupported</code>.</p> <p>Warning</p> <p>Url patterns and servlet names can't be used at the same time.</p> <p>Filter name is not required. If name not provided, then it will be generated as:  . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off. For example, for class \"MyCoolFilter\" generated name will be \".mycool\".</p> <p>Tip</p> <p>Use guicey <code>@Order</code> annotation to order servlets registration. <pre><code>@Order(10)\n@WebFilter(\"/some/*\")\npublic class MyFilter implements Filter { ... }\n</code></pre></p> <p>There is a difference between using filter installer and registering filters with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).</p> <p>Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).       </p>"},{"location":"installers/filter/#async","title":"Async","text":"<p>Example of async filter definition:</p> <pre><code>@WebFilter(urlPatterns = \"/asyncfilter\", asyncSupported = true)\npublic class AsyncFilter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        final AsyncContext context = request.startAsync();\n        context.start(() -&gt; {\n            context.getResponse().writer.write(\"done!\");\n            context.complete();\n        });\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n</code></pre> <p>Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters.</p>"},{"location":"installers/filter/#admin-context","title":"Admin context","text":"<p>By default, installer target application context. If you want to install into admin context then  use guicey <code>@AdminContext</code> annotation.</p> <p>For example: </p> <pre><code>@AdminContext\n@WebFilter(\"/some/*\")\npublic class MyFilter implements Filter { ... }\n</code></pre> <p>Will install filter in admin context only.</p> <p>If you want to install in both contexts use andMain attribute:</p> <pre><code>@AdminContext(andMain = true)\n@WebFilter(\"/some/*\")\npublic class MyFilter implements Filter { ... }\n</code></pre>"},{"location":"installers/healthcheck/","title":"Health check installer","text":"<p>CoreInstallersBundle / HealthCheckInstaller </p> <p>Installs dropwizard health check.</p>"},{"location":"installers/healthcheck/#recognition","title":"Recognition","text":"<p>Detects classes extending guicey <code>NamedHealthCheck</code> and register their instances in environment. Custom base class is required, because default <code>HealthCheck</code> did not provide check name, which is required for registration.</p> <pre><code>public class MyHealthCheck extends NamedHealthCheck {\n\n    @Inject\n    private MyService service;\n\n    @Override\n    protected Result check() throws Exception {\n        if (service.isOk()) {\n            return Result.healthy();\n        } else {\n            return Result.unhealthy(\"Service is not ok\");\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"my-service\";\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/","title":"Jersey extension installer","text":"<p>CoreInstallersBundle / JerseyProviderInstaller </p> <p>Installs various jersey extensions, usually annotated with jersey <code>@Provider</code> annotation and installed via <code>environment.jersey().register()</code>:</p> <pre><code>Supplier, ExceptionMapper, ValueParamProvider, InjectionResolver, \nParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, \nReaderInterceptor, WriterInterceptor, ContainerRequestFilter, \nContainerResponseFilter, DynamicFeature, ApplicationEventListener, ModelProcessor\n</code></pre>"},{"location":"installers/jersey-ext/#recognition","title":"Recognition","text":"<p>Detects known jersey extension classes and classes annotated with jersey <code>@jakarta.ws.rs.ext.Provider</code> annotation and register their instances in jersey.</p> <p>Extensions registered as singletons, when no explicit scope annotation is used. Behaviour could be disabled with option: <pre><code>.option(InstallerOptions.ForceSingletonForJerseyExtensions, false)\n</code></pre></p> <p>Before guicey 5.7.0 it was required to annotate all extensions with <code>@Provide</code>, but now it is not required - extension would be recognized by implemented interface. But, if you prefer legacy behaviour then it could be reverted with: <pre><code>.option(InstallersOptions.JerseyExtensionsRecognizedByType, false)\n</code></pre></p> <p>Special <code>@Prototype</code> scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so <code>@RequestScoped</code> could not be used).</p> <p>Due to specifics of HK2 integration, you may need to use:</p> <ul> <li><code>@JerseyManaged</code> to delegate bean creation to HK2</li> <li><code>@LazyBinding</code> to delay bean creation to time when all dependencies will be available </li> <li><code>jakarta.inject.Provider</code> as universal workaround (to wrap not immediately available dependency).</li> </ul> <p>Or you can enable HK2 management for jersey extensions by default. Note that this will affect resources too and guice aop will not work on jersey extensions.</p>"},{"location":"installers/jersey-ext/#priority","title":"Priority","text":"<p>By default, all registered providers are qualified with <code>@org.glassfish.jersey.internal.inject.Custom</code> to  prioritize them (be able to override dropwizard defaults). This mimics the default behaviour of manual registration with <code>environment.jersey().register(...)</code>.</p> <p>For example, when you register your own <code>ExceptionMapper&lt;Throwable&gt;</code> it would be used instead of default dropwizard one (due to prioritized qualification).</p> <p>For more details see <code>org.glassfish.jersey.internal.inject.Providers#getAllServiceHolders( org.glassfish.jersey.internal.inject.InjectionManager, java.lang.Class)</code> which is used by jersey for providers loading.</p> <p>Tip</p> <p>Previously (&lt;= 5.2.0) guicey were not qualifying providers and qualification may (unlikely, but can!) introduce behaviour changes on guicey upgrade (due to prioritized custom providers). In this case, auto qualification may be disabled with  <pre><code>.option(InstallerOptions.PrioritizeJerseyExtensions, false) \n</code></pre> to revert to legacy guicey behaviour. <code>@Custom</code> may be used directly in this case on some providers for prioritization. </p> <p><code>@Priority</code> annotation may be used for ordering providers. Value should be &gt; 0 (but may be negative, just a convention).  For example, 1000 is prioritized before 2000. See <code>jakarta.ws.rs.Priorities</code> for default priority constants.</p> <p>Note</p> <p><code>@Priority</code> may work differently on <code>@Custom</code> qualified providers (all user providers by default) and unqualified (e.g. registered through hk module, like dropwizard defaults). Right now, qualified providers sorted ascending while unqualified sorted descending (due to different selection implementations, see <code>getAllServiceHolders</code> reference above). Probably a jersey bug.</p>"},{"location":"installers/jersey-ext/#supplier","title":"Supplier","text":"<p>Warning</p> <p><code>Supplier</code> is used now by hk2 as a replacement to its own <code>Factory</code> interface.</p> <p>If you were using <code>AbstractContainerRequestValueFactory</code> then use just <code>Supplier&lt;T&gt;</code> instead.</p> <p>Any class implementing <code>java.util.function.Supplier</code> (or extending abstract class implementing it).</p> <pre><code>public class MySupplier implements Supplier&lt;MyModel&gt; {\n    @Override\n    public MyModel get() {\n       ...    \n    }   \n}\n</code></pre> <p>Suppliers in essence are very like guice (or <code>jakarta.inject</code>) providers (<code>Provider</code>).</p> <p>Warning</p> <p>Previously, factories were used as auth objects providers. Now <code>Function&lt;ContainerRequest, ?&gt;</code> must be used instead: </p> <pre><code>@Provider\nclass AuthFactory implements Function&lt;ContainerRequest, User&gt; {\n\n    @Override\n    public User apply(ContainerRequest containerRequest) {\n        return new User();\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#exceptionmapper","title":"ExceptionMapper","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.ExceptionMapper</code> (or extending abstract class implementing it).  Useful for error handling customization.</p> <pre><code>public class DummyExceptionMapper implements ExceptionMapper&lt;RuntimeException&gt; {\n\n    private final Logger logger = LoggerFactory.getLogger(DummyExceptionMapper.class);\n\n    @Override\n    public Response toResponse(RuntimeException e) {\n        logger.debug(\"Problem while executing\", e);\n        return Response.status(Response.Status.BAD_REQUEST)\n                .type(MediaType.TEXT_PLAIN)\n                .entity(e.getMessage())\n                .build();\n    }\n\n}\n</code></pre> <p>Tip</p> <p>You can also use <code>ExtendedExceptionMapper</code> as more flexible alternative. See example usage in dropwizard-views.</p> <p>Tip</p> <p>Default exception dropwizard mappers (registered in <code>io.dropwizard.setup.ExceptionMapperBinder</code>) could be  overridden (see priority section) or completely disabled with <code>server.registerDefaultExceptionMappers</code> option.    </p>"},{"location":"installers/jersey-ext/#valueparamprovider","title":"ValueParamProvider","text":"<p>Any class implementing <code>org.glassfish.jersey.server.spi.internal.ValueParamProvider</code> (or extending abstract class implementing it).</p> <pre><code>public class AuthFactoryProvider extends AbstractValueParamProvider {\n\n    private final AuthFactory authFactory;\n\n    @Inject\n    public AuthFactoryProvider(final jakarta.inject.Provider&lt;MultivaluedParameterExtractorProvider&gt; extractorProvider,\n                               final AuthFactory factory) {\n        super(extractorProvider, Parameter.Source.UNKNOWN);\n        this.authFactory = factory;\n    }\n\n    @Override\n    protected Function&lt;ContainerRequest, User&gt; createValueProvider(Parameter parameter) {\n        final Auth auth = parameter.getAnnotation(Auth.class);\n        return auth != null ? authFactory : null;\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#injectionresolver","title":"InjectionResolver","text":"<p>Any class implementing <code>org.glassfish.hk2.api.InjectionResolver</code> (or extending abstract class implementing it).</p> <pre><code>class MyObjInjectionResolver implements InjectionResolver&lt;MyObjAnn&gt; {\n\n    @Override\n    public Object resolve(Injectee injectee) {\n        return new MyObj();\n    }\n\n    @Override\n    public Class&lt;MyObjAnn&gt; getAnnotation() {\n        return MyObjAnn.class;\n    }\n\n    @Override\n    public boolean isConstructorParameterIndicator() {\n        return false;\n    }\n\n    @Override\n    public boolean isMethodParameterIndicator() {\n        return true;\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#paramconverterprovider","title":"ParamConverterProvider","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.ParamConverterProvider</code> (or extending abstract class implementing it).</p> <pre><code>public class FooParamConverter implements ParamConverterProvider {\n\n    @Override\n    public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation[] annotations) {\n        if (Foo.class.isAssignableFrom(rawType)) {\n            return (ParamConverter&lt;T&gt;) new FooConverter();\n        }\n        return null;\n    }\n\n    private static class FooConverter implements ParamConverter&lt;Foo&gt; {\n        @Override\n        public Foo fromString(String value) {\n            return new Foo(value);\n        }\n\n        @Override\n        public String toString(Foo value) {\n            return value.value;\n        }\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#contextresolver","title":"ContextResolver","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.ContextResolver</code> (or extending abstract class implementing it).</p> <pre><code>public class MyContextResolver implements ContextResolver&lt;Context&gt; {\n\n    @Override\n    public Context getContext(Class type) {\n        return new Context();\n    }\n\n    public static class Context {}\n}\n</code></pre>"},{"location":"installers/jersey-ext/#messagebodyreader","title":"MessageBodyReader","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.MessageBodyReader</code> (or extending abstract class implementing it). Useful for custom representations.</p> <pre><code>public class TypeMessageBodyReader implements MessageBodyReader&lt;Type&gt; {\n\n    @Override\n    public boolean isReadable(Class&lt;?&gt; type, java.lang.reflect.Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return false;\n    }\n\n    @Override\n    public Type readFrom(Class&lt;Type&gt; type, java.lang.reflect.Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap&lt;String, String&gt; httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {\n        return null;\n    }\n\n    public static class Type {}\n}\n</code></pre>"},{"location":"installers/jersey-ext/#messagebodywriter","title":"MessageBodyWriter","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.MessageBodyWriter</code> (or extending abstract class implementing it). Useful for custom representations.</p> <pre><code>public class TypeMessageBodyWriter implements MessageBodyWriter&lt;Type&gt; {\n\n    @Override\n    public boolean isWriteable(Class&lt;?&gt; type, java.lang.reflect.Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return false;\n    }\n\n    @Override\n    public long getSize(Type type, Class&lt;?&gt; type2, java.lang.reflect.Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return 0;\n    }\n\n    @Override\n    public void writeTo(Type type, Class&lt;?&gt; type2, java.lang.reflect.Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap&lt;String, Object&gt; httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {\n    }\n\n    public static class Type {}\n}\n</code></pre>"},{"location":"installers/jersey-ext/#readerinterceptor","title":"ReaderInterceptor","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.ReaderInterceptor</code> (or extending abstract class implementing it).</p> <pre><code>public class MyReaderInterceptor implements ReaderInterceptor {\n\n    @Override\n    public Object aroundReadFrom(ReaderInterceptorContext context) throws IOException, WebApplicationException {\n        return null;\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#writerinterceptor","title":"WriterInterceptor","text":"<p>Any class implementing <code>jakarta.ws.rs.ext.WriterInterceptor</code> (or extending abstract class implementing it).</p> <pre><code>public class MyWriterInterceptor implements WriterInterceptor {\n\n    @Override\n    void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#containerrequestfilter","title":"ContainerRequestFilter","text":"<p>Any class implementing <code>jakarta.ws.rs.container.ContainerRequestFilter</code> (or extending abstract class implementing it). Useful for request modifications.</p> <pre><code>public class MyContainerRequestFilter implements ContainerRequestFilter {\n\n    @Override\n    public void filter(ContainerRequestContext requestContext) throws IOException {\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#containerresponsefilter","title":"ContainerResponseFilter","text":"<p>Any class implementing <code>jakarta.ws.rs.container.ContainerResponseFilter</code> (or extending abstract class implementing it). Useful for response modifications.</p> <pre><code>public class MyContainerResponseFilter implements ContainerResponseFilter {\n\n    @Override\n    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#dynamicfeature","title":"DynamicFeature","text":"<p>Any class implementing <code>jakarta.ws.rs.container.DynamicFeature</code> (or extending abstract class implementing it). Useful for conditional activation of filters.</p> <pre><code>public class MyDynamicFeature implements DynamicFeature {\n\n    @Override\n    public void configure(ResourceInfo resourceInfo, FeatureContext context) {\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#applicationeventlistener","title":"ApplicationEventListener","text":"<p>Any class implementing <code>org.glassfish.jersey.server.monitoring.ApplicationEventListener</code> (or extending abstract class implementing it).</p> <pre><code>public class MyApplicationEventListener implements ApplicationEventListener {\n\n    @Override\n    public void onEvent(ApplicationEvent event) {\n    }\n\n    @Override\n    public RequestEventListener onRequest(RequestEvent requestEvent) {\n        return null;\n    }\n}\n</code></pre>"},{"location":"installers/jersey-ext/#modelprocessor","title":"ModelProcessor","text":"<p>Any class implementing <code>org.glassfish.jersey.server.model.ModelProcessor</code> (or extending abstract class implementing it).</p> <pre><code>public class MyModelProcessor implements ModelProcessor {\n\n    @Override\n    public ResourceModel processResourceModel(ResourceModel resourceModel, \n                                              Configuration configuration) {\n        return resourceModel;\n    }\n\n    @Override\n    public ResourceModel processSubResource(ResourceModel subResourceModel, \n                                            Configuration configuration) {\n        return subResourceModel;\n    }\n}\n</code></pre>"},{"location":"installers/jersey-feature/","title":"Jersey feature installer","text":"<p>CoreInstallersBundle / JerseyFeatureInstaller</p>"},{"location":"installers/jersey-feature/#recognition","title":"Recognition","text":"<p>Detects classes implementing <code>jakarta.ws.rs.core.Feature</code> and register their instances in jersey.</p> <p>It may be useful to configure jersey inside guice components:</p> <pre><code>public class MyClass {\n    ...   \n    public static class ConfigurationFeature implements Feature {\n        @Override\n        public boolean configure(FeatureContext context) {\n            context.register(RolesAllowedDynamicFeature.class);\n            context.register(new AuthValueFactoryProvider.Binder(User.class));\n            return true;\n        }\n    }\n}\n</code></pre> <p>Inner classes are also recognized by classpath scan.</p> <p>But often the same could be achieved by injecting <code>Environment</code> instance.</p> <pre><code>@Singleton\npublic class MyClass {\n\n    @Inject\n    public MyClass(Environment environment) {\n        environment.jersey().register(RolesAllowedDynamicFeature.class);\n        environment.jersey().register(\n                new AuthValueFactoryProvider.Binder(User.class));\n    }    \n}\n</code></pre>"},{"location":"installers/lifecycle/","title":"Lifecycle installer","text":"<p>CoreInstallersBundle / LifeCycleInstaller </p> <p>Installs jetty LifeCycle implementations.</p>"},{"location":"installers/lifecycle/#recognition","title":"Recognition","text":"<p>Detects classes implementing jetty <code>LifeCycle</code> interface and register their instances in environment.</p> <pre><code>public class MyCycle implements LifeCycle {\n    ...\n}\n</code></pre> <p>In most cases it's better to use managed object instead of implementing lifecycle.</p> <p>Tip</p> <p>Use guicey <code>@Order</code> annotation to order managed objects.   <pre><code>@Order(10)\npublic class MyCycle implements LifeCycle\n</code></pre></p>"},{"location":"installers/listener/","title":"Web listener installer","text":"<p>WebInstallersBundle / WebListenerInstaller </p> <p>Register new web listener in main or admin contexts.</p>"},{"location":"installers/listener/#recognition","title":"Recognition","text":"<p>Detects classes annotated with <code>@jakarta.servlet.annotation.WebListener</code> annotation and register them in dropwizard environment.</p> <pre><code>@WebListener\npublic class MyListener implements ServletContextListener, ServletRequestListener {...}\n</code></pre> <p>Listener could implement multiple listener interfaces and all types will be registered.</p> <p>Supported listeners (the same as declared in annotation):</p> <ul> <li>jakarta.servlet.ServletContextListener</li> <li>jakarta.servlet.ServletContextAttributeListener</li> <li>jakarta.servlet.ServletRequestListener</li> <li>jakarta.servlet.ServletRequestAttributeListener</li> <li>jakarta.servlet.http.HttpSessionListener</li> <li>jakarta.servlet.http.HttpSessionAttributeListener</li> <li>jakarta.servlet.http.HttpSessionIdListener</li> </ul> <p>By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support then warning will be logged (and servlet listeners will actually not be registered). Error is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work). If you want to throw exception in such case, use special option: <pre><code>bundle.option(InstallersOptions.DenySessionListenersWithoutSession, true)\n</code></pre></p> <p>Tip</p> <p>Use guicey <code>@Order</code> annotation to order servlets registration. <pre><code>@Order(10)\n@WebListener\npublic class MyListener implements ServletContextListener {...}\n</code></pre></p>"},{"location":"installers/listener/#admin-context","title":"Admin context","text":"<p>By default, installer target application context. If you want to install into admin context then  use guicey <code>@AdminContext</code> annotation.</p> <p>For example: </p> <pre><code>@AdminContext\n@WebListener\npublic class MyListener implements ServletContextListener {...}\n</code></pre> <p>Will install filter in admin context only.</p> <p>If you want to install in both contexts use andMain attribute:</p> <pre><code>@AdminContext(andMain = true)\n@WebListener\npublic class MyListener implements ServletContextListener {...}\n</code></pre>"},{"location":"installers/managed/","title":"Managed installer","text":"<p>CoreInstallersBundle / ManagedInstaller </p> <p>Installs dropwizard managed objects.</p>"},{"location":"installers/managed/#recognition","title":"Recognition","text":"<p>Detects classes implementing dropwizard <code>Managed</code> and register their instances in environment.</p> <pre><code>public class MyService implements Managed {\n\n    @Override\n    public void start() throws Exception {\n        ...\n    }\n\n    @Override\n    public void stop() throws Exception {\n        ...\n    }\n}\n</code></pre> <p>It is perfect for implementing guice service lifecycle.</p> <p>Tip</p> <p>Alternatively you can use <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations inside guice beans with lifecycle-annotations extension module.</p> <p>Tip</p> <p>Use guicey <code>@Order</code> annotation to order managed objects. <pre><code>@Order(10)\npublic class MyService implements Managed\n</code></pre></p>"},{"location":"installers/plugin/","title":"Plugin installer","text":"<p>CoreInstallersBundle / PluginInstaller</p> <p>Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).  </p>"},{"location":"installers/plugin/#recognition","title":"Recognition","text":"<p>Detects classes annotated with guicey <code>@Plugin</code> annotation and bind them into set or map using guice  multibindings mechanism.</p> <p>Suppose you have plugin interface <code>public interface PluginInterface</code>.</p> <p>Annotate plugin implementations with <code>@Plugin</code>:</p> <pre><code>@Plugin(PluginInterface.class)\npublic class PluginImpl1 implements PluginInterface\n</code></pre> <p>Now all implementations could be autowired as</p> <pre><code>@Inject Set&lt;PluginInterface&gt; plugins;\n</code></pre> <p>Warning</p> <p>At least one implementation must be provided because otherwise guicey will not be able to register Set binding and guice startup will fail. If no plugins situation is possible, then you will have to manually register empty (default) plugins binding:  <pre><code>public class MyModule extends AbstractModule {    \n    @Override\n    protected configure() {\n        Multibinder.newSetBinder(binder(), PluginInterface.class);\n    }\n}\n</code></pre> Guicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting."},{"location":"installers/plugin/#named-plugins","title":"Named plugins","text":"<p>Sometimes it's required to have named plugin mapping: to bind, Map instead of simple set. For example, when you have multiple authorization providers and each provider implementation must be registered with name. <p>Most likely, you would use enum for keys:</p> <pre><code>public enum PluginKey {\n    FIRST, SECOND\n}\n</code></pre> <p>Custom plugin annotation needs to be defined to use new keys:</p> <pre><code>@Plugin(PluginInterface.class)\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyPlugin {\n    PluginKey value();\n}\n</code></pre> <p>Note</p> <p>Annotation itself is annotated with <code>@Plugin</code>, defining target plugin interface. Guicey will detect your custom annotation usage by analyzing its annotations. </p> <p>Annotating plugin implementation:</p> <pre><code>@MyPlugin(PluginKey.FIRST)\npublic class PluginImpl1 implements PluginInterface\n</code></pre> <p>All plugins could be referenced as map:</p> <pre><code>@Inject Map&lt;PluginKey, PluginInterface&gt; plugins;\n</code></pre> <p>Note</p> <p>It's not required to use enum as key. Any type could be set in your custom annotation.  For example, string key could be used:  <pre><code>public @interface MyPlugin {\n    String value();\n}\n\n@MyPlugin(\"first\")\npublic class PluginImpl1 implements PluginInterface\n\n@Inject Map&lt;String, PluginInterface&gt; plugins;\n</code></pre></p> <p>Warning</p> <p>As with simple plugin bindings, at least one plugin must be registered so guice could create map binding. Otherwise, you need to manually declare empty (default) plugins map binding: <pre><code>MapBinder.newMapBinder(binder, keyType, pluginType);\n</code></pre></p>"},{"location":"installers/resource/","title":"Resource installer","text":"<p>CoreInstallersBundle / ResourceInstaller</p> <p>Installs rest resources.</p>"},{"location":"installers/resource/#recognition","title":"Recognition","text":"<p>Detects classes annotated with jax-rs <code>@Path</code> annotation and register them as rest resources. Guice will manage resource creation, so you may think of it as usual guice bean.</p> <pre><code>@Path(\"/res\")\n@Produces('application/json')\nclass SampleResource {\n\n    @Inject\n    private MyService service;\n\n    @GET\n    @Path(\"/sample\")\n    public Response sample() {\n        return Response.ok(service.result()).build();\n    }\n}\n</code></pre> <p>Resources registered as singletons, when no explicit scope annotation is used. Behaviour could be disabled with option: <pre><code>.option(InstallerOptions.ForceSingletonForJerseyExtensions, false)\n</code></pre></p> <p>Special <code>@Prototype</code> scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so <code>@RequestScoped</code> could not be used). </p>"},{"location":"installers/resource/#interface-recognition","title":"Interface recognition","text":"<p>Class will also be recognized if <code>@Path</code> annotation found on directly implemented interface.</p> <pre><code>@Path(\"/res\")\n@Produces('application/json')\ninterface ResourceContract {\n\n    @GET\n    @Path(\"/sample\")\n    String sample();\n}\n\nclass SampleResource implements ResourceContract {\n\n    @Inject\n    private MyService service;\n\n    @Override\n    public Response sample() {\n        return Response.ok(service.result()).build();\n    }\n}\n</code></pre> <p>Annotations on interfaces are useful for jersey client proxies </p> <pre><code>Client client = ClientBuilder.newClient();\nResourceContract resource = WebResourceFactory\n    .newResource(ResourceContract.class, client.target(\"http://localhost:8080/\"));\n\n// call sample method on remote resource http://localhost:8080/res/sample\nString result = resource.sample();\n</code></pre> <p>Jersey client proxies requires extra dependency <code>org.glassfish.jersey.ext:jersey-proxy-client</code></p>"},{"location":"installers/resource/#request-scope-bindings","title":"Request scope bindings","text":"<p>If you need request scoped objects, use <code>Provider</code>:</p> <pre><code>class SampleResource {\n\n    @Inject\n    private Provider&lt;HttpServletRequest&gt; requestProvider;\n\n    @GET\n    @Path(\"/sample\")\n    public Response sample() {\n        HttpServletRequest request = requestProvider.get();\n        ...\n    }\n</code></pre> <p>See jersey objects, available for injection.</p>"},{"location":"installers/resource/#context-usage","title":"@Context usage","text":"<p><code>@Context</code> annotation usage is a common point of confusion. You can't use it for class fields: </p> <p>this will not work</p> <pre><code>public class MyResource {\n    @Context UriInfo info;\n}\n</code></pre> <p>Use provider instead:</p> <p>correct way</p> <pre><code>public class MyResource {\n    @Inject Provider&lt;UriInfo&gt; infoProvider;\n}\n</code></pre> <p>But, you can use <code>@Context</code> on method parameters:</p> <pre><code>public class MyResource {\n    @GET\n    public Response get(@Context UriInfo info) { ... }\n}\n</code></pre>"},{"location":"installers/resource/#jersey-managed-resource","title":"Jersey managed resource","text":"<p>If resource class is annotated with <code>@JerseyManaged</code> then jersey HK2 container will manage bean creation instead of guice.  Injection of guice managed beans could still be possible via registered HK2-guice-bridge, but guice aop features will not work.</p> <p>Note</p> <p>You can manage resources with HK2 by default, but this will also affect all jersey extensions</p> <pre><code>@Path(\"/res\")\n@Produces('application/json')\n@JerseyManaged\nclass SampleResource {\n    ...\n}\n</code></pre> <p><code>@Context</code> annotation on field will work on HK2 managed bean: <pre><code>@Path()\n@JerseyManaged\npublic class MyResource {\n    @Context UriInfo info;\n}\n</code></pre></p>"},{"location":"installers/servlet/","title":"Web servlet installer","text":"<p>WebInstallersBundle / WebServletInstaller </p> <p>Register new servlet in main or admin contexts.</p>"},{"location":"installers/servlet/#recognition","title":"Recognition","text":"<p>Detects classes annotated with <code>@jakarta.servlet.annotation.WebServlet</code> annotation and register them in dropwizard environment.</p> <pre><code>@WebServlet(\"/mapped\")\npublic class MyServlet extends HttpServlet { ... }\n</code></pre> <p>Only the following annotation properties are supported: <code>name</code>, <code>urlPatterns</code> (or <code>value</code>), <code>initParams</code>, <code>asyncSupported</code>.</p> <p>Servlet name is not required. If name not provided, it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off. For example, for class \"MyCoolServlet\" generated name will be \".mycool\".</p> <p>Warning</p> <p>One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings. If you want to throw exception in this case, use special option: <pre><code>bundle.option(InstallersOptions.DenyServletRegistrationWithClash, true)\n</code></pre> Note that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later  (and so exception will not be thrown).</p> <p>Tip</p> <p>Use guicey <code>@Order</code> annotation to order servlets registration. <pre><code>@Order(10)\n@WebServlet(\"/mapped\")\npublic class MyServlet extends HttpServlet \n</code></pre></p> <p>There is a difference between using servlet installer and registering servlets with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).</p> <p>Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).       </p>"},{"location":"installers/servlet/#async","title":"Async","text":"<p>Example of async servlet definition:</p> <pre><code>@WebServlet(urlPatterns = \"/async\", asyncSupported = true)\npublic class AsyncServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        final AsyncContext context = req.startAsync();\n        context.start(() -&gt; {\n            context.getResponse().getWriter().write(\"done!\");\n            context.complete();\n        });\n    }\n}\n</code></pre> <p>Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.</p>"},{"location":"installers/servlet/#admin-context","title":"Admin context","text":"<p>By default, installer target application context. If you want to install into admin context then  use guicey <code>@AdminContext</code> annotation.</p> <p>For example: </p> <pre><code>@AdminContext\n@WebServlet(\"/mapped\")\npublic class MyServlet extends HttpServlet { ... }\n</code></pre> <p>Will install servlet in admin context only.</p> <p>If you want to install in both contexts use andMain attribute:</p> <pre><code>@AdminContext(andMain = true)\n@WebServlet(\"/mapped\")\npublic class MyServlet extends HttpServlet { ... }\n</code></pre>"},{"location":"installers/task/","title":"Task installer","text":"<p>CoreInstallersBundle / TaskInstaller </p> <p>Installs dropwizard tasks.</p>"},{"location":"installers/task/#recognition","title":"Recognition","text":"<p>Detects classes extending dropwizard <code>Task</code> and register their instances in environment.</p> <pre><code>public class MyTask extends Task {\n\n    @Inject\n    private MyService service;\n\n    public TruncateDatabaseTask() {\n        super(\"mytask\");\n    }\n\n    @Override\n    public void execute(ImmutableMultimap&lt;String, String&gt; parameters, PrintWriter output) throws Exception {\n        service.doSomething();\n    }\n}\n</code></pre> <p>Task can be triggered with: <code>http://localhost:8081/tasks/mytask</code></p>"}]}