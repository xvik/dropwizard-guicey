{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to dropwizard-guicey \u00b6 Guice integration for dropwizard . Release notes - Support - License Main features \u00b6 Auto configuration : use classpath scan to find and install extensions automatically without manual configurations (of course, manual mode is also possible) Configuration values bindings by path or unique sub objects. Web (servlets, filters): supports both contexts (main and admin) guice ServletModule support is enabled by default ( could be disabled ) jee web annotations (@WebServlet, @WebFilter) support ( could be enabled ) Dropwizard style reporting : detected (and installed) extensions are printed to console to remove uncertainty Admin context rest emulation Test support : custom junit and spock extensions Developer friendly: core integrations may be replaced (to better fit needs) rich api for developing custom integrations , custom behaviours and configuration modification out of the box support for plug-n-play plugins ( auto discoverable ) self diagnostic tools ( configuration diagnostic report , bindable configuration paths , lifecycle stages ) How to use docs \u00b6 Introduction \u00b6 If you are migrating from dropwizard-guice read migration guide first Getting started guide describes installation and shows core usage examples Concepts overview guide introduce core guicey concepts and explains differences with pure dropwizard usage Reference \u00b6 User guide section contain detailed features descriptions. Good to read, but if no time, read as you need it. Installers section describes all guicey installers. Use it as a extensions hand book . Examples and integrations \u00b6 Examples section contains common example cases. Look also examples repository for additinoal examples. Extras section covers extra modules: admin rest, 3 rd party integrations (event bus, jdbi) provided by guicey itself or extensions project. Sources structure \u00b6 The main repository contains library itself and this documentation sources. Guicey stays as feature complete library with commonly used core integrations and rich api for building custom integrations (for specific needs). It's very close to guice philosophy of being simple and stable. Examples repository holds examples of main features usage, dropwizard bundles integrations and extensions samples. Extensions repository contains guicey external integrations. Extensions project shows what is possible to achieve based on guicey. Besides, provided integrations itself might be quite useful. BOM module unifies dependencies management for extensions, dropwizard and guice (as it includes boms for them). Overall, extensions project is more like spring: growing set of solutions for everything (more \"enterprisy\").","title":"Home"},{"location":"#welcome-to-dropwizard-guicey","text":"Guice integration for dropwizard . Release notes - Support - License","title":"Welcome to dropwizard-guicey"},{"location":"#main-features","text":"Auto configuration : use classpath scan to find and install extensions automatically without manual configurations (of course, manual mode is also possible) Configuration values bindings by path or unique sub objects. Web (servlets, filters): supports both contexts (main and admin) guice ServletModule support is enabled by default ( could be disabled ) jee web annotations (@WebServlet, @WebFilter) support ( could be enabled ) Dropwizard style reporting : detected (and installed) extensions are printed to console to remove uncertainty Admin context rest emulation Test support : custom junit and spock extensions Developer friendly: core integrations may be replaced (to better fit needs) rich api for developing custom integrations , custom behaviours and configuration modification out of the box support for plug-n-play plugins ( auto discoverable ) self diagnostic tools ( configuration diagnostic report , bindable configuration paths , lifecycle stages )","title":"Main features"},{"location":"#how-to-use-docs","text":"","title":"How to use docs"},{"location":"#introduction","text":"If you are migrating from dropwizard-guice read migration guide first Getting started guide describes installation and shows core usage examples Concepts overview guide introduce core guicey concepts and explains differences with pure dropwizard usage","title":"Introduction"},{"location":"#reference","text":"User guide section contain detailed features descriptions. Good to read, but if no time, read as you need it. Installers section describes all guicey installers. Use it as a extensions hand book .","title":"Reference"},{"location":"#examples-and-integrations","text":"Examples section contains common example cases. Look also examples repository for additinoal examples. Extras section covers extra modules: admin rest, 3 rd party integrations (event bus, jdbi) provided by guicey itself or extensions project.","title":"Examples and integrations"},{"location":"#sources-structure","text":"The main repository contains library itself and this documentation sources. Guicey stays as feature complete library with commonly used core integrations and rich api for building custom integrations (for specific needs). It's very close to guice philosophy of being simple and stable. Examples repository holds examples of main features usage, dropwizard bundles integrations and extensions samples. Extensions repository contains guicey external integrations. Extensions project shows what is possible to achieve based on guicey. Besides, provided integrations itself might be quite useful. BOM module unifies dependencies management for extensions, dropwizard and guice (as it includes boms for them). Overall, extensions project is more like spring: growing set of solutions for everything (more \"enterprisy\").","title":"Sources structure"},{"location":"concepts/","text":"Concepts overview \u00b6 Section briefly describes new concepts introduced by guicey and explains why it was done that way. For usage instruction and basic examples see getting-started section . Injector creation phase \u00b6 Dropwizard declares two phases: initialization ( App.initialize method) - when dropwizard app must be configured run ( App.run method) - when configuration is available and extensions could be registered in environment If we create injector in initialization phase then we will not have access to Configuration and Environment in guice modules, but configuration could be required, especially for 3 rd party modules, which does not support lazy configuration. Guicey creates injector at run phase to allow using configuration (and environment) in guice modules. Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it in the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase). For example, it is impossible to use HK2 to instantiate dropwizard managed object because managed must be registered before HK2 context starts. Guice module \u00b6 But gucie modules are still registered in initialization phase (in GuiceBundle ), when configuration is not available. To overcome this, guicey provides marker interfaces like ConfigurationAwareModule to set configuration object into module before injector creation. Tip If possible, use DropwizardAwareModule as base module class to avoid boilerplate public class SampleModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { configuration () // access configuration environment () // access environment bootstrap () // access dropwizard bootstrap configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) options () // access guicey options } } Note This works only for top level modules registered in root bundle or guicey bundles. Bindings \u00b6 Guicey always apply it's own module ( GuiceBootstrapModule ) to injector. This module adds all extra bindings (for dropwizard and jersey objects). io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Bindings below are not immediately available as HK2 context starts after guice : javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.internal.process.AsyncContext javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse Request scoped objects must be used through provider: @Inject Provider < HttpServletRequest > requestProvider ; Configuration bindings \u00b6 It is quite common need to access configuration value by path, instead of using entire configuration object. Often this removes boilerplate when one option is used in multiple places, compare: @Inject MyConfiguration config ... // in each usage config . getSub (). getFoo () and @Inject @Config ( \"sub.foo\" ) String foo ; // and use direct value in all places Also, often you have some unique configuration sub object, e.g. public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; } It may be more convenient to bind it directly, instead of full configuration: @Inject @Config AuthConfig auth ; Note This is especially helpful for extensions: if extension can be sure that it's configuration object would be used only once in your configuration - it could inject it directly, without dealing with your root configuration class. You can see all available bindings from your configuration using configuration report . Extensions \u00b6 In raw dropwizard you register extensions like: public class App extends Application < Configuration > { ... @Override public void run ( Configuration configuration , Environment environment ) throws Exception { // resource registration environment . jersey (). register ( MyResource . class ); // if extension requires configuration: environment . lifecycle (). manage ( new MyManaged ( configuration . getSomething ())); } } Very easy, just need to remember where it should be registered. If we want to use guice for extensions management, then all extensions must be obtained from guice injector, but it's a boilerplate. Instead, guicey introduce Extension-Installer concept: you create extension (e.g. MyResource ) and Installer knows how to install it. Guicey only need to know extension class. If you use classpath scanning , then you don't need to do anything: guicey will recognize extensions and install them. For example, ResourceInstaller will: recognize MyResource class as rest resource by @Path annotation gets instance from injector ( injector.getInstance(MyResource.class) ) and performs registration environment.jersey().register(guiceManagedInstance) The same way, MangedInstaller recognize MyManaged as managed extension (by implemented interface) and installs guice managed instance (and so all other extensions). Summary With classpath scan you don't need to do anything to install extension and in manual mode you only need to specify extension classes. Tip Most installer implementations are very simple, so you can easily understand how it works (all core installers are declared in core installers bundle ). Jersey extensions \u00b6 It is important to note that jersey extensions ( resources and other ) are forced to be singletons (if explicit scope annotation is not set). This force you to always use all request scoped objects through Provider . But, from the other side, this avoids a jvm garbage from creating them for each request and makes everything a bit faster (no extra DI work required for each request). If you think that developer comfort worth more then small performance gain, then: You can use explicit scope annotations to change singleton scope ( @RequestScoped , @Prototype ) Switch off forced singletons ( .option(InstallerOptions.ForceSingletonForJerseyExtensions, false) ) Delegate some extensions or resources management to HK2 using @HK2Managed Use HK2 by default for jersey extensions Warning Guice AOP will not work on extensions managed by HK2 For more guice-HK2 integration specifics read lifecycle section . Custom extensions \u00b6 Installers are not limited to dropwizard only features: you can use custom installers to write any 3 rd party integration. The only condition is extension classes must have some unique identity (usually annotation). For example, guice has .asEeagerSingleton() configuration option, which declares service as singleton and grants it's initialization in time of injector creation (even in Development scope). Yes, in dropwizard case it's better to use Managed extensions instead, but sometimes eager singletons are convenient for quick hacking something (besides, it's just an example). To simplify eager singleton integrations we create new annotation @EagerSingleton and installer ( EagerSingletonInstaller ) which recognize annotation and register extensions as eager singletons. Now we need to just annotate class and (assuming classpath scan) it will be registered automatically. Tip Installers are also discovered and registered during classpath scan. Another example is PluginInstaller which allows you to declare plugins (e.g. implementing some interface) and inject all of them at once (as Set<PluginInterface> ). Extensions project provides special installer to register events in guava eventBus : EventBusInstaller check class methods and if any method is annotated with @Subscribe - register extension as event bus listener. Not existing, but possible extension for scheduled tasks: we can create @Schedule annotation and write installer to automatically register such classes in scheduler framework. Summary In essence, custom installers could help you avoid many boilerplate operations. Warning Each extension could be installed only by one installer. It will be the first installer which recognize the extension in class (according to installers order ). Core installers override \u00b6 It is also possible to replace any core installer (e.g. to change it's behaviour) - you just need to disable core installer and install a replacement: bootstrap . addBundle ( GuiceBundle . builder () ... . disableInstaller ( ManagedInstaller . class ) . installers ( MyCustomManagedInstaller . class ) . build ()); Tip You can disable all installers enabled by default with: . noDefaultInstallers () In this case, you will have to register some installers manually (even if it would be just a few of guicey's own installers). Bundles \u00b6 Dropwizard use bundles for re-usable logic. Bundle also support both dropwizard phases (in essence, it's the same as application) public interface ConfiguredBundle < T > { void initialize ( Bootstrap <?> bootstrap ); void run ( T configuration , Environment environment ) throws Exception ; } The concept is great, but, in context of guice, dropwizard bundle did not allow us to register guice modules (and, of course, guicey installers and extensions). So there is no way to elegantly re-use dropwizard bundles mechanism. Guicey introduce it's own bundles: public interface GuiceyBundle { void initialize ( GuiceyBootstrap bootstrap ); } GuiceyBootstrap provides almost all the same methods as main GuiceBundle , allowing you to register installers, extensions, modules and other bundles. Also, it provides access to dropwizard objects (bootstrap, configuration, environment) Warning Guicey bundles are called under dropwizard run phase (method name may be confusing, comparing to dropwizard bundles). That means you can't register dropwizard bundles inside guicey bundle (too late for that). Run phase used to provide all dropwizard objects (environment and configuration) and only one method used because guicey bundles usually don't need to register dropwizard bundles) Tip For special cases, there is a way to mix guicey bundle with dropwizard : class must just implement both bundle interfaces. Bundles usage difference \u00b6 In dropwizard bundles are helpful not just for extracting re-usable extensions, but for separation of application logic. In guicey, you don't need to write registration code and, with auto scan enabled, don't need to configure much at all. This makes guicy bundles mostly usable for 3 rd party integrations (or core modules extraction for large projects), where you can't (and should not) rely on class path scan and must declare all installers and extensions manually. Guicey itself comes with multiple bundles: Core installers bundle - installers, enabled by default Web installers bundle - web annotations installers for servlets and filters HK2/guice scope diagnostic bundle - enables instantiation tracking to catch extensions instantiation by both (or just not intended) DI Diagnostics bundle - configuration diagnostic reporting to look under the hood of configuration process Lookup \u00b6 Dropwizard force you to always register bundles manually, and this is good for clarity. But, sometimes, it is desirable to apply bundles under some condition. For example, you want custom installers to be registered when 3 rd party integrations jar is available or you may want to enable some bundles under integration tests only. Guicey provides such ability: add bundles appeared in classpath (with ServiceLoader, not classpath scan) declare extra bundles with system property (for example, could be used in tests) apply custom lookup implementation ServiceLookup based lookup is ideal for 3 rd party integrations. For example, suppose you have scheduler framework integration which provides installers for custom annotation ( @Job ). All you need to do to apply extension is to put integration jar into classpath - installers will be implicitly registered. Important ServiceLookup requires you to prepare extra files so you prepare your bundle for using that way. It does not mean guicey loads all bundles in classpath! Note ServiceLoader and property based lookups are always enabled, but you can switch them off if required with .disableBundleLookup() bundle option. Disabling \u00b6 As you have seen in overriding installers example, you can disable installers. But actually you can disable almost anything: installers, extensions, guice modules and guicey bundles. Mostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else). But, in some cases, you may want to change behaviour of 3 rd party module: as an example above (with replaced installer), you can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles) installation. Suppose you have some 3 rd party bundle: public class XBundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . extensions (...) . modules ( new XModule (), new XAddonModule ()); } } And, for some reason, you don't need XAddonModule guice module, then you can simply disable it: bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new XBundle ()) . disableModules ( XAddonModule . class ) . build ()) Tip You can even perform mass disables by predicate . For example, disable all installations (extensions, bundles etc) from package: . disable ( Disables . inPackage ( \"some.package.here\" )) Guice bindings overrides \u00b6 Guice allows you to override any binding using Modules.override() . With it you can override any service in context. Guicey provides direct shortcut for using this feature . Mostly, this is handful for tests, but could be used to override some service, registered by 3 rd party module (probably registered by some bundle). Options \u00b6 Dropwizard configuration covers most configuration cases, except development specific cases. For example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration). Other example is an ability of low level tuning for 3 rd party bundles. Options are developer configurations: either required only for development or triggers set during development and not intended to be changed later. Options are declared with enum (each enum represents options group) with value type declaration to grant safety. Option could be set only in main bundle (in your application class) You can access options anywhere : guice module, guicey bundle, and in any guice service by injecting special service Options report is included into diagnostic report so you can see all option values. For example, guicey use two option groups: GuiceyOptions and InstallersOptions . GuiceyOptions used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc. That means you have access to all these application configurations from anywhere in your code (for example, you can know if classpath scan is enabled or not in 3 rd party bundle). Another good example is InstallersOptions.JerseyExtensionsManagedByGuice which changes the way jersey extensions are handled: with guice or with HK2. This is developer time decision and must be selected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could know what was chosen. HK2 usage is highly dependent on HK2-guice-bridge presence and with option we can verify it: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" ) Dynamic options \u00b6 You can bind option to system property in order to introduce special \"hidden\" application flag: GuiceBuilder . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . map ()) . build () Now you can run application with -Dmyprop=value and this value will be mapped to option (accessible everywhere in the application). Note There are built-in basic value conversions from string, but in complex cases you can do manual conversion . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) Note You can map options from sys properties, environment variables or strings (obtained somewhere else). You can even allow mass binding to allow external definition of any option .props(\"prefix\") . See options lookup doc. You don't need to remember all this \u00b6 All guicey features could be revealed from main bundle methods. So you don't need to remember everything - just look methods. There is a special group of print[Something] methods, which are intended to help you understand internal state (and help with debugging). As you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan, bundles, bundles installing other bundles, many gucie modules. Also, some bundles may disable extensions, installers, guice modules (and some modules could even override bindings). During startup guicey tracks all performed configurations and you can even access this information at runtime using @Inject GuiceyConfigurationInfo info . Out of the box, guicey could print all this into console, you just need to add .printDiagnosticInfo() : bootstrap . addBundle ( GuiceBundle . builder () . printDiagnosticInfo () . build ()) You can see additional logs in console like: GUICEY started in 453.3 ms \u2502 \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) \u2502 \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms \u2502 \u2514\u2500\u2500 registered 2 commands \u2502 \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms \u2502 \u251c\u2500\u2500 2 resolved in 8.149 ms \u2502 \u2514\u2500\u2500 6 processed ... APPLICATION \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) \u251c\u2500\u2500 module GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) \u2502 \u251c\u2500\u2500 Foo2Bundle (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) *IGNORED \u2502 \u251c\u2500\u2500 module FooBundleModule (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 -disable ManagedInstaller (r.v.d.g.m.i.feature) ... And other logs giving you inside look on configuration. Other helpful reports: printAvailableInstallers() - see all registered installers to know what features you can use printConfigurationBindings() - show available configuration bindings (by path and unique objects) printCustomConfigurationBindings() - the same as above, but without dropwizard configuration (shorter report) printLifecyclePhases() - indicate running steps in logs printLifecyclePhasesDetailed() - very detailed startup reports Not mentioned \u00b6 Dropwizard commands support (automatic commands installation with classpath scan) Hiding classes from classpath scan Integration tests support Lifecycle events Configuration hook Admin rest support Ext integrations like jdbi , eventbus","title":"Concepts overview"},{"location":"concepts/#concepts-overview","text":"Section briefly describes new concepts introduced by guicey and explains why it was done that way. For usage instruction and basic examples see getting-started section .","title":"Concepts overview"},{"location":"concepts/#injector-creation-phase","text":"Dropwizard declares two phases: initialization ( App.initialize method) - when dropwizard app must be configured run ( App.run method) - when configuration is available and extensions could be registered in environment If we create injector in initialization phase then we will not have access to Configuration and Environment in guice modules, but configuration could be required, especially for 3 rd party modules, which does not support lazy configuration. Guicey creates injector at run phase to allow using configuration (and environment) in guice modules. Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it in the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase). For example, it is impossible to use HK2 to instantiate dropwizard managed object because managed must be registered before HK2 context starts.","title":"Injector creation phase"},{"location":"concepts/#guice-module","text":"But gucie modules are still registered in initialization phase (in GuiceBundle ), when configuration is not available. To overcome this, guicey provides marker interfaces like ConfigurationAwareModule to set configuration object into module before injector creation. Tip If possible, use DropwizardAwareModule as base module class to avoid boilerplate public class SampleModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { configuration () // access configuration environment () // access environment bootstrap () // access dropwizard bootstrap configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) options () // access guicey options } } Note This works only for top level modules registered in root bundle or guicey bundles.","title":"Guice module"},{"location":"concepts/#bindings","text":"Guicey always apply it's own module ( GuiceBootstrapModule ) to injector. This module adds all extra bindings (for dropwizard and jersey objects). io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Bindings below are not immediately available as HK2 context starts after guice : javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.internal.process.AsyncContext javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse Request scoped objects must be used through provider: @Inject Provider < HttpServletRequest > requestProvider ;","title":"Bindings"},{"location":"concepts/#configuration-bindings","text":"It is quite common need to access configuration value by path, instead of using entire configuration object. Often this removes boilerplate when one option is used in multiple places, compare: @Inject MyConfiguration config ... // in each usage config . getSub (). getFoo () and @Inject @Config ( \"sub.foo\" ) String foo ; // and use direct value in all places Also, often you have some unique configuration sub object, e.g. public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; } It may be more convenient to bind it directly, instead of full configuration: @Inject @Config AuthConfig auth ; Note This is especially helpful for extensions: if extension can be sure that it's configuration object would be used only once in your configuration - it could inject it directly, without dealing with your root configuration class. You can see all available bindings from your configuration using configuration report .","title":"Configuration bindings"},{"location":"concepts/#extensions","text":"In raw dropwizard you register extensions like: public class App extends Application < Configuration > { ... @Override public void run ( Configuration configuration , Environment environment ) throws Exception { // resource registration environment . jersey (). register ( MyResource . class ); // if extension requires configuration: environment . lifecycle (). manage ( new MyManaged ( configuration . getSomething ())); } } Very easy, just need to remember where it should be registered. If we want to use guice for extensions management, then all extensions must be obtained from guice injector, but it's a boilerplate. Instead, guicey introduce Extension-Installer concept: you create extension (e.g. MyResource ) and Installer knows how to install it. Guicey only need to know extension class. If you use classpath scanning , then you don't need to do anything: guicey will recognize extensions and install them. For example, ResourceInstaller will: recognize MyResource class as rest resource by @Path annotation gets instance from injector ( injector.getInstance(MyResource.class) ) and performs registration environment.jersey().register(guiceManagedInstance) The same way, MangedInstaller recognize MyManaged as managed extension (by implemented interface) and installs guice managed instance (and so all other extensions). Summary With classpath scan you don't need to do anything to install extension and in manual mode you only need to specify extension classes. Tip Most installer implementations are very simple, so you can easily understand how it works (all core installers are declared in core installers bundle ).","title":"Extensions"},{"location":"concepts/#jersey-extensions","text":"It is important to note that jersey extensions ( resources and other ) are forced to be singletons (if explicit scope annotation is not set). This force you to always use all request scoped objects through Provider . But, from the other side, this avoids a jvm garbage from creating them for each request and makes everything a bit faster (no extra DI work required for each request). If you think that developer comfort worth more then small performance gain, then: You can use explicit scope annotations to change singleton scope ( @RequestScoped , @Prototype ) Switch off forced singletons ( .option(InstallerOptions.ForceSingletonForJerseyExtensions, false) ) Delegate some extensions or resources management to HK2 using @HK2Managed Use HK2 by default for jersey extensions Warning Guice AOP will not work on extensions managed by HK2 For more guice-HK2 integration specifics read lifecycle section .","title":"Jersey extensions"},{"location":"concepts/#custom-extensions","text":"Installers are not limited to dropwizard only features: you can use custom installers to write any 3 rd party integration. The only condition is extension classes must have some unique identity (usually annotation). For example, guice has .asEeagerSingleton() configuration option, which declares service as singleton and grants it's initialization in time of injector creation (even in Development scope). Yes, in dropwizard case it's better to use Managed extensions instead, but sometimes eager singletons are convenient for quick hacking something (besides, it's just an example). To simplify eager singleton integrations we create new annotation @EagerSingleton and installer ( EagerSingletonInstaller ) which recognize annotation and register extensions as eager singletons. Now we need to just annotate class and (assuming classpath scan) it will be registered automatically. Tip Installers are also discovered and registered during classpath scan. Another example is PluginInstaller which allows you to declare plugins (e.g. implementing some interface) and inject all of them at once (as Set<PluginInterface> ). Extensions project provides special installer to register events in guava eventBus : EventBusInstaller check class methods and if any method is annotated with @Subscribe - register extension as event bus listener. Not existing, but possible extension for scheduled tasks: we can create @Schedule annotation and write installer to automatically register such classes in scheduler framework. Summary In essence, custom installers could help you avoid many boilerplate operations. Warning Each extension could be installed only by one installer. It will be the first installer which recognize the extension in class (according to installers order ).","title":"Custom extensions"},{"location":"concepts/#core-installers-override","text":"It is also possible to replace any core installer (e.g. to change it's behaviour) - you just need to disable core installer and install a replacement: bootstrap . addBundle ( GuiceBundle . builder () ... . disableInstaller ( ManagedInstaller . class ) . installers ( MyCustomManagedInstaller . class ) . build ()); Tip You can disable all installers enabled by default with: . noDefaultInstallers () In this case, you will have to register some installers manually (even if it would be just a few of guicey's own installers).","title":"Core installers override"},{"location":"concepts/#bundles","text":"Dropwizard use bundles for re-usable logic. Bundle also support both dropwizard phases (in essence, it's the same as application) public interface ConfiguredBundle < T > { void initialize ( Bootstrap <?> bootstrap ); void run ( T configuration , Environment environment ) throws Exception ; } The concept is great, but, in context of guice, dropwizard bundle did not allow us to register guice modules (and, of course, guicey installers and extensions). So there is no way to elegantly re-use dropwizard bundles mechanism. Guicey introduce it's own bundles: public interface GuiceyBundle { void initialize ( GuiceyBootstrap bootstrap ); } GuiceyBootstrap provides almost all the same methods as main GuiceBundle , allowing you to register installers, extensions, modules and other bundles. Also, it provides access to dropwizard objects (bootstrap, configuration, environment) Warning Guicey bundles are called under dropwizard run phase (method name may be confusing, comparing to dropwizard bundles). That means you can't register dropwizard bundles inside guicey bundle (too late for that). Run phase used to provide all dropwizard objects (environment and configuration) and only one method used because guicey bundles usually don't need to register dropwizard bundles) Tip For special cases, there is a way to mix guicey bundle with dropwizard : class must just implement both bundle interfaces.","title":"Bundles"},{"location":"concepts/#bundles-usage-difference","text":"In dropwizard bundles are helpful not just for extracting re-usable extensions, but for separation of application logic. In guicey, you don't need to write registration code and, with auto scan enabled, don't need to configure much at all. This makes guicy bundles mostly usable for 3 rd party integrations (or core modules extraction for large projects), where you can't (and should not) rely on class path scan and must declare all installers and extensions manually. Guicey itself comes with multiple bundles: Core installers bundle - installers, enabled by default Web installers bundle - web annotations installers for servlets and filters HK2/guice scope diagnostic bundle - enables instantiation tracking to catch extensions instantiation by both (or just not intended) DI Diagnostics bundle - configuration diagnostic reporting to look under the hood of configuration process","title":"Bundles usage difference"},{"location":"concepts/#lookup","text":"Dropwizard force you to always register bundles manually, and this is good for clarity. But, sometimes, it is desirable to apply bundles under some condition. For example, you want custom installers to be registered when 3 rd party integrations jar is available or you may want to enable some bundles under integration tests only. Guicey provides such ability: add bundles appeared in classpath (with ServiceLoader, not classpath scan) declare extra bundles with system property (for example, could be used in tests) apply custom lookup implementation ServiceLookup based lookup is ideal for 3 rd party integrations. For example, suppose you have scheduler framework integration which provides installers for custom annotation ( @Job ). All you need to do to apply extension is to put integration jar into classpath - installers will be implicitly registered. Important ServiceLookup requires you to prepare extra files so you prepare your bundle for using that way. It does not mean guicey loads all bundles in classpath! Note ServiceLoader and property based lookups are always enabled, but you can switch them off if required with .disableBundleLookup() bundle option.","title":"Lookup"},{"location":"concepts/#disabling","text":"As you have seen in overriding installers example, you can disable installers. But actually you can disable almost anything: installers, extensions, guice modules and guicey bundles. Mostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else). But, in some cases, you may want to change behaviour of 3 rd party module: as an example above (with replaced installer), you can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles) installation. Suppose you have some 3 rd party bundle: public class XBundle implements GuiceyBundle { public void initialize ( GuiceyBootstrap bootstrap ) { bootstrap . extensions (...) . modules ( new XModule (), new XAddonModule ()); } } And, for some reason, you don't need XAddonModule guice module, then you can simply disable it: bootstrap . addBundle ( GuiceBundle . builder () . bundles ( new XBundle ()) . disableModules ( XAddonModule . class ) . build ()) Tip You can even perform mass disables by predicate . For example, disable all installations (extensions, bundles etc) from package: . disable ( Disables . inPackage ( \"some.package.here\" ))","title":"Disabling"},{"location":"concepts/#guice-bindings-overrides","text":"Guice allows you to override any binding using Modules.override() . With it you can override any service in context. Guicey provides direct shortcut for using this feature . Mostly, this is handful for tests, but could be used to override some service, registered by 3 rd party module (probably registered by some bundle).","title":"Guice bindings overrides"},{"location":"concepts/#options","text":"Dropwizard configuration covers most configuration cases, except development specific cases. For example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration). Other example is an ability of low level tuning for 3 rd party bundles. Options are developer configurations: either required only for development or triggers set during development and not intended to be changed later. Options are declared with enum (each enum represents options group) with value type declaration to grant safety. Option could be set only in main bundle (in your application class) You can access options anywhere : guice module, guicey bundle, and in any guice service by injecting special service Options report is included into diagnostic report so you can see all option values. For example, guicey use two option groups: GuiceyOptions and InstallersOptions . GuiceyOptions used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc. That means you have access to all these application configurations from anywhere in your code (for example, you can know if classpath scan is enabled or not in 3 rd party bundle). Another good example is InstallersOptions.JerseyExtensionsManagedByGuice which changes the way jersey extensions are handled: with guice or with HK2. This is developer time decision and must be selected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could know what was chosen. HK2 usage is highly dependent on HK2-guice-bridge presence and with option we can verify it: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" )","title":"Options"},{"location":"concepts/#dynamic-options","text":"You can bind option to system property in order to introduce special \"hidden\" application flag: GuiceBuilder . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . map ()) . build () Now you can run application with -Dmyprop=value and this value will be mapped to option (accessible everywhere in the application). Note There are built-in basic value conversions from string, but in complex cases you can do manual conversion . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) Note You can map options from sys properties, environment variables or strings (obtained somewhere else). You can even allow mass binding to allow external definition of any option .props(\"prefix\") . See options lookup doc.","title":"Dynamic options"},{"location":"concepts/#you-dont-need-to-remember-all-this","text":"All guicey features could be revealed from main bundle methods. So you don't need to remember everything - just look methods. There is a special group of print[Something] methods, which are intended to help you understand internal state (and help with debugging). As you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan, bundles, bundles installing other bundles, many gucie modules. Also, some bundles may disable extensions, installers, guice modules (and some modules could even override bindings). During startup guicey tracks all performed configurations and you can even access this information at runtime using @Inject GuiceyConfigurationInfo info . Out of the box, guicey could print all this into console, you just need to add .printDiagnosticInfo() : bootstrap . addBundle ( GuiceBundle . builder () . printDiagnosticInfo () . build ()) You can see additional logs in console like: GUICEY started in 453.3 ms \u2502 \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) \u2502 \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms \u2502 \u2514\u2500\u2500 registered 2 commands \u2502 \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms \u2502 \u251c\u2500\u2500 2 resolved in 8.149 ms \u2502 \u2514\u2500\u2500 6 processed ... APPLICATION \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) \u251c\u2500\u2500 module GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) \u2502 \u251c\u2500\u2500 Foo2Bundle (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) *IGNORED \u2502 \u251c\u2500\u2500 module FooBundleModule (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 -disable ManagedInstaller (r.v.d.g.m.i.feature) ... And other logs giving you inside look on configuration. Other helpful reports: printAvailableInstallers() - see all registered installers to know what features you can use printConfigurationBindings() - show available configuration bindings (by path and unique objects) printCustomConfigurationBindings() - the same as above, but without dropwizard configuration (shorter report) printLifecyclePhases() - indicate running steps in logs printLifecyclePhasesDetailed() - very detailed startup reports","title":"You don't need to remember all this"},{"location":"concepts/#not-mentioned","text":"Dropwizard commands support (automatic commands installation with classpath scan) Hiding classes from classpath scan Integration tests support Lifecycle events Configuration hook Admin rest support Ext integrations like jdbi , eventbus","title":"Not mentioned"},{"location":"getting-started/","text":"Getting started \u00b6 Getting started guide briefly shows the most commonly used features. Advanced description of guicey concepts may be found in the concepts section . If you are migrating from dropwizard-guice, read migration guide . Installation \u00b6 Available from maven central and bintray jcenter . Maven: <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> <version> 4.2.2 </version> </dependency> Gradle: compile 'ru.vyarus:dropwizard-guicey:4.2.2' BOM \u00b6 Guicey pom may be also used as maven BOM: plugins { id \"io.spring.dependency-management\" version \"1.0.6.RELEASE\" } dependencyManagement { imports { mavenBom 'ru.vyarus:dropwizard-guicey:4.2.2' // uncomment to override dropwizard version // mavenBom 'io.dropwizard:dropwizard-bom:1.3.7' } } dependencies { compile 'ru.vyarus:dropwizard-guicey:4.2.2' // no need to specify versions compile 'io.dropwizard:dropwizard-auth' compile 'com.google.inject:guice-assistedinject' testCompile 'io.dropwizard:dropwizard-test' testCompile 'org.spockframework:spock-core' } Bom includes: Dropwizard BOM (io.dropwizard:dropwizard-bom) Guice BOM (com.google.inject:guice-bom) HK2 bridge (org.glassfish.hk2:guice-bridge) System rules, required for StartupErrorRule (com.github.stefanbirkner:system-rules) Spock (org.spockframework:spock-core) Guicey extensions project provide extended BOM with guicey and all guicey modules included. See extensions project BOM section for more details of BOM usage. Usage \u00b6 Full source of example application is published here Register guice bundle: public class SampleApplication extends Application < Configuration > { public static void main ( String [] args ) throws Exception { new SampleApplication (). run ( args ); } @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( getClass (). getPackage (). getName ()) . build ()); } @Override public void run ( Configuration configuration , Environment environment ) throws Exception { } } Tip Bundle builder contains shortcuts for all available features, so required function may be found only by looking at available methods (and reading javadoc). Auto configuration (activated with enableAutoConfig ) means that guicey will search for extensions in application package and subpackages. Tip You can declare multiple packages for classpath scan: . enableAutoConfig ( \"com.mycompany.foo\" , \"com.mycompany.bar\" ) Application could be launched by simply running main class (assume you will use IDE run command): SampleApplication server Note config.yml is not passed as parameter because we don't need additional configuration now Add resource \u00b6 Creating custom rest resource: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @GET @Path ( \"/\" ) public Response ask () { return Response . ok ( \"ok\" ). build (); } } Now, when you run application, you can see that resource was installed automatically: INFO [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource) Call http://localhost:8080/sample/ to make sure it works. Tip Rest context is mapped to root by default. To change it use configuration file: server : rootPath : '/rest/*' Resource is a guice bean, so you can use guice injection here. To accessing request specific objects like request, response, jersey javax.ws.rs.core.UriInfo etc. use Provider : @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/\" ) public Response ask () { final String ip = requestProvider . get (). getRemoteAddr (); return Response . ok ( ip ). build (); } } Now resource will return caller IP. Important Providers must be used instead of @Context field injections Also, you can inject request specific objects as method parameter Field injection used in examples for simplicity. In real life projects prefer constructor injection . By default, resources are forced to be singletons (when no scope annotation defined). Add managed \u00b6 Dropwizard managed objects are extremely useful for managing resources. Create simple managed implementation: @Singleton public class SampleBootstrap implements Managed { private final Logger logger = LoggerFactory . getLogger ( SampleBootstrap . class ); @Override public void start () throws Exception { logger . info ( \"Starting some resource\" ); } @Override public void stop () throws Exception { logger . info ( \"Shutting down some resource\" ); } } It will be automatically discovered and installed. Guicey always reports installed extensions (when they are not reported by dropwizard itself). So you can see in startup logs now: INFO [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap) Add filter \u00b6 Note Guice ServletModule may be used for servlets and filters definitions, but most of the time it's more convenient to use simple servlet annotations ( @WebFilter , @WebServlet , @WebListener ). Moreover, guice servlet module is not able to register async filters and servlets. To use @WebFilter annotation for filter installation web installers must be activated with shortcut method: bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( getClass (). getPackage (). getName ()) . useWebInstallers () . build ()); Add sample filter around rest methods: @WebFilter ( urlPatterns = \"/*\" ) public class CustomHeaderFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( \"me\" . equals ( request . getParameter ( \"user\" ))) { chain . doFilter ( request , response ); } else { (( HttpServletResponse ) response ) . sendError ( HttpServletResponse . SC_UNAUTHORIZED , \"Not authorized\" ); } } @Override public void destroy () { } } Filter will pass through only requests with user=me request parameter. It is used just to show how to register custom filters with annotations (implementation itself is not useful). New lines in log will appear confirming filter installation: INFO [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters = /* (ru.vyarus.dropwizard.guice.examples.web.AuthFilter) .auth Call http://localhost:8080/sample/ and http://localhost:8080/sample/?user=me to make sure filter works. Add guice module \u00b6 If you need to register guice module in injector: bootstrap . addBundle ( GuiceBundle . builder () ... . modules ( new SampleModule ()) . build ()); Multiple modules could be registered: . modules ( new SampleModule (), new Some3rdPatyModule ()) Guice ServletModule could be used for filters and servlets registration. If you have at least one module of your own then it's recommended to move all guice modules registration there to encapsulate guice staff: . modules ( new SampleModule ()) public class SampleModule extends AbstractModule { @Override protected void configure () { install ( new Some3rdPatyModule ()); // some custom bindings there } } Except when you need to access dropwizard objects in module Warning Guicey removes duplicate registrations by type. For example, in case: . modules ( new SampleModule (), new SampleModule ()) Only one module will be registered. This is intentional restriction to simplify bundles usage (to let you register common modules in different bundles and be sure that only one instance will be used). In some cases, it could be desired to use different instances of the same module: . modules ( new ParametrizableModule ( \"mod1\" ), new ParametrizableModule ( \"mod2\" )) This will not work (second instance will be dropped). In such cases do registrations in custom guice module: install ( new ParametrizableModule ( \"mod1\" )); install ( new ParametrizableModule ( \"mod2\" )); Manual mode \u00b6 If you don't want to use auto configuration, then you will have to manually specify all extensions. Example above would look in manual mode like this: bootstrap . addBundle ( GuiceBundle . builder () . useWebInstallers () . modules ( new SampleModule ()) . extensions ( SampleResource . class , SampleBootstrap . class , CustomHeaderFilter . class ) . build ()); As you can see the actual difference is only the absence of classpath scan, so you have to manually specify all extensions. Tip Explicit extensions declaration could be used in auto configuration mode too: for example, classpath scan could not cover all packages with extensions (e.g. due to too much classes) and not covered extensions may be specified manually. Important Duplicate extensions are filtered. If some extension is registered manually and also found with auto scan then only one extension instance will be registered. Even if extension registered multiple times manually, only one extension will work.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"Getting started guide briefly shows the most commonly used features. Advanced description of guicey concepts may be found in the concepts section . If you are migrating from dropwizard-guice, read migration guide .","title":"Getting started"},{"location":"getting-started/#installation","text":"Available from maven central and bintray jcenter . Maven: <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> <version> 4.2.2 </version> </dependency> Gradle: compile 'ru.vyarus:dropwizard-guicey:4.2.2'","title":"Installation"},{"location":"getting-started/#bom","text":"Guicey pom may be also used as maven BOM: plugins { id \"io.spring.dependency-management\" version \"1.0.6.RELEASE\" } dependencyManagement { imports { mavenBom 'ru.vyarus:dropwizard-guicey:4.2.2' // uncomment to override dropwizard version // mavenBom 'io.dropwizard:dropwizard-bom:1.3.7' } } dependencies { compile 'ru.vyarus:dropwizard-guicey:4.2.2' // no need to specify versions compile 'io.dropwizard:dropwizard-auth' compile 'com.google.inject:guice-assistedinject' testCompile 'io.dropwizard:dropwizard-test' testCompile 'org.spockframework:spock-core' } Bom includes: Dropwizard BOM (io.dropwizard:dropwizard-bom) Guice BOM (com.google.inject:guice-bom) HK2 bridge (org.glassfish.hk2:guice-bridge) System rules, required for StartupErrorRule (com.github.stefanbirkner:system-rules) Spock (org.spockframework:spock-core) Guicey extensions project provide extended BOM with guicey and all guicey modules included. See extensions project BOM section for more details of BOM usage.","title":"BOM"},{"location":"getting-started/#usage","text":"Full source of example application is published here Register guice bundle: public class SampleApplication extends Application < Configuration > { public static void main ( String [] args ) throws Exception { new SampleApplication (). run ( args ); } @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( getClass (). getPackage (). getName ()) . build ()); } @Override public void run ( Configuration configuration , Environment environment ) throws Exception { } } Tip Bundle builder contains shortcuts for all available features, so required function may be found only by looking at available methods (and reading javadoc). Auto configuration (activated with enableAutoConfig ) means that guicey will search for extensions in application package and subpackages. Tip You can declare multiple packages for classpath scan: . enableAutoConfig ( \"com.mycompany.foo\" , \"com.mycompany.bar\" ) Application could be launched by simply running main class (assume you will use IDE run command): SampleApplication server Note config.yml is not passed as parameter because we don't need additional configuration now","title":"Usage"},{"location":"getting-started/#add-resource","text":"Creating custom rest resource: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @GET @Path ( \"/\" ) public Response ask () { return Response . ok ( \"ok\" ). build (); } } Now, when you run application, you can see that resource was installed automatically: INFO [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource) Call http://localhost:8080/sample/ to make sure it works. Tip Rest context is mapped to root by default. To change it use configuration file: server : rootPath : '/rest/*' Resource is a guice bean, so you can use guice injection here. To accessing request specific objects like request, response, jersey javax.ws.rs.core.UriInfo etc. use Provider : @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/\" ) public Response ask () { final String ip = requestProvider . get (). getRemoteAddr (); return Response . ok ( ip ). build (); } } Now resource will return caller IP. Important Providers must be used instead of @Context field injections Also, you can inject request specific objects as method parameter Field injection used in examples for simplicity. In real life projects prefer constructor injection . By default, resources are forced to be singletons (when no scope annotation defined).","title":"Add resource"},{"location":"getting-started/#add-managed","text":"Dropwizard managed objects are extremely useful for managing resources. Create simple managed implementation: @Singleton public class SampleBootstrap implements Managed { private final Logger logger = LoggerFactory . getLogger ( SampleBootstrap . class ); @Override public void start () throws Exception { logger . info ( \"Starting some resource\" ); } @Override public void stop () throws Exception { logger . info ( \"Shutting down some resource\" ); } } It will be automatically discovered and installed. Guicey always reports installed extensions (when they are not reported by dropwizard itself). So you can see in startup logs now: INFO [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)","title":"Add managed"},{"location":"getting-started/#add-filter","text":"Note Guice ServletModule may be used for servlets and filters definitions, but most of the time it's more convenient to use simple servlet annotations ( @WebFilter , @WebServlet , @WebListener ). Moreover, guice servlet module is not able to register async filters and servlets. To use @WebFilter annotation for filter installation web installers must be activated with shortcut method: bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( getClass (). getPackage (). getName ()) . useWebInstallers () . build ()); Add sample filter around rest methods: @WebFilter ( urlPatterns = \"/*\" ) public class CustomHeaderFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( \"me\" . equals ( request . getParameter ( \"user\" ))) { chain . doFilter ( request , response ); } else { (( HttpServletResponse ) response ) . sendError ( HttpServletResponse . SC_UNAUTHORIZED , \"Not authorized\" ); } } @Override public void destroy () { } } Filter will pass through only requests with user=me request parameter. It is used just to show how to register custom filters with annotations (implementation itself is not useful). New lines in log will appear confirming filter installation: INFO [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters = /* (ru.vyarus.dropwizard.guice.examples.web.AuthFilter) .auth Call http://localhost:8080/sample/ and http://localhost:8080/sample/?user=me to make sure filter works.","title":"Add filter"},{"location":"getting-started/#add-guice-module","text":"If you need to register guice module in injector: bootstrap . addBundle ( GuiceBundle . builder () ... . modules ( new SampleModule ()) . build ()); Multiple modules could be registered: . modules ( new SampleModule (), new Some3rdPatyModule ()) Guice ServletModule could be used for filters and servlets registration. If you have at least one module of your own then it's recommended to move all guice modules registration there to encapsulate guice staff: . modules ( new SampleModule ()) public class SampleModule extends AbstractModule { @Override protected void configure () { install ( new Some3rdPatyModule ()); // some custom bindings there } } Except when you need to access dropwizard objects in module Warning Guicey removes duplicate registrations by type. For example, in case: . modules ( new SampleModule (), new SampleModule ()) Only one module will be registered. This is intentional restriction to simplify bundles usage (to let you register common modules in different bundles and be sure that only one instance will be used). In some cases, it could be desired to use different instances of the same module: . modules ( new ParametrizableModule ( \"mod1\" ), new ParametrizableModule ( \"mod2\" )) This will not work (second instance will be dropped). In such cases do registrations in custom guice module: install ( new ParametrizableModule ( \"mod1\" )); install ( new ParametrizableModule ( \"mod2\" ));","title":"Add guice module"},{"location":"getting-started/#manual-mode","text":"If you don't want to use auto configuration, then you will have to manually specify all extensions. Example above would look in manual mode like this: bootstrap . addBundle ( GuiceBundle . builder () . useWebInstallers () . modules ( new SampleModule ()) . extensions ( SampleResource . class , SampleBootstrap . class , CustomHeaderFilter . class ) . build ()); As you can see the actual difference is only the absence of classpath scan, so you have to manually specify all extensions. Tip Explicit extensions declaration could be used in auto configuration mode too: for example, classpath scan could not cover all packages with extensions (e.g. due to too much classes) and not covered extensions may be specified manually. Important Duplicate extensions are filtered. If some extension is registered manually and also found with auto scan then only one extension instance will be registered. Even if extension registered multiple times manually, only one extension will work.","title":"Manual mode"},{"location":"about/compatibility/","text":"Dropwizard compatibility \u00b6 Dropwizard Guicey 1.3.0 4.2.2 1.2.0 4.1.0 1.1.0 4.1.0 1.0 4.0.1 0.9 3.3.0 0.8 3.1.0 0.7 1.1.0","title":"Compatibility"},{"location":"about/compatibility/#dropwizard-compatibility","text":"Dropwizard Guicey 1.3.0 4.2.2 1.2.0 4.1.0 1.1.0 4.1.0 1.0 4.0.1 0.9 3.3.0 0.8 3.1.0 0.7 1.1.0","title":"Dropwizard compatibility"},{"location":"about/history/","text":"4.2.2 (2018-11-26) \u00b6 Update to guice 4.2.2 (java 11 compatible) Update to dropwizard 1.3.7 Fix inner non static classes detection by classpath scan Fix lifecycle debug messages decoration (unicode fix) 4.2.1 (2018-07-23) \u00b6 Show warning when configuration path's value resolution failed instead of startup fail (#53) Add GuiceyOptions.BindConfigurationByPath to be able to disable configuration introspection (for edge cases) (#53) Fix unique sub configuration object access (#54) 4.2.0 (2018-06-25) \u00b6 Update to guice 4.2.0 remove guice-multibindings dependency as it's moved to guice core Update to dropwizard 1.3.5 Add more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions: Guicey bundles disabled through main builder only: .disableBundles() Other disable methods available in both main bundle and guicey bundles bootstrap: .disableModules(Class...) - disable guice modules .disableExtensions(Class...) - extensions disabling (for possible replacement) generic disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.) Add direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap: .modulesOverride(Module...) Add BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case) Add hooks for configuration override in integration tests (#23): New GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods) Junit: New rule GuiceyConfigurationRule for hook registration Spock: New @UseGuiceyConfiguration extension allows base hook definition (in base class) New attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks Add guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment. It may be used to write instance specific features (post processing) or just advanced logging Add new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...) Add guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic): .printLifecyclePhases() - identify configuration stages in console logs .printLifecyclePhasesDetailed() - identify lifecycle phases with detailed configuration report (in console logs) Improve options support: Add OptionsAwareModule interface to let guice modules access options Add OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options() Add ability to manage jersey extensions with HK2 by default (#41). It's like using @HK2Managed on all jersey-related beans (resources, filters etc). This is useful, for example, if you get common to jersey resources features like @Context injection. Add option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default. HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not). Add @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless). In guice-first mode this annotation is useless. Builder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling. Guice beans scope-related improvements: Singleton scope is not forced for jersey extensions with explicit scoping annotation Add option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions Add annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled Fix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49) Add Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object) Add ConfigScope enum for special scopes description (to not remember special classes). Add shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo) (breaking) Config reporting api changes: Diagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items Diagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application) New configuration bindings: Configuration object could be bound as: any class from configuration class hierarchy (as before) any class from hierarchy with @Config qualifier: @Inject @Config Configuration conf interface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config (Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before), but prefer binding interfaces with qualifier (@Config), which is always available. Option will be removed in the future versions (Deprecated) bundle's builder.bindConfigurationInterfaces() Configuration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg Sub configuration objects could be bound without path if object type appear only once in configuration: @Inject @Config ServerFactory serverCfg ConfigurationTree - configuration introspection object is available for direct binding and from GuiceyConfigurationInfo bean: getConfigurationTree() Alternative configuration access: New configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule): configuration(String) - configuration value by path configuration(Class) - unique sub configuration object configurations(Class) - all sub configuration objects with assignable type (on any depth) configurationTree() - access raw introspection data for more complex searches Reports to see available config bindings (before injector creation for potential problems solving) in main bundle: .printConfigurationBindings() - log all bindings (including dropwizard Configuration) .printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes) Includes much improved generics-resolver 4.1.0 (2017-05-09) \u00b6 Update to dropwizard 1.1.0 Add StartupErrorRule to simplify dropwizard startup error testing (breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used to enable bridge (#28) Fix NPE when used with JRebel (#29) Add binding for jersey javax.ws.rs.container.ResourceInfo (#26) Fix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32) Fix guava conflict in guicey pom. Make guicey pom usable as BOM. 4.0.1 (2016-11-18) \u00b6 Update to dropwizard 1.0.5 and fix compatibility (#24) Fix guice version conflict for maven (#20) 4.0.0 (2016-08-22) \u00b6 Update to dropwizard 1.0.0 (breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle) Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts: WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3 rd party bundles use it's own low-level options. GuiceyBootstrap option(option) method provides access to defined options from bundles Options guice bean provide access to options from guice services Installers could access options by implementing WithOptions interface OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions()) Options reporting added to DiagnosticBundle (breaking) remove GuiceBunldle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) (use either shortcuts without parameters or generic options method instead) (breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option (breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava (breaking) InjectorLookup changed to use java8 Optional instead of guava Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2) Add methods to GuiceBundle builder: option(option, value) - used to specify custom option value options(Map) - used to provide multiple options at once (for custom options lookup mechanisms) printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features) useWebInstallers() - shortcut for installing WebInstallersBundle noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support noDefaultInstallers() - disables CoreInstallersBundle automatic installation 3.3.0 (2016-08-02) \u00b6 Update to guice 4.1.0 Update to dropwizard 0.9.3 Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings ResourceInstaller looks for @Path on directly implemented interface (#10) Fix bundles lookup reporting (correct multiline) Fix duplicate extensions installation when registered both manually and by auto scan Restrict extension installation to one installer (first matching, according to installers order) Improve dropwizard configuration class binding: Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself) (optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces())) Add GuiceyBootstrap methods (extend GuiceyBundle abilities): bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type. application(): returns current application instance Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc) Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). Add GuiceBundle builder configuration options: bindConfigurationInterfaces() to enable configuration interface bindings strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests) printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs) shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces() NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api) 3.2.0 (2016-01-23) \u00b6 Clear possible duplicate guicey bundle instances Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources. Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles. Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions. Add builder bundleLookup method to register custom lookup implementation Add builder disableBundleLookup to disable default lookups Default lookup implementation logs all resolved bundles Fix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support. Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed are managed by HK2 only. May be used in tests as extra validation. Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. Update to dropwizard 0.9 Revert system exit on guice injector creation error (added in 3.1.1) 3.1.1 (2015-11-24) \u00b6 Exit on guice injector creation error. Add classpath scan packages validation for intersection (to prevent duplicate instances) 3.1.0 (2015-09-06) \u00b6 JerseyProviderInstaller: add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener support multiple extension interfaces on the same bean Introduce bundles (GuiceyBundle) to simplify extensions: core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed builder bundles() method to add guicey bundles builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism) Add admin context rest support (AdminRestBundle) Add request scoped beans support in admin context 3.0.1 (2015-07-04) \u00b6 Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces 3.0.0 (2015-04-26) \u00b6 Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) (breaking) Remove static state from GuiceBundle: GuiceBundle.getInjector method remain, but its now instance specific (instead of static) Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() JerseyInstaller interface signature changed: now install method receives injector instance 2.2.0 (2015-04-17) \u00b6 Fix ExceptionMapper registration Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 (to simplify custom installers injection between them) 2.1.2 (2015-03-03) \u00b6 Spock 1.0 compatibility 2.1.1 (2015-01-25) \u00b6 Dropwizard 0.8-rc2 compatibility 2.1.0 (2015-01-04) \u00b6 Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by Nicholas Pace Add spock extensions to use injections directly in specification (like spock-guice do) 2.0.0 (2014-11-25) \u00b6 Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)). Jersey integration completely rewritten. Add JerseyInstaller installer type Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request) 1.1.0 (2014-10-23) \u00b6 Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils Drop java 1.6 compatibility, because dropwizard is 1.7 compatible Add junit rule for lightweight testing (run guice without starting jetty) 1.0.0 (2014-10-14) \u00b6 Add dependency on guice-multibindings Installers may choose now from three types of installation (binding, type or instance) or combine them. Add PluginInstaller: shortcut for multibindings mechanism Updated guice (4.0.beta4 -> 4.0.beta5) Force singleton for resources @Eager renamed to @EagerSingleton and now forces singleton scope for bean Add dropwizard style reporting for installed features (like resources or tasks) Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers) Add admin context filter and servlet installers Rename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions 0.9.0 (2014-09-05) \u00b6 Initial release","title":"Release notes"},{"location":"about/history/#422-2018-11-26","text":"Update to guice 4.2.2 (java 11 compatible) Update to dropwizard 1.3.7 Fix inner non static classes detection by classpath scan Fix lifecycle debug messages decoration (unicode fix)","title":"4.2.2 (2018-11-26)"},{"location":"about/history/#421-2018-07-23","text":"Show warning when configuration path's value resolution failed instead of startup fail (#53) Add GuiceyOptions.BindConfigurationByPath to be able to disable configuration introspection (for edge cases) (#53) Fix unique sub configuration object access (#54)","title":"4.2.1 (2018-07-23)"},{"location":"about/history/#420-2018-06-25","text":"Update to guice 4.2.0 remove guice-multibindings dependency as it's moved to guice core Update to dropwizard 1.3.5 Add more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions: Guicey bundles disabled through main builder only: .disableBundles() Other disable methods available in both main bundle and guicey bundles bootstrap: .disableModules(Class...) - disable guice modules .disableExtensions(Class...) - extensions disabling (for possible replacement) generic disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.) Add direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap: .modulesOverride(Module...) Add BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case) Add hooks for configuration override in integration tests (#23): New GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods) Junit: New rule GuiceyConfigurationRule for hook registration Spock: New @UseGuiceyConfiguration extension allows base hook definition (in base class) New attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks Add guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment. It may be used to write instance specific features (post processing) or just advanced logging Add new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...) Add guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic): .printLifecyclePhases() - identify configuration stages in console logs .printLifecyclePhasesDetailed() - identify lifecycle phases with detailed configuration report (in console logs) Improve options support: Add OptionsAwareModule interface to let guice modules access options Add OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options() Add ability to manage jersey extensions with HK2 by default (#41). It's like using @HK2Managed on all jersey-related beans (resources, filters etc). This is useful, for example, if you get common to jersey resources features like @Context injection. Add option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default. HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not). Add @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless). In guice-first mode this annotation is useless. Builder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling. Guice beans scope-related improvements: Singleton scope is not forced for jersey extensions with explicit scoping annotation Add option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions Add annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled Fix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49) Add Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object) Add ConfigScope enum for special scopes description (to not remember special classes). Add shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo) (breaking) Config reporting api changes: Diagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items Diagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application) New configuration bindings: Configuration object could be bound as: any class from configuration class hierarchy (as before) any class from hierarchy with @Config qualifier: @Inject @Config Configuration conf interface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config (Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before), but prefer binding interfaces with qualifier (@Config), which is always available. Option will be removed in the future versions (Deprecated) bundle's builder.bindConfigurationInterfaces() Configuration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg Sub configuration objects could be bound without path if object type appear only once in configuration: @Inject @Config ServerFactory serverCfg ConfigurationTree - configuration introspection object is available for direct binding and from GuiceyConfigurationInfo bean: getConfigurationTree() Alternative configuration access: New configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule): configuration(String) - configuration value by path configuration(Class) - unique sub configuration object configurations(Class) - all sub configuration objects with assignable type (on any depth) configurationTree() - access raw introspection data for more complex searches Reports to see available config bindings (before injector creation for potential problems solving) in main bundle: .printConfigurationBindings() - log all bindings (including dropwizard Configuration) .printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes) Includes much improved generics-resolver","title":"4.2.0 (2018-06-25)"},{"location":"about/history/#410-2017-05-09","text":"Update to dropwizard 1.1.0 Add StartupErrorRule to simplify dropwizard startup error testing (breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used to enable bridge (#28) Fix NPE when used with JRebel (#29) Add binding for jersey javax.ws.rs.container.ResourceInfo (#26) Fix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32) Fix guava conflict in guicey pom. Make guicey pom usable as BOM.","title":"4.1.0 (2017-05-09)"},{"location":"about/history/#401-2016-11-18","text":"Update to dropwizard 1.0.5 and fix compatibility (#24) Fix guice version conflict for maven (#20)","title":"4.0.1 (2016-11-18)"},{"location":"about/history/#400-2016-08-22","text":"Update to dropwizard 1.0.0 (breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle) Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts: WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3 rd party bundles use it's own low-level options. GuiceyBootstrap option(option) method provides access to defined options from bundles Options guice bean provide access to options from guice services Installers could access options by implementing WithOptions interface OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions()) Options reporting added to DiagnosticBundle (breaking) remove GuiceBunldle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) (use either shortcuts without parameters or generic options method instead) (breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option (breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava (breaking) InjectorLookup changed to use java8 Optional instead of guava Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2) Add methods to GuiceBundle builder: option(option, value) - used to specify custom option value options(Map) - used to provide multiple options at once (for custom options lookup mechanisms) printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features) useWebInstallers() - shortcut for installing WebInstallersBundle noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support noDefaultInstallers() - disables CoreInstallersBundle automatic installation","title":"4.0.0 (2016-08-22)"},{"location":"about/history/#330-2016-08-02","text":"Update to guice 4.1.0 Update to dropwizard 0.9.3 Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings ResourceInstaller looks for @Path on directly implemented interface (#10) Fix bundles lookup reporting (correct multiline) Fix duplicate extensions installation when registered both manually and by auto scan Restrict extension installation to one installer (first matching, according to installers order) Improve dropwizard configuration class binding: Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself) (optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces())) Add GuiceyBootstrap methods (extend GuiceyBundle abilities): bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type. application(): returns current application instance Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc) Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). Add GuiceBundle builder configuration options: bindConfigurationInterfaces() to enable configuration interface bindings strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests) printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs) shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces() NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)","title":"3.3.0 (2016-08-02)"},{"location":"about/history/#320-2016-01-23","text":"Clear possible duplicate guicey bundle instances Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources. Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles. Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions. Add builder bundleLookup method to register custom lookup implementation Add builder disableBundleLookup to disable default lookups Default lookup implementation logs all resolved bundles Fix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support. Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed are managed by HK2 only. May be used in tests as extra validation. Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. Update to dropwizard 0.9 Revert system exit on guice injector creation error (added in 3.1.1)","title":"3.2.0 (2016-01-23)"},{"location":"about/history/#311-2015-11-24","text":"Exit on guice injector creation error. Add classpath scan packages validation for intersection (to prevent duplicate instances)","title":"3.1.1 (2015-11-24)"},{"location":"about/history/#310-2015-09-06","text":"JerseyProviderInstaller: add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener support multiple extension interfaces on the same bean Introduce bundles (GuiceyBundle) to simplify extensions: core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed builder bundles() method to add guicey bundles builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism) Add admin context rest support (AdminRestBundle) Add request scoped beans support in admin context","title":"3.1.0 (2015-09-06)"},{"location":"about/history/#301-2015-07-04","text":"Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces","title":"3.0.1 (2015-07-04)"},{"location":"about/history/#300-2015-04-26","text":"Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) (breaking) Remove static state from GuiceBundle: GuiceBundle.getInjector method remain, but its now instance specific (instead of static) Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() JerseyInstaller interface signature changed: now install method receives injector instance","title":"3.0.0 (2015-04-26)"},{"location":"about/history/#220-2015-04-17","text":"Fix ExceptionMapper registration Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 (to simplify custom installers injection between them)","title":"2.2.0 (2015-04-17)"},{"location":"about/history/#212-2015-03-03","text":"Spock 1.0 compatibility","title":"2.1.2 (2015-03-03)"},{"location":"about/history/#211-2015-01-25","text":"Dropwizard 0.8-rc2 compatibility","title":"2.1.1 (2015-01-25)"},{"location":"about/history/#210-2015-01-04","text":"Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by Nicholas Pace Add spock extensions to use injections directly in specification (like spock-guice do)","title":"2.1.0 (2015-01-04)"},{"location":"about/history/#200-2014-11-25","text":"Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)). Jersey integration completely rewritten. Add JerseyInstaller installer type Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)","title":"2.0.0 (2014-11-25)"},{"location":"about/history/#110-2014-10-23","text":"Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils Drop java 1.6 compatibility, because dropwizard is 1.7 compatible Add junit rule for lightweight testing (run guice without starting jetty)","title":"1.1.0 (2014-10-23)"},{"location":"about/history/#100-2014-10-14","text":"Add dependency on guice-multibindings Installers may choose now from three types of installation (binding, type or instance) or combine them. Add PluginInstaller: shortcut for multibindings mechanism Updated guice (4.0.beta4 -> 4.0.beta5) Force singleton for resources @Eager renamed to @EagerSingleton and now forces singleton scope for bean Add dropwizard style reporting for installed features (like resources or tasks) Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers) Add admin context filter and servlet installers Rename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions","title":"1.0.0 (2014-10-14)"},{"location":"about/history/#090-2014-09-05","text":"Initial release","title":"0.9.0 (2014-09-05)"},{"location":"about/license/","text":"The MIT License (MIT) Copyright \u00a9 2014-2018, Vyacheslav Rusakov Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/support/","text":"Support \u00b6 Google group - mailing list Gitter - chat Github issues - problems / enhancements","title":"Support"},{"location":"about/support/#support","text":"Google group - mailing list Gitter - chat Github issues - problems / enhancements","title":"Support"},{"location":"examples/authentication/","text":"Authentication \u00b6 Example of dropwizard authentication usage with guice. Simple auth \u00b6 Using dropwizard oauth example as basement. Other auth types are configured in similar way. @Provider public class OAuthDynamicFeature extends AuthDynamicFeature { @Inject public OAuthDynamicFeature ( OAuthAuthenticator authenticator , UserAuthorizer authorizer , Environment environment ) { super ( new OAuthCredentialAuthFilter . Builder < User >() . setAuthenticator ( authenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ()); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } // classes below may be external (internal for simplicity) @Singleton public static class OAuthAuthenticator implements Authenticator < String , User > { @Override public Optional < User > authenticate ( String credentials ) throws AuthenticationException { return Optional . fromNullable ( \"valid\" . equals ( credentials ) ? new User () : null ); } } @Singleton public static class UserAuthorizer implements Authorizer < User > { @Override public boolean authorize ( User user , String role ) { return user . getName (). equals ( \"good-guy\" ) && role . equals ( \"ADMIN\" ); } } } The class is automatically picked up by the jersey installer . OAuthAuthenticator and OAuthAuthorizer are simple guice beans (no special installation required). Constructor injection is used to obtain required guice managed instances and then configure authentication the same way as described in dropwizard docs. If auto configuration is enabled, then the class will be resolved and installed automatically. Complete OAuth example source Chained auth \u00b6 Chained auth can be used to support different authentication schemes. Integration approach is the same as in simple case: @Provider public class ChainedAuthDynamicFeature extends AuthDynamicFeature { @Inject public ChainedAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OAuthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( new ChainedAuthFilter ( Arrays . asList ( new BasicCredentialAuthFilter . Builder <>() . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Basic\" ) . buildAuthFilter (), new OAuthCredentialAuthFilter . Builder <>() . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter () ))); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } } Polymorphic auth \u00b6 Polymorphic auth allows using different auth schemes simultaneously. Integration approach is the same as in simple case: @Provider public class PolyAuthDynamicFeature extends PolymorphicAuthDynamicFeature { @Inject public PolyAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OauthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( ImmutableMap . of ( BasicPrincipal . class , new BasicCredentialAuthFilter . Builder < BasicPrincipal >() . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setRealm ( \"SUPER SECRET STUFF\" ) . buildAuthFilter (), OAuthPrincipal . class , new OAuthCredentialAuthFilter . Builder < OAuthPrincipal >() . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ())); final AbstractBinder binder = new PolymorphicAuthValueFactoryProvider . Binder <>( ImmutableSet . of ( BasicPrincipal . class , OAuthPrincipal . class )); environment . jersey (). register ( binder ); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); } }","title":"Authentication"},{"location":"examples/authentication/#authentication","text":"Example of dropwizard authentication usage with guice.","title":"Authentication"},{"location":"examples/authentication/#simple-auth","text":"Using dropwizard oauth example as basement. Other auth types are configured in similar way. @Provider public class OAuthDynamicFeature extends AuthDynamicFeature { @Inject public OAuthDynamicFeature ( OAuthAuthenticator authenticator , UserAuthorizer authorizer , Environment environment ) { super ( new OAuthCredentialAuthFilter . Builder < User >() . setAuthenticator ( authenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ()); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } // classes below may be external (internal for simplicity) @Singleton public static class OAuthAuthenticator implements Authenticator < String , User > { @Override public Optional < User > authenticate ( String credentials ) throws AuthenticationException { return Optional . fromNullable ( \"valid\" . equals ( credentials ) ? new User () : null ); } } @Singleton public static class UserAuthorizer implements Authorizer < User > { @Override public boolean authorize ( User user , String role ) { return user . getName (). equals ( \"good-guy\" ) && role . equals ( \"ADMIN\" ); } } } The class is automatically picked up by the jersey installer . OAuthAuthenticator and OAuthAuthorizer are simple guice beans (no special installation required). Constructor injection is used to obtain required guice managed instances and then configure authentication the same way as described in dropwizard docs. If auto configuration is enabled, then the class will be resolved and installed automatically. Complete OAuth example source","title":"Simple auth"},{"location":"examples/authentication/#chained-auth","text":"Chained auth can be used to support different authentication schemes. Integration approach is the same as in simple case: @Provider public class ChainedAuthDynamicFeature extends AuthDynamicFeature { @Inject public ChainedAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OAuthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( new ChainedAuthFilter ( Arrays . asList ( new BasicCredentialAuthFilter . Builder <>() . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Basic\" ) . buildAuthFilter (), new OAuthCredentialAuthFilter . Builder <>() . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter () ))); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } }","title":"Chained auth"},{"location":"examples/authentication/#polymorphic-auth","text":"Polymorphic auth allows using different auth schemes simultaneously. Integration approach is the same as in simple case: @Provider public class PolyAuthDynamicFeature extends PolymorphicAuthDynamicFeature { @Inject public PolyAuthDynamicFeature ( BasicAuthenticator basicAuthenticator , OauthAuthenticator oauthAuthenticator , UserAuthorizer authorizer , Environment environment ) { super ( ImmutableMap . of ( BasicPrincipal . class , new BasicCredentialAuthFilter . Builder < BasicPrincipal >() . setAuthenticator ( basicAuthenticator ) . setAuthorizer ( authorizer ) . setRealm ( \"SUPER SECRET STUFF\" ) . buildAuthFilter (), OAuthPrincipal . class , new OAuthCredentialAuthFilter . Builder < OAuthPrincipal >() . setAuthenticator ( oauthAuthenticator ) . setAuthorizer ( authorizer ) . setPrefix ( \"Bearer\" ) . buildAuthFilter ())); final AbstractBinder binder = new PolymorphicAuthValueFactoryProvider . Binder <>( ImmutableSet . of ( BasicPrincipal . class , OAuthPrincipal . class )); environment . jersey (). register ( binder ); environment . jersey (). register ( RolesAllowedDynamicFeature . class ); } }","title":"Polymorphic auth"},{"location":"examples/eventbus/","text":"Guava EventBus integration \u00b6 Example of guicey-eventbus extension usage. Example source code The eventbus extension is used for: automatic listeners registration binding eventbus instance in guice context (for publication) printing available listeners to console Configuration \u00b6 An additional dependency is required: compile 'ru.vyarus.guicey:guicey-eventbus:0.6.0' Note guicey-eventbus version could be managed with BOM Register eventbus bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ()) Event \u00b6 Events are simple POJOs. Create event classes with properties you need (or without everything): public class FooEvent { private String something ; public FooEvent ( String something ) { this . something = something ; } public void getSomething () { return something ; } } Use event hierarchies, if appropriate: public abstract class BaseEvent {} public class FooEvent extends BaseEvent {} public class BarEvent extends BaseEvent {} For simplicity, properties are omitted. Publication \u00b6 Inject the eventbus instance to enable publication: @Inject EventBus eventbus ; public void someAction () { ... eventbus . post ( new FooEvent ()); } Listening \u00b6 Listener methods must be annotated with @Subscribe and contain only one parameter of the target event type: @Subscribe public void onFooEvent ( FooEvent event ) {} @Subscribe // listen for all events of type (FooEvent, BarEvent) public void onMultipleEvents ( BaseEvent event ) {} Attention Listener methods will only be registered for \"known\" guice beans. That means any extension or manually declared guice bean (using module) or bean created with guice AOT (because it's declared as dependency for other bean) will be searched for listener methods. See a complete example","title":"EventBus"},{"location":"examples/eventbus/#guava-eventbus-integration","text":"Example of guicey-eventbus extension usage. Example source code The eventbus extension is used for: automatic listeners registration binding eventbus instance in guice context (for publication) printing available listeners to console","title":"Guava EventBus integration"},{"location":"examples/eventbus/#configuration","text":"An additional dependency is required: compile 'ru.vyarus.guicey:guicey-eventbus:0.6.0' Note guicey-eventbus version could be managed with BOM Register eventbus bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ())","title":"Configuration"},{"location":"examples/eventbus/#event","text":"Events are simple POJOs. Create event classes with properties you need (or without everything): public class FooEvent { private String something ; public FooEvent ( String something ) { this . something = something ; } public void getSomething () { return something ; } } Use event hierarchies, if appropriate: public abstract class BaseEvent {} public class FooEvent extends BaseEvent {} public class BarEvent extends BaseEvent {} For simplicity, properties are omitted.","title":"Event"},{"location":"examples/eventbus/#publication","text":"Inject the eventbus instance to enable publication: @Inject EventBus eventbus ; public void someAction () { ... eventbus . post ( new FooEvent ()); }","title":"Publication"},{"location":"examples/eventbus/#listening","text":"Listener methods must be annotated with @Subscribe and contain only one parameter of the target event type: @Subscribe public void onFooEvent ( FooEvent event ) {} @Subscribe // listen for all events of type (FooEvent, BarEvent) public void onMultipleEvents ( BaseEvent event ) {} Attention Listener methods will only be registered for \"known\" guice beans. That means any extension or manually declared guice bean (using module) or bean created with guice AOT (because it's declared as dependency for other bean) will be searched for listener methods. See a complete example","title":"Listening"},{"location":"examples/governator/","text":"Governator integration \u00b6 Include the Netflix Governator dependency: compile \"com.netflix.governator:governator:1.5.11\" Governator owns injector creation , so we need to create custom guicey InjectorFactory public class GovernatorInjectorFactory implements InjectorFactory { public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return LifecycleInjector . builder (). withModules ( modules ). inStage ( stage ). build (). createInjector (); } } Configure the new factory in the guice bundle: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new GovernatorInjectorFactory ()) . enableAutoConfig ( \"com.mycompany.myapp\" ) ... . build () ); } Note Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package). Governator Lifecycle \u00b6 Many Governator enhancements are only available when the Governator LifecycleManager is properly started and closed with the application. Use dropwizard's managed object to control governator lifecycle: import io.dropwizard.lifecycle.Managed ; import ru.vyarus.dropwizard.guice.GuiceBundle ; import com.netflix.governator.lifecycle.LifecycleManager ; import javax.inject.Inject ; public class GovernatorLifecycle implements Managed { @Inject private LifecycleManager manager ; @Override public void start () throws Exception { manager . start (); } @Override public void stop () throws Exception { manager . close (); } } Guicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard. This will \"bind\" the governator lifecycle to the dropwizard lifecycle. Note If you need to control the order which the managed beans are started, use the @Order annotation .","title":"Governator"},{"location":"examples/governator/#governator-integration","text":"Include the Netflix Governator dependency: compile \"com.netflix.governator:governator:1.5.11\" Governator owns injector creation , so we need to create custom guicey InjectorFactory public class GovernatorInjectorFactory implements InjectorFactory { public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return LifecycleInjector . builder (). withModules ( modules ). inStage ( stage ). build (). createInjector (); } } Configure the new factory in the guice bundle: @Override public void initialize ( Bootstrap < Configuration > bootstrap ) { bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new GovernatorInjectorFactory ()) . enableAutoConfig ( \"com.mycompany.myapp\" ) ... . build () ); } Note Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).","title":"Governator integration"},{"location":"examples/governator/#governator-lifecycle","text":"Many Governator enhancements are only available when the Governator LifecycleManager is properly started and closed with the application. Use dropwizard's managed object to control governator lifecycle: import io.dropwizard.lifecycle.Managed ; import ru.vyarus.dropwizard.guice.GuiceBundle ; import com.netflix.governator.lifecycle.LifecycleManager ; import javax.inject.Inject ; public class GovernatorLifecycle implements Managed { @Inject private LifecycleManager manager ; @Override public void start () throws Exception { manager . start (); } @Override public void stop () throws Exception { manager . close (); } } Guicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard. This will \"bind\" the governator lifecycle to the dropwizard lifecycle. Note If you need to control the order which the managed beans are started, use the @Order annotation .","title":"Governator Lifecycle"},{"location":"examples/hibernate/","text":"Hibernate integration \u00b6 Example of dropwizard-hibernate bundle usage with guicey. Example source code Configuration \u00b6 Additional dependencies required: compile 'io.dropwizard:dropwizard-hibernate:1.3.0' compile 'com.h2database:h2:1.4.193' H2 used as the simplest example. Overall configuration is exactly the same as described in dropwizard docs , but extracted to separate class for simplicity: public class HbnBundle extends HibernateBundle < HbnAppConfiguration > { public HbnBundle () { super ( Sample . class ); } @Override public PooledDataSourceFactory getDataSourceFactory ( HbnAppConfiguration configuration ) { return configuration . getDataSourceFactory (); } } Note All model classes are configured inside the constructor: super ( Sample . class ); Configuration class: public class HbnAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDataSourceFactory () { return database ; } } Configuration file for in-memory database and automatic schema creation: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:mem:sample properties : charSet : UTF-8 hibernate.dialect : org.hibernate.dialect.H2Dialect hibernate.hbm2ddl.auto : create Guice integration \u00b6 Guice module used to provide SessionFactory instance into guice context: public class HbnModule extends AbstractModule { private final HbnBundle hbnBundle ; public HbnModule ( HbnBundle hbnBundle ) { this . hbnBundle = hbnBundle ; } @Override protected void configure () { bind ( SessionFactory . class ). toInstance ( hbnBundle . getSessionFactory ()); } } Application: @Override public void initialize ( Bootstrap < HbnAppConfiguration > bootstrap ) { final HbnBundle hibernate = new HbnBundle (); // register hbn bundle before guice to make sure factory initialized before guice context start bootstrap . addBundle ( hibernate ); bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( \"com.myapp.package\" ) . modules ( new HbnModule ( hibernate )) . build ()); } Usage \u00b6 It is simpler to use dropwizard AbstractDAO for hibernate logic: public class SampleService extends AbstractDAO < Sample > { @Inject public SampleService ( SessionFactory factory ) { super ( factory ); } public void create ( Sample sample ) { return persist ( sample ); } public List < Sample > findAll () { return list ( currentSession (). createQuery ( \"from Sample\" )); } } You will need to use dropwizard @UnitOfWork annotation to declare transaction scope. For example: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private SampleService service ; @GET @Path ( \"/\" ) @Timed @UnitOfWork public Response doStaff () { final Sample sample = new Sample ( \"sample\" ); service . create ( sample ); final List < Sample > res = service . findAll (); // using response to render entities inside unit of work and avoid lazy load exceptions return Response . ok ( res ). build (); } }","title":"Hibernate"},{"location":"examples/hibernate/#hibernate-integration","text":"Example of dropwizard-hibernate bundle usage with guicey. Example source code","title":"Hibernate integration"},{"location":"examples/hibernate/#configuration","text":"Additional dependencies required: compile 'io.dropwizard:dropwizard-hibernate:1.3.0' compile 'com.h2database:h2:1.4.193' H2 used as the simplest example. Overall configuration is exactly the same as described in dropwizard docs , but extracted to separate class for simplicity: public class HbnBundle extends HibernateBundle < HbnAppConfiguration > { public HbnBundle () { super ( Sample . class ); } @Override public PooledDataSourceFactory getDataSourceFactory ( HbnAppConfiguration configuration ) { return configuration . getDataSourceFactory (); } } Note All model classes are configured inside the constructor: super ( Sample . class ); Configuration class: public class HbnAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDataSourceFactory () { return database ; } } Configuration file for in-memory database and automatic schema creation: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:mem:sample properties : charSet : UTF-8 hibernate.dialect : org.hibernate.dialect.H2Dialect hibernate.hbm2ddl.auto : create","title":"Configuration"},{"location":"examples/hibernate/#guice-integration","text":"Guice module used to provide SessionFactory instance into guice context: public class HbnModule extends AbstractModule { private final HbnBundle hbnBundle ; public HbnModule ( HbnBundle hbnBundle ) { this . hbnBundle = hbnBundle ; } @Override protected void configure () { bind ( SessionFactory . class ). toInstance ( hbnBundle . getSessionFactory ()); } } Application: @Override public void initialize ( Bootstrap < HbnAppConfiguration > bootstrap ) { final HbnBundle hibernate = new HbnBundle (); // register hbn bundle before guice to make sure factory initialized before guice context start bootstrap . addBundle ( hibernate ); bootstrap . addBundle ( GuiceBundle . builder () . enableAutoConfig ( \"com.myapp.package\" ) . modules ( new HbnModule ( hibernate )) . build ()); }","title":"Guice integration"},{"location":"examples/hibernate/#usage","text":"It is simpler to use dropwizard AbstractDAO for hibernate logic: public class SampleService extends AbstractDAO < Sample > { @Inject public SampleService ( SessionFactory factory ) { super ( factory ); } public void create ( Sample sample ) { return persist ( sample ); } public List < Sample > findAll () { return list ( currentSession (). createQuery ( \"from Sample\" )); } } You will need to use dropwizard @UnitOfWork annotation to declare transaction scope. For example: @Path ( \"/sample\" ) @Produces ( \"application/json\" ) public class SampleResource { @Inject private SampleService service ; @GET @Path ( \"/\" ) @Timed @UnitOfWork public Response doStaff () { final Sample sample = new Sample ( \"sample\" ); service . create ( sample ); final List < Sample > res = service . findAll (); // using response to render entities inside unit of work and avoid lazy load exceptions return Response . ok ( res ). build (); } }","title":"Usage"},{"location":"examples/jdbi/","text":"JDBI integration \u00b6 Example of guicey-jdbi extension usage. Example source code The JDBI extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation Configuration \u00b6 Additional dependencies required: compile 'ru.vyarus.guicey:guicey-jdbi:0.6.0' compile 'com.h2database:h2:1.4.193' Note guicey-jdbi version could be managed with BOM dropwizard-jdbi is used to configure and create dbi instance: public class JdbiAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. DBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle .< JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) Note You can use pre-build dbi instance instead. Repository definition \u00b6 Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public abstract class UserRepository extends Crud < User > { // have to use field injection because class is still used by dbi (which is no aware of guice) for proxy creation @Inject private RandomNameGenerator generator ; // sample of hybrid method in repository, using injected service public User createRandomUser () { final User user = new User (); user . setName ( generator . generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys public abstract long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override public abstract int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) public abstract List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) public abstract User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base class tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public abstract class Crud < T extends IdEntity > { @InTransaction public T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } public abstract long insert ( T entry ); public abstract int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use field injections: @Inject private RandomNameGenerator generator ; Result set mapper \u00b6 Result set mapper is used to map query result set to entity: public class UserMapper implements ResultSetMapper < User > { @Override public User map ( int index , ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the dbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you dont want to use auto configuration then you can register it manually in dbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @BindingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements BinderFactory < UserBind > { @Override public Binder build ( UserBind annotation ) { return ( Binder < UserBind , User >) ( q , bind , arg ) -> { q . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by DBI. Usage \u00b6 Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"JDBI"},{"location":"examples/jdbi/#jdbi-integration","text":"Example of guicey-jdbi extension usage. Example source code The JDBI extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation","title":"JDBI integration"},{"location":"examples/jdbi/#configuration","text":"Additional dependencies required: compile 'ru.vyarus.guicey:guicey-jdbi:0.6.0' compile 'com.h2database:h2:1.4.193' Note guicey-jdbi version could be managed with BOM dropwizard-jdbi is used to configure and create dbi instance: public class JdbiAppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. DBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle .< JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) Note You can use pre-build dbi instance instead.","title":"Configuration"},{"location":"examples/jdbi/#repository-definition","text":"Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public abstract class UserRepository extends Crud < User > { // have to use field injection because class is still used by dbi (which is no aware of guice) for proxy creation @Inject private RandomNameGenerator generator ; // sample of hybrid method in repository, using injected service public User createRandomUser () { final User user = new User (); user . setName ( generator . generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys public abstract long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override public abstract int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) public abstract List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) public abstract User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base class tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public abstract class Crud < T extends IdEntity > { @InTransaction public T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } public abstract long insert ( T entry ); public abstract int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use field injections: @Inject private RandomNameGenerator generator ;","title":"Repository definition"},{"location":"examples/jdbi/#result-set-mapper","text":"Result set mapper is used to map query result set to entity: public class UserMapper implements ResultSetMapper < User > { @Override public User map ( int index , ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the dbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you dont want to use auto configuration then you can register it manually in dbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @BindingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements BinderFactory < UserBind > { @Override public Binder build ( UserBind annotation ) { return ( Binder < UserBind , User >) ( q , bind , arg ) -> { q . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by DBI.","title":"Result set mapper"},{"location":"examples/jdbi/#usage","text":"Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"Usage"},{"location":"examples/jdbi3/","text":"JDBI3 integration \u00b6 Example of guicey-jdbi3 extension usage. Example source code The JDBI3 extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation Configuration \u00b6 Additional dependencies required: compile 'ru.vyarus.guicey:guicey-jdbi3:0.6.0' compile 'com.h2database:h2:1.4.193' Note guicey-jdbi version could be managed with BOM dropwizard-jdbi3 is used to configure and create dbi instance: public class Jdbi3AppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. JDBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle .< JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) . withPlugins ( new H2DatabasePlugin ())) Note You can use pre-build jdbi instance instead. Repository definition \u00b6 Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public interface UserRepository extends Crud < User > { @Inject RandomNameGenerator getGenerator (); // sample of hybrid method in repository, using injected service default User createRandomUser () { final User user = new User (); user . setName ( getGenerator (). generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base interface tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public interface Crud < T extends IdEntity > { @InTransaction default T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } long insert ( T entry ); int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use getter injections: @Inject RandomNameGenerator getGenerator (); Row mapper \u00b6 Row mapper is used to map query result set to entity: public class UserMapper implements RowMapper < User > { @Override public User map ( ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the jdbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you don't want to use auto configuration then you can register it manually in jdbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @SqlStatementCustomizingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements SqlStatementCustomizerFactory { @Override public SqlStatementParameterCustomizer createForParameter ( Annotation annotation , Class <?> sqlObjectType , Method method , Parameter param , int index , Type paramType ) { return ( stmt , obj ) -> { User arg = ( User ) obj ; (( SqlStatement ) stmt ) . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by JDBI. Usage \u00b6 Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"JDBI3"},{"location":"examples/jdbi3/#jdbi3-integration","text":"Example of guicey-jdbi3 extension usage. Example source code The JDBI3 extension allows: using jdbi proxies as guice beans using injection inside proxies using AOP on proxies using annotations for transaction definition automatic repository and mapper installation","title":"JDBI3 integration"},{"location":"examples/jdbi3/#configuration","text":"Additional dependencies required: compile 'ru.vyarus.guicey:guicey-jdbi3:0.6.0' compile 'com.h2database:h2:1.4.193' Note guicey-jdbi version could be managed with BOM dropwizard-jdbi3 is used to configure and create dbi instance: public class Jdbi3AppConfiguration extends Configuration { @Valid @NotNull @JsonProperty private DataSourceFactory database = new DataSourceFactory (); public DataSourceFactory getDatabase () { return database ; } } For simplicity, an embedded H2 database is used: database : driverClass : org.h2.Driver user : sa password : url : jdbc:h2:~/sample properties : charSet : UTF-8 maxWaitForConnection : 1s validationQuery : \"SELECT 1\" validationQueryTimeout : 3s minSize : 8 maxSize : 32 checkConnectionWhileIdle : false evictionInterval : 10s minIdleTime : 1 minute Warning Database scheme must be created manually. You can use dropwizard-flyway module to prepare database. See example app source for details. JDBI instance created exactly as described in dropwizard docs using provided db configuration: GuiceBundle . builder () . bundles ( JdbiBundle .< JdbiAppConfiguration > forDatabase (( conf , env ) -> conf . getDatabase ())) . withPlugins ( new H2DatabasePlugin ())) Note You can use pre-build jdbi instance instead.","title":"Configuration"},{"location":"examples/jdbi3/#repository-definition","text":"Warning All jdbi repositories must be annotated with @JdbiRepository to let the repository installer recognize and properly install them. @JdbiRepository @InTransaction public interface UserRepository extends Crud < User > { @Inject RandomNameGenerator getGenerator (); // sample of hybrid method in repository, using injected service default User createRandomUser () { final User user = new User (); user . setName ( getGenerator (). generateName ()); save ( user ); return user ; } @Override @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) @GetGeneratedKeys long insert ( @UserBind User entry ); @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) @Override int update ( @UserBind User entry ); @SqlQuery ( \"select * from users\" ) List < User > findAll (); @SqlQuery ( \"select * from users where name = :name\" ) User findByName ( @Bind ( \"name\" ) String name ); } Where Crud base interface tries to unify repositories and provide hibernate-like optimistic locking behaviour (on each entity save version field is assigned/incremented and checked during update to prevent data loss): public interface Crud < T extends IdEntity > { @InTransaction default T save ( final T entry ) { // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database if ( entry . getId () == 0 ) { entry . setVersion ( 1 ); entry . setId ( insert ( entry )); } else { final int ver = entry . getVersion (); entry . setVersion ( ver + 1 ); if ( update ( entry ) == 0 ) { throw new ConcurrentModificationException ( String . format ( \"Concurrent modification for object %s %s version %s\" , entry . getClass (). getName (), entry . getId (), ver )); } } return entry ; } long insert ( T entry ); int update ( T entry ); } You don't necessarily need to use Crud - it's an advanced usage example. The repository is annotated with @InTransaction to allow direct usage; repository method calls are the smallest transaction scope. The transaction scope can be enlarged by using annotations on calling guice beans or declaring transactions manually . In order to better understand how transactions work, read the unit of work docs section . Note @InTransaction is handled with guice AOP, so you can use any other guice aop related features. Attention Constructor injection is impossible in repositories, but you can use getter injections: @Inject RandomNameGenerator getGenerator ();","title":"Repository definition"},{"location":"examples/jdbi3/#row-mapper","text":"Row mapper is used to map query result set to entity: public class UserMapper implements RowMapper < User > { @Override public User map ( ResultSet r , StatementContext ctx ) throws SQLException { User user = new User (); user . setId ( r . getLong ( \"id\" )); user . setVersion ( r . getInt ( \"version\" )); user . setName ( r . getString ( \"name\" )); return user ; } } Mappers are installed with the mapper installer . If auto scan is enabled then all mappers will be detected automatically and registered in the jdbi instance. Mappers are instantiated as normal guice beans without restrictions which means you can use injection and aop (it's only not shown in example mapper). Note The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean and you don't want to use auto configuration then you can register it manually in jdbi instance, making it available for injection. Also, see complementing binding annotation, used to bind object to query parameters: @SqlStatementCustomizingAnnotation ( UserBind . UserBinder . class ) @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . PARAMETER ) public @interface UserBind { class UserBinder implements SqlStatementCustomizerFactory { @Override public SqlStatementParameterCustomizer createForParameter ( Annotation annotation , Class <?> sqlObjectType , Method method , Parameter param , int index , Type paramType ) { return ( stmt , obj ) -> { User arg = ( User ) obj ; (( SqlStatement ) stmt ) . bind ( \"id\" , arg . getId ()) . bind ( \"version\" , arg . getVersion ()) . bind ( \"name\" , arg . getName ()); }; } } } See @UserBind usage above in repository definition. There is no custom installer for annotation because it's detected automatically by JDBI.","title":"Row mapper"},{"location":"examples/jdbi3/#usage","text":"Repositories are used as normal guice beans: @Path ( \"/users\" ) @Produces ( \"application/json\" ) public class UserResource { @Inject private final UserRepository repository ; @POST @Path ( \"/\" ) public User create ( String name ) { User user = new User (); user . setName ( name ); return repository . save ( user ); } @GET @Path ( \"/\" ) public List < User > findAll () { return repository . findAll (); } } UserMapper and UserBind are used implicitly to convert the POJO into a db record and back. You can use @InTransaction on repository method to enlarge transaction scope, but, in contrast to hibernate you dont't have to always declare it to avoid lazy initialization exception (because jdbi produces simple pojos). Note @InTrasaction is named to avoid confusion with the commonly used @Transactional annotation. You can bind any annotation class if you like to use a different name (the annotation is just a marker)","title":"Usage"},{"location":"extras/admin-rest/","text":"Admin REST \u00b6 All rest resources could be \"published\" in the admin context too. This is just an emulation of rest: the same resources are accessible in both contexts. On admin side special servlet simply redirects all incoming requests into the jersey context. Such an approach is better than registering a completely separate jersey context for admin rest because of no overhead and the simplicity of jersey extensions management. Configuration \u00b6 To install admin rest servlet, register bundle: bootstrap . addBundle ( new AdminRestBundle ()); In this case, rest is registered either to '/api/ ', if main context rest is mapped to root ('/ ') or to the same path as main context rest. To register on a custom path: bootstrap . addBundle ( new AdminRestBundle ( \"/custom/*\" )); Security \u00b6 In order to hide specific resource methods or entire resources on the main context, annotate resource methods or resource classes with the @AdminResource annotation. For example: @GET @Path ( \"/admin\" ) @AdminResource public String admin () { return \"admin\" } This (annotated) method will return 403 error when called from main context, but should function normally when called from the admin context. This is just the simplest option to control resources access. Any other method may be used (with some security framework or something else).","title":"Admin REST"},{"location":"extras/admin-rest/#admin-rest","text":"All rest resources could be \"published\" in the admin context too. This is just an emulation of rest: the same resources are accessible in both contexts. On admin side special servlet simply redirects all incoming requests into the jersey context. Such an approach is better than registering a completely separate jersey context for admin rest because of no overhead and the simplicity of jersey extensions management.","title":"Admin REST"},{"location":"extras/admin-rest/#configuration","text":"To install admin rest servlet, register bundle: bootstrap . addBundle ( new AdminRestBundle ()); In this case, rest is registered either to '/api/ ', if main context rest is mapped to root ('/ ') or to the same path as main context rest. To register on a custom path: bootstrap . addBundle ( new AdminRestBundle ( \"/custom/*\" ));","title":"Configuration"},{"location":"extras/admin-rest/#security","text":"In order to hide specific resource methods or entire resources on the main context, annotate resource methods or resource classes with the @AdminResource annotation. For example: @GET @Path ( \"/admin\" ) @AdminResource public String admin () { return \"admin\" } This (annotated) method will return 403 error when called from main context, but should function normally when called from the admin context. This is just the simplest option to control resources access. Any other method may be used (with some security framework or something else).","title":"Security"},{"location":"extras/bom/","text":"Guicey BOM \u00b6 Extensions project module Maven BOM containing guicey and guicey ext modules versions. Also includes dropwizard and guice boms. Tip BOM's are useful for versions management. After including bom you can simply include required dependencies (dropwizard, guice, guicey, guicey-ext) without versions: bom version will control all versions. BOM version Guicey Dropwizard Guice 0.7.0 4.2.2 1.3.7 4.2.2 0.6.0 4.2.2 1.3.7 4.2.2 0.5.0 4.2.1 1.3.5 4.2.0 0.4.0 4.2.0 1.3.5 4.2.0 0.3.0 4.1.0 1.1.0 4.1.0 Setup \u00b6 Maven: <!-- Implicitly imports Dropwizard and Guice BOMs --> <dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-bom </artifactId> <version> 0.7.0 </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <!-- declare guice and ext modules without versions --> <dependencies> <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> </dependency> <!-- For example, using dropwizard module (without version) --> <dependency> <groupId> io.dropwizard </groupId> <artifactId> dropwizard-auth </artifactId> </dependency> <!-- Example of extension module usage --> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> </dependency> </dependencies> Gradle: plugins { id \"io.spring.dependency-management\" version \"1.0.6.RELEASE\" } dependencyManagement { // Implicitly imports Dropwizard and Guice BOMs imports { mavenBom \"ru.vyarus.guicey:guicey-bom:0.7.0\" } } // declare guice and ext modules without versions dependencies { compile 'ru.vyarus:dropwizard-guicey' // For example, using dropwizard module (without version) compile 'io.dropwizard:dropwizard-auth' // Example of extension module usage compile 'ru.vyarus.guicey:guicey-eventbus' } Spring's dependency management plugin is required to import BOM. Dependencies override \u00b6 You may override BOM version for any dependency by simply specifying exact version in dependecy declaration section. If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly: io.dropwizard:dropwizard-bom:$VERSION for dropwizard com.google.inject:guice-bom:$VERSION for guice","title":"BOM"},{"location":"extras/bom/#guicey-bom","text":"Extensions project module Maven BOM containing guicey and guicey ext modules versions. Also includes dropwizard and guice boms. Tip BOM's are useful for versions management. After including bom you can simply include required dependencies (dropwizard, guice, guicey, guicey-ext) without versions: bom version will control all versions. BOM version Guicey Dropwizard Guice 0.7.0 4.2.2 1.3.7 4.2.2 0.6.0 4.2.2 1.3.7 4.2.2 0.5.0 4.2.1 1.3.5 4.2.0 0.4.0 4.2.0 1.3.5 4.2.0 0.3.0 4.1.0 1.1.0 4.1.0","title":"Guicey BOM"},{"location":"extras/bom/#setup","text":"Maven: <!-- Implicitly imports Dropwizard and Guice BOMs --> <dependencyManagement> <dependencies> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-bom </artifactId> <version> 0.7.0 </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <!-- declare guice and ext modules without versions --> <dependencies> <dependency> <groupId> ru.vyarus </groupId> <artifactId> dropwizard-guicey </artifactId> </dependency> <!-- For example, using dropwizard module (without version) --> <dependency> <groupId> io.dropwizard </groupId> <artifactId> dropwizard-auth </artifactId> </dependency> <!-- Example of extension module usage --> <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> </dependency> </dependencies> Gradle: plugins { id \"io.spring.dependency-management\" version \"1.0.6.RELEASE\" } dependencyManagement { // Implicitly imports Dropwizard and Guice BOMs imports { mavenBom \"ru.vyarus.guicey:guicey-bom:0.7.0\" } } // declare guice and ext modules without versions dependencies { compile 'ru.vyarus:dropwizard-guicey' // For example, using dropwizard module (without version) compile 'io.dropwizard:dropwizard-auth' // Example of extension module usage compile 'ru.vyarus.guicey:guicey-eventbus' } Spring's dependency management plugin is required to import BOM.","title":"Setup"},{"location":"extras/bom/#dependencies-override","text":"You may override BOM version for any dependency by simply specifying exact version in dependecy declaration section. If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly: io.dropwizard:dropwizard-bom:$VERSION for dropwizard com.google.inject:guice-bom:$VERSION for guice","title":"Dependencies override"},{"location":"extras/eventbus/","text":"Guava EventBus integration \u00b6 Extensions project module Integrates Guava EventBus with guice. Features: EventBus available for injection (to publish events) Automatic registration of listener methods (annotated with @Subscribe ) Console reporting of registered listeners Setup \u00b6 Remove version in dependency declaration below if you using the BOM extensions . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-eventbus:0.7.0' See the most recent version in the badge above. Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ()) ... Create event: public class MyEvent { // some state } Inject EventBus to publish new events. public class SomeService { @Inject private EventBus eventbus ; public void inSomeMethod () { evetbus . post ( new MyEvent ()); } } Listen for event: public class SomeOtherService { @Subscribe public void onEvent ( MyEvent event ) { // handle event } } After server start you should see all registered event listeners in the log: INFO [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = MyEvent com.foo.something.SomeOtherService Note Only subscriptions of beans registered at the time of injector startup will be shown. For example, if MyBean has a subscription method but a binding for it is not declared (and noone depends on it), a JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs. Consuming multiple events \u00b6 Note that you can build event hierarchies and subscribe to some base event to receive any derived event. To receive all events use: @Subscribe public void onEvent ( Object event ){ } Event bus \u00b6 By default, events will be handled synchronously ( bus.push() waits while all subscribers process). If you want events to be async use custom eventbus: new EventBusBundle ( new AsyncEventBus ( someExecutor ) ) By default, event listeners are not considered thread safe and no parallel events processing (for single method) will be performed. To mark subscriber as thread safe use @AllowConcurrentEvents : @Subscribe @AllowConcurrentEvents public void onEvent ( MyEvent event ) If a listener method fails to process an event (throws an exception), then other listeners will still be processed and the exception will be logged. If you want to change this behaviour, set a custom exception handler by creating a custom eventbus instance: new EventBusBundle ( new EventBus ( customExceptionHandler ) ) Listeners recognition \u00b6 The guice type listener is used to intercept all bean instances and thus looks at every method in the class hierarchy; however, only beans that actually have @Subscribe rs will be registered with the event bus. This process is fast and usually causes no issues. If needed, you can reduce the scope with a custom class matcher: new EventBusBundle () . withMatcher ( Matchers . inSubpackage ( \"some.package\" )) If you want maximum performance, then you can add a marker annotation (e.g. @HasEvents ) and reduce scope to just annotated classes: new EventBusBundle () . withMatcher ( Matchers . annotatedWith ( HasEvents . class )) Console reporting \u00b6 You can switch off console reporting (for example, if you have too many listeners): new EventBusBundle (). noReport () Note Reporting has to use reflection to get subscribers list. If this fails with a newer guava version (not yet supported), then simply disable reporting and everything will work as expected. Subscribers info bean \u00b6 EventSubscribersInfo is a registered (available for injection) bean that provides active listeners and used event types. As described above, it uses reflection internally to access the eventbus listeners map. It may be useful for testing.","title":"Guava EventBus"},{"location":"extras/eventbus/#guava-eventbus-integration","text":"Extensions project module Integrates Guava EventBus with guice. Features: EventBus available for injection (to publish events) Automatic registration of listener methods (annotated with @Subscribe ) Console reporting of registered listeners","title":"Guava EventBus integration"},{"location":"extras/eventbus/#setup","text":"Remove version in dependency declaration below if you using the BOM extensions . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-eventbus </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-eventbus:0.7.0' See the most recent version in the badge above.","title":"Setup"},{"location":"extras/eventbus/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( new EventBusBundle ()) ... Create event: public class MyEvent { // some state } Inject EventBus to publish new events. public class SomeService { @Inject private EventBus eventbus ; public void inSomeMethod () { evetbus . post ( new MyEvent ()); } } Listen for event: public class SomeOtherService { @Subscribe public void onEvent ( MyEvent event ) { // handle event } } After server start you should see all registered event listeners in the log: INFO [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = MyEvent com.foo.something.SomeOtherService Note Only subscriptions of beans registered at the time of injector startup will be shown. For example, if MyBean has a subscription method but a binding for it is not declared (and noone depends on it), a JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs.","title":"Usage"},{"location":"extras/eventbus/#consuming-multiple-events","text":"Note that you can build event hierarchies and subscribe to some base event to receive any derived event. To receive all events use: @Subscribe public void onEvent ( Object event ){ }","title":"Consuming multiple events"},{"location":"extras/eventbus/#event-bus","text":"By default, events will be handled synchronously ( bus.push() waits while all subscribers process). If you want events to be async use custom eventbus: new EventBusBundle ( new AsyncEventBus ( someExecutor ) ) By default, event listeners are not considered thread safe and no parallel events processing (for single method) will be performed. To mark subscriber as thread safe use @AllowConcurrentEvents : @Subscribe @AllowConcurrentEvents public void onEvent ( MyEvent event ) If a listener method fails to process an event (throws an exception), then other listeners will still be processed and the exception will be logged. If you want to change this behaviour, set a custom exception handler by creating a custom eventbus instance: new EventBusBundle ( new EventBus ( customExceptionHandler ) )","title":"Event bus"},{"location":"extras/eventbus/#listeners-recognition","text":"The guice type listener is used to intercept all bean instances and thus looks at every method in the class hierarchy; however, only beans that actually have @Subscribe rs will be registered with the event bus. This process is fast and usually causes no issues. If needed, you can reduce the scope with a custom class matcher: new EventBusBundle () . withMatcher ( Matchers . inSubpackage ( \"some.package\" )) If you want maximum performance, then you can add a marker annotation (e.g. @HasEvents ) and reduce scope to just annotated classes: new EventBusBundle () . withMatcher ( Matchers . annotatedWith ( HasEvents . class ))","title":"Listeners recognition"},{"location":"extras/eventbus/#console-reporting","text":"You can switch off console reporting (for example, if you have too many listeners): new EventBusBundle (). noReport () Note Reporting has to use reflection to get subscribers list. If this fails with a newer guava version (not yet supported), then simply disable reporting and everything will work as expected.","title":"Console reporting"},{"location":"extras/eventbus/#subscribers-info-bean","text":"EventSubscribersInfo is a registered (available for injection) bean that provides active listeners and used event types. As described above, it uses reflection internally to access the eventbus listeners map. It may be useful for testing.","title":"Subscribers info bean"},{"location":"extras/gsp/","text":"Guicey Server Pages \u00b6 Extensions project module Brings the simplicity of JSP to dropwizard-views. Basement for pluggable and extendable ui applications (like dashboards). EXPERIMENTAL MODULE Features: Use standard dropwizard modules: dropwizard-views and dropwizard-assets Support direct templates rendering (without rest resource declaration) Static resources, direct templates and dropwizard-views rest endpoints are handled under the same url (like everything is stored in the same directory - easy to link css, js and other resources) Multiple ui applications declaration with individual errors handling (error pages declaration like in servlet api, but not global) Ability to extend applications (much like good old resources copying above exploded war in tomcat) Pluggable ui applications (e.g. admin dashboard may be easily installed with a bundle) Problem \u00b6 Suppose you want to serve your ui to from the root url, then you need to re-map rest: server : rootPath : '/rest/*' applicationContextPath : / Static resources are in classpath: com/something/ index.html style.css Using dropwizard assets bundle to configure application: bootstrap . addBundle ( new AssetsBundle ( \"/com/something/\" , \"/\" , \"index.html\" )); Note that index.html could reference css with relative path: < link href = \"style.css\" rel = \"stylesheet\" > Now if we want to use template instead of pure html we configure dropwizard views: bootstrap . addBundle ( new ViewBundle < MyConfiguration >()); Renaming index.html to index.ftl and add view resource: @Path ( \"/ui/\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { public static class IndexView extends View { public IndexView () { super ( \"/com/something/index.ftl\" ); } } @GET public IndexView get () { return new IndexView (); } } As a result, index page url become /rest/ui/ so we need to link css resource with full path ( /style.css ) instead of relative (or even re-configure server to back rest mapping to into root). It is already obvious that asset servlet and templates are not play well together. Solution \u00b6 The solution is obvious: make asserts servlet as major resources supplier and with an additional filter to detect template requests and redirect rendering to actual rest. So example above should become: com/something/ index.ftl style.css Where index.ftl could use < link href = \"style.css\" rel = \"stylesheet\" > because it is queried by url /index.ftl : no difference with usual index.html - template rendering is hidden (and direct template file even don't need custom resource). When we need custom resource (most likely, for parameters mapping) we can still use it: @Path ( \"/ui/\" ) @Template ( \"foo.ftl\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { @GET @Path ( \"/foo/{id}\" ) public IndexView get ( @PathParam ( \"id\" ) String id ) { return new TemplateView (); } } It would be accessible from assets root /foo/12 (more on naming and mapping details below). Under the hood /foo/12 will be recognized as template call and redirected (server redirect) to /rest/ui/foo/12 . As you can see rest endpoints and templates are now \"a part\" of static resources.. just like good-old JSP (powered with rest mappings). And it is still pure dropwizard views. GSP implements per-application error pages support so each application could use it's own errors. In pure dropwizard-views such things should be implemented manually, which is not good for application incapsulation. Setup \u00b6 Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-gsp </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-gsp:0.7.0' See the most recent version in the badge above. Usage \u00b6 First of all, global GSP bundle must be installed in main application class. It configures and installs dropwizard-views (global). It supports the same configurations as pure dropwizard-views bundle. bootstrap . addBundle ( ServerPagesBundle . builder (). build ()); Remove direct dropwizard-views bundle registrations ( ViewBundle ) if it was already used in application. Template engines \u00b6 Out of the box dropwizard provides freemarker and mustache engines support. You will need to add dependency to one of them (or both) in order to activate it (or, maybe, some third party engine): compile ( io.dropwizard:dropwizard-views-freemarker ) compile ( io.dropwizard:dropwizard-views-mustache ) Other template engines available as 3 rd party modules. If your template engine is not yet supported then simply implement io.dropwizard.views.ViewRenderer in order to support it. ViewRenderer implementations are loaded automatically using ServiceLoader mechanism. If your renderer is not declared as service then simply add it directly: bootstrap . addBundle ( ServerPagesBundle . builder () addViewRenderers ( new MyTempateSupport ()) . build ()); Duplicate renderers are automatically removed. List of detected template engines will be printed to console. You can get list of used renderers from bundle instance ServerPagesBundle#getRenderers() Note This is pure dropwizard-views staff (everything is totally standard). Configuration \u00b6 Views yaml configuration binding is the same as in dropwizard-views. views : freemarker : strict_syntax : true mustache : cache : false Where freemarker and mustache are keys from installed template renderer io.dropwizard.views.ViewRenderer#getConfigurationKey() . public class AppConfig extends Configuration { @JsonProperty private Map < String , Map < String , String >> views ; public Map < String , Map < String , String >> getViews () { return views ;} } bootstrap . addBundle ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . build ()); If AppConfig#getViews return null then empty map will be used instead as config. Additionally to direct yaml configuration binding, you can apply exact template engine modifications bootstrap . addBundle ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . viewsConfigurationModifier ( \"freemarker\" , map -> map . put ( \"cache_storage\" , \"freemarker.cache.NullCacheStorage\" )) . build ()); Modifier always receive not null map (empty map is created automatically in global configuration). Multiple modifiers could be applied (even for the same section). Each GSP application could also apply modifiers (this is useful to tune defaults: e.g. in case of freemarker, application may need to apply default imports). The final configuration (after all modifiers) could be printed to console with .printViewsConfiguration() . Also, configuration is accessible from the bundle instance: ServerPagesBundle#getViewsConfig() . Applications \u00b6 Each GSP application is registered as separate bundle in main or admin context: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . indexPage ( \"index.ftl\" ) . build ()) bootstrap . addBundle ( ServerPagesBundle . adminApp ( \"com.project.admin\" , \"/com/app/admin/\" , \"/admin\" ) . build ()) Or inside GuiceyBundle : ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . register ( guiceyBootstrap ) Unlimited number of applications may be registered on each context. app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) com.mycompany.ui - unique(!) application name. Uniqueness is very important as name used for rest paths. To avoid collisions it's recommended to use domain-prefixed names to better identify application related resources. /com/app/ui/ - path to resources in classpath (application \"root\" folder; the same meaning as in dropwizard-assets) / - application mapping url (in main or admin context; the same as in dropwizard-assets) (if context is prefixed ( server.applicationContextPath: /some or server.adminContextPath: /admin ) then GSP application will be available under this prefix) Warning It is a common desire to map ui on main context's root path ( / ), but, by default, dropwizard maps rest there and so you may see an error: java.lang.IllegalStateException: Multiple servlets map to path /*: app[mapped:JAVAX_API:null],io.dropwizard.jersey.setup.JerseyServletContainer-1280682[mapped:EMBEDDED:null] In this case simply re-map rest in yaml config: server : rootPath : '/rest/*' Template engine constraint \u00b6 As GSP application declaration is separated from views configuration (GSP application may be even a 3 rd party bundle) then it must be able to check required template engines presence. For example, this application requires freemarker: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . requireRenderers ( \"freemarker\" ) . build ()) Template engine name is declared in io.dropwizard.views.ViewRenderer#getConfigurationKey() (same name used in configuration). Templates support \u00b6 As dropwizard-views are used under the hood, all templates are always rendered with rest endpoints. All these rest endpoints are part of global rest. But, in contrast to dropwizard-views, GSP must be able to differentiate rest endpoints by target application. That's why there is a naming convention for template resources mapping path: it must always start with application name. Let's see it on example. Suppose rest is re-mapped from root: server : rootPath : '/rest/*' And GSP application is registered with name com.project.ui under main context root path ( / ). bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . build ()) So application related resources (powering views) paths must start with com.project.ui/ . For each application default resource is always registered in order to render direct template files and so by default you will see in console: INFO [2019-06-07 04:10:47,978] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /rest/com.project.ui/{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource) POST /rest/com.project.ui/{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource) INFO [2019-06-07 04:10:47,982] ru.vyarus.guicey.gsp.app.ServerPagesApp: Server pages app 'com.project.ui' registered on uri '/*' in main context Static resources locations: /com/app/ui/ Mapped handlers: GET /{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource #get) POST /{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource #post) Here you can see real rest mapping GET /rest/com.project.ui/{file:.*} and how it could be used relative to application path GET /{file:.*} . This report will always contain all correct view paths which must simplify overall understanding: if path not appear in the report - it's incorrectly mapped and when it's appear - always use the path from application report to access it. So if we call http://localhost:8080/template.ftl it will be redirected on server into /rest/com.project.ui/template.ftl and handled by DirectTemplateResource Tip Templates in sub folders will be rendered the same way, e.g. http://localhost:8080/sub/path/template.ftl will render /com/app/ui/sub/path/template.ftl . When we declare custom resource to handle view it's path must start with application prefix: @Path(\"/com.project.ui/mypage/\") which will be available as http://localhost:8080/mypage/ !!! attention: I know, it may seem not intuitive at first, but using redirection is the only way to \"merry\" templates with static resources and bring usage comfort. Just forget about real rest mappings (after correct declaration) and use application console report to know the real paths. Template rest declaration \u00b6 Declaration differences with pure dropwizard-views: @Path value must start with target application name (see the chapter above) Resource class must be annotated with @Template (even without exact template declaration) TemplateView must be used instead of dropwizard View as a base class for view models. Suppose we declaring page for gsp application .app(\"com.project.ui\", \"/com/app/ui/\", \"/\") As in pure views, in most cases we will need custom model object: public class SampleView extends TemplateView { private String name ; public SampleView ( String name ) { this . name = name ; } public String getName () { return this . name ; } } Note Custom model is optional - you can use TemplateView directly, as default \"empty\" model. @Path ( \"/com.project.ui/sample/\" ) @Template ( \"sample.ftl\" ) public class SamplePage { @Path ( \"{name}\" ) public SampleView doSomething ( @PathParam ( \"name\" ) String name ) { return new SampleView ( name ); } } And example template: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Name: ${name} </body> </html> After application startup, new url must appear in GSP application console report. If we call new page with http://localhost:8080/sample/fred we should see Name: fred as a result. @Template \u00b6 @Template annotation must be used on ALL template resources. It may declare default template for all methods in resource ( @Template(\"sample.ftl\") ) or be just a marker annotation ( @Template ). Annotation differentiate template resources from other api resources and lets you delare jersey extension only for template resources: @Provider @Template public class MyExtensions implements ContainerRequestFilter { ... } This request filter will be applied only to template resources. Such targeting is used internally in order to not affect global api with GSP specific handling logic. Template path resolution: If path starts with / then it would be resolved from classpath root Path relative to resource class Path relative to static resources location ( /com/app/ui/ in the example above) Examples: @Template(\"/com/project/custom/path/sample.ftl\") - absolute declaration. @Template(\"sub/sample.ftl\") - relative declaration @Template(\"../sub/sample.ftl\") - relative declaration Even if template is configured in the annotation, exact resource method could specify it's own template directly in TemplateView constructor: @Path ( \"/com.project.ui/sample/\" ) @Template ( \"sample.ftl\" ) // default template public class SamplePage { @Path ( \"/\" ) public TemplateView doSomething () { // override template return new TemplateView ( \"otherTemplate.ftl\" ); } } Template path resolution rules are the same as with annotation. TemplateContext \u00b6 TemplateContext contains all template contextual information. It could be accessed inside template with model's getContext() , e.g.: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Current url: ${context.url} </body> </html> In rest view resources it could be accessed with a static lookup: TemplateContext.getInstance() . This way you can always know current gsp application name, original url (before redirection to rest), root application mapping prefix and get origial request object (which may be required for error pages). Index page \u00b6 Index page is a page shown for root application url ( / ). It could be declared as: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . indexPage ( ' index . html ' ) . build ()) It could be: * Direct resource: index.html * Direct template: index.ftl * Rest powered template: /mapping/ Note By default, index page is set to \"\" because most likely your index page will be handled with rest and \"\" will redirect to root path (for current application): /com.project.ui/ Error pages \u00b6 Each GSP application could declare it's own error pages (very similar to servlet api). It could be one global error page and different pages per status: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . errorPage ( ' error . html ' ) . errorPage ( 500 , ' 500. html ' ) . errorPage ( 401 , ' 401. html ' ) . build ()) As with index pages, error page may be direct static html, direct template or rest path. Important Error pages are shown ONLY if requested type was text/html and pass error as is in other cases. Simply because it is not correct to return html when client was expecting different type. Errors handling logic detects: Static resources errors (404) Exceptions during view resource processing (including rendering errors) Direct error codes return without exception ( Resounce.status(404).build() ) Error pages may use special view class (or extend it) ErrorTemplateView which collects additional error-related info. For example, even direct error template could show: <#-- @ftlvariable name=\"\" type=\"ru.vyarus.guicey.gsp.views.template.ErrorTemplateView\" --> <h3>Url ${erroredUrl} failed to render with ${errorCode} status code</h3> <div>Error: ${error.class.simpleName}</div> <pre> ${errorTrace} </pre> For rest-powered error page: @Path ( \"/com.project.ui/error/\" ) @Template ( \"error.ftl\" ) public class ErrorPage { @Path ( \"/\" ) public TemplateView render () { // it may be any extending class if additional properties are required (the same as usual) ErrorTemplateView view = new ErrorTemplateView (); WebApplicationException ex = view . getError (); // analyze error return view ; } } (this error page can be mapped as .errorPage(\"/error/\") ). view.getError() always return WebApplicationException so use ex.geCause() to get original exception. But there will not always be useful exception because direct exception is only one of error cases (see above). In order to differentiate useful exceptions, you can check: if ( ex instanceof TracelessException ) { // only status code availbale int status = (( TracelessException ) ex ). getStatus (); } else { // actually throwed exception to analyze Throwable actualCause = ex . getCause () } TracelessException may be either AssertError for static resource fail or TemplateRestCodeError for direct non 200 response code in rest. Important GSP errors handling override ExceptionMapper and views errors mechanisms because it intercept exceptions before them (using RequestEventListener )! So your ExceptionMapper will be called, but user will still see GSP error page. The motivation is simple: otherwise it would be very hard to write side effect free GSP applications because template resources exceptions could be intercepted with ExceptionMapper 's declared in dropwizard application. To overcome this limitation, you can disable errors handling with @ManuaErrorHandling . It may be applied on resource method or to resource class (to disable on all methods). For example: @Path ( \"/com.project.ui/error/\" ) @Template ( \"page.ftl\" ) public class ErrorPage { @ManualErrorHandling @Path ( \"/\" ) public TemplateView render () { // if exception appear inside this method, it would be handled with ExceptionMapper // GSP error page will not be used // Also, if method return non 200 error code (>=400) like // return Response.status(500).build() // it would be also not handled with GSP error mechanism (only pure dropwizard staff) } } Note that disabled errors will be indicated as [DISABLED ERRORS] in console report. SPA routing \u00b6 If you use Single Page Applications then you may face the need to recognize html5 client routing urls and redirect to index page. You can read more about it in guicey SPA module . As guicey SPA module can't be used directly with GSP, it's abilities is integrated directly and could be activated with: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . spaRouting () . build ()) Or, if custom detection regex is required: .spaRouting(customRegex) Most likely, usage use-case would be: index page requires some server-size templating. Template requests detection \u00b6 GSP must differentiate static resource calls from template calls. It assumes that static resources would always end with an extension (e.g. /something/some.ext ) and so: If request without extension - it's a template If extension is recognized as template extension - render as template Other cases are static resources The following regular expression used for extension detection: (?:^|/)([^/]+\\.(?:[a-zA-Z\\d]+))(?:\\?.+)?$ If it does not cover you specific cases, it could be changed using: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . filePattern ( \"(?:^|/)([^/]+\\\\.(?:[a-zA-Z\\\\d]+))(?:\\\\?.+)?$\" ) . build ()) In case when you have static files without extension, you can include them directly into detection regexp (using regex or (|) syntax). Pattern must return detected file name as first matched group (so direct template could be detected). Pattern is searched (find) inside path, not matched (so simple patterns will also work). Extending applications \u00b6 In \"war world\" there is a a very handy thing as overlays: when we can apply our resources \"above\" existing war. This way we can replace existing files (hack & tune) and add our own files so they would live inside app as they were always be there. In order to achieve similar goals there is a application extension mechanism. For example we application: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . build ()) With multiple pages inside: /com/app/ui/ page1.ftl page2.ftl style.css Each page could include style relatively as style.css . Most likely there will even be master template (freemarker) which unifies styles and common sscript installation. This application is destributed as 3 rd party bundle (jar). If we need to add one more page to this application in our current dropwizard application, we can: ServerPagesBundle . extendApp ( \"com.project.ui\" , \"/com/otherApp/ui/ext\" ) And put another page into classpath: /com/otherApp/ui/ext/ page3.ftl This page could also reference style.css relatively, the same as pages in the main application. On application startup, you will notice new resources location: Static resources locations: /com/app/ui/ /com/otherApp/ui/ext/ Now both locations are \"roots\" for the application. The same way as if we copied /com/otherApp/ui/ext/ into /com/app/ui/ . http://localhost:8080/page3.ftl would correctly render new page. There may be unlimited number of application extensions. If extended application is not available, it is not considered as an error: it's assumed as optional application extension, which will be activated if some 3 rd party jar with GSP application appear in classpath. Webjars usage \u00b6 If you want to use resources from webjars in GSP application: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . attachWebjars () . build ()) For example, to add jquery: compile 'org.webjars.npm:jquery:3.4.1' And it could be referenced as: < script src = \"jquery/3.4.1/dist/jquery.min.js\" /> Under the hood .attachWebjars() use extensions mechanism and adds META-INF/resources/webjars/ as application resources path: ServerPagesBundle . extendApp ( \"app name\" , \"META-INF/resources/webjars/\" ) Tip You can always see the content of webjar on webjars site by clicking on package \"Files\" column. Use everything after \"META-INF/resources/webjars/\" to reference file.","title":"Server Pages"},{"location":"extras/gsp/#guicey-server-pages","text":"Extensions project module Brings the simplicity of JSP to dropwizard-views. Basement for pluggable and extendable ui applications (like dashboards). EXPERIMENTAL MODULE Features: Use standard dropwizard modules: dropwizard-views and dropwizard-assets Support direct templates rendering (without rest resource declaration) Static resources, direct templates and dropwizard-views rest endpoints are handled under the same url (like everything is stored in the same directory - easy to link css, js and other resources) Multiple ui applications declaration with individual errors handling (error pages declaration like in servlet api, but not global) Ability to extend applications (much like good old resources copying above exploded war in tomcat) Pluggable ui applications (e.g. admin dashboard may be easily installed with a bundle)","title":"Guicey Server Pages"},{"location":"extras/gsp/#problem","text":"Suppose you want to serve your ui to from the root url, then you need to re-map rest: server : rootPath : '/rest/*' applicationContextPath : / Static resources are in classpath: com/something/ index.html style.css Using dropwizard assets bundle to configure application: bootstrap . addBundle ( new AssetsBundle ( \"/com/something/\" , \"/\" , \"index.html\" )); Note that index.html could reference css with relative path: < link href = \"style.css\" rel = \"stylesheet\" > Now if we want to use template instead of pure html we configure dropwizard views: bootstrap . addBundle ( new ViewBundle < MyConfiguration >()); Renaming index.html to index.ftl and add view resource: @Path ( \"/ui/\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { public static class IndexView extends View { public IndexView () { super ( \"/com/something/index.ftl\" ); } } @GET public IndexView get () { return new IndexView (); } } As a result, index page url become /rest/ui/ so we need to link css resource with full path ( /style.css ) instead of relative (or even re-configure server to back rest mapping to into root). It is already obvious that asset servlet and templates are not play well together.","title":"Problem"},{"location":"extras/gsp/#solution","text":"The solution is obvious: make asserts servlet as major resources supplier and with an additional filter to detect template requests and redirect rendering to actual rest. So example above should become: com/something/ index.ftl style.css Where index.ftl could use < link href = \"style.css\" rel = \"stylesheet\" > because it is queried by url /index.ftl : no difference with usual index.html - template rendering is hidden (and direct template file even don't need custom resource). When we need custom resource (most likely, for parameters mapping) we can still use it: @Path ( \"/ui/\" ) @Template ( \"foo.ftl\" ) @Produces ( MediaType . TEXT_HTML ) public class IndexResource { @GET @Path ( \"/foo/{id}\" ) public IndexView get ( @PathParam ( \"id\" ) String id ) { return new TemplateView (); } } It would be accessible from assets root /foo/12 (more on naming and mapping details below). Under the hood /foo/12 will be recognized as template call and redirected (server redirect) to /rest/ui/foo/12 . As you can see rest endpoints and templates are now \"a part\" of static resources.. just like good-old JSP (powered with rest mappings). And it is still pure dropwizard views. GSP implements per-application error pages support so each application could use it's own errors. In pure dropwizard-views such things should be implemented manually, which is not good for application incapsulation.","title":"Solution"},{"location":"extras/gsp/#setup","text":"Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-gsp </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-gsp:0.7.0' See the most recent version in the badge above.","title":"Setup"},{"location":"extras/gsp/#usage","text":"First of all, global GSP bundle must be installed in main application class. It configures and installs dropwizard-views (global). It supports the same configurations as pure dropwizard-views bundle. bootstrap . addBundle ( ServerPagesBundle . builder (). build ()); Remove direct dropwizard-views bundle registrations ( ViewBundle ) if it was already used in application.","title":"Usage"},{"location":"extras/gsp/#template-engines","text":"Out of the box dropwizard provides freemarker and mustache engines support. You will need to add dependency to one of them (or both) in order to activate it (or, maybe, some third party engine): compile ( io.dropwizard:dropwizard-views-freemarker ) compile ( io.dropwizard:dropwizard-views-mustache ) Other template engines available as 3 rd party modules. If your template engine is not yet supported then simply implement io.dropwizard.views.ViewRenderer in order to support it. ViewRenderer implementations are loaded automatically using ServiceLoader mechanism. If your renderer is not declared as service then simply add it directly: bootstrap . addBundle ( ServerPagesBundle . builder () addViewRenderers ( new MyTempateSupport ()) . build ()); Duplicate renderers are automatically removed. List of detected template engines will be printed to console. You can get list of used renderers from bundle instance ServerPagesBundle#getRenderers() Note This is pure dropwizard-views staff (everything is totally standard).","title":"Template engines"},{"location":"extras/gsp/#configuration","text":"Views yaml configuration binding is the same as in dropwizard-views. views : freemarker : strict_syntax : true mustache : cache : false Where freemarker and mustache are keys from installed template renderer io.dropwizard.views.ViewRenderer#getConfigurationKey() . public class AppConfig extends Configuration { @JsonProperty private Map < String , Map < String , String >> views ; public Map < String , Map < String , String >> getViews () { return views ;} } bootstrap . addBundle ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . build ()); If AppConfig#getViews return null then empty map will be used instead as config. Additionally to direct yaml configuration binding, you can apply exact template engine modifications bootstrap . addBundle ( ServerPagesBundle . builder () . viewsConfiguration ( AppConfig :: getViews ) . viewsConfigurationModifier ( \"freemarker\" , map -> map . put ( \"cache_storage\" , \"freemarker.cache.NullCacheStorage\" )) . build ()); Modifier always receive not null map (empty map is created automatically in global configuration). Multiple modifiers could be applied (even for the same section). Each GSP application could also apply modifiers (this is useful to tune defaults: e.g. in case of freemarker, application may need to apply default imports). The final configuration (after all modifiers) could be printed to console with .printViewsConfiguration() . Also, configuration is accessible from the bundle instance: ServerPagesBundle#getViewsConfig() .","title":"Configuration"},{"location":"extras/gsp/#applications","text":"Each GSP application is registered as separate bundle in main or admin context: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . indexPage ( \"index.ftl\" ) . build ()) bootstrap . addBundle ( ServerPagesBundle . adminApp ( \"com.project.admin\" , \"/com/app/admin/\" , \"/admin\" ) . build ()) Or inside GuiceyBundle : ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . register ( guiceyBootstrap ) Unlimited number of applications may be registered on each context. app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) com.mycompany.ui - unique(!) application name. Uniqueness is very important as name used for rest paths. To avoid collisions it's recommended to use domain-prefixed names to better identify application related resources. /com/app/ui/ - path to resources in classpath (application \"root\" folder; the same meaning as in dropwizard-assets) / - application mapping url (in main or admin context; the same as in dropwizard-assets) (if context is prefixed ( server.applicationContextPath: /some or server.adminContextPath: /admin ) then GSP application will be available under this prefix) Warning It is a common desire to map ui on main context's root path ( / ), but, by default, dropwizard maps rest there and so you may see an error: java.lang.IllegalStateException: Multiple servlets map to path /*: app[mapped:JAVAX_API:null],io.dropwizard.jersey.setup.JerseyServletContainer-1280682[mapped:EMBEDDED:null] In this case simply re-map rest in yaml config: server : rootPath : '/rest/*'","title":"Applications"},{"location":"extras/gsp/#template-engine-constraint","text":"As GSP application declaration is separated from views configuration (GSP application may be even a 3 rd party bundle) then it must be able to check required template engines presence. For example, this application requires freemarker: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . requireRenderers ( \"freemarker\" ) . build ()) Template engine name is declared in io.dropwizard.views.ViewRenderer#getConfigurationKey() (same name used in configuration).","title":"Template engine constraint"},{"location":"extras/gsp/#templates-support","text":"As dropwizard-views are used under the hood, all templates are always rendered with rest endpoints. All these rest endpoints are part of global rest. But, in contrast to dropwizard-views, GSP must be able to differentiate rest endpoints by target application. That's why there is a naming convention for template resources mapping path: it must always start with application name. Let's see it on example. Suppose rest is re-mapped from root: server : rootPath : '/rest/*' And GSP application is registered with name com.project.ui under main context root path ( / ). bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . build ()) So application related resources (powering views) paths must start with com.project.ui/ . For each application default resource is always registered in order to render direct template files and so by default you will see in console: INFO [2019-06-07 04:10:47,978] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources: GET /rest/com.project.ui/{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource) POST /rest/com.project.ui/{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource) INFO [2019-06-07 04:10:47,982] ru.vyarus.guicey.gsp.app.ServerPagesApp: Server pages app 'com.project.ui' registered on uri '/*' in main context Static resources locations: /com/app/ui/ Mapped handlers: GET /{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource #get) POST /{file:.*} (ru.vyarus.guicey.gsp.app.rest.DirectTemplateResource #post) Here you can see real rest mapping GET /rest/com.project.ui/{file:.*} and how it could be used relative to application path GET /{file:.*} . This report will always contain all correct view paths which must simplify overall understanding: if path not appear in the report - it's incorrectly mapped and when it's appear - always use the path from application report to access it. So if we call http://localhost:8080/template.ftl it will be redirected on server into /rest/com.project.ui/template.ftl and handled by DirectTemplateResource Tip Templates in sub folders will be rendered the same way, e.g. http://localhost:8080/sub/path/template.ftl will render /com/app/ui/sub/path/template.ftl . When we declare custom resource to handle view it's path must start with application prefix: @Path(\"/com.project.ui/mypage/\") which will be available as http://localhost:8080/mypage/ !!! attention: I know, it may seem not intuitive at first, but using redirection is the only way to \"merry\" templates with static resources and bring usage comfort. Just forget about real rest mappings (after correct declaration) and use application console report to know the real paths.","title":"Templates support"},{"location":"extras/gsp/#template-rest-declaration","text":"Declaration differences with pure dropwizard-views: @Path value must start with target application name (see the chapter above) Resource class must be annotated with @Template (even without exact template declaration) TemplateView must be used instead of dropwizard View as a base class for view models. Suppose we declaring page for gsp application .app(\"com.project.ui\", \"/com/app/ui/\", \"/\") As in pure views, in most cases we will need custom model object: public class SampleView extends TemplateView { private String name ; public SampleView ( String name ) { this . name = name ; } public String getName () { return this . name ; } } Note Custom model is optional - you can use TemplateView directly, as default \"empty\" model. @Path ( \"/com.project.ui/sample/\" ) @Template ( \"sample.ftl\" ) public class SamplePage { @Path ( \"{name}\" ) public SampleView doSomething ( @PathParam ( \"name\" ) String name ) { return new SampleView ( name ); } } And example template: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Name: ${name} </body> </html> After application startup, new url must appear in GSP application console report. If we call new page with http://localhost:8080/sample/fred we should see Name: fred as a result.","title":"Template rest declaration"},{"location":"extras/gsp/#template","text":"@Template annotation must be used on ALL template resources. It may declare default template for all methods in resource ( @Template(\"sample.ftl\") ) or be just a marker annotation ( @Template ). Annotation differentiate template resources from other api resources and lets you delare jersey extension only for template resources: @Provider @Template public class MyExtensions implements ContainerRequestFilter { ... } This request filter will be applied only to template resources. Such targeting is used internally in order to not affect global api with GSP specific handling logic. Template path resolution: If path starts with / then it would be resolved from classpath root Path relative to resource class Path relative to static resources location ( /com/app/ui/ in the example above) Examples: @Template(\"/com/project/custom/path/sample.ftl\") - absolute declaration. @Template(\"sub/sample.ftl\") - relative declaration @Template(\"../sub/sample.ftl\") - relative declaration Even if template is configured in the annotation, exact resource method could specify it's own template directly in TemplateView constructor: @Path ( \"/com.project.ui/sample/\" ) @Template ( \"sample.ftl\" ) // default template public class SamplePage { @Path ( \"/\" ) public TemplateView doSomething () { // override template return new TemplateView ( \"otherTemplate.ftl\" ); } } Template path resolution rules are the same as with annotation.","title":"@Template"},{"location":"extras/gsp/#templatecontext","text":"TemplateContext contains all template contextual information. It could be accessed inside template with model's getContext() , e.g.: <#-- @ftlvariable name=\"\" type=\"com.project.ui.SampleView\" --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Sample page</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> </head> <body> Current url: ${context.url} </body> </html> In rest view resources it could be accessed with a static lookup: TemplateContext.getInstance() . This way you can always know current gsp application name, original url (before redirection to rest), root application mapping prefix and get origial request object (which may be required for error pages).","title":"TemplateContext"},{"location":"extras/gsp/#index-page","text":"Index page is a page shown for root application url ( / ). It could be declared as: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . indexPage ( ' index . html ' ) . build ()) It could be: * Direct resource: index.html * Direct template: index.ftl * Rest powered template: /mapping/ Note By default, index page is set to \"\" because most likely your index page will be handled with rest and \"\" will redirect to root path (for current application): /com.project.ui/","title":"Index page"},{"location":"extras/gsp/#error-pages","text":"Each GSP application could declare it's own error pages (very similar to servlet api). It could be one global error page and different pages per status: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . errorPage ( ' error . html ' ) . errorPage ( 500 , ' 500. html ' ) . errorPage ( 401 , ' 401. html ' ) . build ()) As with index pages, error page may be direct static html, direct template or rest path. Important Error pages are shown ONLY if requested type was text/html and pass error as is in other cases. Simply because it is not correct to return html when client was expecting different type. Errors handling logic detects: Static resources errors (404) Exceptions during view resource processing (including rendering errors) Direct error codes return without exception ( Resounce.status(404).build() ) Error pages may use special view class (or extend it) ErrorTemplateView which collects additional error-related info. For example, even direct error template could show: <#-- @ftlvariable name=\"\" type=\"ru.vyarus.guicey.gsp.views.template.ErrorTemplateView\" --> <h3>Url ${erroredUrl} failed to render with ${errorCode} status code</h3> <div>Error: ${error.class.simpleName}</div> <pre> ${errorTrace} </pre> For rest-powered error page: @Path ( \"/com.project.ui/error/\" ) @Template ( \"error.ftl\" ) public class ErrorPage { @Path ( \"/\" ) public TemplateView render () { // it may be any extending class if additional properties are required (the same as usual) ErrorTemplateView view = new ErrorTemplateView (); WebApplicationException ex = view . getError (); // analyze error return view ; } } (this error page can be mapped as .errorPage(\"/error/\") ). view.getError() always return WebApplicationException so use ex.geCause() to get original exception. But there will not always be useful exception because direct exception is only one of error cases (see above). In order to differentiate useful exceptions, you can check: if ( ex instanceof TracelessException ) { // only status code availbale int status = (( TracelessException ) ex ). getStatus (); } else { // actually throwed exception to analyze Throwable actualCause = ex . getCause () } TracelessException may be either AssertError for static resource fail or TemplateRestCodeError for direct non 200 response code in rest. Important GSP errors handling override ExceptionMapper and views errors mechanisms because it intercept exceptions before them (using RequestEventListener )! So your ExceptionMapper will be called, but user will still see GSP error page. The motivation is simple: otherwise it would be very hard to write side effect free GSP applications because template resources exceptions could be intercepted with ExceptionMapper 's declared in dropwizard application. To overcome this limitation, you can disable errors handling with @ManuaErrorHandling . It may be applied on resource method or to resource class (to disable on all methods). For example: @Path ( \"/com.project.ui/error/\" ) @Template ( \"page.ftl\" ) public class ErrorPage { @ManualErrorHandling @Path ( \"/\" ) public TemplateView render () { // if exception appear inside this method, it would be handled with ExceptionMapper // GSP error page will not be used // Also, if method return non 200 error code (>=400) like // return Response.status(500).build() // it would be also not handled with GSP error mechanism (only pure dropwizard staff) } } Note that disabled errors will be indicated as [DISABLED ERRORS] in console report.","title":"Error pages"},{"location":"extras/gsp/#spa-routing","text":"If you use Single Page Applications then you may face the need to recognize html5 client routing urls and redirect to index page. You can read more about it in guicey SPA module . As guicey SPA module can't be used directly with GSP, it's abilities is integrated directly and could be activated with: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . spaRouting () . build ()) Or, if custom detection regex is required: .spaRouting(customRegex) Most likely, usage use-case would be: index page requires some server-size templating.","title":"SPA routing"},{"location":"extras/gsp/#template-requests-detection","text":"GSP must differentiate static resource calls from template calls. It assumes that static resources would always end with an extension (e.g. /something/some.ext ) and so: If request without extension - it's a template If extension is recognized as template extension - render as template Other cases are static resources The following regular expression used for extension detection: (?:^|/)([^/]+\\.(?:[a-zA-Z\\d]+))(?:\\?.+)?$ If it does not cover you specific cases, it could be changed using: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . filePattern ( \"(?:^|/)([^/]+\\\\.(?:[a-zA-Z\\\\d]+))(?:\\\\?.+)?$\" ) . build ()) In case when you have static files without extension, you can include them directly into detection regexp (using regex or (|) syntax). Pattern must return detected file name as first matched group (so direct template could be detected). Pattern is searched (find) inside path, not matched (so simple patterns will also work).","title":"Template requests detection"},{"location":"extras/gsp/#extending-applications","text":"In \"war world\" there is a a very handy thing as overlays: when we can apply our resources \"above\" existing war. This way we can replace existing files (hack & tune) and add our own files so they would live inside app as they were always be there. In order to achieve similar goals there is a application extension mechanism. For example we application: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . build ()) With multiple pages inside: /com/app/ui/ page1.ftl page2.ftl style.css Each page could include style relatively as style.css . Most likely there will even be master template (freemarker) which unifies styles and common sscript installation. This application is destributed as 3 rd party bundle (jar). If we need to add one more page to this application in our current dropwizard application, we can: ServerPagesBundle . extendApp ( \"com.project.ui\" , \"/com/otherApp/ui/ext\" ) And put another page into classpath: /com/otherApp/ui/ext/ page3.ftl This page could also reference style.css relatively, the same as pages in the main application. On application startup, you will notice new resources location: Static resources locations: /com/app/ui/ /com/otherApp/ui/ext/ Now both locations are \"roots\" for the application. The same way as if we copied /com/otherApp/ui/ext/ into /com/app/ui/ . http://localhost:8080/page3.ftl would correctly render new page. There may be unlimited number of application extensions. If extended application is not available, it is not considered as an error: it's assumed as optional application extension, which will be activated if some 3 rd party jar with GSP application appear in classpath.","title":"Extending applications"},{"location":"extras/gsp/#webjars-usage","text":"If you want to use resources from webjars in GSP application: bootstrap . addBundle ( ServerPagesBundle . app ( \"com.project.ui\" , \"/com/app/ui/\" , \"/\" ) . attachWebjars () . build ()) For example, to add jquery: compile 'org.webjars.npm:jquery:3.4.1' And it could be referenced as: < script src = \"jquery/3.4.1/dist/jquery.min.js\" /> Under the hood .attachWebjars() use extensions mechanism and adds META-INF/resources/webjars/ as application resources path: ServerPagesBundle . extendApp ( \"app name\" , \"META-INF/resources/webjars/\" ) Tip You can always see the content of webjar on webjars site by clicking on package \"Files\" column. Use everything after \"META-INF/resources/webjars/\" to reference file.","title":"Webjars usage"},{"location":"extras/jdbi/","text":"JDBI integration \u00b6 Extensions project module Integrates JDBI2 with guice. Based on dropwizard-jdbi integration. Features: DBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces and abstract classes): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. Automatic installation for custom ResultSetMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - result set mappers Setup \u00b6 Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-jdbi:0.7.0' See the most recent version in the badge above. Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle .< ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default DBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build DBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) Unit of work \u00b6 Unit of work concept states for: every database related operation must be performed inside unit of work. In DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with DBI own's Transaction annotation and more common Transactional annotations). At the beginning of unit of work, DBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work. @InTransaction \u00b6 Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation. If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class ); Context Handle \u00b6 Inside unit of work you may reference current handle by using: @Inject Provider < Handle > Manual transaction definition \u00b6 You may define transaction (with unit of work) without annotation using: @Inject TransactionTenpate template ; ... template . inTrabsansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation. Repository \u00b6 Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. You can also use injection inside repositories, but only field injection: public abstract class MyRepo { @Inject SomeBean bean ; } Constructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able to construct proxy for class with constructor injection. Don't use DBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi.support.repository.SampleRepository) Result set mapper \u00b6 If you have custom implementations of ResultSetMapper , it may be registered automatically. You will be able to use injections there because mappers become ususal guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements ResutlSetMapper < Custom > { @Override public Cusom map ( int row , ResultSet rs , StatementContext ctx ) { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper) Manual unit of work definition \u00b6 If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started).","title":"JDBI"},{"location":"extras/jdbi/#jdbi-integration","text":"Extensions project module Integrates JDBI2 with guice. Based on dropwizard-jdbi integration. Features: DBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces and abstract classes): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. Automatic installation for custom ResultSetMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - result set mappers","title":"JDBI integration"},{"location":"extras/jdbi/#setup","text":"Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-jdbi:0.7.0' See the most recent version in the badge above.","title":"Setup"},{"location":"extras/jdbi/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle .< ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default DBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build DBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ())","title":"Usage"},{"location":"extras/jdbi/#unit-of-work","text":"Unit of work concept states for: every database related operation must be performed inside unit of work. In DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with DBI own's Transaction annotation and more common Transactional annotations). At the beginning of unit of work, DBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work.","title":"Unit of work"},{"location":"extras/jdbi/#intransaction","text":"Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation. If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class );","title":"@InTransaction"},{"location":"extras/jdbi/#context-handle","text":"Inside unit of work you may reference current handle by using: @Inject Provider < Handle >","title":"Context Handle"},{"location":"extras/jdbi/#manual-transaction-definition","text":"You may define transaction (with unit of work) without annotation using: @Inject TransactionTenpate template ; ... template . inTrabsansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation.","title":"Manual transaction definition"},{"location":"extras/jdbi/#repository","text":"Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. You can also use injection inside repositories, but only field injection: public abstract class MyRepo { @Inject SomeBean bean ; } Constructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able to construct proxy for class with constructor injection. Don't use DBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi.support.repository.SampleRepository)","title":"Repository"},{"location":"extras/jdbi/#result-set-mapper","text":"If you have custom implementations of ResultSetMapper , it may be registered automatically. You will be able to use injections there because mappers become ususal guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements ResutlSetMapper < Custom > { @Override public Cusom map ( int row , ResultSet rs , StatementContext ctx ) { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper)","title":"Result set mapper"},{"location":"extras/jdbi/#manual-unit-of-work-definition","text":"If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started).","title":"Manual unit of work definition"},{"location":"extras/jdbi3/","text":"JDBI3 integration \u00b6 Extensions project module Integrates JDBI3 with guice. Based on dropwizard-jdbi3 integration. Features: JDBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. can reference guice beans (with annotated getters) Automatic installation for custom RowMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - row mappers Setup \u00b6 Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi3 </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-jdbi3:0.7.0' See the most recent version in the badge above. Usage \u00b6 Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle .< ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default JDBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build JDBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) Jdbi3 introduce plugins concept. Dropwizard will automatically register SqlObjectPlugin , GuavaPlugin , JodaTimePlugin . If you need to install custom plugin: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withPlugins ( new H2DatabasePlugin ()) Also, If custom registration must be performed on jdbi instance: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withConfig (( jdbi ) -> { jdbi . callSomething () }) Such configuration block will be called just after jdbi instance creation (but before injector creation). Unit of work \u00b6 Unit of work concept states for: every database related operation must be performed inside unit of work. In JDBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with JDBI own's Transaction annotation and more common Transactional annotations). At the beginning of unit of work, JDBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work. @InTransaction \u00b6 Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation. Transaction configuration \u00b6 Transaction isolation level and readonly flag could be defined with annotation: @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) @InTransaction ( readOnly = true ) In case of nested transactions error will be thrown if: Current transaction level is different then nested one Current transaction is read only and nexted one is not (note that some drivers, like h2, ignore readOnly flag completely) For example: @InTransaction public void action () { nestedAction (); } @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) public void nestedAction () { ... } When action() method called new transaction is created with default level (usually READ_COMMITTED). When nestedAction() is called exception will be thrown because it's transaction level requirement (READ_UNCOMMITTED) contradict with current transaction. Custom transactional annotation \u00b6 If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class ); If you need to support transaction configuration (level and read only settings) with your annotation then: Add required properties into annotation itself (see @InTransaction as example). Create implementation of TxConfigFactory (see InTransactionTxConfigFactory as example) Register factory inside your annotation with @TxConfigSupport(MyCustomAnnotationTxConfigFactory.class) Your factory will be instantiated as guice bean so annotate it as Singleton, if possible to avoid redundant instances creation. Configuration is resolved just once for each method, so yur factory will be called just once for each annotated (with your custom annotation) method. Context Handle \u00b6 Inside unit of work you may reference current handle by using: @Inject Provider < Handle > Manual transaction definition \u00b6 You may define transaction (with unit of work) without annotation using: @Inject TransactionTempate template ; ... template . inTrasansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation. You can also specify transaction config (if required): @Inject TransactionTempate template ; ... template . inTrasansaction ( new TxConfig (). level ( TransactionIsolationLevel . READ_UNCOMMITTED ), ( handle ) -> doSomething ()) Repository \u00b6 Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Note singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual JDBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. Warning Don't use JDBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi3.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi3.support.repository.SampleRepository) Guice beans access \u00b6 You can access guice beans by annotating getter with @Inject (javax or guice): @JdbiRepository @InTransaction public interface MyRepository { @Inject MyOtherRepository getOtherRepo (); @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); default String doSomething ( int id ) { String name = findNameById ( id ); return getOtherRepo (). doSOmethingWithName ( name ); } } Here call to getOtherRepo() will return MyOtherRepository guice bean, which is actually another proxy. Row mapper \u00b6 If you have custom implementations of RowMapper , it may be registered automatically. You will be able to use injections there because mappers become ususal guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements RowMapper < Custom > { @Override Custom map ( ResultSet rs , StatementContext ctx ) throws SQLException { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi3.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi3.support.mapper.SampleMapper) Manual unit of work definition \u00b6 If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started). Migration from guice-jdbi (jdbi2) \u00b6 Module package changed from ru.vyarus.guicey.jdbi to ru.vyarus.guicey.jdbi3 . Jdbi object was previously bound as DBI insterface. Now it's bound as Jdbi (DBI interface was removed in jdbi3). New methods in JdbiBundle : withPlugins - install custom plugins withConfig - to simplify manual configuration In jdbi3 ResultSetMapper was changed to RowMapper (and ColumnMapper). Installer supports RowMapper automatic installation. If you were using binding annotations then: @BindingAnnotation -> @SqlStatementCustomizingAnnotation BindingFactory -> SqlStatementCustomizerFactory Sql obect proxies must be interfaces now (jdbi3 restriction). But as java 8 interfaces support default methods, its not a big problem instead of field injection (to access other proxies), now getter annotated with @Inject must be used. See jdbi3 migration gude for other (pure jdbi related) differences","title":"JDBI3"},{"location":"extras/jdbi3/#jdbi3-integration","text":"Extensions project module Integrates JDBI3 with guice. Based on dropwizard-jdbi3 integration. Features: JDBI instance available for injection Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional) Repositories (JDBI proxies for interfaces): installed automatically (when classpath scan enabled) are normal guice beans, supporting aop and participating in global (thread bound) transaction. no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction. can reference guice beans (with annotated getters) Automatic installation for custom RowMapper Added installers: RepositoryInstaller - sql proxies MapperInstaller - row mappers","title":"JDBI3 integration"},{"location":"extras/jdbi3/#setup","text":"Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-jdbi3 </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-jdbi3:0.7.0' See the most recent version in the badge above.","title":"Setup"},{"location":"extras/jdbi3/#usage","text":"Register bundle: GuiceBundle . builder () . bundles ( JdbiBundle .< ConfType > forDatabase (( conf , env ) -> conf . getDatabase ())) ... Here default JDBI instance will be created from database configuration (much like it's described in dropwizard documentation ). Or build JDBI instance yourself: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) Jdbi3 introduce plugins concept. Dropwizard will automatically register SqlObjectPlugin , GuavaPlugin , JodaTimePlugin . If you need to install custom plugin: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withPlugins ( new H2DatabasePlugin ()) Also, If custom registration must be performed on jdbi instance: JdbiBundle . forDbi (( conf , env ) -> locateDbi ()) . withConfig (( jdbi ) -> { jdbi . callSomething () }) Such configuration block will be called just after jdbi instance creation (but before injector creation).","title":"Usage"},{"location":"extras/jdbi3/#unit-of-work","text":"Unit of work concept states for: every database related operation must be performed inside unit of work. In JDBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of sql object proxies: if you create it on-demand it would always create new handle; if you want to combine multiple objects in one transaction, you have to always create them manually for each transaction. Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction scope is controlled by @InTransaction annotation (note that such name was intentional to avoid confusion with JDBI own's Transaction annotation and more common Transactional annotations). At the beginning of unit of work, JDBI handle is created and bound to thread (thread local). All repositories are simply using this bound handle and so share transaction inside unit of work.","title":"Unit of work"},{"location":"extras/jdbi3/#intransaction","text":"Annotation on method or class declares transactional scope. For example: @Inject MyDAO dao @InTransaction public Result doSomething () { dao . select (); ... } Transaction opened before doSomething() method and closed after it. Dao call is also performed inside transaction. If exception appears during execution, it's propagated and transaction rolled back. Nested annotations are allowed (they simply ignored). Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). But, for simplicity, you may think of it as the same things, if you always use @InTransaction annotation.","title":"@InTransaction"},{"location":"extras/jdbi3/#transaction-configuration","text":"Transaction isolation level and readonly flag could be defined with annotation: @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) @InTransaction ( readOnly = true ) In case of nested transactions error will be thrown if: Current transaction level is different then nested one Current transaction is read only and nexted one is not (note that some drivers, like h2, ignore readOnly flag completely) For example: @InTransaction public void action () { nestedAction (); } @InTransaction ( TransactionIsolationLevel . READ_UNCOMMITTED ) public void nestedAction () { ... } When action() method called new transaction is created with default level (usually READ_COMMITTED). When nestedAction() is called exception will be thrown because it's transaction level requirement (READ_UNCOMMITTED) contradict with current transaction.","title":"Transaction configuration"},{"location":"extras/jdbi3/#custom-transactional-annotation","text":"If required, you may use your own annotation for transaction definition: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( MyCustomTransactional . class ); Note that this will override default annotation support. If you want to support multiple annotations then specify all of them: JdbiBundle . forDatabase (( conf , env ) -> conf . getDatabase ()) . withTxAnnotations ( InTransaction . class , MyCustomTransactional . class ); If you need to support transaction configuration (level and read only settings) with your annotation then: Add required properties into annotation itself (see @InTransaction as example). Create implementation of TxConfigFactory (see InTransactionTxConfigFactory as example) Register factory inside your annotation with @TxConfigSupport(MyCustomAnnotationTxConfigFactory.class) Your factory will be instantiated as guice bean so annotate it as Singleton, if possible to avoid redundant instances creation. Configuration is resolved just once for each method, so yur factory will be called just once for each annotated (with your custom annotation) method.","title":"Custom transactional annotation"},{"location":"extras/jdbi3/#context-handle","text":"Inside unit of work you may reference current handle by using: @Inject Provider < Handle >","title":"Context Handle"},{"location":"extras/jdbi3/#manual-transaction-definition","text":"You may define transaction (with unit of work) without annotation using: @Inject TransactionTempate template ; ... template . inTrasansaction (( handle ) -> doSomething ()) Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as with annotation. You can also specify transaction config (if required): @Inject TransactionTempate template ; ... template . inTrasansaction ( new TxConfig (). level ( TransactionIsolationLevel . READ_UNCOMMITTED ), ( handle ) -> doSomething ())","title":"Manual transaction definition"},{"location":"extras/jdbi3/#repository","text":"Declare repository (interface or abstract class) as usual, using DBI annotations. It only must be annotated with @JdbiRepository so installer could recognize it and register in guice context. Note singleton scope will be forced for repositories. @JdbiRepository @InTransaction public interface MyRepository { @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); } Note the use of @InTransaction : it was used to be able to call repository methods without extra annotations (the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual JDBI on demand sql object proxies. @InTransaction annotation is handled using guice aop. You can use any other guice aop related features. Warning Don't use JDBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not needed now and may confuse. All installed repositories are reported into console: INFO [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi3.installer.repository.RepositoryInstaller: repositories = (ru.vyarus.guicey.jdbi3.support.repository.SampleRepository)","title":"Repository"},{"location":"extras/jdbi3/#guice-beans-access","text":"You can access guice beans by annotating getter with @Inject (javax or guice): @JdbiRepository @InTransaction public interface MyRepository { @Inject MyOtherRepository getOtherRepo (); @SqlQuery ( \"select name from something where id = :id\" ) String findNameById ( @Bind ( \"id\" ) int id ); default String doSomething ( int id ) { String name = findNameById ( id ); return getOtherRepo (). doSOmethingWithName ( name ); } } Here call to getOtherRepo() will return MyOtherRepository guice bean, which is actually another proxy.","title":"Guice beans access"},{"location":"extras/jdbi3/#row-mapper","text":"If you have custom implementations of RowMapper , it may be registered automatically. You will be able to use injections there because mappers become ususal guice beans (singletons). When classpath scan is enabled, such classes will be searched and installed automatically. public class CustomMapper implements RowMapper < Custom > { @Override Custom map ( ResultSet rs , StatementContext ctx ) throws SQLException { // mapping here return custom ; } } And now Custom type could be used for queries: @JdbiRepository @InTransaction public interface CustomRepository { @SqlQuery ( \"select * from custom where id = :id\" ) Custom findNameById ( @Bind ( \"id\" ) int id ); } All installed mappers are reported to console: INFO [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi3.installer.MapperInstaller: jdbi mappers = Sample (ru.vyarus.guicey.jdbi3.support.mapper.SampleMapper)","title":"Row mapper"},{"location":"extras/jdbi3/#manual-unit-of-work-definition","text":"If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use assigned handle directly: @Inject UnitManager manager ; manager . beginUnit (); try { Handle handle = manager . get (); // logic executed in unit of work but without transaction } finally { manager . endUnit (); } Repositories could also be called inside such manual unit (as unit of work is correctly started).","title":"Manual unit of work definition"},{"location":"extras/jdbi3/#migration-from-guice-jdbi-jdbi2","text":"Module package changed from ru.vyarus.guicey.jdbi to ru.vyarus.guicey.jdbi3 . Jdbi object was previously bound as DBI insterface. Now it's bound as Jdbi (DBI interface was removed in jdbi3). New methods in JdbiBundle : withPlugins - install custom plugins withConfig - to simplify manual configuration In jdbi3 ResultSetMapper was changed to RowMapper (and ColumnMapper). Installer supports RowMapper automatic installation. If you were using binding annotations then: @BindingAnnotation -> @SqlStatementCustomizingAnnotation BindingFactory -> SqlStatementCustomizerFactory Sql obect proxies must be interfaces now (jdbi3 restriction). But as java 8 interfaces support default methods, its not a big problem instead of field injection (to access other proxies), now getter annotated with @Inject must be used. See jdbi3 migration gude for other (pure jdbi related) differences","title":"Migration from guice-jdbi (jdbi2)"},{"location":"extras/lifecycle-annotations/","text":"Lifecycle annotations \u00b6 Extensions project module Allows using lifecycle annotations for initialization/destruction methods in guice beans. Main motivation is to replace Managed usage in places where it's simpler to just annotate method, rather than register extension. @PostCostruct - same as Managed.start() @PostStartup - called after server startup (application completely started) @PreDestroy - same as Managed.stop() Setup \u00b6 Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-lifecycle-annotations </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:lifecycle-annotations:0.7.0' See the most recent version in the badge above. Usage \u00b6 By default no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work. import javax.annotation.PostConstruct ; import javax.annotation.PreDestroy ; import ru.vyarus.guicey.annotations.lifecycle.PostStartup ; public class SampleBean { @PostConstruct private void start () { // same time as Managed.start() } @PostStartup private void afterStartup () { // application completely started } @PreDestroy private void stop () { // same time as Managed.stop() } } Annotated methods must not contain parameters. Method could have any visibility. @PostConstruct or @PostStartup methods fail fails entire application startup (fail fast) @PreDestroy method fails are just logged to guarantee that all destroy methods will be procesed If both current class and super class have annotated methods - both methods will be executed (the only obvious exception is overridden methods) Important If bean is created on demand (lazy creation by guice JIT), annotated methods will still be called, even if actual lifecycle event was already passed. Warning log message will be printed to indicate this \"not quite correct\" execution, but you can be sure that your methods will always be processed. Reducing scope \u00b6 Annotations are applied using guice TypeListener api which means that all guice beans are introspected for annotated methods. If you want to limit the scope of processed beans then register bundle manually (in this case lookup will be ignored): GuiceBundle . builder () . bundles ( new LifecycleAnnotationsBundle ( \"package.to.apply\" )) . build () In this example only beans lying in specified package will be checked. Also, direct Matcher implementation could be specified for more sophisticated cases. For example, if I want to exclude only one class: new LifecycleAnnotationsBundle ( new AbstractMatcher < TypeLiteral <?>>() { @Override public boolean matches ( TypeLiteral <?> o ) { return o . getRawType () != SomeExcludedBean . class ; } })","title":"Lifecycle annotations"},{"location":"extras/lifecycle-annotations/#lifecycle-annotations","text":"Extensions project module Allows using lifecycle annotations for initialization/destruction methods in guice beans. Main motivation is to replace Managed usage in places where it's simpler to just annotate method, rather than register extension. @PostCostruct - same as Managed.start() @PostStartup - called after server startup (application completely started) @PreDestroy - same as Managed.stop()","title":"Lifecycle annotations"},{"location":"extras/lifecycle-annotations/#setup","text":"Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-lifecycle-annotations </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:lifecycle-annotations:0.7.0' See the most recent version in the badge above.","title":"Setup"},{"location":"extras/lifecycle-annotations/#usage","text":"By default no setup required: bundle will be loaded automatically with the bundles lookup mechanism (enabled by default). So just add jar into classpath and annotations will work. import javax.annotation.PostConstruct ; import javax.annotation.PreDestroy ; import ru.vyarus.guicey.annotations.lifecycle.PostStartup ; public class SampleBean { @PostConstruct private void start () { // same time as Managed.start() } @PostStartup private void afterStartup () { // application completely started } @PreDestroy private void stop () { // same time as Managed.stop() } } Annotated methods must not contain parameters. Method could have any visibility. @PostConstruct or @PostStartup methods fail fails entire application startup (fail fast) @PreDestroy method fails are just logged to guarantee that all destroy methods will be procesed If both current class and super class have annotated methods - both methods will be executed (the only obvious exception is overridden methods) Important If bean is created on demand (lazy creation by guice JIT), annotated methods will still be called, even if actual lifecycle event was already passed. Warning log message will be printed to indicate this \"not quite correct\" execution, but you can be sure that your methods will always be processed.","title":"Usage"},{"location":"extras/lifecycle-annotations/#reducing-scope","text":"Annotations are applied using guice TypeListener api which means that all guice beans are introspected for annotated methods. If you want to limit the scope of processed beans then register bundle manually (in this case lookup will be ignored): GuiceBundle . builder () . bundles ( new LifecycleAnnotationsBundle ( \"package.to.apply\" )) . build () In this example only beans lying in specified package will be checked. Also, direct Matcher implementation could be specified for more sophisticated cases. For example, if I want to exclude only one class: new LifecycleAnnotationsBundle ( new AbstractMatcher < TypeLiteral <?>>() { @Override public boolean matches ( TypeLiteral <?> o ) { return o . getRawType () != SomeExcludedBean . class ; } })","title":"Reducing scope"},{"location":"extras/spa/","text":"Single page applications support \u00b6 Extensions project module Provides a replacement for dropwizard-assets bundle for single page applications (SPA) to properly handle html5 client routing. Features: Pure dropwizard bundle, but can be used with guicey bundles Build above dropwizard-assets servlet Support registration on main and admin contexts Multiple apps could be registered Sets no-cache headers for index page Regex could be used to tune routes detection Problem \u00b6 The problem with SPA is html5 routing. For example, suppose your app base url is /app and client route url is /app/someroute (before there were no problem because route would look like /app/#!/someroute ). When user hit refresh (or bookmark) such route, server is actually called with route url. Server must recognize it and return index page. For example, Angular 2 router use html5 mode my default. Solution \u00b6 The problem consists of two points: Correctly process resource calls (css, js, images, etc) and return 404 for missed resources Recognize application routes and return index page instead Bundles register dropwizard-assets servlet with special filter above it. Filter tries to process all incoming urls. This approach grants that all calls to resources will be processed and index page will not be returned instead of resource (solves problem 1). If resource is not found - index page returned. To avoid redirection in case of bad resources request, filter will redirect only requests accepting 'text/html'. Additional regexp (configurable) is used to recognize most resource calls and avoid redirection (show correct 404). From example above, /app/someroute will return index page and /app/css/some.css will return css. /app/css/unknown.css will return 404 as resource call will be recognized and css file is not exists. Setup \u00b6 Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-spa </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-spa:0.7.0' See the most recent version in the badge above. Usage \u00b6 Register dropwizard bundle: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build ()); This will register app with name \"app\" (name is used to name servlets and filters and must be unique). Application files are located in \"app\" package in classpath (e.g. resources inside jar). Application is mapped to root context (note that this will work only if rest is mapped to some sub context: e.g. with server.rootPath: '/rest/*' configuration). http://localhost:8080/ -> app index http://loclahost:8080/css/app.css -> application resource, located at /app/css/app.css in classpath http://localhost:8080/someroute -> application client route - index page returned Example registration to admin context: bootstrap . addBundle ( SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build ()); Register \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager' admin context (note that admin root is already used by dropwizard admin servlet). http://localhost:8081/manager -> admin app index You can register as many apps as you like. They just must use different urls and have different names: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build ()); bootstrap . addBundle ( SpaBundle . app ( \"app2\" , \"/app2\" , \"/\" ). build ()); bootstrap . addBundle ( SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build ()); bootstrap . addBundle ( SpaBundle . adminApp ( \"admin2\" , \"/com/mycompany/adminapp2/\" , \"/manager2\" ). build ()); Note If you publish SPA application not in the root path, don't forget to set appropriate <base href=\"/path/\"/> tag. All modern client side routers rely on it. Pay attention that path in base tag must end with / . Index page \u00b6 By default, index page assumed to be \"index.html\". Could be changed with: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). indexPage ( \"main.html\" ). build ()); Prevent redirect regex \u00b6 By default, the following regex is used to prevent resources redirection (to not send index for missed resource): \\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$ Could be changed with: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ) . preventRedirectRegex ( \"\\\\.\\\\w{2,5}(\\\\?.*)?$\" ) . build ()); This regexp implements naive assumption that all app routes does not contain \"extension\". Note: regexp is applied with find so use ^ or $ to apply boundaries. Use with guicey bundle \u00b6 Bundle could be used inside guicey bundle: public class AppBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). register ( bootstrap ); } } This allows you to register application from guicey bundles. Together with bundles lookup guicey feature it could be used to auto installation of client apps (e.g. admin app) when jar appear in classpath.","title":"SPA"},{"location":"extras/spa/#single-page-applications-support","text":"Extensions project module Provides a replacement for dropwizard-assets bundle for single page applications (SPA) to properly handle html5 client routing. Features: Pure dropwizard bundle, but can be used with guicey bundles Build above dropwizard-assets servlet Support registration on main and admin contexts Multiple apps could be registered Sets no-cache headers for index page Regex could be used to tune routes detection","title":"Single page applications support"},{"location":"extras/spa/#problem","text":"The problem with SPA is html5 routing. For example, suppose your app base url is /app and client route url is /app/someroute (before there were no problem because route would look like /app/#!/someroute ). When user hit refresh (or bookmark) such route, server is actually called with route url. Server must recognize it and return index page. For example, Angular 2 router use html5 mode my default.","title":"Problem"},{"location":"extras/spa/#solution","text":"The problem consists of two points: Correctly process resource calls (css, js, images, etc) and return 404 for missed resources Recognize application routes and return index page instead Bundles register dropwizard-assets servlet with special filter above it. Filter tries to process all incoming urls. This approach grants that all calls to resources will be processed and index page will not be returned instead of resource (solves problem 1). If resource is not found - index page returned. To avoid redirection in case of bad resources request, filter will redirect only requests accepting 'text/html'. Additional regexp (configurable) is used to recognize most resource calls and avoid redirection (show correct 404). From example above, /app/someroute will return index page and /app/css/some.css will return css. /app/css/unknown.css will return 404 as resource call will be recognized and css file is not exists.","title":"Solution"},{"location":"extras/spa/#setup","text":"Avoid version in dependency declaration below if you use extensions BOM . Maven: <dependency> <groupId> ru.vyarus.guicey </groupId> <artifactId> guicey-spa </artifactId> <version> 0.7.0 </version> </dependency> Gradle: compile 'ru.vyarus.guicey:guicey-spa:0.7.0' See the most recent version in the badge above.","title":"Setup"},{"location":"extras/spa/#usage","text":"Register dropwizard bundle: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build ()); This will register app with name \"app\" (name is used to name servlets and filters and must be unique). Application files are located in \"app\" package in classpath (e.g. resources inside jar). Application is mapped to root context (note that this will work only if rest is mapped to some sub context: e.g. with server.rootPath: '/rest/*' configuration). http://localhost:8080/ -> app index http://loclahost:8080/css/app.css -> application resource, located at /app/css/app.css in classpath http://localhost:8080/someroute -> application client route - index page returned Example registration to admin context: bootstrap . addBundle ( SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build ()); Register \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager' admin context (note that admin root is already used by dropwizard admin servlet). http://localhost:8081/manager -> admin app index You can register as many apps as you like. They just must use different urls and have different names: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). build ()); bootstrap . addBundle ( SpaBundle . app ( \"app2\" , \"/app2\" , \"/\" ). build ()); bootstrap . addBundle ( SpaBundle . adminApp ( \"admin\" , \"/com/mycompany/adminapp/\" , \"/manager\" ). build ()); bootstrap . addBundle ( SpaBundle . adminApp ( \"admin2\" , \"/com/mycompany/adminapp2/\" , \"/manager2\" ). build ()); Note If you publish SPA application not in the root path, don't forget to set appropriate <base href=\"/path/\"/> tag. All modern client side routers rely on it. Pay attention that path in base tag must end with / .","title":"Usage"},{"location":"extras/spa/#index-page","text":"By default, index page assumed to be \"index.html\". Could be changed with: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). indexPage ( \"main.html\" ). build ());","title":"Index page"},{"location":"extras/spa/#prevent-redirect-regex","text":"By default, the following regex is used to prevent resources redirection (to not send index for missed resource): \\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$ Could be changed with: bootstrap . addBundle ( SpaBundle . app ( \"app\" , \"/app\" , \"/\" ) . preventRedirectRegex ( \"\\\\.\\\\w{2,5}(\\\\?.*)?$\" ) . build ()); This regexp implements naive assumption that all app routes does not contain \"extension\". Note: regexp is applied with find so use ^ or $ to apply boundaries.","title":"Prevent redirect regex"},{"location":"extras/spa/#use-with-guicey-bundle","text":"Bundle could be used inside guicey bundle: public class AppBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { SpaBundle . app ( \"app\" , \"/app\" , \"/\" ). register ( bootstrap ); } } This allows you to register application from guicey bundles. Together with bundles lookup guicey feature it could be used to auto installation of client apps (e.g. admin app) when jar appear in classpath.","title":"Use with guicey bundle"},{"location":"guide/bindings/","text":"Bindings \u00b6 Note Guicey is compatible with some guice restrictive options (like disableCircularProxies) Registered bindings \u00b6 Guicey binds: Dropwizard objects: io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Detailed configuration bindings (by root classes, interfaces, yaml path or unique sub type) All installed extensions (extensions are explicitly bound to guice, except some specific installers which do manual bindings). Jersey objects (including request scoped) Guicey special objects Configuration \u00b6 Configuration bound to guice as: io.dropwizard.Configuration Your configuration class ( MyConfiguration extends Configuration ) All classes between them For example, if MyConfiguration extends MyAbstractConfiguration extends Configuration Then MyAbstractConfiguration will be also bound and following injection will work: @Inject MyAbstractConfiguration conf Note Configuration object bindings could be declared with or without qualifier @Config . So @Inject @Config MyAbstractConfiguration conf will also work. It is suggested to always use qualifier (to get in common with direct value bindings), but it's up to you. If root configuration classes implement interfaces then configuration could be bound by interface. This may be used to support common Has<Something> configuration interfaces convention used to recognize your extension configuration in configuration object. public interface HasFeatureX { FeatureXConfig getFetureXConfig (); } public class MyConfiguration extends Configuration implements HasFeatureXConfig {...} public class MyBean { @Inject @Config HasFeatureX conf ; ... } Important It is required to use qualifier @Config for interface binding (to avoid accidental binding clashes). There is a deprecated bundle option .bindConfigurationInterfaces() , which enables direct interfaces bindings without qualifier (feature remains for compatibility, prefer qualified interfaces bindings). Interface binding will ignore interfaces in java.* or groovy.* packages (to avoid unnecessary bindings). Tip Consider using direct sub configuration object binding (see below) instead of marker interface if object uniqueness is guaranteed in user configuration. Configuration tree \u00b6 Guicey introspects configuration instance using jackson serialization api. That means only values visible for jackson serialization will be presented. Note Jackson will see all properties which either have getter and setter or annotated with @JsonProperty . For example, public class MyConfig extends Configuration { private String one // visible (getter and setter) @JsonProperty private String two // visible (annotation) private String three // invisible (no getter) public void setOne ( String one ) { ... } public String getOne () { ... } public void setTwo ( String two ) { ... } public void setThree ( String three ) { ... } } Tree of visible configuration paths could be accessed with bound ru.vyarus.dropwizard.guice.module.yaml.ConfigurationTree object. It could be used for config analysis, reporting or something else. For simple cases, direct configuration value bindings could be used (see below). Tip To prevent binding of configuration property use @JsonIgnore on property getter private String prop // dropwizard will set value from yaml public void setProp ( Stirng prop ) { ... } // property will not be available as path binding @JsonIgnore public String getProp () { ... } Unique sub configuration \u00b6 It is quite common to group configuration properties into sub objects like: public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; @JsonProperty DbConfig db ; } Guicey detects such unique objects and provides direct bindings for them: @Inject @Config AuthConfig auth ; @Inject @Config DbConfig db ; This is very useful for re-usable modules, which are not aware of your configuration object structure, but require only one sub configuration object: public class MyConfig extends Configuration { @JsonProperty FeatureXConfig featureX ; } Somewhere in module service: public class FeatureXService { @Inject @Config FeatureXConfig featureX ; } Important Sub configuration object uniqueness is checked as direct match, so you may have @JsonProperty SubConfig sub @JsonProperty SubConfigExt subExt where class SubConfigExt extends SubConfig , but still both objects would be considered unique. Whereas @JsonProperty SubConfig sub1 @JsonProperty SubConfig sub2 will not. Tip Guicey bundles and guice modules also could use sub configuration objects directly: GuiceyBootstrap # configuration ( SubConfig . class ) DropwizardAwareModule # configuration ( SubConfig . class ) Configuration by path \u00b6 All visible configuration paths values are directly bindable: public class MyConfig extends Configuration { SubConf sub ; } public class SubConf { String smth ; List < String > values ; } @Inject @Config ( \"sub\" ) SubConf sub ; @Inject @Config ( \"sub.smth\" ) String smth ; @Inject @Config ( \"sub.values\" ) List < String > values ; Note Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations). The only exception is conditional mappin like dropwizard \"server\" when available paths could change, depending on configuration (what configuration class will be used) Note Generified types are bound only with generics (with all available type information). If you will have SubConf<T> sub in config, then it will be bound with correct generic SubConfig<String> (suppose generic T is declared as String). Value type, declared in configuration class is used for binding, but there are two exceptions. If declared type is declared as collection (Set, List, Map) implementation then binding will use base collection interface: ArrayList < String > value @Inject @Config ( \"value\" ) List < String > vlaue ; If, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence: @Config(\"path\") Object val - when value is null @Config(\"path\") ValueType val - actual value type, when value is not null It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\"). Tip You can declare you own additional bindings using ConfigurationTree (accessible from guice module), which contains all paths information (including declaration and actual types with generics). Configuration bindings report \u00b6 You can print all available configuration bindings with values: GuiceBundle . builder () ... . printConfigurationBindings () // or printCustomConfigurationBindings() to avoid dropwizard bindings . build () Will print: INFO [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = ComplexGenericCase (visible paths) \u2502 \u251c\u2500\u2500 sub: ComplexGenericCase.Sub<String> \u2502 \u2514\u2500\u2500 smth: String = null \u2502 \u251c\u2500\u2500 logging: DefaultLoggingFactory \u2502 \u251c\u2500\u2500 level: String = \"INFO\" \u2502 \u251c\u2500\u2500 loggers: RegularImmutableMap<String, JsonNode> = {} \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<ILoggingEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] \u2502 \u251c\u2500\u2500 metrics: MetricsFactory \u2502 \u251c\u2500\u2500 frequency: Duration = 1 minute \u2502 \u2514\u2500\u2500 reporters: RegularImmutableList<ReporterFactory> = [] \u2502 \u2514\u2500\u2500 server: DefaultServerFactory \u251c\u2500\u2500 maxThreads: Integer = 1024 \u251c\u2500\u2500 minThreads: Integer = 8 \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024 \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute \u251c\u2500\u2500 nofileSoftLimit: Integer = null \u251c\u2500\u2500 nofileHardLimit: Integer = null \u251c\u2500\u2500 gid: Integer = null \u251c\u2500\u2500 uid: Integer = null \u251c\u2500\u2500 user: String = null \u251c\u2500\u2500 group: String = null \u251c\u2500\u2500 umask: String = null \u251c\u2500\u2500 startsAsRoot: Boolean = null \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds \u251c\u2500\u2500 allowedMethods: HashSet<String> = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true \u251c\u2500\u2500 applicationConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] \u251c\u2500\u2500 adminConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@227a47] \u251c\u2500\u2500 adminMaxThreads: Integer = 64 \u251c\u2500\u2500 adminMinThreads: Integer = 1 \u251c\u2500\u2500 applicationContextPath: String = \"/\" \u251c\u2500\u2500 adminContextPath: String = \"/\" \u2502 \u251c\u2500\u2500 serverPush: ServerPushFilterFactory \u2502 \u251c\u2500\u2500 enabled: Boolean = false \u2502 \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds \u2502 \u251c\u2500\u2500 maxAssociations: Integer = 16 \u2502 \u251c\u2500\u2500 refererHosts: List<String> = null \u2502 \u2514\u2500\u2500 refererPorts: List<Integer> = null \u2502 \u251c\u2500\u2500 rootPath: Optional<String> = Optional.empty \u2502 \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<IAccessEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] \u2502 \u2514\u2500\u2500 gzip: GzipHandlerFactory \u251c\u2500\u2500 enabled: Boolean = true \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet<String> = [] \u251c\u2500\u2500 compressedMimeTypes: Set<String> = null \u251c\u2500\u2500 includedMethods: Set<String> = null \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1 \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true \u2514\u2500\u2500 syncFlush: Boolean = false Configuration object bindings: @Config ComplexGenericCase @Config Configuration Unique sub configuration objects bindings: ComplexGenericCase.sub @Config ComplexGenericCase.Sub<String> = null Configuration.logging @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} Configuration.metrics @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} Configuration.server @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} Configuration.server.gzip @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 Configuration.server.requestLog @Config RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 Configuration.server.serverPush @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 Configuration paths bindings: ComplexGenericCase: @Config(\"sub\") ComplexGenericCase.Sub<String> = null @Config(\"sub.smth\") String = null Configuration: @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} @Config(\"logging.appenders\") List<AppenderFactory<ILoggingEvent>> (with actual type SingletonImmutableList<AppenderFactory<ILoggingEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] @Config(\"logging.level\") String = \"INFO\" @Config(\"logging.loggers\") Map<String, JsonNode> (with actual type RegularImmutableMap<String, JsonNode>) = {} @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} @Config(\"metrics.frequency\") Duration = 1 minute @Config(\"metrics.reporters\") List<ReporterFactory> (with actual type RegularImmutableList<ReporterFactory>) = [] @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} @Config(\"server.adminConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@227a47] @Config(\"server.adminContextPath\") String = \"/\" @Config(\"server.adminMaxThreads\") Integer = 64 @Config(\"server.adminMinThreads\") Integer = 1 @Config(\"server.allowedMethods\") Set<String> (with actual type HashSet<String>) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] @Config(\"server.applicationConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] @Config(\"server.applicationContextPath\") String = \"/\" @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false @Config(\"server.enableThreadNameFilter\") Boolean = true @Config(\"server.gid\") Integer = null @Config(\"server.group\") String = null @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes @Config(\"server.gzip.compressedMimeTypes\") Set<String> = null @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1 @Config(\"server.gzip.enabled\") Boolean = true @Config(\"server.gzip.excludedUserAgentPatterns\") Set<String> (with actual type HashSet<String>) = [] @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true @Config(\"server.gzip.includedMethods\") Set<String> = null @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes @Config(\"server.gzip.syncFlush\") Boolean = false @Config(\"server.idleThreadTimeout\") Duration = 1 minute @Config(\"server.maxQueuedRequests\") Integer = 1024 @Config(\"server.maxThreads\") Integer = 1024 @Config(\"server.minThreads\") Integer = 8 @Config(\"server.nofileHardLimit\") Integer = null @Config(\"server.nofileSoftLimit\") Integer = null @Config(\"server.registerDefaultExceptionMappers\") Boolean = true @Config(\"server.requestLog\") RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 @Config(\"server.requestLog.appenders\") List<AppenderFactory<IAccessEvent>> (with actual type SingletonImmutableList<AppenderFactory<IAccessEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] @Config(\"server.rootPath\") Optional<String> = Optional.empty @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds @Config(\"server.serverPush.enabled\") Boolean = false @Config(\"server.serverPush.maxAssociations\") Integer = 16 @Config(\"server.serverPush.refererHosts\") List<String> = null @Config(\"server.serverPush.refererPorts\") List<Integer> = null @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds @Config(\"server.startsAsRoot\") Boolean = null @Config(\"server.uid\") Integer = null @Config(\"server.umask\") String = null @Config(\"server.user\") String = null Introspected configuration \u00b6 ConfigurationTree object provides access for introspected configuration tree: getRootTypes() - all classes in configuration hierarchy (including interfaces) getPaths() - all paths (including all steps (\"sub\", \"sub.value\")) getUniqueTypePaths() - paths of unique sub configuration types Each path item ( ConfigPath ) contains: Root path reference (\"sub.value\" reference \"sub\") Child sub-paths (\"sub\" reference \"sub.value\") Declaration class (type used in configuration class) Value type (type of actual value; when value null - declaration type (but they still could be different for collections)) Current path name Current path value Generics for declaration and value types (may be incomplete for value type) Custom type marker: contains sub paths or just looks like sub configuration Declaration type (class where property was declared - configuration object containing property) You can traverse up or down from any path (tree structure). ConfigurationTree provides basic search methods (more as usage example): findByPath(String) - search path by case-insensitive match findAllByType(Class) - find all paths with assignable declared value findAllFrom(Class<? extends Configuration>) - find all paths, started in specified configuration class findAllRootPaths() - get all root paths (1 st level paths) findAllRootPathsFrom(Class<? extends Configuration>) - all 1 st level paths of configuration class valueByPath(String) - return path value or null if value null or path not exists valuesByType(Class) - all not null values with assignable type valueByType(Class) - first not null value with assignable type valueByUniqueDeclaredType(Class) - value of unique sub conifguration or null if value is null or config is not unique Paths are sorted by configuration class (to put custom properties upper) and by path name (for predictable paths order). Disable configuration introspection \u00b6 Introspection process should not fail application startup. In worse case it will show warning log that property can't be introspected: WARN [2018-07-23 09:11:13,034] ru.vyarus.dropwizard.guice.module.yaml.ConfigTreeBuilder: Can't bind configuration path 'sub.sample' due to IllegalArgumentException: Failed to getValue() with method ru.vyarus.dropwizard.guice.yaml.support.FailedGetterConfig#getSample(0 params): null. Enable debug logs to see complete stack trace or use @JsonIgnore on property getter. Such warnings could be hidden by using @JsonIgnore on property getter. If this is not enough, or you need to avoid configuration introspection for other reasons, you can disable introspection completely with option: GuiceBundle . builder () . option ( GuiceyOptions . BindConfigurationByPath , false ) ... When introspection disabled, only configuration object would be bound and bindings by path would not be available. Note that even ConfigurationTree object will not contain configuration paths (option completely disables introspection mechanism). Environment binding \u00b6 Dropwizard io.dropwizard.setup.Environment is bound to guice context. It is mostly useful to perform additional configurations in guice bean for features not covered with installers. For example: public class MyBean { @Inject public MyBean ( Environment environment ) { environment . lifecycle (). addServerLifecycleListener ( new ServerLifecycleListener { public void serverStarted ( Server server ) { callSomeMethod (); } }) } } It's not the best example, but it illustrates usage (and such things usually helps to quick-test something). See also authentication configuration example . Jersey specific bindings \u00b6 Jersey bindings are not immediately available, because HK2 context starts after guice, so use Provider to inject these bindings. These bindings available after HK2 context start: javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.internal.process.AsyncContext Tip Read about jersey bindings implementation in lifecycle section . Request and response \u00b6 By default, GuiceFilter is enabled on both contexts (admin and main). So you can inject request and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions). If you disable guice filter with .noGuiceFilter() then guicey will bridge objects from HK2 context: javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse This means you can still inject them, but request and response will only be available under resource calls (the only part managed by jersey). Example usage: @Inject Provider < HttpServletRequest > requestProvider ; Note Pay attention, that in guice-managed resources @Context field bindings must be replaced with providers . Options \u00b6 ru.vyarus.dropwizard.guice.module.context.option.Options binding provides access to guicey options : @Inject Options options ; Example usage: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" ) Guicey configuration \u00b6 ru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo binding provides access to guicey configuration details : @Inject GuiceyConfigurationInfo info Binding scope \u00b6 As you know, guice assume prototype scope by default (when no scope annotation declared). Guice scope annotations: @Singleton - single instance per context @RequestScoped - object per request (if guice filter support is not disabled @Prototype - prototype scope annotation (useful for jersey services to override force singleton scope) Jersey extensions ( resources , providers ) force singleton scope for extensions without explicit binding annotation (but this could be disabled with an option ). Use explicit scope annotations where singletons are not required. Request scope transition \u00b6 This is guice feature, it is just mentioned here. Guice could access request scoped bindings only in current thread. If you need to access request scoped binding in different thread, you need to transfer request scope into that thread: @Singleton public class RequestBean { // provider will not work in other thread because of request scope @Inject Provider < UriInfo > uri ; public void doSomethingInRequestScope () { // wrap logic that require request scope Callable < String > action = ServletScopes . transferRequest (() -> { // access request scoped binding in different thread return uri . get (). getQueryParameters (). getFirst ( \"q\" ); }); CompletableFuture . runAsync (() -> { try { // execute action in different thread action . call (); } catch ( Exception e ) { e . printStackTrace (); } }); } } Extensions initialisation \u00b6 All guicey extensions are bound to guice context ( .bind(ExtType) , to be compatible with .requireExplicitBindings() strict option) that means that all singleton scoped extensions will be initialized in time of injector creation (because by default, Stage.PRODCUTION used). Tip You can change guice injector stage to Stage.DEVELOPMENT in the main bundle to avoid singletons initialization during context creation (only .asEagerSingleton() ) bindings will be initialized). But don't do it without a really good reason (for example, legacy codebase required development stage). Also, you can avoid extension binding by annotating it with @LazyBinding : this way extension will not be bound to guice context and so will initialize only on first usage (obtaining from context). HK2 scope \u00b6 By default, all jersey extensions (resources, providers) are managed by guice. But you can switch it to be managed by HK2 by default GuiceBundle . builder () ... . useHK2ForJerseyExtensions () . build () Warning You will not be able to use guice AOP on HK2 managed beans. Depending on default mode selected, you can use annotations to change extension DI: @HK2Managed - extension managed by HK2 (useful in default mode when all beans created by guice) @GuiceManaged - extension managed by guice (default, useful only when .useHK2ForJerseyExtensions() enabled) Bindings override \u00b6 Guicey provides direct support for overriding bindings and even override overridden bindings in tests .","title":"Bindings"},{"location":"guide/bindings/#bindings","text":"Note Guicey is compatible with some guice restrictive options (like disableCircularProxies)","title":"Bindings"},{"location":"guide/bindings/#registered-bindings","text":"Guicey binds: Dropwizard objects: io.dropwizard.setup.Bootstrap io.dropwizard.Configuration io.dropwizard.setup.Environment Detailed configuration bindings (by root classes, interfaces, yaml path or unique sub type) All installed extensions (extensions are explicitly bound to guice, except some specific installers which do manual bindings). Jersey objects (including request scoped) Guicey special objects","title":"Registered bindings"},{"location":"guide/bindings/#configuration","text":"Configuration bound to guice as: io.dropwizard.Configuration Your configuration class ( MyConfiguration extends Configuration ) All classes between them For example, if MyConfiguration extends MyAbstractConfiguration extends Configuration Then MyAbstractConfiguration will be also bound and following injection will work: @Inject MyAbstractConfiguration conf Note Configuration object bindings could be declared with or without qualifier @Config . So @Inject @Config MyAbstractConfiguration conf will also work. It is suggested to always use qualifier (to get in common with direct value bindings), but it's up to you. If root configuration classes implement interfaces then configuration could be bound by interface. This may be used to support common Has<Something> configuration interfaces convention used to recognize your extension configuration in configuration object. public interface HasFeatureX { FeatureXConfig getFetureXConfig (); } public class MyConfiguration extends Configuration implements HasFeatureXConfig {...} public class MyBean { @Inject @Config HasFeatureX conf ; ... } Important It is required to use qualifier @Config for interface binding (to avoid accidental binding clashes). There is a deprecated bundle option .bindConfigurationInterfaces() , which enables direct interfaces bindings without qualifier (feature remains for compatibility, prefer qualified interfaces bindings). Interface binding will ignore interfaces in java.* or groovy.* packages (to avoid unnecessary bindings). Tip Consider using direct sub configuration object binding (see below) instead of marker interface if object uniqueness is guaranteed in user configuration.","title":"Configuration"},{"location":"guide/bindings/#configuration-tree","text":"Guicey introspects configuration instance using jackson serialization api. That means only values visible for jackson serialization will be presented. Note Jackson will see all properties which either have getter and setter or annotated with @JsonProperty . For example, public class MyConfig extends Configuration { private String one // visible (getter and setter) @JsonProperty private String two // visible (annotation) private String three // invisible (no getter) public void setOne ( String one ) { ... } public String getOne () { ... } public void setTwo ( String two ) { ... } public void setThree ( String three ) { ... } } Tree of visible configuration paths could be accessed with bound ru.vyarus.dropwizard.guice.module.yaml.ConfigurationTree object. It could be used for config analysis, reporting or something else. For simple cases, direct configuration value bindings could be used (see below). Tip To prevent binding of configuration property use @JsonIgnore on property getter private String prop // dropwizard will set value from yaml public void setProp ( Stirng prop ) { ... } // property will not be available as path binding @JsonIgnore public String getProp () { ... }","title":"Configuration tree"},{"location":"guide/bindings/#unique-sub-configuration","text":"It is quite common to group configuration properties into sub objects like: public class MyConfig extends Configuration { @JsonProperty AuthConfig auth ; @JsonProperty DbConfig db ; } Guicey detects such unique objects and provides direct bindings for them: @Inject @Config AuthConfig auth ; @Inject @Config DbConfig db ; This is very useful for re-usable modules, which are not aware of your configuration object structure, but require only one sub configuration object: public class MyConfig extends Configuration { @JsonProperty FeatureXConfig featureX ; } Somewhere in module service: public class FeatureXService { @Inject @Config FeatureXConfig featureX ; } Important Sub configuration object uniqueness is checked as direct match, so you may have @JsonProperty SubConfig sub @JsonProperty SubConfigExt subExt where class SubConfigExt extends SubConfig , but still both objects would be considered unique. Whereas @JsonProperty SubConfig sub1 @JsonProperty SubConfig sub2 will not. Tip Guicey bundles and guice modules also could use sub configuration objects directly: GuiceyBootstrap # configuration ( SubConfig . class ) DropwizardAwareModule # configuration ( SubConfig . class )","title":"Unique sub configuration"},{"location":"guide/bindings/#configuration-by-path","text":"All visible configuration paths values are directly bindable: public class MyConfig extends Configuration { SubConf sub ; } public class SubConf { String smth ; List < String > values ; } @Inject @Config ( \"sub\" ) SubConf sub ; @Inject @Config ( \"sub.smth\" ) String smth ; @Inject @Config ( \"sub.values\" ) List < String > values ; Note Path bindings are available even for null values. For example, if sub configuration object is null, all it's sub paths will still be available (by class declarations). The only exception is conditional mappin like dropwizard \"server\" when available paths could change, depending on configuration (what configuration class will be used) Note Generified types are bound only with generics (with all available type information). If you will have SubConf<T> sub in config, then it will be bound with correct generic SubConfig<String> (suppose generic T is declared as String). Value type, declared in configuration class is used for binding, but there are two exceptions. If declared type is declared as collection (Set, List, Map) implementation then binding will use base collection interface: ArrayList < String > value @Inject @Config ( \"value\" ) List < String > vlaue ; If, for some (unforgivable) reason, property is declared as Object in configuration, then binding type will depend on value presence: @Config(\"path\") Object val - when value is null @Config(\"path\") ValueType val - actual value type, when value is not null It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\"). Tip You can declare you own additional bindings using ConfigurationTree (accessible from guice module), which contains all paths information (including declaration and actual types with generics).","title":"Configuration by path"},{"location":"guide/bindings/#configuration-bindings-report","text":"You can print all available configuration bindings with values: GuiceBundle . builder () ... . printConfigurationBindings () // or printCustomConfigurationBindings() to avoid dropwizard bindings . build () Will print: INFO [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = ComplexGenericCase (visible paths) \u2502 \u251c\u2500\u2500 sub: ComplexGenericCase.Sub<String> \u2502 \u2514\u2500\u2500 smth: String = null \u2502 \u251c\u2500\u2500 logging: DefaultLoggingFactory \u2502 \u251c\u2500\u2500 level: String = \"INFO\" \u2502 \u251c\u2500\u2500 loggers: RegularImmutableMap<String, JsonNode> = {} \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<ILoggingEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] \u2502 \u251c\u2500\u2500 metrics: MetricsFactory \u2502 \u251c\u2500\u2500 frequency: Duration = 1 minute \u2502 \u2514\u2500\u2500 reporters: RegularImmutableList<ReporterFactory> = [] \u2502 \u2514\u2500\u2500 server: DefaultServerFactory \u251c\u2500\u2500 maxThreads: Integer = 1024 \u251c\u2500\u2500 minThreads: Integer = 8 \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024 \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute \u251c\u2500\u2500 nofileSoftLimit: Integer = null \u251c\u2500\u2500 nofileHardLimit: Integer = null \u251c\u2500\u2500 gid: Integer = null \u251c\u2500\u2500 uid: Integer = null \u251c\u2500\u2500 user: String = null \u251c\u2500\u2500 group: String = null \u251c\u2500\u2500 umask: String = null \u251c\u2500\u2500 startsAsRoot: Boolean = null \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds \u251c\u2500\u2500 allowedMethods: HashSet<String> = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true \u251c\u2500\u2500 applicationConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] \u251c\u2500\u2500 adminConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@227a47] \u251c\u2500\u2500 adminMaxThreads: Integer = 64 \u251c\u2500\u2500 adminMinThreads: Integer = 1 \u251c\u2500\u2500 applicationContextPath: String = \"/\" \u251c\u2500\u2500 adminContextPath: String = \"/\" \u2502 \u251c\u2500\u2500 serverPush: ServerPushFilterFactory \u2502 \u251c\u2500\u2500 enabled: Boolean = false \u2502 \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds \u2502 \u251c\u2500\u2500 maxAssociations: Integer = 16 \u2502 \u251c\u2500\u2500 refererHosts: List<String> = null \u2502 \u2514\u2500\u2500 refererPorts: List<Integer> = null \u2502 \u251c\u2500\u2500 rootPath: Optional<String> = Optional.empty \u2502 \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory \u2502 \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<IAccessEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] \u2502 \u2514\u2500\u2500 gzip: GzipHandlerFactory \u251c\u2500\u2500 enabled: Boolean = true \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet<String> = [] \u251c\u2500\u2500 compressedMimeTypes: Set<String> = null \u251c\u2500\u2500 includedMethods: Set<String> = null \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1 \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true \u2514\u2500\u2500 syncFlush: Boolean = false Configuration object bindings: @Config ComplexGenericCase @Config Configuration Unique sub configuration objects bindings: ComplexGenericCase.sub @Config ComplexGenericCase.Sub<String> = null Configuration.logging @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} Configuration.metrics @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} Configuration.server @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} Configuration.server.gzip @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 Configuration.server.requestLog @Config RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 Configuration.server.serverPush @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 Configuration paths bindings: ComplexGenericCase: @Config(\"sub\") ComplexGenericCase.Sub<String> = null @Config(\"sub.smth\") String = null Configuration: @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]} @Config(\"logging.appenders\") List<AppenderFactory<ILoggingEvent>> (with actual type SingletonImmutableList<AppenderFactory<ILoggingEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7] @Config(\"logging.level\") String = \"INFO\" @Config(\"logging.loggers\") Map<String, JsonNode> (with actual type RegularImmutableMap<String, JsonNode>) = {} @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]} @Config(\"metrics.frequency\") Duration = 1 minute @Config(\"metrics.reporters\") List<ReporterFactory> (with actual type RegularImmutableList<ReporterFactory>) = [] @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/} @Config(\"server.adminConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@227a47] @Config(\"server.adminContextPath\") String = \"/\" @Config(\"server.adminMaxThreads\") Integer = 64 @Config(\"server.adminMinThreads\") Integer = 1 @Config(\"server.allowedMethods\") Set<String> (with actual type HashSet<String>) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH] @Config(\"server.applicationConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b] @Config(\"server.applicationContextPath\") String = \"/\" @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false @Config(\"server.enableThreadNameFilter\") Boolean = true @Config(\"server.gid\") Integer = null @Config(\"server.group\") String = null @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6 @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes @Config(\"server.gzip.compressedMimeTypes\") Set<String> = null @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1 @Config(\"server.gzip.enabled\") Boolean = true @Config(\"server.gzip.excludedUserAgentPatterns\") Set<String> (with actual type HashSet<String>) = [] @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true @Config(\"server.gzip.includedMethods\") Set<String> = null @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes @Config(\"server.gzip.syncFlush\") Boolean = false @Config(\"server.idleThreadTimeout\") Duration = 1 minute @Config(\"server.maxQueuedRequests\") Integer = 1024 @Config(\"server.maxThreads\") Integer = 1024 @Config(\"server.minThreads\") Integer = 8 @Config(\"server.nofileHardLimit\") Integer = null @Config(\"server.nofileSoftLimit\") Integer = null @Config(\"server.registerDefaultExceptionMappers\") Boolean = true @Config(\"server.requestLog\") RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571 @Config(\"server.requestLog.appenders\") List<AppenderFactory<IAccessEvent>> (with actual type SingletonImmutableList<AppenderFactory<IAccessEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c] @Config(\"server.rootPath\") Optional<String> = Optional.empty @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4 @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds @Config(\"server.serverPush.enabled\") Boolean = false @Config(\"server.serverPush.maxAssociations\") Integer = 16 @Config(\"server.serverPush.refererHosts\") List<String> = null @Config(\"server.serverPush.refererPorts\") List<Integer> = null @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds @Config(\"server.startsAsRoot\") Boolean = null @Config(\"server.uid\") Integer = null @Config(\"server.umask\") String = null @Config(\"server.user\") String = null","title":"Configuration bindings report"},{"location":"guide/bindings/#introspected-configuration","text":"ConfigurationTree object provides access for introspected configuration tree: getRootTypes() - all classes in configuration hierarchy (including interfaces) getPaths() - all paths (including all steps (\"sub\", \"sub.value\")) getUniqueTypePaths() - paths of unique sub configuration types Each path item ( ConfigPath ) contains: Root path reference (\"sub.value\" reference \"sub\") Child sub-paths (\"sub\" reference \"sub.value\") Declaration class (type used in configuration class) Value type (type of actual value; when value null - declaration type (but they still could be different for collections)) Current path name Current path value Generics for declaration and value types (may be incomplete for value type) Custom type marker: contains sub paths or just looks like sub configuration Declaration type (class where property was declared - configuration object containing property) You can traverse up or down from any path (tree structure). ConfigurationTree provides basic search methods (more as usage example): findByPath(String) - search path by case-insensitive match findAllByType(Class) - find all paths with assignable declared value findAllFrom(Class<? extends Configuration>) - find all paths, started in specified configuration class findAllRootPaths() - get all root paths (1 st level paths) findAllRootPathsFrom(Class<? extends Configuration>) - all 1 st level paths of configuration class valueByPath(String) - return path value or null if value null or path not exists valuesByType(Class) - all not null values with assignable type valueByType(Class) - first not null value with assignable type valueByUniqueDeclaredType(Class) - value of unique sub conifguration or null if value is null or config is not unique Paths are sorted by configuration class (to put custom properties upper) and by path name (for predictable paths order).","title":"Introspected configuration"},{"location":"guide/bindings/#disable-configuration-introspection","text":"Introspection process should not fail application startup. In worse case it will show warning log that property can't be introspected: WARN [2018-07-23 09:11:13,034] ru.vyarus.dropwizard.guice.module.yaml.ConfigTreeBuilder: Can't bind configuration path 'sub.sample' due to IllegalArgumentException: Failed to getValue() with method ru.vyarus.dropwizard.guice.yaml.support.FailedGetterConfig#getSample(0 params): null. Enable debug logs to see complete stack trace or use @JsonIgnore on property getter. Such warnings could be hidden by using @JsonIgnore on property getter. If this is not enough, or you need to avoid configuration introspection for other reasons, you can disable introspection completely with option: GuiceBundle . builder () . option ( GuiceyOptions . BindConfigurationByPath , false ) ... When introspection disabled, only configuration object would be bound and bindings by path would not be available. Note that even ConfigurationTree object will not contain configuration paths (option completely disables introspection mechanism).","title":"Disable configuration introspection"},{"location":"guide/bindings/#environment-binding","text":"Dropwizard io.dropwizard.setup.Environment is bound to guice context. It is mostly useful to perform additional configurations in guice bean for features not covered with installers. For example: public class MyBean { @Inject public MyBean ( Environment environment ) { environment . lifecycle (). addServerLifecycleListener ( new ServerLifecycleListener { public void serverStarted ( Server server ) { callSomeMethod (); } }) } } It's not the best example, but it illustrates usage (and such things usually helps to quick-test something). See also authentication configuration example .","title":"Environment binding"},{"location":"guide/bindings/#jersey-specific-bindings","text":"Jersey bindings are not immediately available, because HK2 context starts after guice, so use Provider to inject these bindings. These bindings available after HK2 context start: javax.ws.rs.core.Application javax.ws.rs.ext.Providers org.glassfish.hk2.api.ServiceLocator org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider Request-scoped bindings: javax.ws.rs.core.UriInfo javax.ws.rs.container.ResourceInfo javax.ws.rs.core.HttpHeaders javax.ws.rs.core.SecurityContext javax.ws.rs.core.Request org.glassfish.jersey.server.ContainerRequest org.glassfish.jersey.server.internal.process.AsyncContext Tip Read about jersey bindings implementation in lifecycle section .","title":"Jersey specific bindings"},{"location":"guide/bindings/#request-and-response","text":"By default, GuiceFilter is enabled on both contexts (admin and main). So you can inject request and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions). If you disable guice filter with .noGuiceFilter() then guicey will bridge objects from HK2 context: javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletResponse This means you can still inject them, but request and response will only be available under resource calls (the only part managed by jersey). Example usage: @Inject Provider < HttpServletRequest > requestProvider ; Note Pay attention, that in guice-managed resources @Context field bindings must be replaced with providers .","title":"Request and response"},{"location":"guide/bindings/#options","text":"ru.vyarus.dropwizard.guice.module.context.option.Options binding provides access to guicey options : @Inject Options options ; Example usage: Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ), \"HK2 guice bridge is required!\" )","title":"Options"},{"location":"guide/bindings/#guicey-configuration","text":"ru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo binding provides access to guicey configuration details : @Inject GuiceyConfigurationInfo info","title":"Guicey configuration"},{"location":"guide/bindings/#binding-scope","text":"As you know, guice assume prototype scope by default (when no scope annotation declared). Guice scope annotations: @Singleton - single instance per context @RequestScoped - object per request (if guice filter support is not disabled @Prototype - prototype scope annotation (useful for jersey services to override force singleton scope) Jersey extensions ( resources , providers ) force singleton scope for extensions without explicit binding annotation (but this could be disabled with an option ). Use explicit scope annotations where singletons are not required.","title":"Binding scope"},{"location":"guide/bindings/#request-scope-transition","text":"This is guice feature, it is just mentioned here. Guice could access request scoped bindings only in current thread. If you need to access request scoped binding in different thread, you need to transfer request scope into that thread: @Singleton public class RequestBean { // provider will not work in other thread because of request scope @Inject Provider < UriInfo > uri ; public void doSomethingInRequestScope () { // wrap logic that require request scope Callable < String > action = ServletScopes . transferRequest (() -> { // access request scoped binding in different thread return uri . get (). getQueryParameters (). getFirst ( \"q\" ); }); CompletableFuture . runAsync (() -> { try { // execute action in different thread action . call (); } catch ( Exception e ) { e . printStackTrace (); } }); } }","title":"Request scope transition"},{"location":"guide/bindings/#extensions-initialisation","text":"All guicey extensions are bound to guice context ( .bind(ExtType) , to be compatible with .requireExplicitBindings() strict option) that means that all singleton scoped extensions will be initialized in time of injector creation (because by default, Stage.PRODCUTION used). Tip You can change guice injector stage to Stage.DEVELOPMENT in the main bundle to avoid singletons initialization during context creation (only .asEagerSingleton() ) bindings will be initialized). But don't do it without a really good reason (for example, legacy codebase required development stage). Also, you can avoid extension binding by annotating it with @LazyBinding : this way extension will not be bound to guice context and so will initialize only on first usage (obtaining from context).","title":"Extensions initialisation"},{"location":"guide/bindings/#hk2-scope","text":"By default, all jersey extensions (resources, providers) are managed by guice. But you can switch it to be managed by HK2 by default GuiceBundle . builder () ... . useHK2ForJerseyExtensions () . build () Warning You will not be able to use guice AOP on HK2 managed beans. Depending on default mode selected, you can use annotations to change extension DI: @HK2Managed - extension managed by HK2 (useful in default mode when all beans created by guice) @GuiceManaged - extension managed by guice (default, useful only when .useHK2ForJerseyExtensions() enabled)","title":"HK2 scope"},{"location":"guide/bindings/#bindings-override","text":"Guicey provides direct support for overriding bindings and even override overridden bindings in tests .","title":"Bindings override"},{"location":"guide/bundles/","text":"Guicey bundles \u00b6 By analogy with dropwizard bundles, guicey has it's own GuiceyBundle . These bundles contains almost the same options as main GuiceBundle builder. The main purpose is to group installers, extensions and guice modules related to specific feature. Guicey bundles are initialized during dropwizard run phase. All guice modules registered in bundles will also be checked for required dropwizard objects autowiring . For example, custom integration with some scheduler framework will require installers to register tasks and guice module to configure framework. GuiceyBundle will allow reduce integration to just one bundle installation. public class XLibIntegrationBundle implements GuiceyBundle { @Override public void initialize ( final GuiceyBootstrap bootstrap ) { bootstrap . installers ( XLibFeature1Installer . class , XLibFeature2Installer . class , ) . modules ( new XLibGuiceModule ()); } } bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundles ( new XLibIntegrationBundle ()) . enableAutoConfig ( \"package.to.scan\" ) . build () ); Tip GuiceyBootstrap object used not only for registration, but also provides access to Bootstrap , Configuration , ConfigurationTree , Environment and Options objects. Bundles may be used to group application features: e.g. ResourcesBundle, TasksBundle (for example, when auto-scan not enabled to decompose configuration). Bundles are transitive - bundle can install other bundles. Duplicate bundles are detected using bundle type, so infinite configuration loops or duplicate configurations are not possible. Warning Be careful if bundle is parameterizable (requires constructor arguments). If two such bundles will be registered, only first registration will be actually used and other instance ignored. Note that application configurations (using main GuiceBundle methods) performed before bundles processing and so bundle instance with correct parameters could be registered there. Transitive bundles (or simply a lot of bundles) may cause confusion. Use diagnostic info to see how guicey was actually configured. Predefined bundles \u00b6 Guicey ships with few predefined bundles. Core installers bundle \u00b6 Default installers are grouped into CoreInstallersBundle . This bundle is always installed implicitly (so you always have default installers). It may be disabled using .noDefaultInstallers() . Web installers bundle \u00b6 WebInstallersBundle provides installers for servlets, filters and listeners installation using servlet api annotations ( @WebServlet , @WebFilter , @WebListener ). Warning Bundle is not installed by default to avoid confusion. May be enabled using .useWebInstallers() . Tip If web installers used, then you may not need guice ServletModule support. To remove GuiceFilter registrations and ServletModule support use .noGuiceFilter() . HK2 debug bundle \u00b6 HK2DebugBundle is special debug bundle to check that beans properly instantiated by guice or HK2 (and no beans are instantiated by both). Only beans installed by installers implementing JerseyInstaller ( ResourceInstaller , JerseyProviderInstaller ). All beans must be created by guice and only beans annotated with @HK2Managed must be instantiated by HK2. Bundle may be used in tests. For example using guicey.bundles property (see bundles lookup below). May be enabled by .strictScopeControl() . Note Works in both guice-first or HK2-first modes. Diagnostic bundle \u00b6 Bundle renders collected guicey diagnostic information . Output is highly configurable, use: DiagnosticBundle.builder() to configure reporting (if required). Bundle may be registered with bundle lookup mechanism . For example: PropertyBundleLookup . enableBundles ( DiagnosticBundle . class ); May be enabled by .printDiagnosticInfo() shortcut method. Special shortcut .printAvailableInstallers() register diagnostic bundle configured for showing only installers . Useful when you looking for available features. Only one bundle instance accepted, both options can't be enabled at the same time. Dropwizard bundles unification \u00b6 Guicey bundles and dropwizard bundles may be unified providing single (standard) extension point for both dropwizard and guicey features: public class MixedBundle implements ConfiguredBundle , GuiceyBundle { public void initialize ( Bootstrap <?> bootstrap ) { // do something in init phase } public void initialize ( GuiceyBootstrap bootstrap ) { // apply guicey configurations } public void run ( T configuration , Environment environment ) throws Exception { // not needed because everything could be done in guicey bundle's method } } Feature is disabled by default, to enable it use .configureFromDropwizardBundles() method. bootstrap . addBundle ( new MixedBundle ()); bootstrap . addBundle ( GuiceBundle . builder () . configureFromDropwizardBundles ( true ) . build () ); When active, all registered dropwizard bundles are checked if they implement GuiceyBundle . Works with both Bundle and ConfiguredBundle dropwizard bundle types. Warning Don't assume if guicey bundle's initialize method will be called before/after dropwizard bundle's run method. Both are possible (it depends if bundle registered before or after GuiceBundle). Bundle lookup \u00b6 Bundle lookup mechanism used to lookup guicey bundles in various sources. It may be used to activate specific bundles in tests (e.g. HK2DebugBundle) or to install 3 rd party extensions from classpath. Bundle lookup is equivalent to registering bundle directly using builder bundles method. By default, 2 lookup mechanisms active. All found bundles are logged into console. Duplicate bundles are removed (using bundle class to detect duplicate). To disable default lookups use disableBundleLookup : bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . disableBundleLookup () . build () System property lookup \u00b6 System property guicey.bundles could contain comma separated list of guicey bundle classes. These bundles must have no-args constructor. For example, activate HK2 debug bundle for tests: java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle Alternatively, system property may be set in code: PropertyBundleLookup . enableBundles ( HK2DebugBundle . class ) Service loader lookup \u00b6 Using default java ServiceLoader mechanism, loads all GuiceyBundle services. This is useful for automatically install 3 rd party extensions (additional installers, extensions, guice modules). 3 rd party jar must contain services file: META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle File contain one or more (per line) GuiceyBundle implementations. E.g. com.foo.Bundle1 com.foo.Bundle2 Then Bundle1, Bundle2 would be loaded automatically on startup. Customizing lookup mechanism \u00b6 Custom bundle lookup must implement GuiceyBundleLookup interface: public class CustomBundleLookup implements GuiceyBundleLookup { @Override public List < GuiceyBundle > lookup () { List < GuiceyBundle > bundles = Lists . newArrayList (); ... return bundles ; } } Custom lookup implementation may be registered through: bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundleLookup ( new CustomBundleLookup ()) . build () But it's better to register it through default implementation DefaultBundleLookup , which performs composition of multiple lookup implementations and logs resolved bundles to console. bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundleLookup ( new DefaultBundleLookup (). addLookup ( new CustomBundleLookup ())) . build () To override list of default lookups: bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundleLookup ( new DefaultBundleLookup ( new ServiceLoaderBundleLookup (), new CustomBundleLookup ())) . build () Here two lookup mechanisms registered (property lookup is not registered and will not be implicitly added). Options \u00b6 Options could be used in guicey bundes: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { if ( bootstrap . option ( GuiceyOptions . UseHkBridge )) { // show warning that bridge required } } } Or it could be some custom options usage. Apply modifications \u00b6 Bundles could not only register new items, but also disable other. bootstrap . disableInstallers (..) . disableExtensions (..) . disableModules () Note Bundles can't disable other bundles (because target bundle could be already processed at this point). This could be used to register different versions instead of disabled items. Also, bundle could directly override guice bindings with: bootstrap . modulesOverride ( new OverridingModule ()) Configuration access \u00b6 Unique feature config \u00b6 When working with re-usable bundles, it could be handy to rely on unique configuration object: public class XFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { XFeatureConfig conf = bootstrap . configuration ( XFeatureConfig . class ); ... } } Note that this bundle doesn't known exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt ) it will be different unique config. Access by path \u00b6 When you are not sure that configuration is unique, you can rely on exact path definition: public class XFeatureBundle implements GuiceyBundle { private String path ; public XFeatureBundle ( String path ) { this . path = path ; } @Override public void initialize ( GuiceyBootstrap bootstrap ) { XFeatureConfig conf = bootstrap . configuration ( path ); ... } } Path is declared by bundle user, who knows required configuration location: GuiceBundle . builder () . bundles ( new XFeatureBundle ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... } Warning Remember that you can't register 2 bundles with the same class Multiple configs \u00b6 In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { List < XFeatureConfig > confs = configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } It wil return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses too. So if there are XFeatureConfigExt declared somewhere it will also be returned. Custom configuration analysis \u00b6 In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = bootstrap . configurationTree () . findAllRootPathsFrom ( MyConfig . class ); // search for not null values of marked (annotated) classes List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, bundle search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ). See introspected configuration structure description","title":"Bundles (Guicey)"},{"location":"guide/bundles/#guicey-bundles","text":"By analogy with dropwizard bundles, guicey has it's own GuiceyBundle . These bundles contains almost the same options as main GuiceBundle builder. The main purpose is to group installers, extensions and guice modules related to specific feature. Guicey bundles are initialized during dropwizard run phase. All guice modules registered in bundles will also be checked for required dropwizard objects autowiring . For example, custom integration with some scheduler framework will require installers to register tasks and guice module to configure framework. GuiceyBundle will allow reduce integration to just one bundle installation. public class XLibIntegrationBundle implements GuiceyBundle { @Override public void initialize ( final GuiceyBootstrap bootstrap ) { bootstrap . installers ( XLibFeature1Installer . class , XLibFeature2Installer . class , ) . modules ( new XLibGuiceModule ()); } } bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundles ( new XLibIntegrationBundle ()) . enableAutoConfig ( \"package.to.scan\" ) . build () ); Tip GuiceyBootstrap object used not only for registration, but also provides access to Bootstrap , Configuration , ConfigurationTree , Environment and Options objects. Bundles may be used to group application features: e.g. ResourcesBundle, TasksBundle (for example, when auto-scan not enabled to decompose configuration). Bundles are transitive - bundle can install other bundles. Duplicate bundles are detected using bundle type, so infinite configuration loops or duplicate configurations are not possible. Warning Be careful if bundle is parameterizable (requires constructor arguments). If two such bundles will be registered, only first registration will be actually used and other instance ignored. Note that application configurations (using main GuiceBundle methods) performed before bundles processing and so bundle instance with correct parameters could be registered there. Transitive bundles (or simply a lot of bundles) may cause confusion. Use diagnostic info to see how guicey was actually configured.","title":"Guicey bundles"},{"location":"guide/bundles/#predefined-bundles","text":"Guicey ships with few predefined bundles.","title":"Predefined bundles"},{"location":"guide/bundles/#core-installers-bundle","text":"Default installers are grouped into CoreInstallersBundle . This bundle is always installed implicitly (so you always have default installers). It may be disabled using .noDefaultInstallers() .","title":"Core installers bundle"},{"location":"guide/bundles/#web-installers-bundle","text":"WebInstallersBundle provides installers for servlets, filters and listeners installation using servlet api annotations ( @WebServlet , @WebFilter , @WebListener ). Warning Bundle is not installed by default to avoid confusion. May be enabled using .useWebInstallers() . Tip If web installers used, then you may not need guice ServletModule support. To remove GuiceFilter registrations and ServletModule support use .noGuiceFilter() .","title":"Web installers bundle"},{"location":"guide/bundles/#hk2-debug-bundle","text":"HK2DebugBundle is special debug bundle to check that beans properly instantiated by guice or HK2 (and no beans are instantiated by both). Only beans installed by installers implementing JerseyInstaller ( ResourceInstaller , JerseyProviderInstaller ). All beans must be created by guice and only beans annotated with @HK2Managed must be instantiated by HK2. Bundle may be used in tests. For example using guicey.bundles property (see bundles lookup below). May be enabled by .strictScopeControl() . Note Works in both guice-first or HK2-first modes.","title":"HK2 debug bundle"},{"location":"guide/bundles/#diagnostic-bundle","text":"Bundle renders collected guicey diagnostic information . Output is highly configurable, use: DiagnosticBundle.builder() to configure reporting (if required). Bundle may be registered with bundle lookup mechanism . For example: PropertyBundleLookup . enableBundles ( DiagnosticBundle . class ); May be enabled by .printDiagnosticInfo() shortcut method. Special shortcut .printAvailableInstallers() register diagnostic bundle configured for showing only installers . Useful when you looking for available features. Only one bundle instance accepted, both options can't be enabled at the same time.","title":"Diagnostic bundle"},{"location":"guide/bundles/#dropwizard-bundles-unification","text":"Guicey bundles and dropwizard bundles may be unified providing single (standard) extension point for both dropwizard and guicey features: public class MixedBundle implements ConfiguredBundle , GuiceyBundle { public void initialize ( Bootstrap <?> bootstrap ) { // do something in init phase } public void initialize ( GuiceyBootstrap bootstrap ) { // apply guicey configurations } public void run ( T configuration , Environment environment ) throws Exception { // not needed because everything could be done in guicey bundle's method } } Feature is disabled by default, to enable it use .configureFromDropwizardBundles() method. bootstrap . addBundle ( new MixedBundle ()); bootstrap . addBundle ( GuiceBundle . builder () . configureFromDropwizardBundles ( true ) . build () ); When active, all registered dropwizard bundles are checked if they implement GuiceyBundle . Works with both Bundle and ConfiguredBundle dropwizard bundle types. Warning Don't assume if guicey bundle's initialize method will be called before/after dropwizard bundle's run method. Both are possible (it depends if bundle registered before or after GuiceBundle).","title":"Dropwizard bundles unification"},{"location":"guide/bundles/#bundle-lookup","text":"Bundle lookup mechanism used to lookup guicey bundles in various sources. It may be used to activate specific bundles in tests (e.g. HK2DebugBundle) or to install 3 rd party extensions from classpath. Bundle lookup is equivalent to registering bundle directly using builder bundles method. By default, 2 lookup mechanisms active. All found bundles are logged into console. Duplicate bundles are removed (using bundle class to detect duplicate). To disable default lookups use disableBundleLookup : bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . disableBundleLookup () . build ()","title":"Bundle lookup"},{"location":"guide/bundles/#system-property-lookup","text":"System property guicey.bundles could contain comma separated list of guicey bundle classes. These bundles must have no-args constructor. For example, activate HK2 debug bundle for tests: java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle Alternatively, system property may be set in code: PropertyBundleLookup . enableBundles ( HK2DebugBundle . class )","title":"System property lookup"},{"location":"guide/bundles/#service-loader-lookup","text":"Using default java ServiceLoader mechanism, loads all GuiceyBundle services. This is useful for automatically install 3 rd party extensions (additional installers, extensions, guice modules). 3 rd party jar must contain services file: META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle File contain one or more (per line) GuiceyBundle implementations. E.g. com.foo.Bundle1 com.foo.Bundle2 Then Bundle1, Bundle2 would be loaded automatically on startup.","title":"Service loader lookup"},{"location":"guide/bundles/#customizing-lookup-mechanism","text":"Custom bundle lookup must implement GuiceyBundleLookup interface: public class CustomBundleLookup implements GuiceyBundleLookup { @Override public List < GuiceyBundle > lookup () { List < GuiceyBundle > bundles = Lists . newArrayList (); ... return bundles ; } } Custom lookup implementation may be registered through: bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundleLookup ( new CustomBundleLookup ()) . build () But it's better to register it through default implementation DefaultBundleLookup , which performs composition of multiple lookup implementations and logs resolved bundles to console. bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundleLookup ( new DefaultBundleLookup (). addLookup ( new CustomBundleLookup ())) . build () To override list of default lookups: bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () . bundleLookup ( new DefaultBundleLookup ( new ServiceLoaderBundleLookup (), new CustomBundleLookup ())) . build () Here two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).","title":"Customizing lookup mechanism"},{"location":"guide/bundles/#options","text":"Options could be used in guicey bundes: public class MyBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { if ( bootstrap . option ( GuiceyOptions . UseHkBridge )) { // show warning that bridge required } } } Or it could be some custom options usage.","title":"Options"},{"location":"guide/bundles/#apply-modifications","text":"Bundles could not only register new items, but also disable other. bootstrap . disableInstallers (..) . disableExtensions (..) . disableModules () Note Bundles can't disable other bundles (because target bundle could be already processed at this point). This could be used to register different versions instead of disabled items. Also, bundle could directly override guice bindings with: bootstrap . modulesOverride ( new OverridingModule ())","title":"Apply modifications"},{"location":"guide/bundles/#configuration-access","text":"","title":"Configuration access"},{"location":"guide/bundles/#unique-feature-config","text":"When working with re-usable bundles, it could be handy to rely on unique configuration object: public class XFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { XFeatureConfig conf = bootstrap . configuration ( XFeatureConfig . class ); ... } } Note that this bundle doesn't known exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt ) it will be different unique config.","title":"Unique feature config"},{"location":"guide/bundles/#access-by-path","text":"When you are not sure that configuration is unique, you can rely on exact path definition: public class XFeatureBundle implements GuiceyBundle { private String path ; public XFeatureBundle ( String path ) { this . path = path ; } @Override public void initialize ( GuiceyBootstrap bootstrap ) { XFeatureConfig conf = bootstrap . configuration ( path ); ... } } Path is declared by bundle user, who knows required configuration location: GuiceBundle . builder () . bundles ( new XFeatureBundle ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... } Warning Remember that you can't register 2 bundles with the same class","title":"Access by path"},{"location":"guide/bundles/#multiple-configs","text":"In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { List < XFeatureConfig > confs = configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } It wil return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses too. So if there are XFeatureConfigExt declared somewhere it will also be returned.","title":"Multiple configs"},{"location":"guide/bundles/#custom-configuration-analysis","text":"In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureBundle implements GuiceyBundle { @Override public void initialize ( GuiceyBootstrap bootstrap ) { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = bootstrap . configurationTree () . findAllRootPathsFrom ( MyConfig . class ); // search for not null values of marked (annotated) classes List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, bundle search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ). See introspected configuration structure description","title":"Custom configuration analysis"},{"location":"guide/commands/","text":"Dropwizard commands support \u00b6 Guice injections \u00b6 Guicey calls injector.injectMembers(command) for all registered EnvironmentCommand 's, so you can inject guice beans directly: public class MyCommand extends EnvironmentCommand < MyConfiguration > { @Inject private MyService myservice ; public MyCommand ( Application application ) { super ( application , \"mycli\" , \"my super useful cli\" ); } @Override protected void run ( Environment environment , Namespace namespace , MyConfiguration configuration ) throws Exception { myservice . doSomething (); } } Note It doesn't matter if command was registered manually, by some bundle or with commands search (see below). Warning You can use guice injections only in EnvironmentCommand 's because only these commands start bundles (and so launch guice context creation). Automatic installation \u00b6 Automatic scan for commands is disabled by default. It could be enabled by: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) . searchCommands () When enabled, all classes extending Command are instantiated using default constructor and registered in dropwizard bootstrap object. Simple commands \u00b6 For example, if command below would be inside scanned package, then guicey will automatically register it. public class MyCommand extends Command { public MyCommand () { super ( \"hello\" , \"Prints a greeting\" ); } @Override public void run ( Bootstrap <?> bootstrap , Namespace namespace ) throws Exception { System . out . println ( \"Hello world\" ); } } Environment commands \u00b6 Important EnvironmentCommand must have constructor with Application argument. public class SyncCommand extends EnvironmentCommand < AppConfiguration > { @Inject private RemoteSynchronizer synchronizer ; @Inject private DbManager manager ; public SyncCommand ( Application < AppConfiguration > application ) { super ( application , \"sync\" , \"Perform remote synchronization\" ); } @Override protected void run ( Environment environment , Namespace namespace , AppConfiguration configuration ) throws Exception { manager . start (); try { synchronizer . synchronize (); } finally { manager . stop (); } } } This example shows workaround for managed initialization in commnads: DbManager is some Managed bean which would run automatically in server mode. But commands never call managed objects, so we have to manually start and stop them.","title":"Commands"},{"location":"guide/commands/#dropwizard-commands-support","text":"","title":"Dropwizard commands support"},{"location":"guide/commands/#guice-injections","text":"Guicey calls injector.injectMembers(command) for all registered EnvironmentCommand 's, so you can inject guice beans directly: public class MyCommand extends EnvironmentCommand < MyConfiguration > { @Inject private MyService myservice ; public MyCommand ( Application application ) { super ( application , \"mycli\" , \"my super useful cli\" ); } @Override protected void run ( Environment environment , Namespace namespace , MyConfiguration configuration ) throws Exception { myservice . doSomething (); } } Note It doesn't matter if command was registered manually, by some bundle or with commands search (see below). Warning You can use guice injections only in EnvironmentCommand 's because only these commands start bundles (and so launch guice context creation).","title":"Guice injections"},{"location":"guide/commands/#automatic-installation","text":"Automatic scan for commands is disabled by default. It could be enabled by: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) . searchCommands () When enabled, all classes extending Command are instantiated using default constructor and registered in dropwizard bootstrap object.","title":"Automatic installation"},{"location":"guide/commands/#simple-commands","text":"For example, if command below would be inside scanned package, then guicey will automatically register it. public class MyCommand extends Command { public MyCommand () { super ( \"hello\" , \"Prints a greeting\" ); } @Override public void run ( Bootstrap <?> bootstrap , Namespace namespace ) throws Exception { System . out . println ( \"Hello world\" ); } }","title":"Simple commands"},{"location":"guide/commands/#environment-commands","text":"Important EnvironmentCommand must have constructor with Application argument. public class SyncCommand extends EnvironmentCommand < AppConfiguration > { @Inject private RemoteSynchronizer synchronizer ; @Inject private DbManager manager ; public SyncCommand ( Application < AppConfiguration > application ) { super ( application , \"sync\" , \"Perform remote synchronization\" ); } @Override protected void run ( Environment environment , Namespace namespace , AppConfiguration configuration ) throws Exception { manager . start (); try { synchronizer . synchronize (); } finally { manager . stop (); } } } This example shows workaround for managed initialization in commnads: DbManager is some Managed bean which would run automatically in server mode. But commands never call managed objects, so we have to manually start and stop them.","title":"Environment commands"},{"location":"guide/configuration/","text":"Configuration \u00b6 Builder GuiceBundle.builder() contains shortcuts for all available features, so you can always find required function by looking at available methods and reading javadoc. Configuration subjects (vocabulary) Installers - used to recognize and install extension (usually encapsulates integration logic: get extension instance from guice injector and register in dropwizard (or jersey, HK2, whatever)) Extensions - actual application parts, written by you (resources, tasks, health checks, servlets etc) Guice modules Guicey bundles - groups installers, extensions, gucie modules and other guicey bundles (represent reusable logic or 3 rd party integrations; very similar to dropwizard bundles) Options - general mechanism for low level configurations (development time triggers) Commands - dropwizard commands (mentioned because of ability for automatic registration) Warning Configured bundles, modules, installers and extensions are checked for duplicates using class type . Duplicate configurations will be simply ignored. For modules and bundles, which configured using instances, duplicates removes means that if two instances of the same type registered, then second instance will be ignored. For example, in case of .bundles(new MyBundle(\"one\"), new MyBundle(\"two)) the second bundle will be ignored becuause bundle with the same type is already registered (no matter that constructor parameters are different - only type matters). Configuration process is recorded and may be observed with by diagnostic info , so there is always a way to understand what and how was configured. Tip You can see used configuration objects by enabling detailed lifecycle logs : bundle . printLifecyclePhasesDetailed () Auto configuration \u00b6 Auto configuration enables classpath scan to search for extensions and custom installers. Without auto scan, all extensions (resource, managed, health check etc.) must be registered manually (manual mode). . enableAutoConfig ( \"com.mycompany.app\" ) or multiple packages . enableAutoConfig ( \"com.mycompany.app.resources\" , \"com.mycompany.app.staff\" ) Commands search \u00b6 In auto configuration mode guicey could also search and install dropwiard commands (register in bootstrap object): . searchCommands () By default commands scan is disabled because it may be confusing. Besides, it's not often needed. Extensions \u00b6 All features installed with guicey installers are called extensions. When auto configuration is enabled, extensions are discovered automatically. Without auto configuration (manual mode) all extensions must be specified manually. . extensions ( MyResource1 . class , MyHealthCheck . class ) Auto configuration may be used together with manual definition (for example, manually registered extension could be unreachable for classpath scan). Each extension could be installed only by one installer: if multiple installers could recognize extension, only one of them will install it (first one according to priority). Tip Any extension could be disabled with .disableExtension(Extension.class) (may be useful to disable not needed extension from 3 rd party bundle) Disable extensions \u00b6 You can disable extensions (even if it's not registered) . disableExtensions ( ExtensionOne . class , ExtensionTwo . class ) Tip This may be used when classpath scanner detected class you don't need to be installed and you can't use @InvisibleForScanner annotation on it. Mostly useful for tests. Installers \u00b6 Guicey come with pre-defined set of installers (for common extensions). But you can write your own installers (or use some 3 rd party ones). Most installers implementations are very simple and easy to understand. Look installer source to better understand how extensions work. In case when default installer does not fit your needs, it's not hard to replace installer with your custom version. . installers ( MyExtensionInstaller . class , ThirdPartyExtensionInstaller . class ) Tip In auto configuration mode, installers are also detected and installed automatically Disable default installers \u00b6 You can disable all default installers: . noDefaultInstallers () But note that in this case you must register at least one installer (it could be one of core installers) because otherwise no extensions could be installed. Web installers \u00b6 Guicey has advanced installers for standard servlet annotations ( @WebServlet , @WebFilter , @WebListener ). They are not enabled by default to avoid confusion: user may not expect guice support for these standard annotations. To enable web installers: . useWebInstallers () Disable installers \u00b6 You can disable installers (even if it's not registered) . disableInstallers ( ManagedInstaller . class , ResourceInstaller . class ) Mostly useful for tests. Availbale installers \u00b6 Special debug option could print to console all available installers (with registration sources): . printAvailableInstallers () Use to quickly understand available features. Guice modules \u00b6 You can register one or more guice modules (including guice ServletModule s): . modules ( new MyModule1 (), new MyModule2 ()) If you have many modules try to group their installation inside your custom module in order to keep guice staff together. In some cases, it could be desired to use different instances of the same module: . modules ( new ParametrizableModule ( \"mod1\" ), new ParametrizableModule ( \"mod2\" )) This will not work (second instance will be dropped). In such cases do registrations in custom guice module: install ( new ParametrizableModule ( \"mod1\" )); install ( new ParametrizableModule ( \"mod2\" )); Disable guice modules \u00b6 You can disable guice modules (even if it's not registered) . disableInstallers ( ModleOne . class , ModuleTwo . class ) Important This will affect only modules directly registered in main bundle or guicey bundle (modules installed inside guice module are not affected). This is mostly useful for tests, but could be used to prevent some additional module installation by 3 rd party bundle (or may be used to override such module). Tip Note that you can also override some bindings (see below) instead of entire module override Override guice bindings \u00b6 Guice allows you to override any binding with Modules.override() . With it you can override any service in context. Guicey provides direct shortcut for using this feature. Mostly, this is handful for tests, but could be used to override some service, registered by 3 rd party module (probably registered by some bundle). Suppose we have 3 rd party service with a bug, registered by 3 rd party module: public class XModule extends AbstractModule { protected void configure () { bind ( XService . class ). asEagerSingleton (); ... } } We can override it with fixed version: public class FixXServiceModule extends AbstractModule { protected void configure () { // module with only one binding overriding original definition bind ( XService . class ). to ( FixedXService . class ); } } public class FixedXService extends XService { ... } bootstrap . addBundle ( GuiceBundle . builder () . modules ( new XModule ()) . modulesOverride ( new FixXServiceModule ()) . build ()) Now all guice injector will use your service ( FixedXService ) instead of XService . Guicey bundles \u00b6 In essence, guicey bundles are the same as dropwizard bundles: used to install re-usable logic or 3 rd party library integration. . bundles ( new MyBundle (), new ThirdPartyBundle ()); Dropwizard bundles unification \u00b6 Guice bundles must implement interface ( GuiceyBundle ). Dropwizard bundle could implement it too. This may be useful for universal bundles when you can register something in dropwizard bootstrap (or simply directly) and some features in guicey way (extensions). When: . configureFromDropwizardBundles () guicey checks registered dropwizard bundles if they are also GuiceyBundle and register them as guicey bundles. Bundle lookup \u00b6 Bundle lookup mechanism provides support for indirect guicey bundles installation. Default lookup mechanism allows using service loader (plug-n-play bundles) or system property (test/diagnostic bundles). Custom implementation could be specified: . bundleLookup ( new MyBundleLookupImpl ()) Shortcut to disable default bundle lookup: . disableBundleLookup () Disable bundles \u00b6 Guicey bundles could be disabled only in root bundle. Bundles can't disable other bundles. . disableBundles ( MyBundle . class ) This is mostly useful for tests, but could also be used to disable some not required transitive bundle, installed by 3 rd party bundle. Options \u00b6 Options are used for development time configurations (test specific triggers or low level configurations). Guicey option enums: GuiceyOptions and InstallersOptions . option ( GuiceyOptions . InjectorStage , Stage . DEVELOPMENT ) Tip Options look better with static import: . option ( InjectorStage , DEVELOPMENT ) Options mapper could be used to map option value from system properties, environment variables or simple strings (basic type conversions supported): . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . env ( \"STAGE\" , GuiceyOptions . InjectorStage ) . string ( \"property value\" , Myoptions . SomeOtherOption ) . map ()) Disable by predicate \u00b6 There is also a generic disable method using predicate. With it you can disable items (bundles, modules, installers, extensions) by package or by installation bundle or some other custom condition (e.g. introduce your disabling annotation and handle it with predicate). Supposed to be used in integration tests, but could be used directly too in specific cases. import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( inPackage ( \"com.foo.feature\" , \"com.foo.feature2\" )); Disable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module. If you use package by feature approach then you can easily switch off entire features in tests. import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( installer () . and ( registeredBy ( Application . class )) . and ( type ( SomeInstallerType . class ). negate ()); Disable all installers, directly registered in main bundle except SomeInstallerType import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( type ( MyExtension . class , MyInstaller . class , MyBundle . class , MyModule . class )); Simply disable items by type. The condition is java Predicate . Use Predicate#and(Predicate) , Predicate#or(Predicate) and Predicate#negate() to compose complex conditions from simple ones. Most common predicates could be build with ru.vyarus.dropwizard.guice.module.context.Disables utility (examples above). Guice \u00b6 Stage \u00b6 Guice stage cold be provided in: . build ( Stage . DEVELOPMENT ) By default, PRODUCTION stage used. Injector \u00b6 Custom guice injector factory may be registered to customize injector creation. For example, custom factory is required for governator integration: . injectorFactory ( new GovernatorInjectorFactory ()) Also, custom factory may be used to override already overridden guice bindings in tests ServletModule \u00b6 By default, guicey registers GuiceFilter for both main and admin contexts to provide request scopes for both contexts and ability to use guice ServletModule s on main context. GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types: . option ( GuiceFilterRegistration , EnumSet . of ( REQUEST , FORWARD )) If you don't need servlet module support (and request scopes), guice filter installation could be disabled: . noGuiceFilter () Servlet modules will be rejected in this case. Intended to be used when web installers enabled. Note HttpServletRequest and HttpServletResponse objects will be available for injection only in scope of jersey resources call. Configuration binding by interface \u00b6 Deprecated Option remain for compatibility and will be eventually removed. You can always bind configuration by implemented interface using qualifier : @Inject @Config HasRequiredConfig config ; Also, unique configuration sub objects are also available for injection (much better option rather then marker interface): @Inject @Config RequiredConfig config ; It may be useful to bind configuration instance to interface. Suppose some 3 rd party requires your configuration to implement interface: public class MyConfiguration extends Configuration implements HasRequiredConfig {...} If binding by interface is enabled: . bindConfigurationInterfaces () Then configuration could be injected by interface: @Inject HasRequiredConfig conf ; HK2 bridge \u00b6 If you need HK2 services be able to use guice beans, then HK2 bridge must be activated. This may be useful when some services are managed by HK2 (e.g. with @HK2Managed ). To activate bridge: Add dependency: org.glassfish.hk2:guice-bridge:2.5.0-b32 (version must match HK2 version, used by dropwizard) Enable option: . option ( GuiceyOptions . UseHkBridge , true ) After that, HK2 beans could inject guice beans: @HK2Managed public class HkService { @Inject private GuiceService service ; } Use HK2 for jersey extensions \u00b6 By default, guice is used to construct all extensions, including jersey related (resources, providers) which are registered in HK2 context as instances. If you want to use HK2 for jersey extensions management then use: . useHK2ForJerseyExtensions () (It is the same effect as if you will annotate all jersey extensions with @HK2Managed ) After enabling, all jersey extensions will be created by HK2. Option requires HK2-guice bridge (error will be thrown if bridge is not available in classpath) to use guice services inside HK2 managed beans. Warning Guice AOP will work only for instances created by guice, so after enabling this option you will not be able to use aop on jersey extensions. By analogy with @HK2Managed , you can use @GuiceManaged to mark exceptional extensions, which must be still managed by guice. Lifecycle events \u00b6 Guicey broadcast events on all important configuration phases. These events contain references to all available environment objects and current context configuration. For example, after event with all resolved extension or event with all processed bundles. Events are used to print lifecycle phases report (see below), but you may use it to modify installers, bundles, extensions (post process instances, but not affect quantity). Events are registered with: . listen ( new MyEventListener ()) Read more in events documentation . Diagnostic \u00b6 Startup errors could be debugged with lifecycle logs: . printLifecyclePhasesDetailed () Tip Especially helpful when classpath scanner accept classes you don't need because it will prints all resolved extension before injector creation. Tip Report shows disabled items. Use diagnostic logs to find the disabler. Note .printLifecyclePhases() could be used to just indicate phases in logs without additional details (useful when need to understand initialization order) If you have problems with configuration bindings (or just need to see available bindings) use: . printConfigurationBindings () Note Bindings report is printed before injector creation (in case if startup fails due to missed binding) Enable configuration diagnostic console logs to diagnose configuration problems: . printDiagnosticInfo () In case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation, you can enable strict control which will throw exception in case of wrong owner: . strictScopeControl () Note When you have duplicate initialization (most likely for jersey related extensions) first check that you are not register extension manually! Using constructor injection helps preventing such errors (manual places will immediately reveal). Guicey configuration hooks \u00b6 There is an external configuration mechanism. It could be used to modify application configuration externally without application modification: public interface GuiceyConfigurationHook { void configure ( GuiceBundle . Builder builder ); } Hook implementation will receive the same builder instance as used in GuiceBundle and so it is able to change anything (for example, GuiceyBundle abilities are limited). If hook is a class then it could be registered directly: new MyHook (). register () Otherwise lambda may be used: ConfigurationHooksSupport . register ( builder -> { // do modifications }) All hooks are executed just before guice bundle builder finalization (when you call last .build() method). Hooks registered after this moment will simply be never used. Note This functionality is intended to be used for integration tests and there is a special test support for it. In hook you can do all the same as in main application configuration. In context of tests, the most important is: Change options Disable any bundle, installer, extension, module Register disable predicate (to disable features by package, registration source etc.) Override guice bindings Register additional bundles, extensions, modules (usually test-specific, for example guicey tests register additional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations))","title":"Configuration"},{"location":"guide/configuration/#configuration","text":"Builder GuiceBundle.builder() contains shortcuts for all available features, so you can always find required function by looking at available methods and reading javadoc. Configuration subjects (vocabulary) Installers - used to recognize and install extension (usually encapsulates integration logic: get extension instance from guice injector and register in dropwizard (or jersey, HK2, whatever)) Extensions - actual application parts, written by you (resources, tasks, health checks, servlets etc) Guice modules Guicey bundles - groups installers, extensions, gucie modules and other guicey bundles (represent reusable logic or 3 rd party integrations; very similar to dropwizard bundles) Options - general mechanism for low level configurations (development time triggers) Commands - dropwizard commands (mentioned because of ability for automatic registration) Warning Configured bundles, modules, installers and extensions are checked for duplicates using class type . Duplicate configurations will be simply ignored. For modules and bundles, which configured using instances, duplicates removes means that if two instances of the same type registered, then second instance will be ignored. For example, in case of .bundles(new MyBundle(\"one\"), new MyBundle(\"two)) the second bundle will be ignored becuause bundle with the same type is already registered (no matter that constructor parameters are different - only type matters). Configuration process is recorded and may be observed with by diagnostic info , so there is always a way to understand what and how was configured. Tip You can see used configuration objects by enabling detailed lifecycle logs : bundle . printLifecyclePhasesDetailed ()","title":"Configuration"},{"location":"guide/configuration/#auto-configuration","text":"Auto configuration enables classpath scan to search for extensions and custom installers. Without auto scan, all extensions (resource, managed, health check etc.) must be registered manually (manual mode). . enableAutoConfig ( \"com.mycompany.app\" ) or multiple packages . enableAutoConfig ( \"com.mycompany.app.resources\" , \"com.mycompany.app.staff\" )","title":"Auto configuration"},{"location":"guide/configuration/#commands-search","text":"In auto configuration mode guicey could also search and install dropwiard commands (register in bootstrap object): . searchCommands () By default commands scan is disabled because it may be confusing. Besides, it's not often needed.","title":"Commands search"},{"location":"guide/configuration/#extensions","text":"All features installed with guicey installers are called extensions. When auto configuration is enabled, extensions are discovered automatically. Without auto configuration (manual mode) all extensions must be specified manually. . extensions ( MyResource1 . class , MyHealthCheck . class ) Auto configuration may be used together with manual definition (for example, manually registered extension could be unreachable for classpath scan). Each extension could be installed only by one installer: if multiple installers could recognize extension, only one of them will install it (first one according to priority). Tip Any extension could be disabled with .disableExtension(Extension.class) (may be useful to disable not needed extension from 3 rd party bundle)","title":"Extensions"},{"location":"guide/configuration/#disable-extensions","text":"You can disable extensions (even if it's not registered) . disableExtensions ( ExtensionOne . class , ExtensionTwo . class ) Tip This may be used when classpath scanner detected class you don't need to be installed and you can't use @InvisibleForScanner annotation on it. Mostly useful for tests.","title":"Disable extensions"},{"location":"guide/configuration/#installers","text":"Guicey come with pre-defined set of installers (for common extensions). But you can write your own installers (or use some 3 rd party ones). Most installers implementations are very simple and easy to understand. Look installer source to better understand how extensions work. In case when default installer does not fit your needs, it's not hard to replace installer with your custom version. . installers ( MyExtensionInstaller . class , ThirdPartyExtensionInstaller . class ) Tip In auto configuration mode, installers are also detected and installed automatically","title":"Installers"},{"location":"guide/configuration/#disable-default-installers","text":"You can disable all default installers: . noDefaultInstallers () But note that in this case you must register at least one installer (it could be one of core installers) because otherwise no extensions could be installed.","title":"Disable default installers"},{"location":"guide/configuration/#web-installers","text":"Guicey has advanced installers for standard servlet annotations ( @WebServlet , @WebFilter , @WebListener ). They are not enabled by default to avoid confusion: user may not expect guice support for these standard annotations. To enable web installers: . useWebInstallers ()","title":"Web installers"},{"location":"guide/configuration/#disable-installers","text":"You can disable installers (even if it's not registered) . disableInstallers ( ManagedInstaller . class , ResourceInstaller . class ) Mostly useful for tests.","title":"Disable installers"},{"location":"guide/configuration/#availbale-installers","text":"Special debug option could print to console all available installers (with registration sources): . printAvailableInstallers () Use to quickly understand available features.","title":"Availbale installers"},{"location":"guide/configuration/#guice-modules","text":"You can register one or more guice modules (including guice ServletModule s): . modules ( new MyModule1 (), new MyModule2 ()) If you have many modules try to group their installation inside your custom module in order to keep guice staff together. In some cases, it could be desired to use different instances of the same module: . modules ( new ParametrizableModule ( \"mod1\" ), new ParametrizableModule ( \"mod2\" )) This will not work (second instance will be dropped). In such cases do registrations in custom guice module: install ( new ParametrizableModule ( \"mod1\" )); install ( new ParametrizableModule ( \"mod2\" ));","title":"Guice modules"},{"location":"guide/configuration/#disable-guice-modules","text":"You can disable guice modules (even if it's not registered) . disableInstallers ( ModleOne . class , ModuleTwo . class ) Important This will affect only modules directly registered in main bundle or guicey bundle (modules installed inside guice module are not affected). This is mostly useful for tests, but could be used to prevent some additional module installation by 3 rd party bundle (or may be used to override such module). Tip Note that you can also override some bindings (see below) instead of entire module override","title":"Disable guice modules"},{"location":"guide/configuration/#override-guice-bindings","text":"Guice allows you to override any binding with Modules.override() . With it you can override any service in context. Guicey provides direct shortcut for using this feature. Mostly, this is handful for tests, but could be used to override some service, registered by 3 rd party module (probably registered by some bundle). Suppose we have 3 rd party service with a bug, registered by 3 rd party module: public class XModule extends AbstractModule { protected void configure () { bind ( XService . class ). asEagerSingleton (); ... } } We can override it with fixed version: public class FixXServiceModule extends AbstractModule { protected void configure () { // module with only one binding overriding original definition bind ( XService . class ). to ( FixedXService . class ); } } public class FixedXService extends XService { ... } bootstrap . addBundle ( GuiceBundle . builder () . modules ( new XModule ()) . modulesOverride ( new FixXServiceModule ()) . build ()) Now all guice injector will use your service ( FixedXService ) instead of XService .","title":"Override guice bindings"},{"location":"guide/configuration/#guicey-bundles","text":"In essence, guicey bundles are the same as dropwizard bundles: used to install re-usable logic or 3 rd party library integration. . bundles ( new MyBundle (), new ThirdPartyBundle ());","title":"Guicey bundles"},{"location":"guide/configuration/#dropwizard-bundles-unification","text":"Guice bundles must implement interface ( GuiceyBundle ). Dropwizard bundle could implement it too. This may be useful for universal bundles when you can register something in dropwizard bootstrap (or simply directly) and some features in guicey way (extensions). When: . configureFromDropwizardBundles () guicey checks registered dropwizard bundles if they are also GuiceyBundle and register them as guicey bundles.","title":"Dropwizard bundles unification"},{"location":"guide/configuration/#bundle-lookup","text":"Bundle lookup mechanism provides support for indirect guicey bundles installation. Default lookup mechanism allows using service loader (plug-n-play bundles) or system property (test/diagnostic bundles). Custom implementation could be specified: . bundleLookup ( new MyBundleLookupImpl ()) Shortcut to disable default bundle lookup: . disableBundleLookup ()","title":"Bundle lookup"},{"location":"guide/configuration/#disable-bundles","text":"Guicey bundles could be disabled only in root bundle. Bundles can't disable other bundles. . disableBundles ( MyBundle . class ) This is mostly useful for tests, but could also be used to disable some not required transitive bundle, installed by 3 rd party bundle.","title":"Disable bundles"},{"location":"guide/configuration/#options","text":"Options are used for development time configurations (test specific triggers or low level configurations). Guicey option enums: GuiceyOptions and InstallersOptions . option ( GuiceyOptions . InjectorStage , Stage . DEVELOPMENT ) Tip Options look better with static import: . option ( InjectorStage , DEVELOPMENT ) Options mapper could be used to map option value from system properties, environment variables or simple strings (basic type conversions supported): . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . env ( \"STAGE\" , GuiceyOptions . InjectorStage ) . string ( \"property value\" , Myoptions . SomeOtherOption ) . map ())","title":"Options"},{"location":"guide/configuration/#disable-by-predicate","text":"There is also a generic disable method using predicate. With it you can disable items (bundles, modules, installers, extensions) by package or by installation bundle or some other custom condition (e.g. introduce your disabling annotation and handle it with predicate). Supposed to be used in integration tests, but could be used directly too in specific cases. import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( inPackage ( \"com.foo.feature\" , \"com.foo.feature2\" )); Disable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module. If you use package by feature approach then you can easily switch off entire features in tests. import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( installer () . and ( registeredBy ( Application . class )) . and ( type ( SomeInstallerType . class ). negate ()); Disable all installers, directly registered in main bundle except SomeInstallerType import static ru.vyarus.dropwizard.guice.module.context.Disables.* . disable ( type ( MyExtension . class , MyInstaller . class , MyBundle . class , MyModule . class )); Simply disable items by type. The condition is java Predicate . Use Predicate#and(Predicate) , Predicate#or(Predicate) and Predicate#negate() to compose complex conditions from simple ones. Most common predicates could be build with ru.vyarus.dropwizard.guice.module.context.Disables utility (examples above).","title":"Disable by predicate"},{"location":"guide/configuration/#guice","text":"","title":"Guice"},{"location":"guide/configuration/#stage","text":"Guice stage cold be provided in: . build ( Stage . DEVELOPMENT ) By default, PRODUCTION stage used.","title":"Stage"},{"location":"guide/configuration/#injector","text":"Custom guice injector factory may be registered to customize injector creation. For example, custom factory is required for governator integration: . injectorFactory ( new GovernatorInjectorFactory ()) Also, custom factory may be used to override already overridden guice bindings in tests","title":"Injector"},{"location":"guide/configuration/#servletmodule","text":"By default, guicey registers GuiceFilter for both main and admin contexts to provide request scopes for both contexts and ability to use guice ServletModule s on main context. GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types: . option ( GuiceFilterRegistration , EnumSet . of ( REQUEST , FORWARD )) If you don't need servlet module support (and request scopes), guice filter installation could be disabled: . noGuiceFilter () Servlet modules will be rejected in this case. Intended to be used when web installers enabled. Note HttpServletRequest and HttpServletResponse objects will be available for injection only in scope of jersey resources call.","title":"ServletModule"},{"location":"guide/configuration/#configuration-binding-by-interface","text":"Deprecated Option remain for compatibility and will be eventually removed. You can always bind configuration by implemented interface using qualifier : @Inject @Config HasRequiredConfig config ; Also, unique configuration sub objects are also available for injection (much better option rather then marker interface): @Inject @Config RequiredConfig config ; It may be useful to bind configuration instance to interface. Suppose some 3 rd party requires your configuration to implement interface: public class MyConfiguration extends Configuration implements HasRequiredConfig {...} If binding by interface is enabled: . bindConfigurationInterfaces () Then configuration could be injected by interface: @Inject HasRequiredConfig conf ;","title":"Configuration binding by interface"},{"location":"guide/configuration/#hk2-bridge","text":"If you need HK2 services be able to use guice beans, then HK2 bridge must be activated. This may be useful when some services are managed by HK2 (e.g. with @HK2Managed ). To activate bridge: Add dependency: org.glassfish.hk2:guice-bridge:2.5.0-b32 (version must match HK2 version, used by dropwizard) Enable option: . option ( GuiceyOptions . UseHkBridge , true ) After that, HK2 beans could inject guice beans: @HK2Managed public class HkService { @Inject private GuiceService service ; }","title":"HK2 bridge"},{"location":"guide/configuration/#use-hk2-for-jersey-extensions","text":"By default, guice is used to construct all extensions, including jersey related (resources, providers) which are registered in HK2 context as instances. If you want to use HK2 for jersey extensions management then use: . useHK2ForJerseyExtensions () (It is the same effect as if you will annotate all jersey extensions with @HK2Managed ) After enabling, all jersey extensions will be created by HK2. Option requires HK2-guice bridge (error will be thrown if bridge is not available in classpath) to use guice services inside HK2 managed beans. Warning Guice AOP will work only for instances created by guice, so after enabling this option you will not be able to use aop on jersey extensions. By analogy with @HK2Managed , you can use @GuiceManaged to mark exceptional extensions, which must be still managed by guice.","title":"Use HK2 for jersey extensions"},{"location":"guide/configuration/#lifecycle-events","text":"Guicey broadcast events on all important configuration phases. These events contain references to all available environment objects and current context configuration. For example, after event with all resolved extension or event with all processed bundles. Events are used to print lifecycle phases report (see below), but you may use it to modify installers, bundles, extensions (post process instances, but not affect quantity). Events are registered with: . listen ( new MyEventListener ()) Read more in events documentation .","title":"Lifecycle events"},{"location":"guide/configuration/#diagnostic","text":"Startup errors could be debugged with lifecycle logs: . printLifecyclePhasesDetailed () Tip Especially helpful when classpath scanner accept classes you don't need because it will prints all resolved extension before injector creation. Tip Report shows disabled items. Use diagnostic logs to find the disabler. Note .printLifecyclePhases() could be used to just indicate phases in logs without additional details (useful when need to understand initialization order) If you have problems with configuration bindings (or just need to see available bindings) use: . printConfigurationBindings () Note Bindings report is printed before injector creation (in case if startup fails due to missed binding) Enable configuration diagnostic console logs to diagnose configuration problems: . printDiagnosticInfo () In case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation, you can enable strict control which will throw exception in case of wrong owner: . strictScopeControl () Note When you have duplicate initialization (most likely for jersey related extensions) first check that you are not register extension manually! Using constructor injection helps preventing such errors (manual places will immediately reveal).","title":"Diagnostic"},{"location":"guide/configuration/#guicey-configuration-hooks","text":"There is an external configuration mechanism. It could be used to modify application configuration externally without application modification: public interface GuiceyConfigurationHook { void configure ( GuiceBundle . Builder builder ); } Hook implementation will receive the same builder instance as used in GuiceBundle and so it is able to change anything (for example, GuiceyBundle abilities are limited). If hook is a class then it could be registered directly: new MyHook (). register () Otherwise lambda may be used: ConfigurationHooksSupport . register ( builder -> { // do modifications }) All hooks are executed just before guice bundle builder finalization (when you call last .build() method). Hooks registered after this moment will simply be never used. Note This functionality is intended to be used for integration tests and there is a special test support for it. In hook you can do all the same as in main application configuration. In context of tests, the most important is: Change options Disable any bundle, installer, extension, module Register disable predicate (to disable features by package, registration source etc.) Override guice bindings Register additional bundles, extensions, modules (usually test-specific, for example guicey tests register additional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations))","title":"Guicey configuration hooks"},{"location":"guide/dg-migration/","text":"Migration from dropwizard-guice \u00b6 If you are not migrating from dropwizard-guice then skip straight to getting started Differences \u00b6 The libraries are different in core guice integration aspects. Dropwizard-guice \u00b6 Note I may not be exactly correct because it's been a long time since I look how all this works. Please correct me if I'm wrong. Dropwizard-guice rely on jersey2-guice . Injector is created on initialization dropwizard phase. Pros: Classpath scan for automatic registrations Resources could be registered directly from gucie bindings Resources and jersey extensions registration is the same as in core dropwizard ( env.jersey().register() ) Guice bundles remain the main extension point and guice bindings might be used inside them. Cons: jersey2-guice hacks jersey locator lookup process which could potentially break on future versions Guice child injector created for each request Not declared services are managed by HK2 and you must be careful if you use guice AOP (as it works ony on beans, managed by guice) Environment and Configuration objects may be used only as Provider in eager singletons (as injector created in initialization phase when these objects are not available) Admin context not covered by GuiceFilter (no request scope injections under admin context calls). Overall, integration feels transparent and super easy to learn (great!), but with a runtime price and caution in service definitions. Guicey \u00b6 Guicey prefer guice-first approach when everything is created by guice and registered in jersey as instance (so HK2 does not manage services, resources etc.). In contrast to dropwizard-guice, guicey brings a lot of new concepts to better integrate guice. This was necessary due to moving injector creation into dropwizard run phase (which is conceptually more correct). Guicey abstracts user of knowing registration details and use Installer - Extension concept: installers did all required registrations automatically and hide boilerplate of managing extension instances with guice. In pure dropwizard you need to: environment.jersey().register(MyResource.class) whereas in guicey you just need to declare extension class: bundle.extensions(MyResource.class) and everything else would be automatic. The same for all other extensions (tasks, health checks, jersey providers etc.): only extenion class is required for registration. Pros: Classpath scan for automatic registrations You can be sure that guice manage everything (no problems with AOP) Simple extensions: only extension class required (and no need to know how to install it) Wider range of supported extensions and ability to add more integrations (custom installers support) Configuration bindings (by yaml path and internal configuration object) GuiceFilter works on both main and admin contexts Integration tests support Cons: Resources must use Provider for all request-scoped injections Special bundles ( GuiceyBundle ) should be used instead of dropwizard bundles ( Bundle ) in order to use guice-related features (but, as dropwizard-guice could discover dwopwizard bundles, guicey could discover it's bundles too). Extra diagnostic tools usage required for debug to understand internal state (more a pro, but additional thing to know, which is a con). Overall, guicey has much more features, cleaner guice integration and very developer friendly (customizable and with extra tooling), but with a coast of learning curve (additional concepts to know and use above dropwizard). Matrix \u00b6 Only dropwizard-guice features present for comparison feature dropwizard-guice guicey Auto scan + + Auto scan load class to inspect - + Auto scan recognize Bundle, ConfiguredBundle, HealthCheck, Task, @Provider, resource (@Path), ParamConverterProvider all the same (and more) except dropwizard bundles Resources (rest) recognition directly from guice bindings + - Resources (rest) default scope \"request\" singleton Dropwizard bundle lookup + - (but has custom bundles lookup) Injections in dropwizard Bundle + - Injector creation customization + + Injector creation (dropwizard) phase initialization run Access Bootstrap, Environment, Configuration in guice modules - + GuiceFilter contexts main main, admin Migration \u00b6 Bundle \u00b6 Bundle registration is almost the same, just more methods available: bootstrap . addBundle ( GuiceBundle . builder () . modules ( new HelloWorldModule ()) // instead of addModule . enableAutoConfig ( getClass (). getPackage (). getName ()) // .setConfigClass(HelloWorldConfiguration.class) // not needed . build ()); Auto scan \u00b6 Note In guicey, auto scan load all classes in providied package. The logic is - application classes would be loaded in any case (in dropwizard-guice, classes are inspected by reading structure, without loading). Auto scan will find and install extensions, with few exceptions (below) Health checks \u00b6 Use NamedHealthCheck instead of InjectableHealthCheck as check class. Bundles \u00b6 Guicey will not find dropwizard bundles: all required bundles must be directly registered in bootstrap. Important Guice injections will not work inside dropwizard bundles But note, that bundles, used for features integrations may not be required as guicey perform automatic installation (removes redundant code). For reusable bundles, consider using GuiceyBundle instead. Also, dropwzard bundles, registered in bootsrap could be recognized as guicey bundles (to provide extra guicey features). Resources (rest) \u00b6 First of all, note that resource bound only in guice module will not be discovered (no installation from guice declaration like it was in jersey1 guice integration). Use either classpath scan to install resources or specify them directly into bundle: bundle.extensions(Resource1.class, Resoutrce2.class) . You can still delegate jersey extensions (resources, providers) management to HK2 , but they will lack guice aop and require extra dependency - HK2-guice-bridge (official HK guice bridge) Important Resources are singletons by default and so they will initialize with guice context ( may be disabled ). You may need to wrap some injections with Provider . Alternatively, you may use @LazyBinding , @HK2Managed , set Development stage for guice context or use prototype scope on resources ( @Prototype or with global option ) Diagnostic \u00b6 Use .printDiagnosticInfo() to see all extensions, installed by classpath scan. Use .printLifecyclePhases() to indicate lifecycle phases in logs (split logs to clearly understand onlgoing logic). Injector \u00b6 Remember that injector is created at runtime phase when Configuration and Environment objects are already present, so no need to use Provider for them. Also, you may use direct access for configuration values. See: bundle.printConfigurationBindings() Testing \u00b6 Guicey provides more lightweight alternative to DropwizardAppRule : GuiceyAppRule (starts only guice context without jetty). Use it for core business logic integration tests. Also, note that you may replace any extension or bean in context before test ( GuiceyConfigurationRule ). Go on \u00b6 Read getting started to get in common with guicey concepts","title":"Migration from dropwizard-guice"},{"location":"guide/dg-migration/#migration-from-dropwizard-guice","text":"If you are not migrating from dropwizard-guice then skip straight to getting started","title":"Migration from dropwizard-guice"},{"location":"guide/dg-migration/#differences","text":"The libraries are different in core guice integration aspects.","title":"Differences"},{"location":"guide/dg-migration/#dropwizard-guice","text":"Note I may not be exactly correct because it's been a long time since I look how all this works. Please correct me if I'm wrong. Dropwizard-guice rely on jersey2-guice . Injector is created on initialization dropwizard phase. Pros: Classpath scan for automatic registrations Resources could be registered directly from gucie bindings Resources and jersey extensions registration is the same as in core dropwizard ( env.jersey().register() ) Guice bundles remain the main extension point and guice bindings might be used inside them. Cons: jersey2-guice hacks jersey locator lookup process which could potentially break on future versions Guice child injector created for each request Not declared services are managed by HK2 and you must be careful if you use guice AOP (as it works ony on beans, managed by guice) Environment and Configuration objects may be used only as Provider in eager singletons (as injector created in initialization phase when these objects are not available) Admin context not covered by GuiceFilter (no request scope injections under admin context calls). Overall, integration feels transparent and super easy to learn (great!), but with a runtime price and caution in service definitions.","title":"Dropwizard-guice"},{"location":"guide/dg-migration/#guicey","text":"Guicey prefer guice-first approach when everything is created by guice and registered in jersey as instance (so HK2 does not manage services, resources etc.). In contrast to dropwizard-guice, guicey brings a lot of new concepts to better integrate guice. This was necessary due to moving injector creation into dropwizard run phase (which is conceptually more correct). Guicey abstracts user of knowing registration details and use Installer - Extension concept: installers did all required registrations automatically and hide boilerplate of managing extension instances with guice. In pure dropwizard you need to: environment.jersey().register(MyResource.class) whereas in guicey you just need to declare extension class: bundle.extensions(MyResource.class) and everything else would be automatic. The same for all other extensions (tasks, health checks, jersey providers etc.): only extenion class is required for registration. Pros: Classpath scan for automatic registrations You can be sure that guice manage everything (no problems with AOP) Simple extensions: only extension class required (and no need to know how to install it) Wider range of supported extensions and ability to add more integrations (custom installers support) Configuration bindings (by yaml path and internal configuration object) GuiceFilter works on both main and admin contexts Integration tests support Cons: Resources must use Provider for all request-scoped injections Special bundles ( GuiceyBundle ) should be used instead of dropwizard bundles ( Bundle ) in order to use guice-related features (but, as dropwizard-guice could discover dwopwizard bundles, guicey could discover it's bundles too). Extra diagnostic tools usage required for debug to understand internal state (more a pro, but additional thing to know, which is a con). Overall, guicey has much more features, cleaner guice integration and very developer friendly (customizable and with extra tooling), but with a coast of learning curve (additional concepts to know and use above dropwizard).","title":"Guicey"},{"location":"guide/dg-migration/#matrix","text":"Only dropwizard-guice features present for comparison feature dropwizard-guice guicey Auto scan + + Auto scan load class to inspect - + Auto scan recognize Bundle, ConfiguredBundle, HealthCheck, Task, @Provider, resource (@Path), ParamConverterProvider all the same (and more) except dropwizard bundles Resources (rest) recognition directly from guice bindings + - Resources (rest) default scope \"request\" singleton Dropwizard bundle lookup + - (but has custom bundles lookup) Injections in dropwizard Bundle + - Injector creation customization + + Injector creation (dropwizard) phase initialization run Access Bootstrap, Environment, Configuration in guice modules - + GuiceFilter contexts main main, admin","title":"Matrix"},{"location":"guide/dg-migration/#migration","text":"","title":"Migration"},{"location":"guide/dg-migration/#bundle","text":"Bundle registration is almost the same, just more methods available: bootstrap . addBundle ( GuiceBundle . builder () . modules ( new HelloWorldModule ()) // instead of addModule . enableAutoConfig ( getClass (). getPackage (). getName ()) // .setConfigClass(HelloWorldConfiguration.class) // not needed . build ());","title":"Bundle"},{"location":"guide/dg-migration/#auto-scan","text":"Note In guicey, auto scan load all classes in providied package. The logic is - application classes would be loaded in any case (in dropwizard-guice, classes are inspected by reading structure, without loading). Auto scan will find and install extensions, with few exceptions (below)","title":"Auto scan"},{"location":"guide/dg-migration/#health-checks","text":"Use NamedHealthCheck instead of InjectableHealthCheck as check class.","title":"Health checks"},{"location":"guide/dg-migration/#bundles","text":"Guicey will not find dropwizard bundles: all required bundles must be directly registered in bootstrap. Important Guice injections will not work inside dropwizard bundles But note, that bundles, used for features integrations may not be required as guicey perform automatic installation (removes redundant code). For reusable bundles, consider using GuiceyBundle instead. Also, dropwzard bundles, registered in bootsrap could be recognized as guicey bundles (to provide extra guicey features).","title":"Bundles"},{"location":"guide/dg-migration/#resources-rest","text":"First of all, note that resource bound only in guice module will not be discovered (no installation from guice declaration like it was in jersey1 guice integration). Use either classpath scan to install resources or specify them directly into bundle: bundle.extensions(Resource1.class, Resoutrce2.class) . You can still delegate jersey extensions (resources, providers) management to HK2 , but they will lack guice aop and require extra dependency - HK2-guice-bridge (official HK guice bridge) Important Resources are singletons by default and so they will initialize with guice context ( may be disabled ). You may need to wrap some injections with Provider . Alternatively, you may use @LazyBinding , @HK2Managed , set Development stage for guice context or use prototype scope on resources ( @Prototype or with global option )","title":"Resources (rest)"},{"location":"guide/dg-migration/#diagnostic","text":"Use .printDiagnosticInfo() to see all extensions, installed by classpath scan. Use .printLifecyclePhases() to indicate lifecycle phases in logs (split logs to clearly understand onlgoing logic).","title":"Diagnostic"},{"location":"guide/dg-migration/#injector","text":"Remember that injector is created at runtime phase when Configuration and Environment objects are already present, so no need to use Provider for them. Also, you may use direct access for configuration values. See: bundle.printConfigurationBindings()","title":"Injector"},{"location":"guide/dg-migration/#testing","text":"Guicey provides more lightweight alternative to DropwizardAppRule : GuiceyAppRule (starts only guice context without jetty). Use it for core business logic integration tests. Also, note that you may replace any extension or bean in context before test ( GuiceyConfigurationRule ).","title":"Testing"},{"location":"guide/dg-migration/#go-on","text":"Read getting started to get in common with guicey concepts","title":"Go on"},{"location":"guide/diagnostic/","text":"Diagnostic info \u00b6 During startup guicey records startup metrics and remembers all details of configuration process. All this information is available through GuiceyConfigurationInfo bean in guice context. Diagnostic service \u00b6 Default diagnostic info rendering is provided to assist configuration problems resolution and better guicey internals understanding. The simplest way to enable diagnostic reporting is using bundle .printDiagnosticInfo() option. This registers DiagnosticBundle with default reporting configuration. Bundle could be registered directly in order to customize output. Tip You can use diagnostic logs with lifecycle phases logging and configuration bindings report When .printDiagnosticInfo() enabled, the following kind of logs will be printed after server startup: INFO [2016-08-01 21:22:50,898] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Startup stats = GUICEY started in 453.3 ms \u2502 \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) \u2502 \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms \u2502 \u2514\u2500\u2500 registered 2 commands \u2502 \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms \u2502 \u251c\u2500\u2500 2 resolved in 8.149 ms \u2502 \u2514\u2500\u2500 6 processed \u2502 \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms \u2502 \u251c\u2500\u2500 installers prepared in 13.79 ms \u2502 \u2502 \u2502 \u251c\u2500\u2500 extensions recognized in 9.259 ms \u2502 \u2502 \u251c\u2500\u2500 using 11 installers \u2502 \u2502 \u2514\u2500\u2500 from 7 classes \u2502 \u2502 \u2502 \u2514\u2500\u2500 3 extensions installed in 4.188 ms \u2502 \u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs \u2502 \u2514\u2500\u2500 [1,1%] remaining 5 ms INFO [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Options = Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true ConfigureFromDropwizardBundles = false InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] INFO [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN, GUICE_ENABLED BUNDLES = CoreInstallersBundle (r.v.d.g.m.installer) Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *LOOKUP, REG(2) DiagnosticBundle (r.v.d.g.m.c.debug) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *LOOKUP INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(3) FooResource (r.v.d.g.d.s.features) *SCAN GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) DiagnosticModule (r.v.d.g.m.c.d.DiagnosticBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) GuiceBootstrapModule (r.v.d.guice.module) INFO [2016-08-01 21:22:50,909] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = APPLICATION \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) \u251c\u2500\u2500 module GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) \u2502 \u251c\u2500\u2500 Foo2Bundle (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) *IGNORED \u2502 \u251c\u2500\u2500 module FooBundleModule (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 -disable ManagedInstaller (r.v.d.g.m.i.feature) \u2502 \u2502 \u2502 \u2514\u2500\u2500 FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module FooModule (r.v.d.g.d.s.features) *IGNORED \u2502 \u251c\u2500\u2500 HK2DebugBundle (r.v.d.g.m.j.debug) \u2502 \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u251c\u2500\u2500 extension HK2DebugFeature (r.v.d.g.m.j.d.service) \u2502 \u2514\u2500\u2500 module HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) \u2502 \u251c\u2500\u2500 DiagnosticBundle (r.v.d.g.m.c.debug) \u2502 \u2514\u2500\u2500 module DiagnosticModule (r.v.d.g.m.c.d.DiagnosticBundle) \u2502 \u251c\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) *IGNORED \u2502 \u2514\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u251c\u2500\u2500 BUNDLES LOOKUP \u2502 \u251c\u2500\u2500 HK2DebugBundle (r.v.d.g.m.j.debug) *IGNORED \u2502 \u2502 \u2502 \u2514\u2500\u2500 GuiceRestrictedConfigBundle (r.v.d.g.support.util) \u2502 \u2514\u2500\u2500 module GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \u2502 \u2514\u2500\u2500 CLASSPATH SCAN \u2514\u2500\u2500 extension FooResource (r.v.d.g.d.s.features) Default reporting contains 4 sections: How guicey spent time What options used What was configured From where configuration items come from Timings \u00b6 Startup timings \u00b6 GUICEY started in 453.3 ms Overall guicey time measured: GuiceBundle methods plus part of HK2 configuration time (HK2 started after bundle). All items below represent guicey time detalization. Items always detail time of direct parent. Most of this time actually spent on class loading. For example, report above represent test direct execution. But when this test executed as part of suit time become GUICEY started in 52.95 ms because most classes were pre-loaded by other tests. Classpath scan \u00b6 \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) Classpath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. scanned 5 classes means that 5 classed were found (overall) in configured packages. recognized 4 classes Show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command). NOTE: classpath scan time will be obviously bigger for larger classes count. But most of this time are actually class loading time. If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time move to other some place (for example, to injector creation). Commands \u00b6 \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms \u2502 \u2514\u2500\u2500 registered 2 commands Commands time includes time spent on commands search (in classes from classpath scan; if enabled .searchCommands()) and calling .injectMemebers on configured environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled) Bundles \u00b6 \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms \u2502 \u251c\u2500\u2500 2 resolved in 8.149 ms \u2502 \u2514\u2500\u2500 6 processed Bundles time includes bundles lookup time (if not .disableBundleLookup()), dropwizard bunles lookup (if .configureFromDropwizardBundles()) and bundles execution. 2 resolved in 8.149 ms indicated bundles resolved with guicey bundle lookup or from dropwizard bundles. 6 processed - overall processed bundles (all registered bundles, including just resolved). Injector \u00b6 \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms \u2502 \u251c\u2500\u2500 installers prepared in 13.79 ms \u2502 \u2502 \u2502 \u251c\u2500\u2500 extensions recognized in 9.259 ms \u2502 \u2502 \u251c\u2500\u2500 using 11 installers \u2502 \u2502 \u2514\u2500\u2500 from 7 classes \u2502 \u2502 \u2502 \u2514\u2500\u2500 3 extensions installed in 4.188 ms All installers and extensions operations (except jersey related features) performed inside of guice module and so included into overall injector creation time. installers prepared in 13.79 ms include installers search in classpath (if scan enabled), instantiation and preparing for usage (remove duplicates, sort). extensions recognized in 9.259 ms - all manually configured extensions and all classes from classpath scan ( from 7 classes ) are recognized by all registered installers ( using 11 installers ) using installer match method. Recognized installers bound to guice context (or custom action performed for binding installers). 3 extensions installed in 4.188 ms - all recognized extensions are installed with installers install methods. Note Most time of injector creation is internal guice logic. You can enable guice logs to see more details (see below) HK2 \u00b6 \u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs Jersey starts after dropwizard bundles processing and so after GuiceBundle execution. This time is tracked as (overall) guicey time. Here guicey register required HK2 bindings and (some HK2 beans in guice) and executes jersey installers (installers implement JerseyInstaller) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires HK2 specific bindings). Note that installation time ( 2 jersey extensions installed in 660.9 \u03bcs ) is so tiny just because empty resources (without methods) were used. In real application installation time will be bigger. Remaining \u00b6 \u2514\u2500\u2500 [1,1%] remaining 5 ms Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown. Used options \u00b6 Shows all set or requested (by application logic) options. If you use your own options here they will also be printed. Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true ConfigureFromDropwizardBundles = false InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] Used markers: * CUSTOM - option value set by user * NOT_USED - option was set by user but never used Not used marker just indicated that option is \"not yet\" used. Options may be consumed lazilly by application logic, so it is possible that its not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario). Configuration diagnostic info \u00b6 Section intended to compactly show all configuration (to quickly see what was configured). This and the next sections used condensed package notion: CoreInstallersBundle (r.v.d.g.m.installer) Assumed that all classes in application will be uniquely identifiable by name and package info shown just to be able to understand exact class location. Logback shrinker used. Report also indicates duplicate registrations by REG(N) marker, where N - amount of installations (ignored installations will be visible in configuration tree). Counted: item registration in different places (e.g. different bundles) duplicate registrations in simgle place (e.g. .extensions(MyExt.class, MyExt.class) ) General \u00b6 All configuration items (commands, modules, installers, extension, bundles) are identified by class. Duplicate entities are not allowed and simply ignored. For example, if extension registered manually and by classpath scan then it will be registered once, but internally guicey will remember both configuration sources. In contrast to other items, bundles and modules are registered by instance, but still uniqueness is checked by type: only first instance registered and other instances considered as duplicate. Commands \u00b6 COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN,GUICE_ENABLED Shows commands resolved with classpath scan (enabled with .searchCommands()). The following markers used: SCAN - item from classpath scan (always) GUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts) Bundles \u00b6 BUNDLES = CoreInstallersBundle (r.v.d.g.m.installer) Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *LOOKUP, REG(2) DiagnosticBundle (r.v.d.g.m.c.debug) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *LOOKUP All registered bundles are shown as a tree (to indicate transitive bundles). The following markers used: LOOKUP - bundle resolved with bundle lookup mechanism DW - bundle recognized from registered dropwizard bundle Installers and extensions \u00b6 INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(3) FooResource (r.v.d.g.d.s.features) *SCAN Shows used installers (only installers which install extensions) and installed extensions. Both installers and extensions are shown in the processing order (sorted according to @Order annotations). The following markers used: SCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan) LAZY - extensions annotated with @LazyBinding HK2 - extension annotated with @HK2Managed HOOK - registered by configuration hook Modules \u00b6 GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) DiagnosticModule (r.v.d.g.m.c.d.DiagnosticBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) GuiceBootstrapModule (r.v.d.guice.module) All registered guice modules. Configuration context tree \u00b6 Configuration tree is useful to understand from where configuration items come from. Installer disables are shown like: \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) Duplicate registrations (ignored by guicey) are shown like: \u2502 \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) *IGNORED If number in configuration report (e.g.REG(3)) doesn't match registration appearances, then item registered multiple times in one of this places. Note that CoreInstallersBundle are always below all other bundles. This is because it always registered last (to be able to disable it's registration). It doesn't affect anything other than reporting (because bundles order does not change anything except this tree). Re-using \u00b6 Diagnostic info rendering may be used for custom rendering (showing in web page or some other staff). Rendering is performed with 3 beans, available for injection (when bundle registered): StatsRenderer OptionsRenderer DiagnosticRenderer ContextTreeRenderer Note Renderers are also available in event objects (for events fired after injection creation) Installers mode \u00b6 There is a special option in GuiceBundle .printAvailableInstallers() for printing only installers information. It also use DiagnosticBundle, but with different configuration. Warning Both options can't be used together (but it should never be required as they serve different purposes). Example output: INFO [2016-08-22 00:49:33,557] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = INSTALLERS in processing order = lifecycle (r.v.d.g.m.i.f.LifeCycleInstaller) managed (r.v.d.g.m.i.feature.ManagedInstaller) jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) jerseyprovider (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) resource (r.v.d.g.m.i.f.j.ResourceInstaller) eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) healthcheck (r.v.d.g.m.i.f.h.HealthCheckInstaller) task (r.v.d.g.m.i.feature.TaskInstaller) plugin (r.v.d.g.m.i.f.plugin.PluginInstaller) webservlet (r.v.d.g.m.i.f.w.WebServletInstaller) webfilter (r.v.d.g.m.i.f.web.WebFilterInstaller) weblistener (r.v.d.g.m.i.f.w.l.WebListenerInstaller) INFO [2016-08-22 00:49:33,563] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = APPLICATION \u2502 \u251c\u2500\u2500 WebInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 installer WebFilterInstaller (r.v.d.g.m.i.f.web) \u2502 \u251c\u2500\u2500 installer WebServletInstaller (r.v.d.g.m.i.f.web) \u2502 \u2514\u2500\u2500 installer WebListenerInstaller (r.v.d.g.m.i.f.w.listener) \u2502 \u2514\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u251c\u2500\u2500 installer LifeCycleInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer ManagedInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer JerseyProviderInstaller (r.v.d.g.m.i.f.j.provider) \u251c\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer EagerSingletonInstaller (r.v.d.g.m.i.f.eager) \u251c\u2500\u2500 installer HealthCheckInstaller (r.v.d.g.m.i.f.health) \u251c\u2500\u2500 installer TaskInstaller (r.v.d.g.m.i.feature) \u2514\u2500\u2500 installer PluginInstaller (r.v.d.g.m.i.f.plugin) Important Comparing to complete diagnostic, it shows all installers ( even not used ). In diagnostic reporting not used installers are hidden, because usually it means they are not needed. Guice injector creation timings \u00b6 You will see in guicey timings that almost all time spent creating guice injector. To see some guice internal timings enable guice debug logs: logging: loggers: com.google.inject.internal.util: DEBUG Logs will be something like this: DEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Module execution: 272ms DEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Interceptors creation: 1ms DEBUG [2016-08-03 21:09:45,965] com.google.inject.internal.util.Stopwatch: TypeListeners & ProvisionListener creation: 2ms DEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Scopes creation: 1ms DEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Converters creation: 0ms DEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Binding creation: 26ms DEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Module annotated method scanners creation: 0ms DEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Private environment creation: 1ms DEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Injector construction: 0ms DEBUG [2016-08-03 21:09:46,170] com.google.inject.internal.util.Stopwatch: Binding initialization: 177ms DEBUG [2016-08-03 21:09:46,171] com.google.inject.internal.util.Stopwatch: Binding indexing: 1ms DEBUG [2016-08-03 21:09:46,172] com.google.inject.internal.util.Stopwatch: Collecting injection requests: 1ms DEBUG [2016-08-03 21:09:46,179] com.google.inject.internal.util.Stopwatch: Binding validation: 7ms DEBUG [2016-08-03 21:09:46,183] com.google.inject.internal.util.Stopwatch: Static validation: 4ms DEBUG [2016-08-03 21:09:46,191] com.google.inject.internal.util.Stopwatch: Instance member validation: 8ms DEBUG [2016-08-03 21:09:46,192] com.google.inject.internal.util.Stopwatch: Provider verification: 1ms DEBUG [2016-08-03 21:09:46,201] com.google.inject.internal.util.Stopwatch: Static member injection: 9ms DEBUG [2016-08-03 21:09:46,204] com.google.inject.internal.util.Stopwatch: Instance injection: 3ms DEBUG [2016-08-03 21:09:46,427] com.google.inject.internal.util.Stopwatch: Preloading singletons: 223ms Note 'Preloading singletons' line will be logged long after other guice log messages, so search it at the end of your startup log.","title":"Diagnostic"},{"location":"guide/diagnostic/#diagnostic-info","text":"During startup guicey records startup metrics and remembers all details of configuration process. All this information is available through GuiceyConfigurationInfo bean in guice context.","title":"Diagnostic info"},{"location":"guide/diagnostic/#diagnostic-service","text":"Default diagnostic info rendering is provided to assist configuration problems resolution and better guicey internals understanding. The simplest way to enable diagnostic reporting is using bundle .printDiagnosticInfo() option. This registers DiagnosticBundle with default reporting configuration. Bundle could be registered directly in order to customize output. Tip You can use diagnostic logs with lifecycle phases logging and configuration bindings report When .printDiagnosticInfo() enabled, the following kind of logs will be printed after server startup: INFO [2016-08-01 21:22:50,898] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Startup stats = GUICEY started in 453.3 ms \u2502 \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) \u2502 \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms \u2502 \u2514\u2500\u2500 registered 2 commands \u2502 \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms \u2502 \u251c\u2500\u2500 2 resolved in 8.149 ms \u2502 \u2514\u2500\u2500 6 processed \u2502 \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms \u2502 \u251c\u2500\u2500 installers prepared in 13.79 ms \u2502 \u2502 \u2502 \u251c\u2500\u2500 extensions recognized in 9.259 ms \u2502 \u2502 \u251c\u2500\u2500 using 11 installers \u2502 \u2502 \u2514\u2500\u2500 from 7 classes \u2502 \u2502 \u2502 \u2514\u2500\u2500 3 extensions installed in 4.188 ms \u2502 \u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs \u2502 \u2514\u2500\u2500 [1,1%] remaining 5 ms INFO [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Options = Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true ConfigureFromDropwizardBundles = false InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] INFO [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN, GUICE_ENABLED BUNDLES = CoreInstallersBundle (r.v.d.g.m.installer) Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *LOOKUP, REG(2) DiagnosticBundle (r.v.d.g.m.c.debug) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *LOOKUP INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(3) FooResource (r.v.d.g.d.s.features) *SCAN GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) DiagnosticModule (r.v.d.g.m.c.d.DiagnosticBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) GuiceBootstrapModule (r.v.d.guice.module) INFO [2016-08-01 21:22:50,909] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = APPLICATION \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) \u251c\u2500\u2500 module FooModule (r.v.d.g.d.s.features) \u251c\u2500\u2500 module GuiceBootstrapModule (r.v.d.guice.module) \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) \u2502 \u251c\u2500\u2500 Foo2Bundle (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) *IGNORED \u2502 \u251c\u2500\u2500 module FooBundleModule (r.v.d.g.d.s.bundle) \u2502 \u251c\u2500\u2500 -disable ManagedInstaller (r.v.d.g.m.i.feature) \u2502 \u2502 \u2502 \u2514\u2500\u2500 FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) \u2502 \u2514\u2500\u2500 module FooModule (r.v.d.g.d.s.features) *IGNORED \u2502 \u251c\u2500\u2500 HK2DebugBundle (r.v.d.g.m.j.debug) \u2502 \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u251c\u2500\u2500 extension HK2DebugFeature (r.v.d.g.m.j.d.service) \u2502 \u2514\u2500\u2500 module HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) \u2502 \u251c\u2500\u2500 DiagnosticBundle (r.v.d.g.m.c.debug) \u2502 \u2514\u2500\u2500 module DiagnosticModule (r.v.d.g.m.c.d.DiagnosticBundle) \u2502 \u251c\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) *IGNORED \u2502 \u2514\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u2502 \u251c\u2500\u2500 BUNDLES LOOKUP \u2502 \u251c\u2500\u2500 HK2DebugBundle (r.v.d.g.m.j.debug) *IGNORED \u2502 \u2502 \u2502 \u2514\u2500\u2500 GuiceRestrictedConfigBundle (r.v.d.g.support.util) \u2502 \u2514\u2500\u2500 module GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \u2502 \u2514\u2500\u2500 CLASSPATH SCAN \u2514\u2500\u2500 extension FooResource (r.v.d.g.d.s.features) Default reporting contains 4 sections: How guicey spent time What options used What was configured From where configuration items come from","title":"Diagnostic service"},{"location":"guide/diagnostic/#timings","text":"","title":"Timings"},{"location":"guide/diagnostic/#startup-timings","text":"GUICEY started in 453.3 ms Overall guicey time measured: GuiceBundle methods plus part of HK2 configuration time (HK2 started after bundle). All items below represent guicey time detalization. Items always detail time of direct parent. Most of this time actually spent on class loading. For example, report above represent test direct execution. But when this test executed as part of suit time become GUICEY started in 52.95 ms because most classes were pre-loaded by other tests.","title":"Startup timings"},{"location":"guide/diagnostic/#classpath-scan","text":"\u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms \u2502 \u251c\u2500\u2500 scanned 5 classes \u2502 \u2514\u2500\u2500 recognized 4 classes (80% of scanned) Classpath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. scanned 5 classes means that 5 classed were found (overall) in configured packages. recognized 4 classes Show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command). NOTE: classpath scan time will be obviously bigger for larger classes count. But most of this time are actually class loading time. If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time move to other some place (for example, to injector creation).","title":"Classpath scan"},{"location":"guide/diagnostic/#commands","text":"\u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms \u2502 \u2514\u2500\u2500 registered 2 commands Commands time includes time spent on commands search (in classes from classpath scan; if enabled .searchCommands()) and calling .injectMemebers on configured environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled)","title":"Commands"},{"location":"guide/diagnostic/#bundles","text":"\u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms \u2502 \u251c\u2500\u2500 2 resolved in 8.149 ms \u2502 \u2514\u2500\u2500 6 processed Bundles time includes bundles lookup time (if not .disableBundleLookup()), dropwizard bunles lookup (if .configureFromDropwizardBundles()) and bundles execution. 2 resolved in 8.149 ms indicated bundles resolved with guicey bundle lookup or from dropwizard bundles. 6 processed - overall processed bundles (all registered bundles, including just resolved).","title":"Bundles"},{"location":"guide/diagnostic/#injector","text":"\u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms \u2502 \u251c\u2500\u2500 installers prepared in 13.79 ms \u2502 \u2502 \u2502 \u251c\u2500\u2500 extensions recognized in 9.259 ms \u2502 \u2502 \u251c\u2500\u2500 using 11 installers \u2502 \u2502 \u2514\u2500\u2500 from 7 classes \u2502 \u2502 \u2502 \u2514\u2500\u2500 3 extensions installed in 4.188 ms All installers and extensions operations (except jersey related features) performed inside of guice module and so included into overall injector creation time. installers prepared in 13.79 ms include installers search in classpath (if scan enabled), instantiation and preparing for usage (remove duplicates, sort). extensions recognized in 9.259 ms - all manually configured extensions and all classes from classpath scan ( from 7 classes ) are recognized by all registered installers ( using 11 installers ) using installer match method. Recognized installers bound to guice context (or custom action performed for binding installers). 3 extensions installed in 4.188 ms - all recognized extensions are installed with installers install methods. Note Most time of injector creation is internal guice logic. You can enable guice logs to see more details (see below)","title":"Injector"},{"location":"guide/diagnostic/#hk2","text":"\u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms \u2502 \u251c\u2500\u2500 using 2 jersey installers \u2502 \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs Jersey starts after dropwizard bundles processing and so after GuiceBundle execution. This time is tracked as (overall) guicey time. Here guicey register required HK2 bindings and (some HK2 beans in guice) and executes jersey installers (installers implement JerseyInstaller) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires HK2 specific bindings). Note that installation time ( 2 jersey extensions installed in 660.9 \u03bcs ) is so tiny just because empty resources (without methods) were used. In real application installation time will be bigger.","title":"HK2"},{"location":"guide/diagnostic/#remaining","text":"\u2514\u2500\u2500 [1,1%] remaining 5 ms Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.","title":"Remaining"},{"location":"guide/diagnostic/#used-options","text":"Shows all set or requested (by application logic) options. If you use your own options here they will also be printed. Guicey (r.v.dropwizard.guice.GuiceyOptions) ScanPackages = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM SearchCommands = true *CUSTOM UseCoreInstallers = true ConfigureFromDropwizardBundles = false InjectorStage = PRODUCTION GuiceFilterRegistration = [REQUEST] Used markers: * CUSTOM - option value set by user * NOT_USED - option was set by user but never used Not used marker just indicated that option is \"not yet\" used. Options may be consumed lazilly by application logic, so it is possible that its not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario).","title":"Used options"},{"location":"guide/diagnostic/#configuration-diagnostic-info","text":"Section intended to compactly show all configuration (to quickly see what was configured). This and the next sections used condensed package notion: CoreInstallersBundle (r.v.d.g.m.installer) Assumed that all classes in application will be uniquely identifiable by name and package info shown just to be able to understand exact class location. Logback shrinker used. Report also indicates duplicate registrations by REG(N) marker, where N - amount of installations (ignored installations will be visible in configuration tree). Counted: item registration in different places (e.g. different bundles) duplicate registrations in simgle place (e.g. .extensions(MyExt.class, MyExt.class) )","title":"Configuration diagnostic info"},{"location":"guide/diagnostic/#general","text":"All configuration items (commands, modules, installers, extension, bundles) are identified by class. Duplicate entities are not allowed and simply ignored. For example, if extension registered manually and by classpath scan then it will be registered once, but internally guicey will remember both configuration sources. In contrast to other items, bundles and modules are registered by instance, but still uniqueness is checked by type: only first instance registered and other instances considered as duplicate.","title":"General"},{"location":"guide/diagnostic/#commands_1","text":"COMMANDS = Cli (r.v.d.g.d.s.features) *SCAN EnvCommand (r.v.d.g.d.s.features) *SCAN,GUICE_ENABLED Shows commands resolved with classpath scan (enabled with .searchCommands()). The following markers used: SCAN - item from classpath scan (always) GUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)","title":"Commands"},{"location":"guide/diagnostic/#bundles_1","text":"BUNDLES = CoreInstallersBundle (r.v.d.g.m.installer) Foo2Bundle (r.v.d.g.d.s.bundle) FooBundleRelative2Bundle (r.v.d.g.d.s.bundle) HK2DebugBundle (r.v.d.g.m.j.debug) *LOOKUP, REG(2) DiagnosticBundle (r.v.d.g.m.c.debug) GuiceRestrictedConfigBundle (r.v.d.g.support.util) *LOOKUP All registered bundles are shown as a tree (to indicate transitive bundles). The following markers used: LOOKUP - bundle resolved with bundle lookup mechanism DW - bundle recognized from registered dropwizard bundle","title":"Bundles"},{"location":"guide/diagnostic/#installers-and-extensions","text":"INSTALLERS and EXTENSIONS in processing order = jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2) HK2DebugFeature (r.v.d.g.m.j.d.service) resource (r.v.d.g.m.i.f.j.ResourceInstaller) FooBundleResource (r.v.d.g.d.s.bundle) *REG(3) FooResource (r.v.d.g.d.s.features) *SCAN Shows used installers (only installers which install extensions) and installed extensions. Both installers and extensions are shown in the processing order (sorted according to @Order annotations). The following markers used: SCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan) LAZY - extensions annotated with @LazyBinding HK2 - extension annotated with @HK2Managed HOOK - registered by configuration hook","title":"Installers and extensions"},{"location":"guide/diagnostic/#modules","text":"GUICE MODULES = FooModule (r.v.d.g.d.s.features) *REG(2) FooBundleModule (r.v.d.g.d.s.bundle) HK2DebugModule (r.v.d.g.m.j.d.HK2DebugBundle) DiagnosticModule (r.v.d.g.m.c.d.DiagnosticBundle) GRestrictModule (r.v.d.g.s.u.GuiceRestrictedConfigBundle) GuiceBootstrapModule (r.v.d.guice.module) All registered guice modules.","title":"Modules"},{"location":"guide/diagnostic/#configuration-context-tree","text":"Configuration tree is useful to understand from where configuration items come from. Installer disables are shown like: \u251c\u2500\u2500 -disable LifeCycleInstaller (r.v.d.g.m.i.feature) Duplicate registrations (ignored by guicey) are shown like: \u2502 \u251c\u2500\u2500 extension FooBundleResource (r.v.d.g.d.s.bundle) *IGNORED If number in configuration report (e.g.REG(3)) doesn't match registration appearances, then item registered multiple times in one of this places. Note that CoreInstallersBundle are always below all other bundles. This is because it always registered last (to be able to disable it's registration). It doesn't affect anything other than reporting (because bundles order does not change anything except this tree).","title":"Configuration context tree"},{"location":"guide/diagnostic/#re-using","text":"Diagnostic info rendering may be used for custom rendering (showing in web page or some other staff). Rendering is performed with 3 beans, available for injection (when bundle registered): StatsRenderer OptionsRenderer DiagnosticRenderer ContextTreeRenderer Note Renderers are also available in event objects (for events fired after injection creation)","title":"Re-using"},{"location":"guide/diagnostic/#installers-mode","text":"There is a special option in GuiceBundle .printAvailableInstallers() for printing only installers information. It also use DiagnosticBundle, but with different configuration. Warning Both options can't be used together (but it should never be required as they serve different purposes). Example output: INFO [2016-08-22 00:49:33,557] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = INSTALLERS in processing order = lifecycle (r.v.d.g.m.i.f.LifeCycleInstaller) managed (r.v.d.g.m.i.feature.ManagedInstaller) jerseyfeature (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) jerseyprovider (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) resource (r.v.d.g.m.i.f.j.ResourceInstaller) eagersingleton (r.v.d.g.m.i.f.e.EagerSingletonInstaller) healthcheck (r.v.d.g.m.i.f.h.HealthCheckInstaller) task (r.v.d.g.m.i.feature.TaskInstaller) plugin (r.v.d.g.m.i.f.plugin.PluginInstaller) webservlet (r.v.d.g.m.i.f.w.WebServletInstaller) webfilter (r.v.d.g.m.i.f.web.WebFilterInstaller) weblistener (r.v.d.g.m.i.f.w.l.WebListenerInstaller) INFO [2016-08-22 00:49:33,563] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = APPLICATION \u2502 \u251c\u2500\u2500 WebInstallersBundle (r.v.d.g.m.installer) \u2502 \u251c\u2500\u2500 installer WebFilterInstaller (r.v.d.g.m.i.f.web) \u2502 \u251c\u2500\u2500 installer WebServletInstaller (r.v.d.g.m.i.f.web) \u2502 \u2514\u2500\u2500 installer WebListenerInstaller (r.v.d.g.m.i.f.w.listener) \u2502 \u2514\u2500\u2500 CoreInstallersBundle (r.v.d.g.m.installer) \u251c\u2500\u2500 installer LifeCycleInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer ManagedInstaller (r.v.d.g.m.i.feature) \u251c\u2500\u2500 installer JerseyFeatureInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer JerseyProviderInstaller (r.v.d.g.m.i.f.j.provider) \u251c\u2500\u2500 installer ResourceInstaller (r.v.d.g.m.i.f.jersey) \u251c\u2500\u2500 installer EagerSingletonInstaller (r.v.d.g.m.i.f.eager) \u251c\u2500\u2500 installer HealthCheckInstaller (r.v.d.g.m.i.f.health) \u251c\u2500\u2500 installer TaskInstaller (r.v.d.g.m.i.feature) \u2514\u2500\u2500 installer PluginInstaller (r.v.d.g.m.i.f.plugin) Important Comparing to complete diagnostic, it shows all installers ( even not used ). In diagnostic reporting not used installers are hidden, because usually it means they are not needed.","title":"Installers mode"},{"location":"guide/diagnostic/#guice-injector-creation-timings","text":"You will see in guicey timings that almost all time spent creating guice injector. To see some guice internal timings enable guice debug logs: logging: loggers: com.google.inject.internal.util: DEBUG Logs will be something like this: DEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Module execution: 272ms DEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Interceptors creation: 1ms DEBUG [2016-08-03 21:09:45,965] com.google.inject.internal.util.Stopwatch: TypeListeners & ProvisionListener creation: 2ms DEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Scopes creation: 1ms DEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Converters creation: 0ms DEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Binding creation: 26ms DEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Module annotated method scanners creation: 0ms DEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Private environment creation: 1ms DEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Injector construction: 0ms DEBUG [2016-08-03 21:09:46,170] com.google.inject.internal.util.Stopwatch: Binding initialization: 177ms DEBUG [2016-08-03 21:09:46,171] com.google.inject.internal.util.Stopwatch: Binding indexing: 1ms DEBUG [2016-08-03 21:09:46,172] com.google.inject.internal.util.Stopwatch: Collecting injection requests: 1ms DEBUG [2016-08-03 21:09:46,179] com.google.inject.internal.util.Stopwatch: Binding validation: 7ms DEBUG [2016-08-03 21:09:46,183] com.google.inject.internal.util.Stopwatch: Static validation: 4ms DEBUG [2016-08-03 21:09:46,191] com.google.inject.internal.util.Stopwatch: Instance member validation: 8ms DEBUG [2016-08-03 21:09:46,192] com.google.inject.internal.util.Stopwatch: Provider verification: 1ms DEBUG [2016-08-03 21:09:46,201] com.google.inject.internal.util.Stopwatch: Static member injection: 9ms DEBUG [2016-08-03 21:09:46,204] com.google.inject.internal.util.Stopwatch: Instance injection: 3ms DEBUG [2016-08-03 21:09:46,427] com.google.inject.internal.util.Stopwatch: Preloading singletons: 223ms Note 'Preloading singletons' line will be logged long after other guice log messages, so search it at the end of your startup log.","title":"Guice injector creation timings"},{"location":"guide/events/","text":"Guicey lifecycle events \u00b6 Guicey broadcast lifecycle events in all major points. Each event provides access to all available state at this point. Events could be used for configuration analysis or to add some special post processing (e.g. post process modules before injector creation). Important Event listeners could not modify configuration itself (can't add new extensions, installers, bundles or disable anything). Debug \u00b6 Use bundle.printLifecyclePhases() to see lifecycle events in logs. Could be very helpful during problems investigation. Also, it shows startup timer to easily see where most startup time is spent. Example output: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.008 ]____________________________________________________/ 1 hooks processed \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.104 ]____________________________________________________/ 2 commands installed \\____ INFO [2018-06-15 04:09:56,978] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: / INFO [2018-06-15 04:09:56,981] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: / \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.881 ]____________________________________________________/ Configured from 3 (-1) GuiceyBundles \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.886 ]____________________________________________________/ Staring guice with 3/0 (-1) modules... \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.980 ]____________________________________________________/ 8 (-1) installers initialized \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:01.008 ]____________________________________________________/ 13 (-1) extensions found \\____ ... Note that (-1) in some events means disabled items and actual displayed count did not count disabled items. Use detailed output ( bundle.printLifecyclePhasesDetailed() ) to see more details. Example detailed output (for one event): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.893 ]____________________________________________________/ Configured from 3 (-1) GuiceyBundles \\____ bundles = DiagnosticBundle (r.v.d.g.m.c.debug) GuiceRestrictedConfigBundle (r.v.d.g.support.util) CoreInstallersBundle (r.v.d.g.m.installer) disabled = HK2DebugBundle (r.v.d.g.m.j.debug) Important Lifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events. Anyway, these logs intended to be used for problems resolution and so console only output should not be a problem. Registration \u00b6 Events listener could be registered only through main bundle: GuiceBundle . builder () . listen ( new MyListener (), new MyOtherListener ()) ... . build () All events are listed in GuiceyLifecycle enum in execution order. Event listener could implement generic event interface GuiceyLifecycleListener and use enum to differentiate required events: public class MyListener implements GuiceyLifecycleListener { public void onEvent ( GuiceyLifecycleEvent event ) { switch ( event . getType ()) { case InjectorCreation : InjectorCreationEvent e = ( InjectorCreationEvent ) event ; ... } } } Or use GuiceyLifecycleAdapter adapter and override only required methods: public class MyListener extends GuiceyLifecycleAdapter { @Override protected void injectorCreation ( final InjectorCreationEvent event ) { ... } } Bundles \u00b6 Event listeners could also be registered in guicey bundle, but not all events will be received by such events (as bundles processing is not first lifecycle phase). Aslo, such bundles can't be configuration hooks (because all hooks are already processed at this point). Context modification \u00b6 Event listeners are not allowed to modify configuration, only observe it and, if required, post process instances (modules, bundles etc). But, if listener needs to register any additional extension it can implement GuiceyConfigrator interface to be automatically registered as configuration hook: public class MyDebuggingListener extends GuiceyLifecycleAdapter implements GuiceyConfigurationHook { @Override public void configure ( GuiceBundle . Builder builder ) { builder . extensions ( DebugExtension . class ) . bundles ( new DebugBundle ()) ... } @Override protected void injectorCreation ( final InjectorCreationEvent event ) { ... } } Event structure \u00b6 All events inherit from base event classes. Event classes are extending each other: as initialisation phases go more objects become available. So you can access any available (at this point) object from event instance. Base event Description GuiceyLifecycleEvent The lowest event type. Initialization dropwizard phase. Provides access to event type and options. RunPhaseEvent Dropwizard run phase. Available Bootstrap, Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer InjectorPhaseEvent Guice injector created. Available injector and GuiceyCofigurationInfo (guicey configuration). Shortcuts for configuration reports renderer HK2PhaseEvent Jersey starting. ServiceLocator available. Events \u00b6 Note that some events may not been called - (?). Event Description Possible usage Dropwizard initialization phase HooksProcessed(?) Called after all registered GuiceyConfigurationHook processing Only for info Initialization Called after GuiceBundle initialization. If commands search is enabled then all found commands will be provided in event. Convenient moment to apply registrations into dropwizard Bootstrap object. Dropwizard run phase BeforeRun Meta event, called before guicey configuration just to indicate first point where Environment, Configuration and introspected configuration are available For example, used by bundle.printConfigurationBindings() to print configuration bindings before injector start (help with missed bindings debug) BundlesFromDwResolved(?) Called if configuration from dw bundles enabled and at least one bundle recognized (note: some of these bundles could be actually disabled and not used further) Logging or post processing of recognized bundles. BundlesFromLookupResolved(?) Called if at least one bundle recognized using bundles lookup (note: some of these bundles could be disabled and not used further) Logging or post processing of found bundles. BundlesResolved Called to indicate all top-level bundles (registered manually, from lookup and recognized dropwizard bundles). Called even if no bundles registered to indicate configuration state. Logging or post processing of top-level bundles. BundlesProcessed(?) Called after bundles processing. Note that bundles could register other bundles and so resulted list of installed bundles could be bigger (than in resolution event). Called only when at lest one bundle registered and not disabled. Logging of all used bundles or storing bundles list for modules (for example). InjectorCreation Called just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called, event if no modules registered. Logging or post processing modules (can't add or remove modules, but can manipulate module instance) InstallersResolved Called when installers resolved (from classpath scan, if enabled) and initialized. Injector is under creation at that moment. Logging or post processing of installers (e.g. set list of modules or bundles to some installer) ExtensionsResolved Called when all extensions detected (from classpath scan, if enabled). Injector is under creation at that moment. Logging or remembering list of all enabled extensions (classes only) Guice injector created ExtensionsInstalledBy Called when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later. Logging of installed extensions. Extension instance could be obtained from injector and post processed. ExtensionsInstalled(?) Called after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled) Logging or extensions post processing ApplicationRun Called when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty is't start yet) and all guice singletons initialized. Point is just before Application.run method. Ideal point for jersey and jetty listeners installation (with shortcut methods in event). Jersey initialization (HK2) HK2Configuration HK2 context starting. Both jersey and jetty are starting. First point where ServiceLocator become available HK2ExtensionsInstalledBy Called when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty) Logging of installed extensions. Extension instance could be obtained from injector/locator and post processed. HK2ExtensionsInstalled(?) Called after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions) Logging or extensions post processing","title":"Lifecycle events"},{"location":"guide/events/#guicey-lifecycle-events","text":"Guicey broadcast lifecycle events in all major points. Each event provides access to all available state at this point. Events could be used for configuration analysis or to add some special post processing (e.g. post process modules before injector creation). Important Event listeners could not modify configuration itself (can't add new extensions, installers, bundles or disable anything).","title":"Guicey lifecycle events"},{"location":"guide/events/#debug","text":"Use bundle.printLifecyclePhases() to see lifecycle events in logs. Could be very helpful during problems investigation. Also, it shows startup timer to easily see where most startup time is spent. Example output: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.008 ]____________________________________________________/ 1 hooks processed \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.104 ]____________________________________________________/ 2 commands installed \\____ INFO [2018-06-15 04:09:56,978] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: / INFO [2018-06-15 04:09:56,981] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: / \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.881 ]____________________________________________________/ Configured from 3 (-1) GuiceyBundles \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.886 ]____________________________________________________/ Staring guice with 3/0 (-1) modules... \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.980 ]____________________________________________________/ 8 (-1) installers initialized \\____ \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:01.008 ]____________________________________________________/ 13 (-1) extensions found \\____ ... Note that (-1) in some events means disabled items and actual displayed count did not count disabled items. Use detailed output ( bundle.printLifecyclePhasesDetailed() ) to see more details. Example detailed output (for one event): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 __[ 00:00:00.893 ]____________________________________________________/ Configured from 3 (-1) GuiceyBundles \\____ bundles = DiagnosticBundle (r.v.d.g.m.c.debug) GuiceRestrictedConfigBundle (r.v.d.g.support.util) CoreInstallersBundle (r.v.d.g.m.installer) disabled = HK2DebugBundle (r.v.d.g.m.j.debug) Important Lifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events. Anyway, these logs intended to be used for problems resolution and so console only output should not be a problem.","title":"Debug"},{"location":"guide/events/#registration","text":"Events listener could be registered only through main bundle: GuiceBundle . builder () . listen ( new MyListener (), new MyOtherListener ()) ... . build () All events are listed in GuiceyLifecycle enum in execution order. Event listener could implement generic event interface GuiceyLifecycleListener and use enum to differentiate required events: public class MyListener implements GuiceyLifecycleListener { public void onEvent ( GuiceyLifecycleEvent event ) { switch ( event . getType ()) { case InjectorCreation : InjectorCreationEvent e = ( InjectorCreationEvent ) event ; ... } } } Or use GuiceyLifecycleAdapter adapter and override only required methods: public class MyListener extends GuiceyLifecycleAdapter { @Override protected void injectorCreation ( final InjectorCreationEvent event ) { ... } }","title":"Registration"},{"location":"guide/events/#bundles","text":"Event listeners could also be registered in guicey bundle, but not all events will be received by such events (as bundles processing is not first lifecycle phase). Aslo, such bundles can't be configuration hooks (because all hooks are already processed at this point).","title":"Bundles"},{"location":"guide/events/#context-modification","text":"Event listeners are not allowed to modify configuration, only observe it and, if required, post process instances (modules, bundles etc). But, if listener needs to register any additional extension it can implement GuiceyConfigrator interface to be automatically registered as configuration hook: public class MyDebuggingListener extends GuiceyLifecycleAdapter implements GuiceyConfigurationHook { @Override public void configure ( GuiceBundle . Builder builder ) { builder . extensions ( DebugExtension . class ) . bundles ( new DebugBundle ()) ... } @Override protected void injectorCreation ( final InjectorCreationEvent event ) { ... } }","title":"Context modification"},{"location":"guide/events/#event-structure","text":"All events inherit from base event classes. Event classes are extending each other: as initialisation phases go more objects become available. So you can access any available (at this point) object from event instance. Base event Description GuiceyLifecycleEvent The lowest event type. Initialization dropwizard phase. Provides access to event type and options. RunPhaseEvent Dropwizard run phase. Available Bootstrap, Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer InjectorPhaseEvent Guice injector created. Available injector and GuiceyCofigurationInfo (guicey configuration). Shortcuts for configuration reports renderer HK2PhaseEvent Jersey starting. ServiceLocator available.","title":"Event structure"},{"location":"guide/events/#events","text":"Note that some events may not been called - (?). Event Description Possible usage Dropwizard initialization phase HooksProcessed(?) Called after all registered GuiceyConfigurationHook processing Only for info Initialization Called after GuiceBundle initialization. If commands search is enabled then all found commands will be provided in event. Convenient moment to apply registrations into dropwizard Bootstrap object. Dropwizard run phase BeforeRun Meta event, called before guicey configuration just to indicate first point where Environment, Configuration and introspected configuration are available For example, used by bundle.printConfigurationBindings() to print configuration bindings before injector start (help with missed bindings debug) BundlesFromDwResolved(?) Called if configuration from dw bundles enabled and at least one bundle recognized (note: some of these bundles could be actually disabled and not used further) Logging or post processing of recognized bundles. BundlesFromLookupResolved(?) Called if at least one bundle recognized using bundles lookup (note: some of these bundles could be disabled and not used further) Logging or post processing of found bundles. BundlesResolved Called to indicate all top-level bundles (registered manually, from lookup and recognized dropwizard bundles). Called even if no bundles registered to indicate configuration state. Logging or post processing of top-level bundles. BundlesProcessed(?) Called after bundles processing. Note that bundles could register other bundles and so resulted list of installed bundles could be bigger (than in resolution event). Called only when at lest one bundle registered and not disabled. Logging of all used bundles or storing bundles list for modules (for example). InjectorCreation Called just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called, event if no modules registered. Logging or post processing modules (can't add or remove modules, but can manipulate module instance) InstallersResolved Called when installers resolved (from classpath scan, if enabled) and initialized. Injector is under creation at that moment. Logging or post processing of installers (e.g. set list of modules or bundles to some installer) ExtensionsResolved Called when all extensions detected (from classpath scan, if enabled). Injector is under creation at that moment. Logging or remembering list of all enabled extensions (classes only) Guice injector created ExtensionsInstalledBy Called when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later. Logging of installed extensions. Extension instance could be obtained from injector and post processed. ExtensionsInstalled(?) Called after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled) Logging or extensions post processing ApplicationRun Called when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty is't start yet) and all guice singletons initialized. Point is just before Application.run method. Ideal point for jersey and jetty listeners installation (with shortcut methods in event). Jersey initialization (HK2) HK2Configuration HK2 context starting. Both jersey and jetty are starting. First point where ServiceLocator become available HK2ExtensionsInstalledBy Called when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty) Logging of installed extensions. Extension instance could be obtained from injector/locator and post processed. HK2ExtensionsInstalled(?) Called after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions) Logging or extensions post processing","title":"Events"},{"location":"guide/injector/","text":"Injector instance \u00b6 Restrictive options \u00b6 Guicey itself is compatible with the following guice restrictive options: public class MyModule extends AbstractModule { @Override protected void configure () { binder (). disableCircularProxies (); binder (). requireExactBindingAnnotations (); binder (). requireExplicitBindings (); } } So it is safe to enable them. Access injector \u00b6 In some cases it may be important to get injector instance outside of guice context. Warning Injector is created on dropwizard run phase. Attempt to obtain injector before it will lead to exception. Injector instance could be resolved with: getInjector() method on GuiceBundle instance (NPE will be thrown if injector not initialized) InjectorLookup.getInjector(app).get() static call using application instance (lookup returns Optional for null safety). If you need lazy injector reference, you can use InjectorProvider class (it's actually Provider<Injector> ): Provider < Injector > provider = new InjectorProvider ( app ); // somewhere after run phase Injector injector = provider . get (); When you are inside your application class: public class MyApplication extends Application < Configuration > { @Override public void run ( TestConfiguration configuration , Environment environment ) throws Exception { InjectorLookup . getInjector ( this ). get () . getInstance ( SomeService . class ). doSomething (); } } Tip Most likely, requirement for injector instance means integration with some third party library. Consider writing custom installer in such cases (it will eliminate need for injector instance). Inside guice context you can simply inject Injector instance: @Inject Injector injector ; Injector factory \u00b6 You can control guice injector creation through ru.vyarus.dropwizard.guice.injector.InjectorFactory . Default implementation is very simple: public class DefaultInjectorFactory implements InjectorFactory { @Override public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return Guice . createInjector ( stage , modules ); } } Injector creation customization may be required by some 3 rd party library. For example, netflix governator owns injector creation ( see example ). Custom injector factory could be registered in guice bundle builder: bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new CustomInjectorFactory ()) ...","title":"Injector"},{"location":"guide/injector/#injector-instance","text":"","title":"Injector instance"},{"location":"guide/injector/#restrictive-options","text":"Guicey itself is compatible with the following guice restrictive options: public class MyModule extends AbstractModule { @Override protected void configure () { binder (). disableCircularProxies (); binder (). requireExactBindingAnnotations (); binder (). requireExplicitBindings (); } } So it is safe to enable them.","title":"Restrictive options"},{"location":"guide/injector/#access-injector","text":"In some cases it may be important to get injector instance outside of guice context. Warning Injector is created on dropwizard run phase. Attempt to obtain injector before it will lead to exception. Injector instance could be resolved with: getInjector() method on GuiceBundle instance (NPE will be thrown if injector not initialized) InjectorLookup.getInjector(app).get() static call using application instance (lookup returns Optional for null safety). If you need lazy injector reference, you can use InjectorProvider class (it's actually Provider<Injector> ): Provider < Injector > provider = new InjectorProvider ( app ); // somewhere after run phase Injector injector = provider . get (); When you are inside your application class: public class MyApplication extends Application < Configuration > { @Override public void run ( TestConfiguration configuration , Environment environment ) throws Exception { InjectorLookup . getInjector ( this ). get () . getInstance ( SomeService . class ). doSomething (); } } Tip Most likely, requirement for injector instance means integration with some third party library. Consider writing custom installer in such cases (it will eliminate need for injector instance). Inside guice context you can simply inject Injector instance: @Inject Injector injector ;","title":"Access injector"},{"location":"guide/injector/#injector-factory","text":"You can control guice injector creation through ru.vyarus.dropwizard.guice.injector.InjectorFactory . Default implementation is very simple: public class DefaultInjectorFactory implements InjectorFactory { @Override public Injector createInjector ( final Stage stage , final Iterable <? extends Module > modules ) { return Guice . createInjector ( stage , modules ); } } Injector creation customization may be required by some 3 rd party library. For example, netflix governator owns injector creation ( see example ). Custom injector factory could be registered in guice bundle builder: bootstrap . addBundle ( GuiceBundle . builder () . injectorFactory ( new CustomInjectorFactory ()) ...","title":"Injector factory"},{"location":"guide/installers/","text":"Installers \u00b6 Installer is a core integration concept: every extension point has it's own installer. Installers used for both auto scan and manual modes (the only difference is in manual mode classes specified manually). Installers itself are resolved using classpath scanning, so it's very easy to add custom installers (and possibly override default one by disabling it and registering alternative). All default installers are registered by CoreInstallersBundle How it works \u00b6 When installer recognize class, it binds it into guice binder.bind(foundClass) (or bind by installer if it support binding ). But extensions annotated with @LazyBinding are not bound to guice context. This may be useful to delay bean creation : by default, guice production stage will instantiate all registered beans. On run phase (after injector created) all found or manually provided extensions are installed by type or instantiated ( injector.getInstance(foundClass) ) and passed to installer to register extension within dropwizard (installation type is defined by installer). Installers are ordered . Each extension is installed by only one installer! If extension could be recognized by more then one installers, it will be installed only by first matching installer (according to installers order). Writing custom installer \u00b6 Installer should implement FeatureInstaller interface. It will be automatically registered if auto scan is enabled. To register manually use .installers() bundle option. Installer matches method implements feature detection logic. You can use FeatureUtils for type checks, because it's denies abstract classes. Method is called for classes found during scan to detect installable features and for classes directly specified with .extensions() bundle option to detect installer. Three types of installation supported. Installer should implement one or more of these interfaces: BindingInstaller allows custom guice bindings. If installer doesn't implement this interface simple bind(type) will be called to register in guice. TypeInstaller used for registration based on type (no instance created during installation). InstanceInstaller used for instance registration. Instance created using injector.getInstance(type) . JerseyInstaller used for registration of bindings in HK2 context. Note that extensions may use @LazyBinding annotation. In general case such extensions will not be registered in guice. In case of BindingInstaller , special hint will be passed and installer should decide how to handle it (may throw exception as not supported). BindingInstaller called in time of injector creation, whereas TypeInstaller and InstanceInstaller are called just after injector creation. JerseyInstaller is called on jersey start. Installers are not guice beans! So injections can't be used inside them. This is because installers also used during initialization phase and instantiated before injector creation. Example installer: public class CustomInstaller implements FeatureInstaller < CustomFeature > { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , CustomFeature . class ); } } Finds all CustomFeature derived classes and register them in guice (implicit registration - all classes matched by installer are registered in injector). Note that no installer interfaces were used, because guice registration is enough. Now suppose CustomFeature is a base class for our jersey extensions. Then installer will be: public class CustomInstaller implements FeatureInstaller < CustomFeature >, JerseyInstaller < CustomFeature > { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , CustomFeature . class ); } @Override public void install ( final AbstractBinder binder , final Class < CustomFeature > type ) { JerseyBinding . bindComponent ( binder , type , false , false ); } @Override public void report () { } } Tip For jersey installers see AbstractJerseyInstaller base class, containing common utilities. Ordering \u00b6 In order to support ordering , installer must implement Ordered interface. If installer doesn't implement it extensions will not be sorted, even if extensions has @Order annotations. As example, see ManagedInstaller Options \u00b6 Installer could also use guicey options : * it must implement WithOptions marker interface * or extend form InstallerOptionsSupport base class (implemented boilerplate) Reporting \u00b6 Installers report() method will be called after it finish installation of all found extensions. Report provides user visibility of installed extensions. To simplify reporting use predefined Reporter class. See example usage in ManagedInstaller INFO [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.support.feature.DummyManaged) For complex cases, reporter may be extended to better handle installed extensions. As examples see plugin installer reporter and provider installer reporter INFO [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins = Set<PluginInterface> (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1) (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2) Map<DummyPluginKey, PluginInterface> ONE (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1) TWO (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2) Generics \u00b6 Guicey brings generics-resolver which you can use in installers implementation. For example, to get extension interface parametrization: interface Extension < V > {} class ListExtension implements Extension < List < String >> {} GenericsResolver . resolve ( ListExtension . class ) . type ( Extension . class ) . genericType ( \"V\" ) == List < String > // (ParameterizedType) Guicey itself use it for: types resolution during configuration introspection ( ConfigTreeBuilder ) to introspect type hierarchy and recognize all jersey extensions ( JerseyProviderInstaller ) format type for console reporting ( ProviderReporter ) bing jersey extensions to correct types ( JerseyBinding )","title":"Installers"},{"location":"guide/installers/#installers","text":"Installer is a core integration concept: every extension point has it's own installer. Installers used for both auto scan and manual modes (the only difference is in manual mode classes specified manually). Installers itself are resolved using classpath scanning, so it's very easy to add custom installers (and possibly override default one by disabling it and registering alternative). All default installers are registered by CoreInstallersBundle","title":"Installers"},{"location":"guide/installers/#how-it-works","text":"When installer recognize class, it binds it into guice binder.bind(foundClass) (or bind by installer if it support binding ). But extensions annotated with @LazyBinding are not bound to guice context. This may be useful to delay bean creation : by default, guice production stage will instantiate all registered beans. On run phase (after injector created) all found or manually provided extensions are installed by type or instantiated ( injector.getInstance(foundClass) ) and passed to installer to register extension within dropwizard (installation type is defined by installer). Installers are ordered . Each extension is installed by only one installer! If extension could be recognized by more then one installers, it will be installed only by first matching installer (according to installers order).","title":"How it works"},{"location":"guide/installers/#writing-custom-installer","text":"Installer should implement FeatureInstaller interface. It will be automatically registered if auto scan is enabled. To register manually use .installers() bundle option. Installer matches method implements feature detection logic. You can use FeatureUtils for type checks, because it's denies abstract classes. Method is called for classes found during scan to detect installable features and for classes directly specified with .extensions() bundle option to detect installer. Three types of installation supported. Installer should implement one or more of these interfaces: BindingInstaller allows custom guice bindings. If installer doesn't implement this interface simple bind(type) will be called to register in guice. TypeInstaller used for registration based on type (no instance created during installation). InstanceInstaller used for instance registration. Instance created using injector.getInstance(type) . JerseyInstaller used for registration of bindings in HK2 context. Note that extensions may use @LazyBinding annotation. In general case such extensions will not be registered in guice. In case of BindingInstaller , special hint will be passed and installer should decide how to handle it (may throw exception as not supported). BindingInstaller called in time of injector creation, whereas TypeInstaller and InstanceInstaller are called just after injector creation. JerseyInstaller is called on jersey start. Installers are not guice beans! So injections can't be used inside them. This is because installers also used during initialization phase and instantiated before injector creation. Example installer: public class CustomInstaller implements FeatureInstaller < CustomFeature > { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , CustomFeature . class ); } } Finds all CustomFeature derived classes and register them in guice (implicit registration - all classes matched by installer are registered in injector). Note that no installer interfaces were used, because guice registration is enough. Now suppose CustomFeature is a base class for our jersey extensions. Then installer will be: public class CustomInstaller implements FeatureInstaller < CustomFeature >, JerseyInstaller < CustomFeature > { @Override public boolean matches ( final Class <?> type ) { return FeatureUtils . is ( type , CustomFeature . class ); } @Override public void install ( final AbstractBinder binder , final Class < CustomFeature > type ) { JerseyBinding . bindComponent ( binder , type , false , false ); } @Override public void report () { } } Tip For jersey installers see AbstractJerseyInstaller base class, containing common utilities.","title":"Writing custom installer"},{"location":"guide/installers/#ordering","text":"In order to support ordering , installer must implement Ordered interface. If installer doesn't implement it extensions will not be sorted, even if extensions has @Order annotations. As example, see ManagedInstaller","title":"Ordering"},{"location":"guide/installers/#options","text":"Installer could also use guicey options : * it must implement WithOptions marker interface * or extend form InstallerOptionsSupport base class (implemented boilerplate)","title":"Options"},{"location":"guide/installers/#reporting","text":"Installers report() method will be called after it finish installation of all found extensions. Report provides user visibility of installed extensions. To simplify reporting use predefined Reporter class. See example usage in ManagedInstaller INFO [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed = (ru.vyarus.dropwizard.guice.support.feature.DummyManaged) For complex cases, reporter may be extended to better handle installed extensions. As examples see plugin installer reporter and provider installer reporter INFO [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins = Set<PluginInterface> (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1) (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2) Map<DummyPluginKey, PluginInterface> ONE (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1) TWO (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)","title":"Reporting"},{"location":"guide/installers/#generics","text":"Guicey brings generics-resolver which you can use in installers implementation. For example, to get extension interface parametrization: interface Extension < V > {} class ListExtension implements Extension < List < String >> {} GenericsResolver . resolve ( ListExtension . class ) . type ( Extension . class ) . genericType ( \"V\" ) == List < String > // (ParameterizedType) Guicey itself use it for: types resolution during configuration introspection ( ConfigTreeBuilder ) to introspect type hierarchy and recognize all jersey extensions ( JerseyProviderInstaller ) format type for console reporting ( ProviderReporter ) bing jersey extensions to correct types ( JerseyBinding )","title":"Generics"},{"location":"guide/lifecycle/","text":"Integration lifecycle \u00b6 Jersey2 guice integration is more complicated than for jersey1, because of HK2 container, used by jersey2. Note Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it in the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase). For example, it is impossible to use HK2 to instantiate dropwizard managed object because managed must be registered before HK2 context starts. Guice integration done in guice exclusive way as much as possible: everything should be managed by guice and invisibly integrated into HK2. Anyway, it is not always possible to hide integration details, especially if you need to register jersey extensions. Tip You can use guicey lifecycle events to see initialization stages in logs: .printLifecyclePhases() Lifecycle \u00b6 Dropwizard configuration phase ( ~Application.initialize ) Apply configuration hooks Guice bundle registered Perform classpath scan for commands ( optional ) Dropwizard run phase ( ~Application.run ) Dropwizard runs bundles (guice bundle is one of them so guice initialization may be performed between other dropwizard bundles) Search guicey bundles in dropwizard bundles ( optional ) Lookup guicey bundles Apply configuration from guicey bundles Injector creation ( using factory ) Bind dropwizard objects : Environment, Configuration, Bootstrap Scan for installers (in auto configuration mode) Scan for extensions (in auto configuration mode) Register GuiceFeature in environment (jersey Feature which will trigger jersey side installations) Apply lazy jersey bindings Activate guice servlet support , register GuiceFilter on admin and main contexts ( could be disabled ) Injector created Call installers to register extensions Your application's run method executed. Injector is already available, so any guice bean could be accessed Jersey start Managed beans started HK2 context creation (jersey start) GuiceFeature (registered earlier) called Optionally register HK2-guice bridge (only guice to hk2 way to let hk2 managed beans inject guice beans) Run jersey specific installers ( resource , extension ) Note Any EnvironmentCommand did no start jersey, so managed objects will not be started. Also, all jersey related extensions will not be started. Still, core guice context will be completely operable. When guice context is created, jersey context doesn't exist and when jersey context is created it doesn't aware of guice existence . Cross context bindings \u00b6 Access jersey beans from guice \u00b6 To access HK2 bindings we need HK2 ServiceLocator : it's instance is registered by GuiceFeature (in time of HK2 context startup). Jersey components are bound as providers: binder . bind ( jerseyType ). toProvider ( new LazyJerseyProvider ( jerseyType )); Internally this provider will perform lookup in HK2 service locator: injector . getInstance ( ServiceLocator . class ). getService ( jerseyType ); This way jersey beans are \"bridged\" to guice. They can't be accessed directly in guice beans at injector creation time (as there is nothing to \"bridge\" yet). @Inject Provider < JerseyType > provider must be used to access such beans. See more details in jersey bindings module . Access guice beans from jersey \u00b6 Note It's almost never required to care about beans visibility from HK2 side because guicey already did all required bindings. HK2 could see all guice beans because of registered guice-bridge. But it doesn't mean HK2 can analyze all guice beans to search for extensions (it can resolve only direct injection). Specific jersey installers ( resource , extension ) create required bindings manually in time of HK2 context creation. Jersey extensions installer handles most specific installation cases (where HK2 knowledge is required). It uses the same technic, as the other side binding: binder . bindFactory ( new LazyGuiceProvider ( guiceType )). to ( type ) On request, factory will simply delegate lookup to guice injector: injector . getInstance ( guiceType ); Tip If you just want to add some beans in HK2 context, annotate such beans with @Provider and @HK2Managed - provider will be recognized by installer and HK2 managed annotation will trigger simple registration (overall it's the same as write binding manually). @HK2Managed @Provider public class MyBeanMangedByHK2 { ... } For more details look jersey provider installer Problematic cases \u00b6 The problems may appear with binding of jersey extensions. Good example is ValueFactoryProvider . Most likely you will use AbstractValueFactoryProvider as base class, but it declares direct binding for MultivaluedParameterExtractorProvider . So such bean would be impossible to create eagerly in guice context. There are two options to solve this: use @LazyBinding : bean instance will not be created together with guice context (when MultivaluedParameterExtractorProvider is not available), and creation will be initiated by HK2, when binding could be resolved. or use @HK2Managed this will delegate instance management to HK2, but still guice services may be injected . Note You may use HK2-first strategy and create all jersey extensions in HK2 instead of guice. In this case you can use @GuiceManaged annotation to delegate management back to guice. In other cases simply wrap jersey specific bindings into Provider .","title":"Integration lifecycle"},{"location":"guide/lifecycle/#integration-lifecycle","text":"Jersey2 guice integration is more complicated than for jersey1, because of HK2 container, used by jersey2. Note Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it in the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase). For example, it is impossible to use HK2 to instantiate dropwizard managed object because managed must be registered before HK2 context starts. Guice integration done in guice exclusive way as much as possible: everything should be managed by guice and invisibly integrated into HK2. Anyway, it is not always possible to hide integration details, especially if you need to register jersey extensions. Tip You can use guicey lifecycle events to see initialization stages in logs: .printLifecyclePhases()","title":"Integration lifecycle"},{"location":"guide/lifecycle/#lifecycle","text":"Dropwizard configuration phase ( ~Application.initialize ) Apply configuration hooks Guice bundle registered Perform classpath scan for commands ( optional ) Dropwizard run phase ( ~Application.run ) Dropwizard runs bundles (guice bundle is one of them so guice initialization may be performed between other dropwizard bundles) Search guicey bundles in dropwizard bundles ( optional ) Lookup guicey bundles Apply configuration from guicey bundles Injector creation ( using factory ) Bind dropwizard objects : Environment, Configuration, Bootstrap Scan for installers (in auto configuration mode) Scan for extensions (in auto configuration mode) Register GuiceFeature in environment (jersey Feature which will trigger jersey side installations) Apply lazy jersey bindings Activate guice servlet support , register GuiceFilter on admin and main contexts ( could be disabled ) Injector created Call installers to register extensions Your application's run method executed. Injector is already available, so any guice bean could be accessed Jersey start Managed beans started HK2 context creation (jersey start) GuiceFeature (registered earlier) called Optionally register HK2-guice bridge (only guice to hk2 way to let hk2 managed beans inject guice beans) Run jersey specific installers ( resource , extension ) Note Any EnvironmentCommand did no start jersey, so managed objects will not be started. Also, all jersey related extensions will not be started. Still, core guice context will be completely operable. When guice context is created, jersey context doesn't exist and when jersey context is created it doesn't aware of guice existence .","title":"Lifecycle"},{"location":"guide/lifecycle/#cross-context-bindings","text":"","title":"Cross context bindings"},{"location":"guide/lifecycle/#access-jersey-beans-from-guice","text":"To access HK2 bindings we need HK2 ServiceLocator : it's instance is registered by GuiceFeature (in time of HK2 context startup). Jersey components are bound as providers: binder . bind ( jerseyType ). toProvider ( new LazyJerseyProvider ( jerseyType )); Internally this provider will perform lookup in HK2 service locator: injector . getInstance ( ServiceLocator . class ). getService ( jerseyType ); This way jersey beans are \"bridged\" to guice. They can't be accessed directly in guice beans at injector creation time (as there is nothing to \"bridge\" yet). @Inject Provider < JerseyType > provider must be used to access such beans. See more details in jersey bindings module .","title":"Access jersey beans from guice"},{"location":"guide/lifecycle/#access-guice-beans-from-jersey","text":"Note It's almost never required to care about beans visibility from HK2 side because guicey already did all required bindings. HK2 could see all guice beans because of registered guice-bridge. But it doesn't mean HK2 can analyze all guice beans to search for extensions (it can resolve only direct injection). Specific jersey installers ( resource , extension ) create required bindings manually in time of HK2 context creation. Jersey extensions installer handles most specific installation cases (where HK2 knowledge is required). It uses the same technic, as the other side binding: binder . bindFactory ( new LazyGuiceProvider ( guiceType )). to ( type ) On request, factory will simply delegate lookup to guice injector: injector . getInstance ( guiceType ); Tip If you just want to add some beans in HK2 context, annotate such beans with @Provider and @HK2Managed - provider will be recognized by installer and HK2 managed annotation will trigger simple registration (overall it's the same as write binding manually). @HK2Managed @Provider public class MyBeanMangedByHK2 { ... } For more details look jersey provider installer","title":"Access guice beans from jersey"},{"location":"guide/lifecycle/#problematic-cases","text":"The problems may appear with binding of jersey extensions. Good example is ValueFactoryProvider . Most likely you will use AbstractValueFactoryProvider as base class, but it declares direct binding for MultivaluedParameterExtractorProvider . So such bean would be impossible to create eagerly in guice context. There are two options to solve this: use @LazyBinding : bean instance will not be created together with guice context (when MultivaluedParameterExtractorProvider is not available), and creation will be initiated by HK2, when binding could be resolved. or use @HK2Managed this will delegate instance management to HK2, but still guice services may be injected . Note You may use HK2-first strategy and create all jersey extensions in HK2 instead of guice. In this case you can use @GuiceManaged annotation to delegate management back to guice. In other cases simply wrap jersey specific bindings into Provider .","title":"Problematic cases"},{"location":"guide/module-autowiring/","text":"Module autowiring \u00b6 Because guice modules are registered in dropwizard init section only Bootstrap instance is available. Often Environment and Configuration objects are also required. Autowiring interfaces \u00b6 Guicey can automatically inject environment objects into your module if it implements any of (or all of them): BootstrapAwareModule - access bootstrap instance EnvironmentAwareModule - access environment instance ConfigurationAwareModule - access configuration instance ConfigurationTreeAwareModule - access to configuration values by path OptionsAwareModule - access guicey options Reference object will be set to module just before injector creation, so you can use it inside your module logic ( configuration method). Warning Module autowiring will only work for modules directly set to modules() (of main bundle or any guicey bundle). public class MyModule implements EnvironmentAwareModule { private Environemnt environment ; @Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @Override protected void configure () { // use environment here } } Autowiring base class \u00b6 To avoid manually implementing interfaces (avoid boilerplate) you can use DropwizardAwareModule as base class which already implements all autowiring interfaces: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { bootstrap () // Bootstrap instance environment () // Environment instance configuration () // MyConfiguration instance appPackage () // application class package configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) options () // access guicey options } } Options \u00b6 Options could be used in guice module to access guicey configurations: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { // empty when guicey servlet support is dasabled if ( options .< EnumSet > get ( GuiceyOptions . GuiceFilterRegistration ). isEmtpy ()) { // do nothing } else { // register servlet module } } } Or it could be some custom options usage. Tip If you are going to register module inside guicey bundle, you can simply resolve option value inside guicey bundle and pass it to module directly. Configuration access \u00b6 Tip If you are going to register module inside guicey bundle, you can simply resolve configuration object inside guicey bundle and pass it to module directly (bundle has absolutely the same configuration access methods) Unique feature config \u00b6 When working with re-usable modules, it could be handy to rely on unique configuration object: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { XFeatureConfig conf = configuration ( XFeatureConfig . class ); ... } } Note that this module doesn't known exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt ) it will be different unique config. Access by path \u00b6 When you are not sure that configuration is unique, you can rely on exact path definition: public class XFeatureModule extends DropwizardAwareModule < Configuration > { private String path ; public XFeatureModule ( String path ) { this . path = path ; } @Override protected void configure () { XFeatureConfig conf = configuration ( path ); ... } } Path is declared by module user, who knows required configuration location: GuiceBundle . builder () . modules ( new XFeatureModule ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... } Multiple configs \u00b6 In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { List < XFeatureConfig > confs = configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } It wil return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses too. So if there are XFeatureConfigExt declared somewhere it will also be returned. Custom configuration analysis \u00b6 In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = configurationTree (). findAllRootPathsFrom ( MyConfig . class ); List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, module search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ). See introspected configuration structure description","title":"Module autowiring"},{"location":"guide/module-autowiring/#module-autowiring","text":"Because guice modules are registered in dropwizard init section only Bootstrap instance is available. Often Environment and Configuration objects are also required.","title":"Module autowiring"},{"location":"guide/module-autowiring/#autowiring-interfaces","text":"Guicey can automatically inject environment objects into your module if it implements any of (or all of them): BootstrapAwareModule - access bootstrap instance EnvironmentAwareModule - access environment instance ConfigurationAwareModule - access configuration instance ConfigurationTreeAwareModule - access to configuration values by path OptionsAwareModule - access guicey options Reference object will be set to module just before injector creation, so you can use it inside your module logic ( configuration method). Warning Module autowiring will only work for modules directly set to modules() (of main bundle or any guicey bundle). public class MyModule implements EnvironmentAwareModule { private Environemnt environment ; @Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } @Override protected void configure () { // use environment here } }","title":"Autowiring interfaces"},{"location":"guide/module-autowiring/#autowiring-base-class","text":"To avoid manually implementing interfaces (avoid boilerplate) you can use DropwizardAwareModule as base class which already implements all autowiring interfaces: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { bootstrap () // Bootstrap instance environment () // Environment instance configuration () // MyConfiguration instance appPackage () // application class package configuratonTree () // configuration as tree of values confuguration ( Class ) // unique sub configuration configuration ( String ) // configuration value by yaml path configurations ( Class ) // sub configuration objects by type (including subtypes) options () // access guicey options } }","title":"Autowiring base class"},{"location":"guide/module-autowiring/#options","text":"Options could be used in guice module to access guicey configurations: public class MyModule extends DropwizardAwareModule < MyConfiguration > { @Override protected void configure () { // empty when guicey servlet support is dasabled if ( options .< EnumSet > get ( GuiceyOptions . GuiceFilterRegistration ). isEmtpy ()) { // do nothing } else { // register servlet module } } } Or it could be some custom options usage. Tip If you are going to register module inside guicey bundle, you can simply resolve option value inside guicey bundle and pass it to module directly.","title":"Options"},{"location":"guide/module-autowiring/#configuration-access","text":"Tip If you are going to register module inside guicey bundle, you can simply resolve configuration object inside guicey bundle and pass it to module directly (bundle has absolutely the same configuration access methods)","title":"Configuration access"},{"location":"guide/module-autowiring/#unique-feature-config","text":"When working with re-usable modules, it could be handy to rely on unique configuration object: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { XFeatureConfig conf = configuration ( XFeatureConfig . class ); ... } } Note that this module doesn't known exact type of user configuration, it just assumes that XFeatureConfig is declared somewhere in configuration (on any level) just once. For example: public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; ... } Important Object uniqueness checked by exact type match, so if configuration also contains some extending class ( XFeatureConfigExt ) it will be different unique config.","title":"Unique feature config"},{"location":"guide/module-autowiring/#access-by-path","text":"When you are not sure that configuration is unique, you can rely on exact path definition: public class XFeatureModule extends DropwizardAwareModule < Configuration > { private String path ; public XFeatureModule ( String path ) { this . path = path ; } @Override protected void configure () { XFeatureConfig conf = configuration ( path ); ... } } Path is declared by module user, who knows required configuration location: GuiceBundle . builder () . modules ( new XFeatureModule ( \"sub.feature\" )) ... . build () Where public class MyConfig extends Configuration { @JsonProperty private SubConfig sub = { // pseudo code to combine class declarations @JsonProperty private XFeatureConfig feature ; } ... }","title":"Access by path"},{"location":"guide/module-autowiring/#multiple-configs","text":"In case, when multiple config objects could be declared in user configuration, you can access all of them: public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { List < XFeatureConfig > confs = configurations ( XFeatureConfig . class ); ... } } For configuration public class MyConfig extends Configuration { @JsonProperty private XFeatureConfig xfeature ; @JsonProperty private XFeatureConfig xfeature2 ; ... } It wil return both objects: [xfeature, xfeature2] Important In contrast to unique configurations, this method returns all subclasses too. So if there are XFeatureConfigExt declared somewhere it will also be returned.","title":"Multiple configs"},{"location":"guide/module-autowiring/#custom-configuration-analysis","text":"In all other cases (with more complex requirements) you can use ConfigurationTree object which represents introspected configuration paths. public class XFeatureModule extends DropwizardAwareModule < Configuration > { @Override protected void configure () { // get all properties of custom configuration (ignoring properties from base classes) List < ConfigPath > paths = configurationTree (). findAllRootPathsFrom ( MyConfig . class ); List markedTypes = paths . stream () . filter ( it -> it . getValue () != null && it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) . map ( it -> it . getValue ()) . collect ( Collectors . toList ()); ... } } In this example, module search for properties declared directly in MyConfig configuration class with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ). See introspected configuration structure description","title":"Custom configuration analysis"},{"location":"guide/options/","text":"Options \u00b6 Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific, options are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours. Options are declared with enums. Enums used to naturally group options (also cause pretty reporting). Enums must implement Option interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum), but provides required option info). Guicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through GuiceyOptions enum (for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle). Another use is in web installers to change default behaviour though InstallersOptions enum. Custom options may be defined for 3 rd party bundle or even application. Options is a general mechanism providing configuration and access points with standard reporting (part of diagnostic reporting ). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize application state in tests (just to name a few). Usage \u00b6 Options may be set only in main GuiceBundle using .option method. This is important to let configuration parts to see the same values. For example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and, for sure, this will eventually lead to inconsistent behaviour. Option could not be set to null. Option could be null only if it's default value is null and custom value not set. Custom option value is checked for compatibility with option type (from option definition) and error thrown if does not match. Of course, type checking is limited to top class and generics are ignored (so List<String> could not be specified and so can't be checked), but it's a compromise between complexity and easy of use (the same as Enum & Option pair). Options could be accessed by: Guicey bundles using bootstrap.option() Installer by implementing WithOptions interface Any guice bean could inject Options bean and use it to access options. Guice module could access options by implementing OptionsAwareModule marker interface Guicey tracks options definition and usage and report all used options as part of diagnostic reporting . Pay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options. Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used. Try to consume options closer to actual usage to let user be aware if option not used with current configuration. For example, GuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used. Custom options \u00b6 Options must be enum and implement Option interface, like this: enum MyOptions implements Option { DoExtraWork ( Boolean , true ), EnableDebug ( Boolean , false ), InternalConfig ( String [], new String []{ \"one\" , \"two\" , \"three\" }); private Class type private Object value // generic used only to check type - value correctness < T > SampleOptions ( Class < T > type , T value ) { this . type = type this . value = value } @Override public Class getType () { return type } @Override public Object getDefaultValue () { return value } } Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value. This will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []). Now you can use option, for example, in bean: import static MyOptions.DoExtraWork ; public class MyBean { @Inject Options options ; pulic void someMethod () { ... if ( options . get ( DoExtraWork )) { // extra work impl } } } To provide custom option value: GuiceBundle . builder () . option ( DoExtraWork , false ) ... Options lookup \u00b6 Guicey provides simple mapping utility to map properties to system properties, environment variables or simply bind from string (obtained manually somewhere). GuiceBundle . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . env ( \"STAGE\" , GuiceyOptions . InjectorStage ) . string ( Myoptions . SomeOtherOption , \"property value\" ) . map ()) . build () Here: Myoptions.SomeOption could be changed with \"myprop\" system property ( -Dmyprop=something ) GuiceyOptions.InjectorStage could be changed with environment variable \"STAGE\" Myoptions.SomeOtherOption set from string (string could be obtained somewhere else manually) Important Missed mappings are ignored: e.g. if system property or environment variable is not defined - option will remain with default value (null will not be set!) Supported conversions \u00b6 Each option declares required option type Mapper could automatically convert string to: String Boolean Integer Double Short Byte Enum constant: If option type is exact enum then value must be constant name If option type is generic Enum then value must be 'fullEnumClass.constantName' Array or any type (from above): values must be separated by comma (\"one, two, three\") EnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName') Tip You can use sting conversion directly somewhere else, if required: StringConverter.convert(TargetType, stringValue) Exception is thrown when type is not supported for conversion. In this case use manual converter: new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . map () Converter is actually any java.util.Function (here, lambda with method call ( ::convertVal )). System properties \u00b6 As shown before, you can bind single system property to option. But you can allso allow to set any option with system property: new OptionsMapper (). props (). map () It will bind all properties in format: option.enumClasName.enumValue . For example, -Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true Different prefix could be used: .props(\"myprefix\") Warning All properties with matched prefix must be mappable to option (target enum exists), otherwise error will be thrown. If any property requires custom value conversion then bind it before with converter and it will be ignored during mass mapping by prefix: new OptionsMapper () . prop ( \"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\" , GuiceyOptions . UseHkBridge , val - > convert ( val )) . props () . map () Debug \u00b6 You can enable mapped options print with .printMappings() : new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . printMappings () . map () When enabled, all mapped options will be printed to console (logger is not used becuase it's not yet initialized). Example output: env: VAR Opts.OptInt = 1 prop: foo Opts.OptStr = bar Opts.OptBool = true for mapper: new OptionsMapper () . printMappings () . env ( \"VAR\" , Opts . OptInt ) . env ( \"VAR2\" , Opts . OptDbl ) . prop ( \"foo\" , Opts . OptStr ) . prop ( \"foo2\" , Opts . OptShort ) . string ( Opts . OptBool , \"true\" ) . map () Here \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped. Custom lookup \u00b6 You can directly specify map of options ( .options(Map<Enum, Object>) ) or write your own lookup mechanism: GuiceBundle . builder () . options ( new MyOptionsLookup (). getOptions ()) ... .options() method contract simplified for just Enum , excluding Option for simpler usage, but still only option enums must be provided","title":"Options"},{"location":"guide/options/#options","text":"Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific, options are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours. Options are declared with enums. Enums used to naturally group options (also cause pretty reporting). Enums must implement Option interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum), but provides required option info). Guicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through GuiceyOptions enum (for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle). Another use is in web installers to change default behaviour though InstallersOptions enum. Custom options may be defined for 3 rd party bundle or even application. Options is a general mechanism providing configuration and access points with standard reporting (part of diagnostic reporting ). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize application state in tests (just to name a few).","title":"Options"},{"location":"guide/options/#usage","text":"Options may be set only in main GuiceBundle using .option method. This is important to let configuration parts to see the same values. For example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and, for sure, this will eventually lead to inconsistent behaviour. Option could not be set to null. Option could be null only if it's default value is null and custom value not set. Custom option value is checked for compatibility with option type (from option definition) and error thrown if does not match. Of course, type checking is limited to top class and generics are ignored (so List<String> could not be specified and so can't be checked), but it's a compromise between complexity and easy of use (the same as Enum & Option pair). Options could be accessed by: Guicey bundles using bootstrap.option() Installer by implementing WithOptions interface Any guice bean could inject Options bean and use it to access options. Guice module could access options by implementing OptionsAwareModule marker interface Guicey tracks options definition and usage and report all used options as part of diagnostic reporting . Pay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options. Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used. Try to consume options closer to actual usage to let user be aware if option not used with current configuration. For example, GuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.","title":"Usage"},{"location":"guide/options/#custom-options","text":"Options must be enum and implement Option interface, like this: enum MyOptions implements Option { DoExtraWork ( Boolean , true ), EnableDebug ( Boolean , false ), InternalConfig ( String [], new String []{ \"one\" , \"two\" , \"three\" }); private Class type private Object value // generic used only to check type - value correctness < T > SampleOptions ( Class < T > type , T value ) { this . type = type this . value = value } @Override public Class getType () { return type } @Override public Object getDefaultValue () { return value } } Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value. This will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []). Now you can use option, for example, in bean: import static MyOptions.DoExtraWork ; public class MyBean { @Inject Options options ; pulic void someMethod () { ... if ( options . get ( DoExtraWork )) { // extra work impl } } } To provide custom option value: GuiceBundle . builder () . option ( DoExtraWork , false ) ...","title":"Custom options"},{"location":"guide/options/#options-lookup","text":"Guicey provides simple mapping utility to map properties to system properties, environment variables or simply bind from string (obtained manually somewhere). GuiceBundle . builder () ... . options ( new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption ) . env ( \"STAGE\" , GuiceyOptions . InjectorStage ) . string ( Myoptions . SomeOtherOption , \"property value\" ) . map ()) . build () Here: Myoptions.SomeOption could be changed with \"myprop\" system property ( -Dmyprop=something ) GuiceyOptions.InjectorStage could be changed with environment variable \"STAGE\" Myoptions.SomeOtherOption set from string (string could be obtained somewhere else manually) Important Missed mappings are ignored: e.g. if system property or environment variable is not defined - option will remain with default value (null will not be set!)","title":"Options lookup"},{"location":"guide/options/#supported-conversions","text":"Each option declares required option type Mapper could automatically convert string to: String Boolean Integer Double Short Byte Enum constant: If option type is exact enum then value must be constant name If option type is generic Enum then value must be 'fullEnumClass.constantName' Array or any type (from above): values must be separated by comma (\"one, two, three\") EnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName') Tip You can use sting conversion directly somewhere else, if required: StringConverter.convert(TargetType, stringValue) Exception is thrown when type is not supported for conversion. In this case use manual converter: new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . map () Converter is actually any java.util.Function (here, lambda with method call ( ::convertVal )).","title":"Supported conversions"},{"location":"guide/options/#system-properties","text":"As shown before, you can bind single system property to option. But you can allso allow to set any option with system property: new OptionsMapper (). props (). map () It will bind all properties in format: option.enumClasName.enumValue . For example, -Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true Different prefix could be used: .props(\"myprefix\") Warning All properties with matched prefix must be mappable to option (target enum exists), otherwise error will be thrown. If any property requires custom value conversion then bind it before with converter and it will be ignored during mass mapping by prefix: new OptionsMapper () . prop ( \"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\" , GuiceyOptions . UseHkBridge , val - > convert ( val )) . props () . map ()","title":"System properties"},{"location":"guide/options/#debug","text":"You can enable mapped options print with .printMappings() : new OptionsMapper () . prop ( \"myprop\" , Myoptions . SomeOption , val -> convertVal ( val )) . printMappings () . map () When enabled, all mapped options will be printed to console (logger is not used becuase it's not yet initialized). Example output: env: VAR Opts.OptInt = 1 prop: foo Opts.OptStr = bar Opts.OptBool = true for mapper: new OptionsMapper () . printMappings () . env ( \"VAR\" , Opts . OptInt ) . env ( \"VAR2\" , Opts . OptDbl ) . prop ( \"foo\" , Opts . OptStr ) . prop ( \"foo2\" , Opts . OptShort ) . string ( Opts . OptBool , \"true\" ) . map () Here \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped.","title":"Debug"},{"location":"guide/options/#custom-lookup","text":"You can directly specify map of options ( .options(Map<Enum, Object>) ) or write your own lookup mechanism: GuiceBundle . builder () . options ( new MyOptionsLookup (). getOptions ()) ... .options() method contract simplified for just Enum , excluding Option for simpler usage, but still only option enums must be provided","title":"Custom lookup"},{"location":"guide/ordering/","text":"Ordering \u00b6 Guicey @Order annotation should be used to order extensions and installers. General \u00b6 Order is natural. For example, @Order(10) will be before @Order(20) . When no annotation present, class order set to Integer . MAX_VALUE , so all classes without order annotation are always goes last. Extensions order \u00b6 Note Not all extensions supports ordering: look specific installer page for details. For example, managed, lifecycle, servlets and filters installers support order. Tip Installers supporting ordering implement Ordered interface. The most common case for ordering is ordering managed objects. For example: @Order ( 20 ) public class Managed1 implements Managed { ... } @Order ( 10 ) public class Managed2 implements Managed { ... } public class Managed3 implements Managed { ... } Will be ordered as: Managed2 , Managed1 , Managed3 Note Guicey remembers extensions registration order: . extensions ( Ext1 . class , Ext2 . class ) So when no explicit ordering defined (or for elements with the same order value) registration order will be preserved. Tip Console reporters for most extensions report extensions in correct order. You can use diagnostic reporting to be sure about actual extensions order. Installers order \u00b6 All bundled installers are ordered from 0 to ~110 with gap 10 between them to let you easily put your installers between (if required). Use @Order annotation to order custom installer, otherwise it will go after all default installers. Bundles order \u00b6 Attention Guicey bundles does not support ordering. It makes no sense to order guicey bundles because they simply register other extensions and installers. You can always order installers and extensions registered by bundles. Moreover, bundles are transitive, so it would be extremely hard to understand actual order: for example, when bundle registered both transitively and manually. There are implicit order of bundle processing: Manually registered bundles (including transitive) Dropwizard bundles (when recognition enabled) Bundles lookup But, again, don't count on this order because, for example, bundle resolved through lookup mechanism could be also manually registered and so installed as manual bundle. Modules order \u00b6 Attention Guicey does not support modules ordering. It makes no sense to order guice modules because they simply register bindings. According to guice guice: modules should not contain conditional logic So all that modules should do is registering bindings and order does not matter in that case. Modules, registered directly in guice bundle, must be executed before modules, registered in bundles (because registration order is preserved).","title":"Ordering"},{"location":"guide/ordering/#ordering","text":"Guicey @Order annotation should be used to order extensions and installers.","title":"Ordering"},{"location":"guide/ordering/#general","text":"Order is natural. For example, @Order(10) will be before @Order(20) . When no annotation present, class order set to Integer . MAX_VALUE , so all classes without order annotation are always goes last.","title":"General"},{"location":"guide/ordering/#extensions-order","text":"Note Not all extensions supports ordering: look specific installer page for details. For example, managed, lifecycle, servlets and filters installers support order. Tip Installers supporting ordering implement Ordered interface. The most common case for ordering is ordering managed objects. For example: @Order ( 20 ) public class Managed1 implements Managed { ... } @Order ( 10 ) public class Managed2 implements Managed { ... } public class Managed3 implements Managed { ... } Will be ordered as: Managed2 , Managed1 , Managed3 Note Guicey remembers extensions registration order: . extensions ( Ext1 . class , Ext2 . class ) So when no explicit ordering defined (or for elements with the same order value) registration order will be preserved. Tip Console reporters for most extensions report extensions in correct order. You can use diagnostic reporting to be sure about actual extensions order.","title":"Extensions order"},{"location":"guide/ordering/#installers-order","text":"All bundled installers are ordered from 0 to ~110 with gap 10 between them to let you easily put your installers between (if required). Use @Order annotation to order custom installer, otherwise it will go after all default installers.","title":"Installers order"},{"location":"guide/ordering/#bundles-order","text":"Attention Guicey bundles does not support ordering. It makes no sense to order guicey bundles because they simply register other extensions and installers. You can always order installers and extensions registered by bundles. Moreover, bundles are transitive, so it would be extremely hard to understand actual order: for example, when bundle registered both transitively and manually. There are implicit order of bundle processing: Manually registered bundles (including transitive) Dropwizard bundles (when recognition enabled) Bundles lookup But, again, don't count on this order because, for example, bundle resolved through lookup mechanism could be also manually registered and so installed as manual bundle.","title":"Bundles order"},{"location":"guide/ordering/#modules-order","text":"Attention Guicey does not support modules ordering. It makes no sense to order guice modules because they simply register bindings. According to guice guice: modules should not contain conditional logic So all that modules should do is registering bindings and order does not matter in that case. Modules, registered directly in guice bundle, must be executed before modules, registered in bundles (because registration order is preserved).","title":"Modules order"},{"location":"guide/scan/","text":"Classpath scan \u00b6 Summary Use scan only for application package. When part of application extracted to it's own library (usually already mature part) create guicey bundle for it with explicit extensions definition. Use manual bundles installation or bundle lookup mechanism to install custom bundles. Configuration \u00b6 Classpath scanning is activated by specifying package to scan in bundle: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) Or multiple packages: GuiceBundle . builder () . enableAutoConfig ( \"com.mycompany.pkg1\" , \"com.mycompany.pkg2\" ) How it works \u00b6 When auto scan enabled: Extension installers are searched in classpath (classes implementing FeatureInstaller ). Extensions are searched using registered installers ( FeatureInstaller#matches method). If commands search is enabled ( .searchCommands() ), performs search for all classes extending Command and install them into bootstrap . Classes are searched in specified packages and all their subpackages. Abstract classes are ignored. Inner static classes are also resolved: public abstract class AbstractExceptionMapper < T extends Exception > implements ExceptionMapper < T > { @Provider public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } @Provider public static class BarExceptionMapper extends AbstractExceptionMapper < ServletException > { ... } } FooExceptionMapper and BarExceptionMapper would be detected and installed. Hide class from scan \u00b6 @InvisibleForScanner annotation hides class from scanner (for example, to install it manually or to avoid installation at all) @Provider @InvisibleForScanner public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } In this case FooExceptionMapper will be ignored by classpath scanner. But you still can install extension manually. Tip If you can't use annotation on extension for some reson, you can simply disable extension Motivation \u00b6 Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like reflections , fast scanner or even jersey's internal classpath scan parse class structure instead of loading classes. In general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. Moreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple). Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer. Actual application configuration could always be checked with diagnostic output ), so there should not be any problems for using classpath scan for production too. Warning It's a bad idea to use classpath scan for resolving extensions from 3 rd party jars. Group extensions from external jars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, so it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions. If you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup (enabled by default) which could load bundles with service loader definition .","title":"Classpath scan"},{"location":"guide/scan/#classpath-scan","text":"Summary Use scan only for application package. When part of application extracted to it's own library (usually already mature part) create guicey bundle for it with explicit extensions definition. Use manual bundles installation or bundle lookup mechanism to install custom bundles.","title":"Classpath scan"},{"location":"guide/scan/#configuration","text":"Classpath scanning is activated by specifying package to scan in bundle: GuiceBundle . builder () . enableAutoConfig ( \"package.to.scan\" ) Or multiple packages: GuiceBundle . builder () . enableAutoConfig ( \"com.mycompany.pkg1\" , \"com.mycompany.pkg2\" )","title":"Configuration"},{"location":"guide/scan/#how-it-works","text":"When auto scan enabled: Extension installers are searched in classpath (classes implementing FeatureInstaller ). Extensions are searched using registered installers ( FeatureInstaller#matches method). If commands search is enabled ( .searchCommands() ), performs search for all classes extending Command and install them into bootstrap . Classes are searched in specified packages and all their subpackages. Abstract classes are ignored. Inner static classes are also resolved: public abstract class AbstractExceptionMapper < T extends Exception > implements ExceptionMapper < T > { @Provider public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } @Provider public static class BarExceptionMapper extends AbstractExceptionMapper < ServletException > { ... } } FooExceptionMapper and BarExceptionMapper would be detected and installed.","title":"How it works"},{"location":"guide/scan/#hide-class-from-scan","text":"@InvisibleForScanner annotation hides class from scanner (for example, to install it manually or to avoid installation at all) @Provider @InvisibleForScanner public static class FooExceptionMapper extends AbstractExceptionMapper < IOException > { ... } In this case FooExceptionMapper will be ignored by classpath scanner. But you still can install extension manually. Tip If you can't use annotation on extension for some reson, you can simply disable extension","title":"Hide class from scan"},{"location":"guide/scan/#motivation","text":"Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like reflections , fast scanner or even jersey's internal classpath scan parse class structure instead of loading classes. In general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. Moreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple). Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer. Actual application configuration could always be checked with diagnostic output ), so there should not be any problems for using classpath scan for production too. Warning It's a bad idea to use classpath scan for resolving extensions from 3 rd party jars. Group extensions from external jars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, so it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions. If you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup (enabled by default) which could load bundles with service loader definition .","title":"Motivation"},{"location":"guide/test/","text":"Testing \u00b6 Test support require io.dropwizard:dropwizard-testing:1.3.0 dependency. General test support \u00b6 Configuration hooks \u00b6 Guicey provides hooks mechanism to be able to modify application configuration in tests. Using hooks you can disable installers, extensions, guicey bundles or override guice bindings. It may also be useful to register additional extensions (e.g. to validate some internal behaviour). Example hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . disableModules ( FeatureXModule . class ) . disable ( inPackage ( \"com.foo.feature\" )) . modulesOverride ( new MockDaoModule ()) . option ( Myoptions . DebugOption , true ); } } Note You can modify options in hook and so could enable some custom debug/monitoring options specifically for test. There are special spock and junit extensions for hooks registrations. Disables \u00b6 You can use hooks to disable all not needed features in test: installers extensions guice modules guicey bundles This way you can isolate (as possible) some feature for testing. The most helpful should be bundles disable (if you use bundles for features grouping) and guice modules. Use predicate disabling . Note It is supposed that disabling will be used instead of mocking - you simply remove what you don't need and register replacements, if required. Guice bindings override \u00b6 It is quite common requirement to override bindings for testing. For example, you may want to mock database access. Guicey could use guice Modules.override() to help you override required bindings. To use it prepare module only with changed bindings (bindings that must override existing). For example, you want to replace ServiceX. You have few options: If it implement interface, implement your own service and bind as bind(ServiceContract.class).to(MyServiceXImpl.class) If service is a class, you can modify its behaviour with extended class bind(ServiceX.class).to(MyServiceXExt.class) Or you can simply register some mock instance bind(ServiceX.class).toInstance(myMockInstance) public class MyOverridingModule extends AbstractModule { protected configure () { bind ( ServiceX . class ). to ( MyServiceXExt . class ); } } And register overriding module in hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . modulesOverride ( new MyOverridingModule ()); } } Debug bundles \u00b6 You can also use special guicey bundles, which modify application behaviour. Bundles could contain additional listeners or services to gather additional metrics during tests or validate behaviour. For example, guicey tests use bundle to enable restricted guice options like disableCircularProxies . Bundles are also able to: disable installers, extensions, gucie modules override guice bindings You can use lookup mechanism to load bundles in tests. For example, system properties lookup . Junit \u00b6 Testing core logic \u00b6 For integration testing of guice specific logic you can use GuiceyAppRule . It works almost like DropwizardAppRule , but doesn't start jetty (and so jersey and guice web modules will not be initialized). Managed and lifecycle objects supported. public class MyTest { @Rule GuiceyAppRule < MyConfiguration > RULE = new GuiceyAppRule <>( MyApplication . class , \"path/to/configuration.yaml\" ); public void testSomething () { RULE . getBean ( MyService . class ). doSomething (); ... } } As with dropwizard rule, configuration is optional new GuiceyAppRule <>( MyApplication . class , null ) Testing web logic \u00b6 For web component tests (servlets, filters, resources) use DropwizardAppRule . To access guice beans use injector lookup: InjectorLookup . getInjector ( RULE . getApplication ()). getBean ( MyService . class ); Customizing guicey configuration \u00b6 As described above guicey provides a way to modify it's configuration in tests. You can apply configuration hook using rule: // there may be exact class instead of lambda new GuiceyConfigurationRule (( builder ) -> builder . modules (...)) To use it with DropwizardAppRule or GuiceyAppRule you will have to apply explicit order: static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( new GuiceyConfigurationRule (( builder ) -> builder . modules (...))) . around ( RULE ); Attention RuleChain is required because rules execution order is not guaranteed and configuration rule must obviously be executed before application rule. If you need to declare configurations common for all tests then declare rule instace in base test class and use it in chain (at each test): public class BaseTest { // IMPORTANT no @ClassRule annotation here! static GuiceyConfigurationRule BASE = new GuiceyConfigurationRule (( builder ) -> builder . modules (...)) } public class SomeTest extends BaseTest { static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( BASE ) // optional test-specific staff . around ( new GuiceyConfigurationRule (( builder ) -> builder . modules (...)) . around ( RULE ); } Warning Don't use configuration rule with spock becuase it will not work. Use special spock extension instead. Testing startup errors \u00b6 If exception occur on startup dropwizard will call System . exit ( 1 ) instead of throwing exception (as it was before 1.1.0). System exit could be intercepted with system rules . Special rule is provided to simplify work with system rules: StartupErrorRule . It's a combination of exit and out/err outputs interception rules. To use this rule add dependency: com.github.stefanbirkner:system-rules:1.16.0 public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } This test will pass only if application will throw exception during startup. In junit it is impossible to apply checks after exit statement, so such checks must be registered as a special callback: public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (( out , err ) -> { Assert . assertTrue ( out . contains ( \"some log line\" )); Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } Note that err will contain full exception stack trace and so you can check exception type too by using contains statement like above. Check callback(s) may be added after rule creation: @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () throws Exception { RULE . checkAfterExit (( out , err ) -> { Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); ... } Multiple check callbacks may be registered (even if the first one was registered in rule's create call). Rule works a bit differently with spock (see below). Spock \u00b6 If you use spock framework you can use spock specific extensions: @UseGuiceyApp - internally use GuiceyAppRule @UseDropwizardApp - internally use DropwizardAppRule Both extensions allows using injections directly in specifications (like spock-guice). @UseGuiceyConfiguration extension could be used to apply configuration hook common for all tests Spock lifecycle hooks \u00b6 class MyTest extends Specification { @ClassRule @Shared JunitRule sharedRule = new JunitRule () @Rule JunitRule2 rule = new JunitRule2 () def setupSpec () { } def setup () { } def \"Test method body\" () { setup: } } Class rules are applied once per test class (same as setupSpec ). Rules are applied per test method (same as setup ). Setup order: Class rule Setup spec method Rule Setup method Test method's setup section @UseGuiceyApp \u00b6 @UseGuiceyApp runs all guice logic without starting jetty (so resources, servlets and filters are not available). Managed objects are handled correctly. @UseGuiceyApp ( MyApplication ) class AutoScanModeTest extends Specification { @Inject MyService service def \"My service test\" { when: 'calling service' def res = service . getSmth () then: 'correct result returned' res == 'hello' } Annotation allows you to configure the same things as rules does: application class, configuration file (optional), configuration overrides. @UseGuiceyApp ( value = MyApplication , config = 'path/to/my/config.yml' , configOverride = [ @ConfigOverride ( key = \"foo\" , value = \"2\" ), @ConfigOverride ( key = \"bar\" , value = \"12\" ) ]) class ConfigOverrideTest extends Specification { As with rules, configOverride may be used without setting config file (simply to fill some configurations) @UseDropwizardApp \u00b6 @UseDropwizardApp is useful for complete integration testing (when web part is required): @UseDropwizardApp ( MyApplication ) class WebModuleTest extends Specification { @Inject MyService service def \"Check web bindings\" () { when: \"calling filter\" def res = new URL ( \"http://localhost:8080/dummyFilter\" ). getText () then: \"filter active\" res == 'Sample filter and service called' service . isCalled () Annotation supports the same configuration options as @UseGuiceyApp (see above) Customizing guicey configuration \u00b6 As described above guicey provides a way to modify it's configuration in tests. You can declare custom configuration hooks directly in extension annotations (described above): @UseDropwizardApp ( value = MyApplication , hooks = MyHook ) or @UseGuiceyApp ( value = MyApplication , hooks = MyHook ) Where MyHook is: class MyHook implements GuiceyConfigurationHook {} When you need to register configurations common for all tests, declare hook at the base test class: UseGuiceyConfiguration ( MyBaseHook ) class BaseTest extends Specification { } @UseGuiceyApp ( App ) class SomeTest extends BaseTest {} Note You can still use test specific hooks together with declared base hook (to apply some more test-specific configuration). Warning Only one @UseGuiceyConfiguration declaration may be used in test hierarchy: for example, you can't declare it in base class and then another one on extended class - base for a group of tests. This is spock limitation (only one extension will actually work) but should not be an issue for most cases. Dropwizard startup error \u00b6 StartupErrorRule may be used to intercept dropwizard System . exit ( 1 ) call. But it will work different then for junit: then section is always called with exception ( CheckExitCalled ). Also, then section may be used for assertion after exit calls and so there is no need to add custom assertion callbacks (required by junit tests). class ErrorTest extends Specification { @Rule StartupErrorRule RULE = StartupErrorRule . create () def \"Check startup error\" () { when: \"starting app with error\" new MyErrApp (). main ([ 'server' ]) then: \"startup failed\" thrown ( RULE . indicatorExceptionType ) RULE . output . contains ( 'stating application' ) RULE . error . contains ( 'some error occur' ) Spock extensions details \u00b6 Extensions follow spock-guice style - application started once for all tests in class. It's the same as using rule with @ClassRule annotation. Rules may be used with spock too (the same way as in junit), but don't mix them with annotation extensions. There are two limitations comparing to rules: Application can't be created for each test separately (like with @Rule annotation). This is because of @Shared instances support. You can't customize application creation: application class must have no-args constructor (with rules you can extend rule class and override newApplication method). But this should be rare requirement. All guicey tests use spock, so you can see extensions usage examples there. To better understand injection scopes look the following test: @UseGuiceyApp ( AutoScanApplication ) class InjectionTest extends Specification { // instance remain the same between tests @Shared @Inject TestBean sharedBean // new instance injected on each test @Inject TestBean bean // the same context used for all tests (in class), so the same bean instance inserted before each test @Inject TestSingletonBean singletonBean def \"Check injection types\" () { when: \"changing state of injected beans\" sharedBean . value = 10 bean . value = 5 singletonBean . value = 15 then: \"instances are different\" sharedBean . value == 10 bean . value == 5 singletonBean . value == 15 } def \"Check shared state\" () { expect: \"shared bean instance is the same, whereas other one re-injected\" sharedBean . value == 10 bean . value == 0 singletonBean . value == 15 // the same instance was set before second test } // bean is in prototype scope static class TestBean { int value } @Singleton static class TestSingletonBean { int value } } Overriding overridden beans \u00b6 Guicey provides direct support for overriding guice bindings , so in most cases you don't need to do anything. But, if you use this to override application bindings need to override such bindings in test (again), then you may use provided custom injector factory : Register factory in guice bundle: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) After that you can register overriding bindings (which will override even modules registered in modulesOverride ) with: BindingsOverrideInjectorFactory . override ( new MyOverridingModule ()) Important It is assumed that overrding modules registration and application initialization will be at the same thread (thread local used for holding registered modules to allow parallel tests usage). For example, suppose we have some service CustomerService and it's implementation CustomerServiceImpl , defined in some 3 rd party module. For some reason we need to override this binding in the application: public class OverridingModule extends AbstractModule { @Override protected void configure () { bind ( CustomerService . class ). to ( CustomCustomerServiceImpl . class ); } } If we need to override this binding in test (again): (Simplified) registration looks like this: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) . modules ( new ThirdPatyModule ()) // override binding for application needs . modulesOverride ( new OverridingModule ()) ... . build () // register overriding somewhere BindingsOverrideInjectorFactory . override ( new TestOverridingModule ()) Tip Configuration hook may be used for static call (as a good integration point) After test startup, application will use customer service binding from TestOverridingModule.","title":"Test"},{"location":"guide/test/#testing","text":"Test support require io.dropwizard:dropwizard-testing:1.3.0 dependency.","title":"Testing"},{"location":"guide/test/#general-test-support","text":"","title":"General test support"},{"location":"guide/test/#configuration-hooks","text":"Guicey provides hooks mechanism to be able to modify application configuration in tests. Using hooks you can disable installers, extensions, guicey bundles or override guice bindings. It may also be useful to register additional extensions (e.g. to validate some internal behaviour). Example hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . disableModules ( FeatureXModule . class ) . disable ( inPackage ( \"com.foo.feature\" )) . modulesOverride ( new MockDaoModule ()) . option ( Myoptions . DebugOption , true ); } } Note You can modify options in hook and so could enable some custom debug/monitoring options specifically for test. There are special spock and junit extensions for hooks registrations.","title":"Configuration hooks"},{"location":"guide/test/#disables","text":"You can use hooks to disable all not needed features in test: installers extensions guice modules guicey bundles This way you can isolate (as possible) some feature for testing. The most helpful should be bundles disable (if you use bundles for features grouping) and guice modules. Use predicate disabling . Note It is supposed that disabling will be used instead of mocking - you simply remove what you don't need and register replacements, if required.","title":"Disables"},{"location":"guide/test/#guice-bindings-override","text":"It is quite common requirement to override bindings for testing. For example, you may want to mock database access. Guicey could use guice Modules.override() to help you override required bindings. To use it prepare module only with changed bindings (bindings that must override existing). For example, you want to replace ServiceX. You have few options: If it implement interface, implement your own service and bind as bind(ServiceContract.class).to(MyServiceXImpl.class) If service is a class, you can modify its behaviour with extended class bind(ServiceX.class).to(MyServiceXExt.class) Or you can simply register some mock instance bind(ServiceX.class).toInstance(myMockInstance) public class MyOverridingModule extends AbstractModule { protected configure () { bind ( ServiceX . class ). to ( MyServiceXExt . class ); } } And register overriding module in hook: public class MyHook implements GuiceyConfigurationHook { public void configure ( GuiceBundle . Builder builder ) { builder . modulesOverride ( new MyOverridingModule ()); } }","title":"Guice bindings override"},{"location":"guide/test/#debug-bundles","text":"You can also use special guicey bundles, which modify application behaviour. Bundles could contain additional listeners or services to gather additional metrics during tests or validate behaviour. For example, guicey tests use bundle to enable restricted guice options like disableCircularProxies . Bundles are also able to: disable installers, extensions, gucie modules override guice bindings You can use lookup mechanism to load bundles in tests. For example, system properties lookup .","title":"Debug bundles"},{"location":"guide/test/#junit","text":"","title":"Junit"},{"location":"guide/test/#testing-core-logic","text":"For integration testing of guice specific logic you can use GuiceyAppRule . It works almost like DropwizardAppRule , but doesn't start jetty (and so jersey and guice web modules will not be initialized). Managed and lifecycle objects supported. public class MyTest { @Rule GuiceyAppRule < MyConfiguration > RULE = new GuiceyAppRule <>( MyApplication . class , \"path/to/configuration.yaml\" ); public void testSomething () { RULE . getBean ( MyService . class ). doSomething (); ... } } As with dropwizard rule, configuration is optional new GuiceyAppRule <>( MyApplication . class , null )","title":"Testing core logic"},{"location":"guide/test/#testing-web-logic","text":"For web component tests (servlets, filters, resources) use DropwizardAppRule . To access guice beans use injector lookup: InjectorLookup . getInjector ( RULE . getApplication ()). getBean ( MyService . class );","title":"Testing web logic"},{"location":"guide/test/#customizing-guicey-configuration","text":"As described above guicey provides a way to modify it's configuration in tests. You can apply configuration hook using rule: // there may be exact class instead of lambda new GuiceyConfigurationRule (( builder ) -> builder . modules (...)) To use it with DropwizardAppRule or GuiceyAppRule you will have to apply explicit order: static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( new GuiceyConfigurationRule (( builder ) -> builder . modules (...))) . around ( RULE ); Attention RuleChain is required because rules execution order is not guaranteed and configuration rule must obviously be executed before application rule. If you need to declare configurations common for all tests then declare rule instace in base test class and use it in chain (at each test): public class BaseTest { // IMPORTANT no @ClassRule annotation here! static GuiceyConfigurationRule BASE = new GuiceyConfigurationRule (( builder ) -> builder . modules (...)) } public class SomeTest extends BaseTest { static GuiceyAppRule RULE = new GuiceyAppRule ( App . class , null ); @ClassRule public static RuleChain chain = RuleChain . outerRule ( BASE ) // optional test-specific staff . around ( new GuiceyConfigurationRule (( builder ) -> builder . modules (...)) . around ( RULE ); } Warning Don't use configuration rule with spock becuase it will not work. Use special spock extension instead.","title":"Customizing guicey configuration"},{"location":"guide/test/#testing-startup-errors","text":"If exception occur on startup dropwizard will call System . exit ( 1 ) instead of throwing exception (as it was before 1.1.0). System exit could be intercepted with system rules . Special rule is provided to simplify work with system rules: StartupErrorRule . It's a combination of exit and out/err outputs interception rules. To use this rule add dependency: com.github.stefanbirkner:system-rules:1.16.0 public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } This test will pass only if application will throw exception during startup. In junit it is impossible to apply checks after exit statement, so such checks must be registered as a special callback: public class MyErrTest { @Rule public StartupErrorRule RULE = StartupErrorRule . create (( out , err ) -> { Assert . assertTrue ( out . contains ( \"some log line\" )); Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); public void testSomething () { new MyErrApp (). main ( ' server ' ); } } Note that err will contain full exception stack trace and so you can check exception type too by using contains statement like above. Check callback(s) may be added after rule creation: @Rule public StartupErrorRule RULE = StartupErrorRule . create (); public void testSomething () throws Exception { RULE . checkAfterExit (( out , err ) -> { Assert . assertTrue ( err . contains ( \"expected exception message\" )); }); ... } Multiple check callbacks may be registered (even if the first one was registered in rule's create call). Rule works a bit differently with spock (see below).","title":"Testing startup errors"},{"location":"guide/test/#spock","text":"If you use spock framework you can use spock specific extensions: @UseGuiceyApp - internally use GuiceyAppRule @UseDropwizardApp - internally use DropwizardAppRule Both extensions allows using injections directly in specifications (like spock-guice). @UseGuiceyConfiguration extension could be used to apply configuration hook common for all tests","title":"Spock"},{"location":"guide/test/#spock-lifecycle-hooks","text":"class MyTest extends Specification { @ClassRule @Shared JunitRule sharedRule = new JunitRule () @Rule JunitRule2 rule = new JunitRule2 () def setupSpec () { } def setup () { } def \"Test method body\" () { setup: } } Class rules are applied once per test class (same as setupSpec ). Rules are applied per test method (same as setup ). Setup order: Class rule Setup spec method Rule Setup method Test method's setup section","title":"Spock lifecycle hooks"},{"location":"guide/test/#useguiceyapp","text":"@UseGuiceyApp runs all guice logic without starting jetty (so resources, servlets and filters are not available). Managed objects are handled correctly. @UseGuiceyApp ( MyApplication ) class AutoScanModeTest extends Specification { @Inject MyService service def \"My service test\" { when: 'calling service' def res = service . getSmth () then: 'correct result returned' res == 'hello' } Annotation allows you to configure the same things as rules does: application class, configuration file (optional), configuration overrides. @UseGuiceyApp ( value = MyApplication , config = 'path/to/my/config.yml' , configOverride = [ @ConfigOverride ( key = \"foo\" , value = \"2\" ), @ConfigOverride ( key = \"bar\" , value = \"12\" ) ]) class ConfigOverrideTest extends Specification { As with rules, configOverride may be used without setting config file (simply to fill some configurations)","title":"@UseGuiceyApp"},{"location":"guide/test/#usedropwizardapp","text":"@UseDropwizardApp is useful for complete integration testing (when web part is required): @UseDropwizardApp ( MyApplication ) class WebModuleTest extends Specification { @Inject MyService service def \"Check web bindings\" () { when: \"calling filter\" def res = new URL ( \"http://localhost:8080/dummyFilter\" ). getText () then: \"filter active\" res == 'Sample filter and service called' service . isCalled () Annotation supports the same configuration options as @UseGuiceyApp (see above)","title":"@UseDropwizardApp"},{"location":"guide/test/#customizing-guicey-configuration_1","text":"As described above guicey provides a way to modify it's configuration in tests. You can declare custom configuration hooks directly in extension annotations (described above): @UseDropwizardApp ( value = MyApplication , hooks = MyHook ) or @UseGuiceyApp ( value = MyApplication , hooks = MyHook ) Where MyHook is: class MyHook implements GuiceyConfigurationHook {} When you need to register configurations common for all tests, declare hook at the base test class: UseGuiceyConfiguration ( MyBaseHook ) class BaseTest extends Specification { } @UseGuiceyApp ( App ) class SomeTest extends BaseTest {} Note You can still use test specific hooks together with declared base hook (to apply some more test-specific configuration). Warning Only one @UseGuiceyConfiguration declaration may be used in test hierarchy: for example, you can't declare it in base class and then another one on extended class - base for a group of tests. This is spock limitation (only one extension will actually work) but should not be an issue for most cases.","title":"Customizing guicey configuration"},{"location":"guide/test/#dropwizard-startup-error","text":"StartupErrorRule may be used to intercept dropwizard System . exit ( 1 ) call. But it will work different then for junit: then section is always called with exception ( CheckExitCalled ). Also, then section may be used for assertion after exit calls and so there is no need to add custom assertion callbacks (required by junit tests). class ErrorTest extends Specification { @Rule StartupErrorRule RULE = StartupErrorRule . create () def \"Check startup error\" () { when: \"starting app with error\" new MyErrApp (). main ([ 'server' ]) then: \"startup failed\" thrown ( RULE . indicatorExceptionType ) RULE . output . contains ( 'stating application' ) RULE . error . contains ( 'some error occur' )","title":"Dropwizard startup error"},{"location":"guide/test/#spock-extensions-details","text":"Extensions follow spock-guice style - application started once for all tests in class. It's the same as using rule with @ClassRule annotation. Rules may be used with spock too (the same way as in junit), but don't mix them with annotation extensions. There are two limitations comparing to rules: Application can't be created for each test separately (like with @Rule annotation). This is because of @Shared instances support. You can't customize application creation: application class must have no-args constructor (with rules you can extend rule class and override newApplication method). But this should be rare requirement. All guicey tests use spock, so you can see extensions usage examples there. To better understand injection scopes look the following test: @UseGuiceyApp ( AutoScanApplication ) class InjectionTest extends Specification { // instance remain the same between tests @Shared @Inject TestBean sharedBean // new instance injected on each test @Inject TestBean bean // the same context used for all tests (in class), so the same bean instance inserted before each test @Inject TestSingletonBean singletonBean def \"Check injection types\" () { when: \"changing state of injected beans\" sharedBean . value = 10 bean . value = 5 singletonBean . value = 15 then: \"instances are different\" sharedBean . value == 10 bean . value == 5 singletonBean . value == 15 } def \"Check shared state\" () { expect: \"shared bean instance is the same, whereas other one re-injected\" sharedBean . value == 10 bean . value == 0 singletonBean . value == 15 // the same instance was set before second test } // bean is in prototype scope static class TestBean { int value } @Singleton static class TestSingletonBean { int value } }","title":"Spock extensions details"},{"location":"guide/test/#overriding-overridden-beans","text":"Guicey provides direct support for overriding guice bindings , so in most cases you don't need to do anything. But, if you use this to override application bindings need to override such bindings in test (again), then you may use provided custom injector factory : Register factory in guice bundle: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) After that you can register overriding bindings (which will override even modules registered in modulesOverride ) with: BindingsOverrideInjectorFactory . override ( new MyOverridingModule ()) Important It is assumed that overrding modules registration and application initialization will be at the same thread (thread local used for holding registered modules to allow parallel tests usage). For example, suppose we have some service CustomerService and it's implementation CustomerServiceImpl , defined in some 3 rd party module. For some reason we need to override this binding in the application: public class OverridingModule extends AbstractModule { @Override protected void configure () { bind ( CustomerService . class ). to ( CustomCustomerServiceImpl . class ); } } If we need to override this binding in test (again): (Simplified) registration looks like this: GuiceBundle . builder () . injectorFactory ( new BindingsOverrideInjectorFactory ()) . modules ( new ThirdPatyModule ()) // override binding for application needs . modulesOverride ( new OverridingModule ()) ... . build () // register overriding somewhere BindingsOverrideInjectorFactory . override ( new TestOverridingModule ()) Tip Configuration hook may be used for static call (as a good integration point) After test startup, application will use customer service binding from TestOverridingModule.","title":"Overriding overridden beans"},{"location":"guide/web/","text":"Web features \u00b6 Guice ServletModule support \u00b6 By default, GuiceFilter is registered for both application and admin contexts. And so request and session scopes will be be available in both contexts. Also it makes injection of request and response objects available with provider (in any bean). To register servlets and filters for main context use ServletModule , e.g. public class WebModule extends ServletModule { @Override protected void configureServlets () { filter ( \"/*\" ). through ( MyFilter . class ) serve ( \"/myservlet\" ). with ( MyServlet . class ) } } Request scoped beans \u00b6 You can use request scoped beans in both main and admin contexts. @RequestScoped public class MyRequestScopedBean { ... } To obtain bean reference use provider: Provider < MyRequestScopedBean > myBeanProvider ; You can inject request and response objects in any bean: Provider < HttpServletRequest > requestProvider Provider < HttpServletResponse > responseProvider Limitations \u00b6 By default, GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types use option: . option ( GuiceyOptions . GuiceFilterRegistration , EnumSet . of ( REQUEST , FORWARD )) Warning Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register GuiceFilter for ASYNC type). Use web installers for such cases. Warning GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and there may be problems combining servlets from ServletModule and filters in main scope. Disable ServletModule support \u00b6 If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support: GuiceBundle . builder () . noGuiceFilter () It will: Avoid registration of GuiceFilter in both contexts Remove request and session guice scopes support (because no ServletModule registered) Prevent installation of any ServletModule (error will be thrown indicating duplicate binding) HttpServletRequest and HttpServletResponse still may be injected in resources with Provider (but it will not be possible to use such injections in servlets, filters or any other place) Disabling saves about ~50ms of startup time. Web installers \u00b6 Servlet api 3.0 provides @WebServlet , @WebFilter and @WebListener annotations, but they are not recognized in dropwizard (because dropwizard does not depend on jersey-annotations module). Web installers recognize this annotations and register guice-managed filters, servlets and listeners instances. Web installers are disabled by default. To eable: GuiceBundle . builder () . useWebInstallers () It will register WebInstallersBundle . Web installers are not enabled by default, because dropwizard is primarily rest oriented framework and you may not use custom servlets and filters at all (so no need to spent time trying to recognize them). Moreover, using standard servlet api annotations may confuse users and so it must be user decision to enable such support. Other developers should be guided bu option name and its javadoc (again to avoid confusion, no matter that it will work exactly as expected) Differences with GuiceServlet module \u00b6 There is a difference between using web installers and registering servlets and filters with guice servlet module . Guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Web installers use guice only for filter or servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata). In many cases, annotations are more convenient way to declare servlet or filter registration comparing to servlet module. Tip Using annotations you can register async servlets and filters (with annotations asyncSupported=true option). In contrast, it is impossible to register async with guice servlet module. Admin context \u00b6 By default, web installers (servlet, filter, listener) target application context. If you want to install into admin context then use @AdminContext annotation. For example: @AdminContext @WebServlet ( \"/mapped\" ) public class MyServlet extneds HttpServlet { ... } Will install servlet in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebServlet ( \"/mapped\" ) public class MyServlet extneds HttpServlet { ... } In example above, servlet registered in both contexts.","title":"Web"},{"location":"guide/web/#web-features","text":"","title":"Web features"},{"location":"guide/web/#guice-servletmodule-support","text":"By default, GuiceFilter is registered for both application and admin contexts. And so request and session scopes will be be available in both contexts. Also it makes injection of request and response objects available with provider (in any bean). To register servlets and filters for main context use ServletModule , e.g. public class WebModule extends ServletModule { @Override protected void configureServlets () { filter ( \"/*\" ). through ( MyFilter . class ) serve ( \"/myservlet\" ). with ( MyServlet . class ) } }","title":"Guice ServletModule support"},{"location":"guide/web/#request-scoped-beans","text":"You can use request scoped beans in both main and admin contexts. @RequestScoped public class MyRequestScopedBean { ... } To obtain bean reference use provider: Provider < MyRequestScopedBean > myBeanProvider ; You can inject request and response objects in any bean: Provider < HttpServletRequest > requestProvider Provider < HttpServletResponse > responseProvider","title":"Request scoped beans"},{"location":"guide/web/#limitations","text":"By default, GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types use option: . option ( GuiceyOptions . GuiceFilterRegistration , EnumSet . of ( REQUEST , FORWARD )) Warning Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register GuiceFilter for ASYNC type). Use web installers for such cases. Warning GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and there may be problems combining servlets from ServletModule and filters in main scope.","title":"Limitations"},{"location":"guide/web/#disable-servletmodule-support","text":"If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support: GuiceBundle . builder () . noGuiceFilter () It will: Avoid registration of GuiceFilter in both contexts Remove request and session guice scopes support (because no ServletModule registered) Prevent installation of any ServletModule (error will be thrown indicating duplicate binding) HttpServletRequest and HttpServletResponse still may be injected in resources with Provider (but it will not be possible to use such injections in servlets, filters or any other place) Disabling saves about ~50ms of startup time.","title":"Disable ServletModule support"},{"location":"guide/web/#web-installers","text":"Servlet api 3.0 provides @WebServlet , @WebFilter and @WebListener annotations, but they are not recognized in dropwizard (because dropwizard does not depend on jersey-annotations module). Web installers recognize this annotations and register guice-managed filters, servlets and listeners instances. Web installers are disabled by default. To eable: GuiceBundle . builder () . useWebInstallers () It will register WebInstallersBundle . Web installers are not enabled by default, because dropwizard is primarily rest oriented framework and you may not use custom servlets and filters at all (so no need to spent time trying to recognize them). Moreover, using standard servlet api annotations may confuse users and so it must be user decision to enable such support. Other developers should be guided bu option name and its javadoc (again to avoid confusion, no matter that it will work exactly as expected)","title":"Web installers"},{"location":"guide/web/#differences-with-guiceservlet-module","text":"There is a difference between using web installers and registering servlets and filters with guice servlet module . Guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Web installers use guice only for filter or servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata). In many cases, annotations are more convenient way to declare servlet or filter registration comparing to servlet module. Tip Using annotations you can register async servlets and filters (with annotations asyncSupported=true option). In contrast, it is impossible to register async with guice servlet module.","title":"Differences with GuiceServlet module"},{"location":"guide/web/#admin-context","text":"By default, web installers (servlet, filter, listener) target application context. If you want to install into admin context then use @AdminContext annotation. For example: @AdminContext @WebServlet ( \"/mapped\" ) public class MyServlet extneds HttpServlet { ... } Will install servlet in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebServlet ( \"/mapped\" ) public class MyServlet extneds HttpServlet { ... } In example above, servlet registered in both contexts.","title":"Admin context"},{"location":"installers/eager/","text":"Eager singleton installer \u00b6 CoreInstallersBundle / EagerSingletonInstaller Recognition \u00b6 Detects classes annotated with @EagerSingleton annotation and register them in guice injector. It is equivalent of eager singleton registration bind ( type ). asEagerSingleton () . Useful in case when you have bean not injected by other beans (so guice can't register it through aot). Normally, you would have to manually register such bean in module. Most likely, such bean will contain initialization logic. Ideal for cases not directly covered by installers. For example: @EagerSingleton public class MyListener implements LifeCycle . Listener { @Inject public MyListener ( Environment environment ) { environment . lifecicle . addListener ( this ); } } Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener. May be used in conjunction with @PostConstruct annotations (e.g. using ext-annotations ): installer finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should be used for quick prototyping only.","title":"Eager singleton"},{"location":"installers/eager/#eager-singleton-installer","text":"CoreInstallersBundle / EagerSingletonInstaller","title":"Eager singleton installer"},{"location":"installers/eager/#recognition","text":"Detects classes annotated with @EagerSingleton annotation and register them in guice injector. It is equivalent of eager singleton registration bind ( type ). asEagerSingleton () . Useful in case when you have bean not injected by other beans (so guice can't register it through aot). Normally, you would have to manually register such bean in module. Most likely, such bean will contain initialization logic. Ideal for cases not directly covered by installers. For example: @EagerSingleton public class MyListener implements LifeCycle . Listener { @Inject public MyListener ( Environment environment ) { environment . lifecicle . addListener ( this ); } } Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener. May be used in conjunction with @PostConstruct annotations (e.g. using ext-annotations ): installer finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should be used for quick prototyping only.","title":"Recognition"},{"location":"installers/filter/","text":"Web filter installer \u00b6 WebInstallersBundle / WebFilterInstaller Web installers are not enabled by default. Enable it with bundle . useWebInstallers () . Register new filter in main or admin contexts. Recognition \u00b6 Detects classes annotated with @javax.servlet.annotation.WebFilter annotation and register them in dropwizard environment. @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Only the following annotation properties are supported: filterName , urlPatterns (or value ), servletNames , dispatcherTypes , initParams , asyncSupported . Warning Url patterns and servlet names can't be used at the same time. Filter name is not required. If name not provided, then it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off. For example, for class \"MyCoolFilter\" generated name will be \".mycool\". Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } There is a difference between using filter installer and registering filters with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata). Async \u00b6 Example of async filter definition: @WebFilter ( urlPatterns = \"/asyncfilter\" , asyncSupported = true ) public class AsyncFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { final AsyncContext context = request . startAsync (); context . start (() -> { context . getResponse (). writer . write ( \"done!\" ); context . complete (); }); } @Override public void destroy () { } } Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters. Admin context \u00b6 By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... }","title":"Web filter"},{"location":"installers/filter/#web-filter-installer","text":"WebInstallersBundle / WebFilterInstaller Web installers are not enabled by default. Enable it with bundle . useWebInstallers () . Register new filter in main or admin contexts.","title":"Web filter installer"},{"location":"installers/filter/#recognition","text":"Detects classes annotated with @javax.servlet.annotation.WebFilter annotation and register them in dropwizard environment. @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Only the following annotation properties are supported: filterName , urlPatterns (or value ), servletNames , dispatcherTypes , initParams , asyncSupported . Warning Url patterns and servlet names can't be used at the same time. Filter name is not required. If name not provided, then it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off. For example, for class \"MyCoolFilter\" generated name will be \".mycool\". Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } There is a difference between using filter installer and registering filters with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).","title":"Recognition"},{"location":"installers/filter/#async","text":"Example of async filter definition: @WebFilter ( urlPatterns = \"/asyncfilter\" , asyncSupported = true ) public class AsyncFilter implements Filter { @Override public void init ( FilterConfig filterConfig ) throws ServletException { } @Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { final AsyncContext context = request . startAsync (); context . start (() -> { context . getResponse (). writer . write ( \"done!\" ); context . complete (); }); } @Override public void destroy () { } } Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters.","title":"Async"},{"location":"installers/filter/#admin-context","text":"By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... } Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebFilter ( \"/some/*\" ) public class MyFilter implements Filter { ... }","title":"Admin context"},{"location":"installers/healthcheck/","text":"Health check installer \u00b6 CoreInstallersBundle / HealthCheckInstaller Installs dropwizard health check . Recognition \u00b6 Detects classes extending guicey NamedHealthCheck and register their instances in environment. Custom base class is required, because default HealthCheck did not provide check name, which is required for registration. public class MyHealthCheck extends NamedHealthCheck { @Inject private MyService service ; @Override protected Result check () throws Exception { if ( service . isOk ()) { return Result . healthy (); } else { return Result . unhealthy ( \"Service is not ok\" ); } } @Override public String getName () { return \"my-service\" ; } }","title":"Health check"},{"location":"installers/healthcheck/#health-check-installer","text":"CoreInstallersBundle / HealthCheckInstaller Installs dropwizard health check .","title":"Health check installer"},{"location":"installers/healthcheck/#recognition","text":"Detects classes extending guicey NamedHealthCheck and register their instances in environment. Custom base class is required, because default HealthCheck did not provide check name, which is required for registration. public class MyHealthCheck extends NamedHealthCheck { @Inject private MyService service ; @Override protected Result check () throws Exception { if ( service . isOk ()) { return Result . healthy (); } else { return Result . unhealthy ( \"Service is not ok\" ); } } @Override public String getName () { return \"my-service\" ; } }","title":"Recognition"},{"location":"installers/jersey-ext/","text":"Jersey extension installer \u00b6 CoreInstallersBundle / JerseyProviderInstaller Installs various jersey extensions, usually annotated with jersey @Provider annotation and installed via environment . jersey (). register () : Factory, ExceptionMapper, ValueFactoryProvider, InjectionResolver, ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener Recognition \u00b6 Detects classes annotated with jersey @javax.ws.rs.ext.Provider annotation and register their instances in jersey. Extensions registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Special @Protptype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used). Due to specifics of HK2 integration , you may need to use: @HK2Managed to delegate bean creation to HK2 @LazyBinding to delay bean creation to time when all dependencies will be available javax.inject.Provider as universal workaround (to wrap not immediately available dependency). Or you can enable HK2 management for jersey extensions by default . Note that this will affect resources too and guice aop will not work on jersey extensions. Factory \u00b6 Any class implementing org . glassfish . hk2 . api . Factory (or extending abstract class implementing it). @Provider public class AuthFactory implements Factory < User >{ @Override public User provide () { return new User (); } @Override public void dispose ( User instance ) { } } Factories in essence are very like guice (or javax.inject) providers ( Provider ). Example of using jersey abstract class instead of direct implementation: @Provider public class LocaleInjectableProvider extends AbstractContainerRequestValueFactory < Locale > { @Inject private javax . inject . Provider < HttpHeaders > request ; @Override public Locale provide () { final List < Locale > locales = request . get (). getAcceptableLanguages (); return locales . isEmpty () ? Locale . US : locales . get ( 0 ); } } ExceptionMapper \u00b6 Any class implementing javax . ws . rs . ext . ExceptionMapper (or extending abstract class implementing it). Useful for error handling customization . @Provider public class DummyExceptionMapper implements ExceptionMapper < RuntimeException > { private final Logger logger = LoggerFactory . getLogger ( DummyExceptionMapper . class ); @Override public Response toResponse ( RuntimeException e ) { logger . debug ( \"Problem while executing\" , e ); return Response . status ( Response . Status . BAD_REQUEST ) . type ( MediaType . TEXT_PLAIN ) . entity ( e . getMessage ()) . build (); } } Tip You can also use ExtendedExceptionMapper as more flexible alternative. See example usage in dropwizard-views . Tip Default exception dropwizard mappers (registered in io.dropwizard.setup.ExceptionMapperBinder ) could be overridden or completely disabled with server.registerDefaultExceptionMappers option. ValueFactoryProvider \u00b6 Any class implementing org . glassfish . jersey . server . spi . internal . ValueFactoryProvider (or extending abstract class implementing it). @Provider @LazyBinding public class AuthFactoryProvider extends AbstractValueFactoryProvider { private final Factory < User > authFactory ; @Inject public AuthFactoryProvider ( final MultivaluedParameterExtractorProvider extractorProvider , final AuthFactory factory , final ServiceLocator injector ) { super ( extractorProvider , injector , Parameter . Source . UNKNOWN ); this . authFactory = factory ; } @Override protected Factory <?> createValueFactory ( Parameter parameter ) { final Auth auth = parameter . getAnnotation ( Auth . class ); return auth != null ? authFactory : null ; } } Note @LazyBinding was used to delay provider creation because required dependency MultivaluedParameterExtractorProvider (by super class) will be available only after HK2 context creation (which is created after guice context). Another option could be using @HK2Managed (instead of lazy) which will delegate bean creation to HK2. InjectionResolver \u00b6 Any class implementing org . glassfish . hk2 . api . InjectionResolver (or extending abstract class implementing it). @Provider @LazyBinding public class AuthInjectionResolver extends ParamInjectionResolver < Auth > { public AuthInjectionResolver () { super ( AuthFactoryProvider . class ); } } Note @LazyBinding was used to delay provider creation because super class will require HK2 service locator, which is not yet available. @HK2Managed could also be used instead. ParamConverterProvider \u00b6 Any class implementing javax . ws . rs . ext . ParamConverterProvider (or extending abstract class implementing it). @Provider public class FooParamConverter implements ParamConverterProvider { @Override public < T > ParamConverter < T > getConverter ( Class < T > rawType , Type genericType , Annotation [] annotations ) { if ( Foo . class . isAssignableFrom ( rawType )) { return ( ParamConverter < T >) new FooConverter (); } return null ; } private static class FooConverter implements ParamConverter < Foo > { @Override public Foo fromString ( String value ) { return new Foo ( value ); } @Override public String toString ( Foo value ) { return value . value ; } } } ContextResolver \u00b6 Any class implementing javax . ws . rs . ext . ContextResolver (or extending abstract class implementing it). @Provider public class MyContextResolver implements ContextResolver < Context > { @Override public Context getContext ( Class type ) { return new Context (); } public static class Context {} } MessageBodyReader \u00b6 Any class implementing javax . ws . rs . ext . MessageBodyReader (or extending abstract class implementing it). Useful for custom representations . @Provider public class TypeMessageBodyReader implements MessageBodyReader < Type > { @Override public boolean isReadable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public Type readFrom ( Class < Type > type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , String > httpHeaders , InputStream entityStream ) throws IOException , WebApplicationException { return null ; } public static class Type {} } MessageBodyWriter \u00b6 Any class implementing javax . ws . rs . ext . MessageBodyWriter (or extending abstract class implementing it). Useful for custom representations . @Provider public class TypeMessageBodyWriter implements MessageBodyWriter < Type > { @Override public boolean isWriteable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public long getSize ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return 0 ; } @Override public void writeTo ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , Object > httpHeaders , OutputStream entityStream ) throws IOException , WebApplicationException { } public static class Type {} } ReaderInterceptor \u00b6 Any class implementing javax . ws . rs . ext . ReaderInterceptor (or extending abstract class implementing it). @Provider public class MyReaderInterceptor implements ReaderInterceptor { @Override public Object aroundReadFrom ( ReaderInterceptorContext context ) throws IOException , WebApplicationException { return null ; } } WriterInterceptor \u00b6 Any class implementing javax . ws . rs . ext . WriterInterceptor (or extending abstract class implementing it). @Provider public class MyWriterInterceptor implements WriterInterceptor { @Override void aroundWriteTo ( WriterInterceptorContext context ) throws IOException , WebApplicationException { } } ContainerRequestFilter \u00b6 Any class implementing javax . ws . rs . container . ContainerRequestFilter (or extending abstract class implementing it). Useful for request modifications . @Provider public class MyContainerRequestFilter implements ContainerRequestFilter { @Override public void filter ( ContainerRequestContext requestContext ) throws IOException { } } ContainerResponseFilter \u00b6 Any class implementing javax . ws . rs . container . ContainerResponseFilter (or extending abstract class implementing it). Useful for response modifications . @Provider public class MyContainerResponseFilter implements ContainerResponseFilter { @Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { } } DynamicFeature \u00b6 Any class implementing javax . ws . rs . container . DynamicFeature (or extending abstract class implementing it). Useful for conditional activation of filters . @Provider public class MyDynamicFeature implements DynamicFeature { @Override public void configure ( ResourceInfo resourceInfo , FeatureContext context ) { } } ApplicationEventListener \u00b6 Any class implementing org . glassfish . jersey . server . monitoring . ApplicationEventListener (or extending abstract class implementing it). @Provider public class MyApplicationEventListener implements ApplicationEventListener { @Override public void onEvent ( ApplicationEvent event ) { } @Override public RequestEventListener onRequest ( RequestEvent requestEvent ) { return null ; } }","title":"Jersey extension"},{"location":"installers/jersey-ext/#jersey-extension-installer","text":"CoreInstallersBundle / JerseyProviderInstaller Installs various jersey extensions, usually annotated with jersey @Provider annotation and installed via environment . jersey (). register () : Factory, ExceptionMapper, ValueFactoryProvider, InjectionResolver, ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor, ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener","title":"Jersey extension installer"},{"location":"installers/jersey-ext/#recognition","text":"Detects classes annotated with jersey @javax.ws.rs.ext.Provider annotation and register their instances in jersey. Extensions registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Special @Protptype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used). Due to specifics of HK2 integration , you may need to use: @HK2Managed to delegate bean creation to HK2 @LazyBinding to delay bean creation to time when all dependencies will be available javax.inject.Provider as universal workaround (to wrap not immediately available dependency). Or you can enable HK2 management for jersey extensions by default . Note that this will affect resources too and guice aop will not work on jersey extensions.","title":"Recognition"},{"location":"installers/jersey-ext/#factory","text":"Any class implementing org . glassfish . hk2 . api . Factory (or extending abstract class implementing it). @Provider public class AuthFactory implements Factory < User >{ @Override public User provide () { return new User (); } @Override public void dispose ( User instance ) { } } Factories in essence are very like guice (or javax.inject) providers ( Provider ). Example of using jersey abstract class instead of direct implementation: @Provider public class LocaleInjectableProvider extends AbstractContainerRequestValueFactory < Locale > { @Inject private javax . inject . Provider < HttpHeaders > request ; @Override public Locale provide () { final List < Locale > locales = request . get (). getAcceptableLanguages (); return locales . isEmpty () ? Locale . US : locales . get ( 0 ); } }","title":"Factory"},{"location":"installers/jersey-ext/#exceptionmapper","text":"Any class implementing javax . ws . rs . ext . ExceptionMapper (or extending abstract class implementing it). Useful for error handling customization . @Provider public class DummyExceptionMapper implements ExceptionMapper < RuntimeException > { private final Logger logger = LoggerFactory . getLogger ( DummyExceptionMapper . class ); @Override public Response toResponse ( RuntimeException e ) { logger . debug ( \"Problem while executing\" , e ); return Response . status ( Response . Status . BAD_REQUEST ) . type ( MediaType . TEXT_PLAIN ) . entity ( e . getMessage ()) . build (); } } Tip You can also use ExtendedExceptionMapper as more flexible alternative. See example usage in dropwizard-views . Tip Default exception dropwizard mappers (registered in io.dropwizard.setup.ExceptionMapperBinder ) could be overridden or completely disabled with server.registerDefaultExceptionMappers option.","title":"ExceptionMapper"},{"location":"installers/jersey-ext/#valuefactoryprovider","text":"Any class implementing org . glassfish . jersey . server . spi . internal . ValueFactoryProvider (or extending abstract class implementing it). @Provider @LazyBinding public class AuthFactoryProvider extends AbstractValueFactoryProvider { private final Factory < User > authFactory ; @Inject public AuthFactoryProvider ( final MultivaluedParameterExtractorProvider extractorProvider , final AuthFactory factory , final ServiceLocator injector ) { super ( extractorProvider , injector , Parameter . Source . UNKNOWN ); this . authFactory = factory ; } @Override protected Factory <?> createValueFactory ( Parameter parameter ) { final Auth auth = parameter . getAnnotation ( Auth . class ); return auth != null ? authFactory : null ; } } Note @LazyBinding was used to delay provider creation because required dependency MultivaluedParameterExtractorProvider (by super class) will be available only after HK2 context creation (which is created after guice context). Another option could be using @HK2Managed (instead of lazy) which will delegate bean creation to HK2.","title":"ValueFactoryProvider"},{"location":"installers/jersey-ext/#injectionresolver","text":"Any class implementing org . glassfish . hk2 . api . InjectionResolver (or extending abstract class implementing it). @Provider @LazyBinding public class AuthInjectionResolver extends ParamInjectionResolver < Auth > { public AuthInjectionResolver () { super ( AuthFactoryProvider . class ); } } Note @LazyBinding was used to delay provider creation because super class will require HK2 service locator, which is not yet available. @HK2Managed could also be used instead.","title":"InjectionResolver"},{"location":"installers/jersey-ext/#paramconverterprovider","text":"Any class implementing javax . ws . rs . ext . ParamConverterProvider (or extending abstract class implementing it). @Provider public class FooParamConverter implements ParamConverterProvider { @Override public < T > ParamConverter < T > getConverter ( Class < T > rawType , Type genericType , Annotation [] annotations ) { if ( Foo . class . isAssignableFrom ( rawType )) { return ( ParamConverter < T >) new FooConverter (); } return null ; } private static class FooConverter implements ParamConverter < Foo > { @Override public Foo fromString ( String value ) { return new Foo ( value ); } @Override public String toString ( Foo value ) { return value . value ; } } }","title":"ParamConverterProvider"},{"location":"installers/jersey-ext/#contextresolver","text":"Any class implementing javax . ws . rs . ext . ContextResolver (or extending abstract class implementing it). @Provider public class MyContextResolver implements ContextResolver < Context > { @Override public Context getContext ( Class type ) { return new Context (); } public static class Context {} }","title":"ContextResolver"},{"location":"installers/jersey-ext/#messagebodyreader","text":"Any class implementing javax . ws . rs . ext . MessageBodyReader (or extending abstract class implementing it). Useful for custom representations . @Provider public class TypeMessageBodyReader implements MessageBodyReader < Type > { @Override public boolean isReadable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public Type readFrom ( Class < Type > type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , String > httpHeaders , InputStream entityStream ) throws IOException , WebApplicationException { return null ; } public static class Type {} }","title":"MessageBodyReader"},{"location":"installers/jersey-ext/#messagebodywriter","text":"Any class implementing javax . ws . rs . ext . MessageBodyWriter (or extending abstract class implementing it). Useful for custom representations . @Provider public class TypeMessageBodyWriter implements MessageBodyWriter < Type > { @Override public boolean isWriteable ( Class <?> type , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return false ; } @Override public long getSize ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType ) { return 0 ; } @Override public void writeTo ( Type type , Class <?> type2 , java . lang . reflect . Type genericType , Annotation [] annotations , MediaType mediaType , MultivaluedMap < String , Object > httpHeaders , OutputStream entityStream ) throws IOException , WebApplicationException { } public static class Type {} }","title":"MessageBodyWriter"},{"location":"installers/jersey-ext/#readerinterceptor","text":"Any class implementing javax . ws . rs . ext . ReaderInterceptor (or extending abstract class implementing it). @Provider public class MyReaderInterceptor implements ReaderInterceptor { @Override public Object aroundReadFrom ( ReaderInterceptorContext context ) throws IOException , WebApplicationException { return null ; } }","title":"ReaderInterceptor"},{"location":"installers/jersey-ext/#writerinterceptor","text":"Any class implementing javax . ws . rs . ext . WriterInterceptor (or extending abstract class implementing it). @Provider public class MyWriterInterceptor implements WriterInterceptor { @Override void aroundWriteTo ( WriterInterceptorContext context ) throws IOException , WebApplicationException { } }","title":"WriterInterceptor"},{"location":"installers/jersey-ext/#containerrequestfilter","text":"Any class implementing javax . ws . rs . container . ContainerRequestFilter (or extending abstract class implementing it). Useful for request modifications . @Provider public class MyContainerRequestFilter implements ContainerRequestFilter { @Override public void filter ( ContainerRequestContext requestContext ) throws IOException { } }","title":"ContainerRequestFilter"},{"location":"installers/jersey-ext/#containerresponsefilter","text":"Any class implementing javax . ws . rs . container . ContainerResponseFilter (or extending abstract class implementing it). Useful for response modifications . @Provider public class MyContainerResponseFilter implements ContainerResponseFilter { @Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { } }","title":"ContainerResponseFilter"},{"location":"installers/jersey-ext/#dynamicfeature","text":"Any class implementing javax . ws . rs . container . DynamicFeature (or extending abstract class implementing it). Useful for conditional activation of filters . @Provider public class MyDynamicFeature implements DynamicFeature { @Override public void configure ( ResourceInfo resourceInfo , FeatureContext context ) { } }","title":"DynamicFeature"},{"location":"installers/jersey-ext/#applicationeventlistener","text":"Any class implementing org . glassfish . jersey . server . monitoring . ApplicationEventListener (or extending abstract class implementing it). @Provider public class MyApplicationEventListener implements ApplicationEventListener { @Override public void onEvent ( ApplicationEvent event ) { } @Override public RequestEventListener onRequest ( RequestEvent requestEvent ) { return null ; } }","title":"ApplicationEventListener"},{"location":"installers/jersey-feature/","text":"Jersey feature installer \u00b6 CoreInstallersBundle / JerseyFeatureInstaller Recognition \u00b6 Detects classes implementing javax . ws . rs . core . Feature and register their instances in jersey. It may be useful to configure jersey inside guice components: public class MyClass { ... public static class ConfigurationFeature implements Feature { @Override public boolean configure ( FeatureContext context ) { context . register ( RolesAllowedDynamicFeature . class ); context . register ( new AuthValueFactoryProvider . Binder ( User . class )); return true ; } } } Inner classes are also recognized by classpath scan. But often the same could be achieved by injecting Environment instance. @Singleton public class MyClass { @Inject public MyClass ( Environment environment ) { environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } }","title":"Jersey feature"},{"location":"installers/jersey-feature/#jersey-feature-installer","text":"CoreInstallersBundle / JerseyFeatureInstaller","title":"Jersey feature installer"},{"location":"installers/jersey-feature/#recognition","text":"Detects classes implementing javax . ws . rs . core . Feature and register their instances in jersey. It may be useful to configure jersey inside guice components: public class MyClass { ... public static class ConfigurationFeature implements Feature { @Override public boolean configure ( FeatureContext context ) { context . register ( RolesAllowedDynamicFeature . class ); context . register ( new AuthValueFactoryProvider . Binder ( User . class )); return true ; } } } Inner classes are also recognized by classpath scan. But often the same could be achieved by injecting Environment instance. @Singleton public class MyClass { @Inject public MyClass ( Environment environment ) { environment . jersey (). register ( RolesAllowedDynamicFeature . class ); environment . jersey (). register ( new AuthValueFactoryProvider . Binder ( User . class )); } }","title":"Recognition"},{"location":"installers/lifecycle/","text":"Lifecycle installer \u00b6 CoreInstallersBundle / LifeCycleInstaller Installs jetty LifeCycle implementations. Recognition \u00b6 Detects classes implementing jetty LifeCycle interface and register their instances in environment. public class MyCycle implements LifeCycle { ... } In most cases it's better to use managed object instead of implementing lifecycle. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyCycle implements LifeCycle","title":"Lifecycle"},{"location":"installers/lifecycle/#lifecycle-installer","text":"CoreInstallersBundle / LifeCycleInstaller Installs jetty LifeCycle implementations.","title":"Lifecycle installer"},{"location":"installers/lifecycle/#recognition","text":"Detects classes implementing jetty LifeCycle interface and register their instances in environment. public class MyCycle implements LifeCycle { ... } In most cases it's better to use managed object instead of implementing lifecycle. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyCycle implements LifeCycle","title":"Recognition"},{"location":"installers/listener/","text":"Web listener installer \u00b6 WebInstallersBundle / WebListenerInstaller Web installers are not enabled by default. Enable it with bundle . useWebInstallers () . Register new web listener in main or admin contexts. Recognition \u00b6 Detects classes annotated with @javax.servlet.annotation.WebListener annotation and register them in dropwizard environment. @WebListener public class MyListener implements ServletContextListener , ServletRequestListener {...} Listener could implement multiple listener interfaces and all types will be registered. Supported listeners (the same as declared in annotation): javax.servlet.ServletContextListener javax.servlet.ServletContextAttributeListener javax.servlet.ServletRequestListener javax.servlet.ServletRequestAttributeListener javax.servlet.http.HttpSessionListener javax.servlet.http.HttpSessionAttributeListener javax.servlet.http.HttpSessionIdListener By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support then warning will be logged (and servlet listeners will actually not be registered). Error is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work). If you want to throw exception in such case, use special option: bundle . option ( InstallersOptions . DenySessionListenersWithoutSession , true ) Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebListener public class MyListener implements ServletContextListener {...} Admin context \u00b6 By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebListener public class MyListener implements ServletContextListener {...} Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebListener public class MyListener implements ServletContextListener {...}","title":"Web listener"},{"location":"installers/listener/#web-listener-installer","text":"WebInstallersBundle / WebListenerInstaller Web installers are not enabled by default. Enable it with bundle . useWebInstallers () . Register new web listener in main or admin contexts.","title":"Web listener installer"},{"location":"installers/listener/#recognition","text":"Detects classes annotated with @javax.servlet.annotation.WebListener annotation and register them in dropwizard environment. @WebListener public class MyListener implements ServletContextListener , ServletRequestListener {...} Listener could implement multiple listener interfaces and all types will be registered. Supported listeners (the same as declared in annotation): javax.servlet.ServletContextListener javax.servlet.ServletContextAttributeListener javax.servlet.ServletRequestListener javax.servlet.ServletRequestAttributeListener javax.servlet.http.HttpSessionListener javax.servlet.http.HttpSessionAttributeListener javax.servlet.http.HttpSessionIdListener By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support then warning will be logged (and servlet listeners will actually not be registered). Error is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work). If you want to throw exception in such case, use special option: bundle . option ( InstallersOptions . DenySessionListenersWithoutSession , true ) Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebListener public class MyListener implements ServletContextListener {...}","title":"Recognition"},{"location":"installers/listener/#admin-context","text":"By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebListener public class MyListener implements ServletContextListener {...} Will install filter in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebListener public class MyListener implements ServletContextListener {...}","title":"Admin context"},{"location":"installers/managed/","text":"Managed installer \u00b6 CoreInstallersBundle / ManagedInstaller Installs dropwizard managed objects . Recognition \u00b6 Detects classes implementing dropwizard Managed and register their instances in environment. public class MyService implements Managed { @Override public void start () throws Exception { ... } @Override public void stop () throws Exception { ... } } It is perfect for implementing guice service lifecycle . Tip Alternatively you can use @PostConstruct and @PreDestroy annotations inside guice beans with lifecycle-annotations extension module. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyService implements Managed","title":"Managed"},{"location":"installers/managed/#managed-installer","text":"CoreInstallersBundle / ManagedInstaller Installs dropwizard managed objects .","title":"Managed installer"},{"location":"installers/managed/#recognition","text":"Detects classes implementing dropwizard Managed and register their instances in environment. public class MyService implements Managed { @Override public void start () throws Exception { ... } @Override public void stop () throws Exception { ... } } It is perfect for implementing guice service lifecycle . Tip Alternatively you can use @PostConstruct and @PreDestroy annotations inside guice beans with lifecycle-annotations extension module. Tip Use guicey @Order annotation to order managed objects. @Order ( 10 ) public class MyService implements Managed","title":"Recognition"},{"location":"installers/plugin/","text":"Plugin installer \u00b6 CoreInstallersBundle / PluginInstaller Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case). Recognition \u00b6 Detects classes annotated with guicey @Plugin annotation and bind them into set or map using guice multibindings mechanism. Suppose you have plugin interface public interface PluginInterface . Annotate plugin implementations with @Plugin : @Plugin ( PluginInterface . class ) public class PluginImpl1 implements PluginInterface Now all implementations could be autowired as @Inject Set < PluginInterface > plugins ; Warning At least one implementation must be provided because otherwise guicey will not be able to register Set binding and guice startup will fail. If no plugins situation is possible, then you will have to manually register empty (default) plugins binding: public class MyModule extends AbstractModule { @Override protected configure () { Multibinder . newSetBinder ( binder (), PluginInterface . class ); } } Guicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting. Named plugins \u00b6 Sometimes it's required to have named plugin mapping: to bind, Map instead of simple set. For example, when you have multiple authorization providers and each provider implementation must be registered with name. Most likely, you would use enum for keys: public enum PluginKey { FIRST , SECOND } Custom plugin annotation needs to be defined to use new keys: @Plugin ( PluginInterface . class ) @Target ( ElementType . TYPE ) @Retention ( RetentionPolicy . RUNTIME ) public @interface MyPlugin { PluginKey value (); } Note Annotation itself is annotated with @Plugin , defining target plugin interface. Guicey will detect your custom annotation usage by analyzing its annotations. Annotating plugin implementation: @MyPlugin ( PluginKey . FIRST ) public class PluginImpl1 implements PluginInterface All plugins could be referenced as map: @Inject Map < PluginKey , PluginInterface > plugins ; Note It's not required to use enum as key. Any type could be set in your custom annotation. For example, string key could be used: public @interface MyPlugin { String value (); } @MyPlugin ( \"first\" ) public class PluginImpl1 implements PluginInterface @Inject Map < String , PluginInterface > plugins ; Warning As with simple plugin bindings, at least one plugin must be registered so guice could create map binding. Otherwise, you need to manually declare empty (default) plugnis map binding: MapBinder . newMapBinder ( binder , keyType , pluginType );","title":"Plugin"},{"location":"installers/plugin/#plugin-installer","text":"CoreInstallersBundle / PluginInstaller Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).","title":"Plugin installer"},{"location":"installers/plugin/#recognition","text":"Detects classes annotated with guicey @Plugin annotation and bind them into set or map using guice multibindings mechanism. Suppose you have plugin interface public interface PluginInterface . Annotate plugin implementations with @Plugin : @Plugin ( PluginInterface . class ) public class PluginImpl1 implements PluginInterface Now all implementations could be autowired as @Inject Set < PluginInterface > plugins ; Warning At least one implementation must be provided because otherwise guicey will not be able to register Set binding and guice startup will fail. If no plugins situation is possible, then you will have to manually register empty (default) plugins binding: public class MyModule extends AbstractModule { @Override protected configure () { Multibinder . newSetBinder ( binder (), PluginInterface . class ); } } Guicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting.","title":"Recognition"},{"location":"installers/plugin/#named-plugins","text":"Sometimes it's required to have named plugin mapping: to bind, Map instead of simple set. For example, when you have multiple authorization providers and each provider implementation must be registered with name. Most likely, you would use enum for keys: public enum PluginKey { FIRST , SECOND } Custom plugin annotation needs to be defined to use new keys: @Plugin ( PluginInterface . class ) @Target ( ElementType . TYPE ) @Retention ( RetentionPolicy . RUNTIME ) public @interface MyPlugin { PluginKey value (); } Note Annotation itself is annotated with @Plugin , defining target plugin interface. Guicey will detect your custom annotation usage by analyzing its annotations. Annotating plugin implementation: @MyPlugin ( PluginKey . FIRST ) public class PluginImpl1 implements PluginInterface All plugins could be referenced as map: @Inject Map < PluginKey , PluginInterface > plugins ; Note It's not required to use enum as key. Any type could be set in your custom annotation. For example, string key could be used: public @interface MyPlugin { String value (); } @MyPlugin ( \"first\" ) public class PluginImpl1 implements PluginInterface @Inject Map < String , PluginInterface > plugins ; Warning As with simple plugin bindings, at least one plugin must be registered so guice could create map binding. Otherwise, you need to manually declare empty (default) plugnis map binding: MapBinder . newMapBinder ( binder , keyType , pluginType );","title":"Named plugins"},{"location":"installers/resource/","text":"Resource installer \u00b6 CoreInstallersBundle / ResourceInstaller Installs rest resources . Recognition \u00b6 Detects classes annotated with jax-rs @Path annotation and register them as rest resources. Guice will manage resource creation, so you may think of it as usual guice bean. @Path ( \"/res\" ) @Produces ( ' application / json ' ) class SampleResource { @Inject private MyService service ; @GET @Path ( \"/sample\" ) public Response sample () { return Response . ok ( service . result ()). build (); } } Resources registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Special @Protptype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used). Interface recognition \u00b6 Class will also be recognized if @Path annotation found on directly implemented interface. @Path ( \"/res\" ) @Produces ( ' application / json ' ) interface ResourceContract { @GET @Path ( \"/sample\" ) String sample (); } class SampleResource implements ResourceContract { @Inject private MyService service ; @Override public Response sample () { return Response . ok ( service . result ()). build (); } } Annotations on interfaces are useful for jersey client proxies Client client = ClientBuilder . newClient (); ResourceContract resource = WebResourceFactory . newResource ( ResourceContract . class , client . target ( \"http://localhost:8080/\" )); // call sample method on remote resource http://localhost:8080/res/sample String result = resource . sample (); Jersey client proxies requires extra dependency org.glassfish.jersey.ext:jersey-proxy-client Request scope bindings \u00b6 If you need request scoped objects, use Provider : class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/sample\" ) public Response sample () { HttpServletRequest request = requestProvider . get (); ... } See jersey objects, available for injection . @Context usage \u00b6 @Context annotation usage is a common point of confusion. You can't use it for class fields: this will not work public class MyResource { @Context UriInfo info ; } Use provider instead: correct way public class MyResource { @Inject Provider < UriInfo > infoProvider ; } But, you can use @Context on method parameters: public class MyResource { @GET public Response get ( @Context UriInfo info ) { ... } } HK2 managed resource \u00b6 If resource class is annotated with @HK2Managed then jersey HK2 container will manage bean creation instead of guice. Injection of guice managed beans could still be possible via registered HK2-guice-bridge , but guice aop features will not work. Note You can manage resources with HK2 by default , but this will also affect all jersey extensions @Path ( \"/res\" ) @Produces ( ' application / json ' ) @HK2Managed class SampleResource { ... } @Context annotation on field will work on HK2 managed bean: @Path () @HK2Managed public class MyResource { @Context UriInfo info ; }","title":"Resource"},{"location":"installers/resource/#resource-installer","text":"CoreInstallersBundle / ResourceInstaller Installs rest resources .","title":"Resource installer"},{"location":"installers/resource/#recognition","text":"Detects classes annotated with jax-rs @Path annotation and register them as rest resources. Guice will manage resource creation, so you may think of it as usual guice bean. @Path ( \"/res\" ) @Produces ( ' application / json ' ) class SampleResource { @Inject private MyService service ; @GET @Path ( \"/sample\" ) public Response sample () { return Response . ok ( service . result ()). build (); } } Resources registered as singletons , when no explicit scope annotation is used. Behaviour could be disabled with option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions , false ) Special @Protptype scope annotation may be used to mark resources in prototype scope. It is useful when guice servlet support is disabled (and so @RequestScoped could not be used).","title":"Recognition"},{"location":"installers/resource/#interface-recognition","text":"Class will also be recognized if @Path annotation found on directly implemented interface. @Path ( \"/res\" ) @Produces ( ' application / json ' ) interface ResourceContract { @GET @Path ( \"/sample\" ) String sample (); } class SampleResource implements ResourceContract { @Inject private MyService service ; @Override public Response sample () { return Response . ok ( service . result ()). build (); } } Annotations on interfaces are useful for jersey client proxies Client client = ClientBuilder . newClient (); ResourceContract resource = WebResourceFactory . newResource ( ResourceContract . class , client . target ( \"http://localhost:8080/\" )); // call sample method on remote resource http://localhost:8080/res/sample String result = resource . sample (); Jersey client proxies requires extra dependency org.glassfish.jersey.ext:jersey-proxy-client","title":"Interface recognition"},{"location":"installers/resource/#request-scope-bindings","text":"If you need request scoped objects, use Provider : class SampleResource { @Inject private Provider < HttpServletRequest > requestProvider ; @GET @Path ( \"/sample\" ) public Response sample () { HttpServletRequest request = requestProvider . get (); ... } See jersey objects, available for injection .","title":"Request scope bindings"},{"location":"installers/resource/#context-usage","text":"@Context annotation usage is a common point of confusion. You can't use it for class fields: this will not work public class MyResource { @Context UriInfo info ; } Use provider instead: correct way public class MyResource { @Inject Provider < UriInfo > infoProvider ; } But, you can use @Context on method parameters: public class MyResource { @GET public Response get ( @Context UriInfo info ) { ... } }","title":"@Context usage"},{"location":"installers/resource/#hk2-managed-resource","text":"If resource class is annotated with @HK2Managed then jersey HK2 container will manage bean creation instead of guice. Injection of guice managed beans could still be possible via registered HK2-guice-bridge , but guice aop features will not work. Note You can manage resources with HK2 by default , but this will also affect all jersey extensions @Path ( \"/res\" ) @Produces ( ' application / json ' ) @HK2Managed class SampleResource { ... } @Context annotation on field will work on HK2 managed bean: @Path () @HK2Managed public class MyResource { @Context UriInfo info ; }","title":"HK2 managed resource"},{"location":"installers/servlet/","text":"Web servlet installer \u00b6 WebInstallersBundle / WebServletInstaller Web installers are not enabled by default. Enable it with bundle . useWebInstallers () . Register new servlet in main or admin contexts. Recognition \u00b6 Detects classes annotated with @javax.servlet.annotation.WebServlet annotation and register them in dropwizard environment. @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Only the following annotation properties are supported: name , urlPatterns (or value ), initParams , asyncSupported . Servlet name is not required. If name not provided, it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off. For example, for class \"MyCoolServlet\" generated name will be \".mycool\". Warning One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings. If you want to throw exception in this case, use special option: bundle . option ( InstallersOptions . DenyServletRegistrationWithClash , true ) Note that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later (and so exception will not be thrown). Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet There is a difference between using servlet installer and registering servlets with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata). Async \u00b6 Example of async servlet definition: @WebServlet ( urlPatterns = \"/async\" , asyncSupported = true ) public class AsyncServlet extends HttpServlet { @Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { final AsyncContext context = req . startAsync (); context . start (() -> { context . getResponse (). getWriter (). write ( \"done!\" ); context . complete (); }); } } Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets. Admin context \u00b6 By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Will install servlet in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... }","title":"Web servlet"},{"location":"installers/servlet/#web-servlet-installer","text":"WebInstallersBundle / WebServletInstaller Web installers are not enabled by default. Enable it with bundle . useWebInstallers () . Register new servlet in main or admin contexts.","title":"Web servlet installer"},{"location":"installers/servlet/#recognition","text":"Detects classes annotated with @javax.servlet.annotation.WebServlet annotation and register them in dropwizard environment. @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Only the following annotation properties are supported: name , urlPatterns (or value ), initParams , asyncSupported . Servlet name is not required. If name not provided, it will be generated as: . (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off. For example, for class \"MyCoolServlet\" generated name will be \".mycool\". Warning One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings. If you want to throw exception in this case, use special option: bundle . option ( InstallersOptions . DenyServletRegistrationWithClash , true ) Note that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later (and so exception will not be thrown). Tip Use guicey @Order annotation to order servlets registration. @Order ( 10 ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet There is a difference between using servlet installer and registering servlets with guice servlet module: guice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts). As a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still). Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).","title":"Recognition"},{"location":"installers/servlet/#async","text":"Example of async servlet definition: @WebServlet ( urlPatterns = \"/async\" , asyncSupported = true ) public class AsyncServlet extends HttpServlet { @Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { final AsyncContext context = req . startAsync (); context . start (() -> { context . getResponse (). getWriter (). write ( \"done!\" ); context . complete (); }); } } Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.","title":"Async"},{"location":"installers/servlet/#admin-context","text":"By default, installer target application context. If you want to install into admin context then use guicey @AdminContext annotation. For example: @AdminContext @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... } Will install servlet in admin context only. If you want to install in both contexts use andMain attribute: @AdminContext ( andMain = true ) @WebServlet ( \"/mapped\" ) public class MyServlet extends HttpServlet { ... }","title":"Admin context"},{"location":"installers/task/","text":"Task installer \u00b6 CoreInstallersBundle / TaskInstaller Installs dropwizard tasks . Recognition \u00b6 Detects classes extending dropwizard Task and register their instances in environment. public class MyTask extends Task { @Inject private MyService service ; public TruncateDatabaseTask () { super ( \"mytask\" ); } @Override public void execute ( ImmutableMultimap < String , String > parameters , PrintWriter output ) throws Exception { service . doSomething (); } } Task can be triggered with: http://localhost:8081/tasks/mytask","title":"Task"},{"location":"installers/task/#task-installer","text":"CoreInstallersBundle / TaskInstaller Installs dropwizard tasks .","title":"Task installer"},{"location":"installers/task/#recognition","text":"Detects classes extending dropwizard Task and register their instances in environment. public class MyTask extends Task { @Inject private MyService service ; public TruncateDatabaseTask () { super ( \"mytask\" ); } @Override public void execute ( ImmutableMultimap < String , String > parameters , PrintWriter output ) throws Exception { service . doSomething (); } } Task can be triggered with: http://localhost:8081/tasks/mytask","title":"Recognition"}]}